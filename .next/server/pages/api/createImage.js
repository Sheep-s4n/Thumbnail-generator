/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/api/createImage"],{

/***/ "(middleware)/./node_modules/@shuding/opentype.js/dist/opentype.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@shuding/opentype.js/dist/opentype.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Font\": () => (/* binding */ Font),\n/* harmony export */   \"Glyph\": () => (/* binding */ Glyph),\n/* harmony export */   \"Path\": () => (/* binding */ Path),\n/* harmony export */   \"_parse\": () => (/* binding */ parse),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"load\": () => (/* binding */ load),\n/* harmony export */   \"loadSync\": () => (/* binding */ loadSync),\n/* harmony export */   \"parse\": () => (/* binding */ parseBuffer)\n/* harmony export */ });\n/**\n * https://opentype.js.org v1.3.5 | (c) Frederik De Bleser and other contributors | MIT License | Uses fflate by 101arrowz and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            { ++l[cd[i] - 1]; }\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    { flt[i] = 8; }\nfor (var i = 144; i < 256; ++i)\n    { flt[i] = 9; }\nfor (var i = 256; i < 280; ++i)\n    { flt[i] = 7; }\nfor (var i = 280; i < 288; ++i)\n    { flt[i] = 8; }\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    { fdt[i] = 5; }\n// fixed length map\nvar flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            { m = a[i]; }\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        { s = 0; }\n    if (e == null || e > v.length)\n        { e = v.length; }\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        { Error.captureStackTrace(e, err); }\n    if (!nt)\n        { throw e; }\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        { return buf || new u8(0); }\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        { st = {}; }\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        { buf = new u8(sl * 3); }\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        { err(0); }\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    { cbuf(bt + l); }\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                { lm = flrm, dm = fdrm, lbt = 9, dbt = 5; }\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            { n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1]; }\n                        else if (s == 17)\n                            { n = 3 + bits(dat, pos, 7), pos += 3; }\n                        else if (s == 18)\n                            { n = 11 + bits(dat, pos, 127), pos += 7; }\n                        while (n--)\n                            { ldt[i++] = c; }\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                { err(1); }\n            if (pos > tbts) {\n                if (noSt)\n                    { err(0); }\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            { cbuf(bt + 131072); }\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    { err(0); }\n                break;\n            }\n            if (!c)\n                { err(2); }\n            if (sym < 256)\n                { buf[bt++] = sym; }\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    { err(3); }\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        { err(0); }\n                    break;\n                }\n                if (noBuf)\n                    { cbuf(bt + 131072); }\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            { final = 1, st.m = lbt, st.d = dm, st.n = dbt; }\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction inflateSync(data, out) {\n    return inflt(data, out);\n}\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n\n// Geometric objects\n\n// import BoundingBox from './bbox';\n\n/**\n * A bézier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */\nfunction Path() {\n    this.commands = [];\n    this.fill = 'black';\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.moveTo = function (x, y) {\n    this.commands.push({\n        type: 'M',\n        x: x,\n        y: y,\n    });\n};\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.lineTo = function (x, y) {\n    this.commands.push({\n        type: 'L',\n        x: x,\n        y: y,\n    });\n};\n\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function (\n    x1,\n    y1,\n    x2,\n    y2,\n    x,\n    y\n) {\n    this.commands.push({\n        type: 'C',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y,\n    });\n};\n\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function (\n    x1,\n    y1,\n    x,\n    y\n) {\n    this.commands.push({\n        type: 'Q',\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y,\n    });\n};\n\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */\n\n/**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */\nPath.prototype.close = Path.prototype.closePath = function () {\n    this.commands.push({\n        type: 'Z',\n    });\n};\n\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */\nPath.prototype.extend = function (pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    }\n    // else if (pathOrCommands instanceof BoundingBox) {\n    //     const box = pathOrCommands;\n    //     this.moveTo(box.x1, box.y1);\n    //     this.lineTo(box.x2, box.y1);\n    //     this.lineTo(box.x2, box.y2);\n    //     this.lineTo(box.x1, box.y2);\n    //     this.close();\n    //     return;\n    // }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toPathData = function (decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return '' + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n\n    function packValues() {\n        var arguments$1 = arguments;\n\n        var s = '';\n        for (var i = 0; i < arguments.length; i += 1) {\n            var v = arguments$1[i];\n            if (v >= 0 && i > 0) {\n                s += ' ';\n            }\n\n            s += floatToString(v);\n        }\n\n        return s;\n    }\n\n    var d = '';\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            d += 'M' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            d += 'L' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            d += 'Z';\n        }\n    }\n\n    return d;\n};\n\n// Glyph encoding\n\nvar cffStandardStrings = [\n    '.notdef',\n    'space',\n    'exclam',\n    'quotedbl',\n    'numbersign',\n    'dollar',\n    'percent',\n    'ampersand',\n    'quoteright',\n    'parenleft',\n    'parenright',\n    'asterisk',\n    'plus',\n    'comma',\n    'hyphen',\n    'period',\n    'slash',\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n    'colon',\n    'semicolon',\n    'less',\n    'equal',\n    'greater',\n    'question',\n    'at',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n    'bracketleft',\n    'backslash',\n    'bracketright',\n    'asciicircum',\n    'underscore',\n    'quoteleft',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    'braceleft',\n    'bar',\n    'braceright',\n    'asciitilde',\n    'exclamdown',\n    'cent',\n    'sterling',\n    'fraction',\n    'yen',\n    'florin',\n    'section',\n    'currency',\n    'quotesingle',\n    'quotedblleft',\n    'guillemotleft',\n    'guilsinglleft',\n    'guilsinglright',\n    'fi',\n    'fl',\n    'endash',\n    'dagger',\n    'daggerdbl',\n    'periodcentered',\n    'paragraph',\n    'bullet',\n    'quotesinglbase',\n    'quotedblbase',\n    'quotedblright',\n    'guillemotright',\n    'ellipsis',\n    'perthousand',\n    'questiondown',\n    'grave',\n    'acute',\n    'circumflex',\n    'tilde',\n    'macron',\n    'breve',\n    'dotaccent',\n    'dieresis',\n    'ring',\n    'cedilla',\n    'hungarumlaut',\n    'ogonek',\n    'caron',\n    'emdash',\n    'AE',\n    'ordfeminine',\n    'Lslash',\n    'Oslash',\n    'OE',\n    'ordmasculine',\n    'ae',\n    'dotlessi',\n    'lslash',\n    'oslash',\n    'oe',\n    'germandbls',\n    'onesuperior',\n    'logicalnot',\n    'mu',\n    'trademark',\n    'Eth',\n    'onehalf',\n    'plusminus',\n    'Thorn',\n    'onequarter',\n    'divide',\n    'brokenbar',\n    'degree',\n    'thorn',\n    'threequarters',\n    'twosuperior',\n    'registered',\n    'minus',\n    'eth',\n    'multiply',\n    'threesuperior',\n    'copyright',\n    'Aacute',\n    'Acircumflex',\n    'Adieresis',\n    'Agrave',\n    'Aring',\n    'Atilde',\n    'Ccedilla',\n    'Eacute',\n    'Ecircumflex',\n    'Edieresis',\n    'Egrave',\n    'Iacute',\n    'Icircumflex',\n    'Idieresis',\n    'Igrave',\n    'Ntilde',\n    'Oacute',\n    'Ocircumflex',\n    'Odieresis',\n    'Ograve',\n    'Otilde',\n    'Scaron',\n    'Uacute',\n    'Ucircumflex',\n    'Udieresis',\n    'Ugrave',\n    'Yacute',\n    'Ydieresis',\n    'Zcaron',\n    'aacute',\n    'acircumflex',\n    'adieresis',\n    'agrave',\n    'aring',\n    'atilde',\n    'ccedilla',\n    'eacute',\n    'ecircumflex',\n    'edieresis',\n    'egrave',\n    'iacute',\n    'icircumflex',\n    'idieresis',\n    'igrave',\n    'ntilde',\n    'oacute',\n    'ocircumflex',\n    'odieresis',\n    'ograve',\n    'otilde',\n    'scaron',\n    'uacute',\n    'ucircumflex',\n    'udieresis',\n    'ugrave',\n    'yacute',\n    'ydieresis',\n    'zcaron',\n    'exclamsmall',\n    'Hungarumlautsmall',\n    'dollaroldstyle',\n    'dollarsuperior',\n    'ampersandsmall',\n    'Acutesmall',\n    'parenleftsuperior',\n    'parenrightsuperior',\n    '266 ff',\n    'onedotenleader',\n    'zerooldstyle',\n    'oneoldstyle',\n    'twooldstyle',\n    'threeoldstyle',\n    'fouroldstyle',\n    'fiveoldstyle',\n    'sixoldstyle',\n    'sevenoldstyle',\n    'eightoldstyle',\n    'nineoldstyle',\n    'commasuperior',\n    'threequartersemdash',\n    'periodsuperior',\n    'questionsmall',\n    'asuperior',\n    'bsuperior',\n    'centsuperior',\n    'dsuperior',\n    'esuperior',\n    'isuperior',\n    'lsuperior',\n    'msuperior',\n    'nsuperior',\n    'osuperior',\n    'rsuperior',\n    'ssuperior',\n    'tsuperior',\n    'ff',\n    'ffi',\n    'ffl',\n    'parenleftinferior',\n    'parenrightinferior',\n    'Circumflexsmall',\n    'hyphensuperior',\n    'Gravesmall',\n    'Asmall',\n    'Bsmall',\n    'Csmall',\n    'Dsmall',\n    'Esmall',\n    'Fsmall',\n    'Gsmall',\n    'Hsmall',\n    'Ismall',\n    'Jsmall',\n    'Ksmall',\n    'Lsmall',\n    'Msmall',\n    'Nsmall',\n    'Osmall',\n    'Psmall',\n    'Qsmall',\n    'Rsmall',\n    'Ssmall',\n    'Tsmall',\n    'Usmall',\n    'Vsmall',\n    'Wsmall',\n    'Xsmall',\n    'Ysmall',\n    'Zsmall',\n    'colonmonetary',\n    'onefitted',\n    'rupiah',\n    'Tildesmall',\n    'exclamdownsmall',\n    'centoldstyle',\n    'Lslashsmall',\n    'Scaronsmall',\n    'Zcaronsmall',\n    'Dieresissmall',\n    'Brevesmall',\n    'Caronsmall',\n    'Dotaccentsmall',\n    'Macronsmall',\n    'figuredash',\n    'hypheninferior',\n    'Ogoneksmall',\n    'Ringsmall',\n    'Cedillasmall',\n    'questiondownsmall',\n    'oneeighth',\n    'threeeighths',\n    'fiveeighths',\n    'seveneighths',\n    'onethird',\n    'twothirds',\n    'zerosuperior',\n    'foursuperior',\n    'fivesuperior',\n    'sixsuperior',\n    'sevensuperior',\n    'eightsuperior',\n    'ninesuperior',\n    'zeroinferior',\n    'oneinferior',\n    'twoinferior',\n    'threeinferior',\n    'fourinferior',\n    'fiveinferior',\n    'sixinferior',\n    'seveninferior',\n    'eightinferior',\n    'nineinferior',\n    'centinferior',\n    'dollarinferior',\n    'periodinferior',\n    'commainferior',\n    'Agravesmall',\n    'Aacutesmall',\n    'Acircumflexsmall',\n    'Atildesmall',\n    'Adieresissmall',\n    'Aringsmall',\n    'AEsmall',\n    'Ccedillasmall',\n    'Egravesmall',\n    'Eacutesmall',\n    'Ecircumflexsmall',\n    'Edieresissmall',\n    'Igravesmall',\n    'Iacutesmall',\n    'Icircumflexsmall',\n    'Idieresissmall',\n    'Ethsmall',\n    'Ntildesmall',\n    'Ogravesmall',\n    'Oacutesmall',\n    'Ocircumflexsmall',\n    'Otildesmall',\n    'Odieresissmall',\n    'OEsmall',\n    'Oslashsmall',\n    'Ugravesmall',\n    'Uacutesmall',\n    'Ucircumflexsmall',\n    'Udieresissmall',\n    'Yacutesmall',\n    'Thornsmall',\n    'Ydieresissmall',\n    '001.000',\n    '001.001',\n    '001.002',\n    '001.003',\n    'Black',\n    'Bold',\n    'Book',\n    'Light',\n    'Medium',\n    'Regular',\n    'Roman',\n    'Semibold' ];\n\nvar cffStandardEncoding = [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'space',\n    'exclam',\n    'quotedbl',\n    'numbersign',\n    'dollar',\n    'percent',\n    'ampersand',\n    'quoteright',\n    'parenleft',\n    'parenright',\n    'asterisk',\n    'plus',\n    'comma',\n    'hyphen',\n    'period',\n    'slash',\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n    'colon',\n    'semicolon',\n    'less',\n    'equal',\n    'greater',\n    'question',\n    'at',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n    'bracketleft',\n    'backslash',\n    'bracketright',\n    'asciicircum',\n    'underscore',\n    'quoteleft',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    'braceleft',\n    'bar',\n    'braceright',\n    'asciitilde',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'exclamdown',\n    'cent',\n    'sterling',\n    'fraction',\n    'yen',\n    'florin',\n    'section',\n    'currency',\n    'quotesingle',\n    'quotedblleft',\n    'guillemotleft',\n    'guilsinglleft',\n    'guilsinglright',\n    'fi',\n    'fl',\n    '',\n    'endash',\n    'dagger',\n    'daggerdbl',\n    'periodcentered',\n    '',\n    'paragraph',\n    'bullet',\n    'quotesinglbase',\n    'quotedblbase',\n    'quotedblright',\n    'guillemotright',\n    'ellipsis',\n    'perthousand',\n    '',\n    'questiondown',\n    '',\n    'grave',\n    'acute',\n    'circumflex',\n    'tilde',\n    'macron',\n    'breve',\n    'dotaccent',\n    'dieresis',\n    '',\n    'ring',\n    'cedilla',\n    '',\n    'hungarumlaut',\n    'ogonek',\n    'caron',\n    'emdash',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'AE',\n    '',\n    'ordfeminine',\n    '',\n    '',\n    '',\n    '',\n    'Lslash',\n    'Oslash',\n    'OE',\n    'ordmasculine',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'ae',\n    '',\n    '',\n    '',\n    'dotlessi',\n    '',\n    '',\n    'lslash',\n    'oslash',\n    'oe',\n    'germandbls' ];\n\nvar cffExpertEncoding = [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'space',\n    'exclamsmall',\n    'Hungarumlautsmall',\n    '',\n    'dollaroldstyle',\n    'dollarsuperior',\n    'ampersandsmall',\n    'Acutesmall',\n    'parenleftsuperior',\n    'parenrightsuperior',\n    'twodotenleader',\n    'onedotenleader',\n    'comma',\n    'hyphen',\n    'period',\n    'fraction',\n    'zerooldstyle',\n    'oneoldstyle',\n    'twooldstyle',\n    'threeoldstyle',\n    'fouroldstyle',\n    'fiveoldstyle',\n    'sixoldstyle',\n    'sevenoldstyle',\n    'eightoldstyle',\n    'nineoldstyle',\n    'colon',\n    'semicolon',\n    'commasuperior',\n    'threequartersemdash',\n    'periodsuperior',\n    'questionsmall',\n    '',\n    'asuperior',\n    'bsuperior',\n    'centsuperior',\n    'dsuperior',\n    'esuperior',\n    '',\n    '',\n    'isuperior',\n    '',\n    '',\n    'lsuperior',\n    'msuperior',\n    'nsuperior',\n    'osuperior',\n    '',\n    '',\n    'rsuperior',\n    'ssuperior',\n    'tsuperior',\n    '',\n    'ff',\n    'fi',\n    'fl',\n    'ffi',\n    'ffl',\n    'parenleftinferior',\n    '',\n    'parenrightinferior',\n    'Circumflexsmall',\n    'hyphensuperior',\n    'Gravesmall',\n    'Asmall',\n    'Bsmall',\n    'Csmall',\n    'Dsmall',\n    'Esmall',\n    'Fsmall',\n    'Gsmall',\n    'Hsmall',\n    'Ismall',\n    'Jsmall',\n    'Ksmall',\n    'Lsmall',\n    'Msmall',\n    'Nsmall',\n    'Osmall',\n    'Psmall',\n    'Qsmall',\n    'Rsmall',\n    'Ssmall',\n    'Tsmall',\n    'Usmall',\n    'Vsmall',\n    'Wsmall',\n    'Xsmall',\n    'Ysmall',\n    'Zsmall',\n    'colonmonetary',\n    'onefitted',\n    'rupiah',\n    'Tildesmall',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'exclamdownsmall',\n    'centoldstyle',\n    'Lslashsmall',\n    '',\n    '',\n    'Scaronsmall',\n    'Zcaronsmall',\n    'Dieresissmall',\n    'Brevesmall',\n    'Caronsmall',\n    '',\n    'Dotaccentsmall',\n    '',\n    '',\n    'Macronsmall',\n    '',\n    '',\n    'figuredash',\n    'hypheninferior',\n    '',\n    '',\n    'Ogoneksmall',\n    'Ringsmall',\n    'Cedillasmall',\n    '',\n    '',\n    '',\n    'onequarter',\n    'onehalf',\n    'threequarters',\n    'questiondownsmall',\n    'oneeighth',\n    'threeeighths',\n    'fiveeighths',\n    'seveneighths',\n    'onethird',\n    'twothirds',\n    '',\n    '',\n    'zerosuperior',\n    'onesuperior',\n    'twosuperior',\n    'threesuperior',\n    'foursuperior',\n    'fivesuperior',\n    'sixsuperior',\n    'sevensuperior',\n    'eightsuperior',\n    'ninesuperior',\n    'zeroinferior',\n    'oneinferior',\n    'twoinferior',\n    'threeinferior',\n    'fourinferior',\n    'fiveinferior',\n    'sixinferior',\n    'seveninferior',\n    'eightinferior',\n    'nineinferior',\n    'centinferior',\n    'dollarinferior',\n    'periodinferior',\n    'commainferior',\n    'Agravesmall',\n    'Aacutesmall',\n    'Acircumflexsmall',\n    'Atildesmall',\n    'Adieresissmall',\n    'Aringsmall',\n    'AEsmall',\n    'Ccedillasmall',\n    'Egravesmall',\n    'Eacutesmall',\n    'Ecircumflexsmall',\n    'Edieresissmall',\n    'Igravesmall',\n    'Iacutesmall',\n    'Icircumflexsmall',\n    'Idieresissmall',\n    'Ethsmall',\n    'Ntildesmall',\n    'Ogravesmall',\n    'Oacutesmall',\n    'Ocircumflexsmall',\n    'Otildesmall',\n    'Odieresissmall',\n    'OEsmall',\n    'Oslashsmall',\n    'Ugravesmall',\n    'Uacutesmall',\n    'Ucircumflexsmall',\n    'Udieresissmall',\n    'Yacutesmall',\n    'Thornsmall',\n    'Ydieresissmall' ];\n\n/**\n * This is the encoding used for fonts created from scratch.\n * It loops through all glyphs and finds the appropriate unicode value.\n * Since it's linear time, other encodings will be faster.\n * @exports opentype.DefaultEncoding\n * @class\n * @constructor\n * @param {opentype.Font}\n */\nfunction DefaultEncoding(font) {\n    this.font = font;\n}\n\nDefaultEncoding.prototype.charToGlyphIndex = function (c) {\n    var code = c.codePointAt(0);\n    var glyphs = this.font.glyphs;\n    if (glyphs) {\n        for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @exports opentype.CmapEncoding\n * @class\n * @constructor\n * @param {Object} cmap - a object with the cmap encoded data\n */\nfunction CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n\n/**\n * @param  {string} c - the character\n * @return {number} The glyph index.\n */\nCmapEncoding.prototype.charToGlyphIndex = function (c) {\n    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n};\n\n/**\n * @exports opentype.CffEncoding\n * @class\n * @constructor\n * @param {string} encoding - The encoding\n * @param {Array} charset - The character set.\n */\nfunction CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n\n/**\n * @param  {string} s - The character\n * @return {number} The index.\n */\nCffEncoding.prototype.charToGlyphIndex = function (s) {\n    var code = s.codePointAt(0);\n    var charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\n\nfunction addGlyphNamesAll(font) {\n    var glyph;\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n}\n\nfunction addGlyphNamesToUnicodeMap(font) {\n    font._IndexToUnicodeMap = {};\n\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n            font._IndexToUnicodeMap[glyphIndex] = {\n                unicodes: [parseInt(c)],\n            };\n        } else {\n            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n        }\n    }\n}\n\n/**\n * @alias opentype.addGlyphNames\n * @param {opentype.Font}\n * @param {Object}\n */\nfunction addGlyphNames(font, opt) {\n    if (opt.lowMemory) {\n        addGlyphNamesToUnicodeMap(font);\n    } else {\n        addGlyphNamesAll(font);\n    }\n}\n\n// Run-time checking of preconditions.\n\nfunction fail(message) {\n    throw new Error(message);\n}\n\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nfunction argument(predicate, message) {\n    if (!predicate) {\n        fail(message);\n    }\n}\nvar check = { fail: fail, argument: argument, assert: argument };\n\n// The Glyph object\n// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\nfunction getPathDefinition(glyph, path) {\n    var _path = path || new Path();\n    return {\n        configurable: true,\n\n        get: function () {\n            if (typeof _path === 'function') {\n                _path = _path();\n            }\n\n            return _path;\n        },\n\n        set: function (p) {\n            _path = p;\n        },\n    };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */\n\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */\nfunction Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n\n/**\n * @param  {GlyphOptions}\n */\nGlyph.prototype.bindConstructorValues = function (options) {\n    this.index = options.index || 0;\n\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes =\n        options.unicodes || options.unicode !== undefined\n            ? [options.unicode]\n            : [];\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if ('xMin' in options) {\n        this.xMin = options.xMin;\n    }\n\n    if ('yMin' in options) {\n        this.yMin = options.yMin;\n    }\n\n    if ('xMax' in options) {\n        this.xMax = options.xMax;\n    }\n\n    if ('yMax' in options) {\n        this.yMax = options.yMax;\n    }\n\n    if ('advanceWidth' in options) {\n        this.advanceWidth = options.advanceWidth;\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n\n/**\n * @param {number}\n */\nGlyph.prototype.addUnicode = function (unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n\n    this.unicodes.push(unicode);\n};\n\n// /**\n//  * Calculate the minimum bounding box for this glyph.\n//  * @return {opentype.BoundingBox}\n//  */\n// Glyph.prototype.getBoundingBox = function() {\n//     return this.path.getBoundingBox();\n// };\n\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */\nGlyph.prototype.getPath = function (x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    var commands;\n    var hPoints;\n    if (!options) { options = {}; }\n    var xScale = options.xScale;\n    var yScale = options.yScale;\n\n    if (options.hinting && font && font.hinting) {\n        // in case of hinting, the hinting engine takes care\n        // of scaling the points (not the path) before hinting.\n        hPoints = this.path && font.hinting.exec(this, fontSize);\n        // in case the hinting engine failed hPoints is undefined\n        // and thus reverts to plain rending\n    }\n\n    if (hPoints) {\n        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n        commands = font.hinting.getCommands(hPoints);\n        x = Math.round(x);\n        y = Math.round(y);\n        // TODO in case of hinting xyScaling is not yet supported\n        xScale = yScale = 1;\n    } else {\n        commands = this.path.commands;\n        var scale = (1 / (this.path.unitsPerEm || 1000)) * fontSize;\n        if (xScale === undefined) { xScale = scale; }\n        if (yScale === undefined) { yScale = scale; }\n    }\n\n    var p = new Path();\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type === 'M') {\n            p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n        } else if (cmd.type === 'L') {\n            p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n        } else if (cmd.type === 'Q') {\n            p.quadraticCurveTo(\n                x + cmd.x1 * xScale,\n                y + -cmd.y1 * yScale,\n                x + cmd.x * xScale,\n                y + -cmd.y * yScale\n            );\n        } else if (cmd.type === 'C') {\n            p.curveTo(\n                x + cmd.x1 * xScale,\n                y + -cmd.y1 * yScale,\n                x + cmd.x2 * xScale,\n                y + -cmd.y2 * yScale,\n                x + cmd.x * xScale,\n                y + -cmd.y * yScale\n            );\n        } else if (cmd.type === 'Z') {\n            p.closePath();\n        }\n    }\n\n    return p;\n};\n\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */\nGlyph.prototype.getContours = function () {\n    if (this.points === undefined) {\n        return [];\n    }\n\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < this.points.length; i += 1) {\n        var pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(\n        currentContour.length === 0,\n        'There are still points left in the current contour.'\n    );\n    return contours;\n};\n\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */\nGlyph.prototype.getMetrics = function () {\n    var commands = this.path.commands;\n    var xCoords = [];\n    var yCoords = [];\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type !== 'Z') {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n\n        if (cmd.type === 'Q' || cmd.type === 'C') {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n\n        if (cmd.type === 'C') {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n\n    var metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: this.leftSideBearing,\n    };\n\n    if (!isFinite(metrics.xMin)) {\n        metrics.xMin = 0;\n    }\n\n    if (!isFinite(metrics.xMax)) {\n        metrics.xMax = this.advanceWidth;\n    }\n\n    if (!isFinite(metrics.yMin)) {\n        metrics.yMin = 0;\n    }\n\n    if (!isFinite(metrics.yMax)) {\n        metrics.yMax = 0;\n    }\n\n    metrics.rightSideBearing =\n        this.advanceWidth -\n        metrics.leftSideBearing -\n        (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n\n// The GlyphSet object\n\n// Define a property on the glyph that depends on the path being loaded.\nfunction defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n        get: function () {\n            // Request the path property to make sure the path is loaded.\n            glyph.path; // jshint ignore:line\n            return glyph[internalName];\n        },\n        set: function (newValue) {\n            glyph[internalName] = newValue;\n        },\n        enumerable: true,\n        configurable: true,\n    });\n}\n\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */\nfunction GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for (var i = 0; i < glyphs.length; i++) {\n            var glyph = glyphs[i];\n            glyph.path.unitsPerEm = font.unitsPerEm;\n            this.glyphs[i] = glyph;\n        }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0;\n}\n\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nGlyphSet.prototype.get = function (index) {\n    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n    if (this.glyphs[index] === undefined) {\n        this.font._push(index);\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n\n        var glyph = this.glyphs[index];\n        var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n        if (unicodeObj) {\n            for (var j = 0; j < unicodeObj.unicodes.length; j++)\n                { glyph.addUnicode(unicodeObj.unicodes[j]); }\n        }\n\n        this.glyphs[index].advanceWidth =\n            this.font._hmtxTableData[index].advanceWidth;\n        this.glyphs[index].leftSideBearing =\n            this.font._hmtxTableData[index].leftSideBearing;\n    } else {\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n    }\n\n    return this.glyphs[index];\n};\n\n/**\n * @param  {number} index\n * @param  {Object}\n */\nGlyphSet.prototype.push = function (index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nfunction glyphLoader(font, index) {\n    return new Glyph({ index: index, font: font });\n}\n\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function () {\n        var glyph = new Glyph({ index: index, font: font });\n\n        glyph.path = function () {\n            parseGlyph(glyph, data, position);\n            var path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        defineDependentProperty(glyph, 'xMin', '_xMin');\n        defineDependentProperty(glyph, 'xMax', '_xMax');\n        defineDependentProperty(glyph, 'yMin', '_yMin');\n        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n        return glyph;\n    };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function () {\n        var glyph = new Glyph({ index: index, font: font });\n\n        glyph.path = function () {\n            var path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\nvar glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n// The Layout object is the prototype of Substitution objects, and provides\n\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\n// binary search in a list of ranges (coverage, class definition)\nfunction searchRange(ranges, value) {\n    // jshint bitwise: false\n    var range;\n    var imin = 0;\n    var imax = ranges.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        range = ranges[imid];\n        var start = range.start;\n        if (start === value) {\n            return range;\n        } else if (start < value) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    if (imin > 0) {\n        range = ranges[imin - 1];\n        if (value > range.end) { return 0; }\n        return range;\n    }\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\n\nLayout.prototype = {\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function (create) {\n        var layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] =\n                this.createDefaultTable();\n        }\n        return layout;\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function () {\n        var layout = this.getTable();\n        if (!layout) {\n            return;\n        }\n        var hasLatn = false;\n        for (var i = 0; i < layout.scripts.length; i++) {\n            var name = layout.scripts[i].tag;\n            if (name === 'DFLT') { return name; }\n            if (name === 'latn') { hasLatn = true; }\n        }\n        if (hasLatn) { return 'latn'; }\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function (script, create) {\n        var layout = this.getTable(create);\n        if (layout) {\n            script = script || 'DFLT';\n            var scripts = layout.scripts;\n            var pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                var scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {\n                            reserved: 0,\n                            reqFeatureIndex: 0xffff,\n                            featureIndexes: [],\n                        },\n                        langSysRecords: [],\n                    },\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function (script, language, create) {\n        var scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === 'dflt' || language === 'DFLT') {\n                return scriptTable.defaultLangSys;\n            }\n            var pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                var langSysRecord = {\n                    tag: language,\n                    langSys: {\n                        reserved: 0,\n                        reqFeatureIndex: 0xffff,\n                        featureIndexes: [],\n                    },\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function (script, language, feature, create) {\n        var langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            var featureRecord;\n            var featIndexes = langSysTable.featureIndexes;\n            var allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for (var i = 0; i < featIndexes.length; i++) {\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                var index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(\n                    index === 0 || feature >= allFeatures[index - 1].tag,\n                    'Features must be added in alphabetical order.'\n                );\n                featureRecord = {\n                    tag: feature,\n                    feature: { params: 0, lookupListIndexes: [] },\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 9\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function (script, language, feature, lookupType, create) {\n        var featureTable = this.getFeatureTable(\n            script,\n            language,\n            feature,\n            create\n        );\n        var tables = [];\n        if (featureTable) {\n            var lookupTable;\n            var lookupListIndexes = featureTable.lookupListIndexes;\n            var allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for (var i = 0; i < lookupListIndexes.length; i++) {\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined,\n                };\n                var index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [lookupTable];\n            }\n        }\n        return tables;\n    },\n\n    /**\n     * Find a glyph in a class definition table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n     * @param {object} classDefTable - an OpenType Layout class definition table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getGlyphClass: function (classDefTable, glyphIndex) {\n        switch (classDefTable.format) {\n            case 1:\n                if (\n                    classDefTable.startGlyph <= glyphIndex &&\n                    glyphIndex <\n                        classDefTable.startGlyph + classDefTable.classes.length\n                ) {\n                    return classDefTable.classes[\n                        glyphIndex - classDefTable.startGlyph\n                    ];\n                }\n                return 0;\n            case 2:\n                var range = searchRange(classDefTable.ranges, glyphIndex);\n                return range ? range.classId : 0;\n        }\n    },\n\n    /**\n     * Find a glyph in a coverage table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n     * @param {object} coverageTable - an OpenType Layout coverage table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getCoverageIndex: function (coverageTable, glyphIndex) {\n        switch (coverageTable.format) {\n            case 1:\n                var index = binSearch(coverageTable.glyphs, glyphIndex);\n                return index >= 0 ? index : -1;\n            case 2:\n                var range = searchRange(coverageTable.ranges, glyphIndex);\n                return range ? range.index + glyphIndex - range.start : -1;\n        }\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function (coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            var glyphs = [];\n            var ranges = coverageTable.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                var start = range.start;\n                var end = range.end;\n                for (var j = start; j <= end; j++) {\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    },\n};\n\n// The Position object provides utility methods to manipulate\n\n/**\n * @exports opentype.Position\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Position(font) {\n    Layout.call(this, font, 'gpos');\n}\n\nPosition.prototype = Layout.prototype;\n\n/**\n * Init some data for faster and easier access later.\n */\nPosition.prototype.init = function() {\n    var script = this.getDefaultScriptName();\n    this.defaultKerningTables = this.getKerningTables(script);\n};\n\n/**\n * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n *\n * @param {integer} leftIndex - left glyph index\n * @param {integer} rightIndex - right glyph index\n * @returns {integer}\n */\nPosition.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n    for (var i = 0; i < kerningLookups.length; i++) {\n        var subtables = kerningLookups[i].subtables;\n        for (var j = 0; j < subtables.length; j++) {\n            var subtable = subtables[j];\n            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n            if (covIndex < 0) { continue; }\n            switch (subtable.posFormat) {\n                case 1:\n                    // Search Pair Adjustment Positioning Format 1\n                    var pairSet = subtable.pairSets[covIndex];\n                    for (var k = 0; k < pairSet.length; k++) {\n                        var pair = pairSet[k];\n                        if (pair.secondGlyph === rightIndex) {\n                            return pair.value1 && pair.value1.xAdvance || 0;\n                        }\n                    }\n                    break;      // left glyph found, not right glyph - try next subtable\n                case 2:\n                    // Search Pair Adjustment Positioning Format 2\n                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n                    var pair$1 = subtable.classRecords[class1][class2];\n                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n            }\n        }\n    }\n    return 0;\n};\n\n/**\n * List all kerning lookup tables.\n *\n * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n * @param {string} [language='dflt']\n * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n */\nPosition.prototype.getKerningTables = function(script, language) {\n    if (this.font.tables.gpos) {\n        return this.getLookupTables(script, language, 'kern', 2);\n    }\n};\n\n// The Substitution object provides utility methods to manipulate\n\n/**\n * @exports opentype.Substitution\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Substitution(font) {\n    Layout.call(this, font, 'gsub');\n}\n\n// Check if 2 arrays of primitives are equal.\nfunction arraysEqual(ar1, ar2) {\n    var n = ar1.length;\n    if (n !== ar2.length) {\n        return false;\n    }\n    for (var i = 0; i < n; i++) {\n        if (ar1[i] !== ar2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Find the first subtable of a lookup table in a particular format.\nfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n    var subtables = lookupTable.subtables;\n    for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i];\n        if (subtable.substFormat === format) {\n            return subtable;\n        }\n    }\n    if (defaultSubtable) {\n        subtables.push(defaultSubtable);\n        return defaultSubtable;\n    }\n    return undefined;\n}\n\nSubstitution.prototype = Layout.prototype;\n\n/**\n * Create a default GSUB table.\n * @return {Object} gsub - The GSUB table.\n */\nSubstitution.prototype.createDefaultTable = function () {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n        version: 1,\n        scripts: [\n            {\n                tag: 'DFLT',\n                script: {\n                    defaultLangSys: {\n                        reserved: 0,\n                        reqFeatureIndex: 0xffff,\n                        featureIndexes: [],\n                    },\n                    langSysRecords: [],\n                },\n            } ],\n        features: [],\n        lookups: [],\n    };\n};\n\n/**\n * List all single substitutions (lookup type 1) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getSingle = function (feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 1);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n            if (subtable.substFormat === 1) {\n                var delta = subtable.deltaGlyphId;\n                for (j = 0; j < glyphs.length; j++) {\n                    var glyph = glyphs[j];\n                    substitutions.push({ sub: glyph, by: glyph + delta });\n                }\n            } else {\n                var substitute = subtable.substitute;\n                for (j = 0; j < glyphs.length; j++) {\n                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n                }\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getMultiple = function (feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 2);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n\n            for (j = 0; j < glyphs.length; j++) {\n                var glyph = glyphs[j];\n                var replacements = subtable.sequences[j];\n                substitutions.push({ sub: glyph, by: replacements });\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all alternates (lookup type 3) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n * @return {Array} alternates - The list of alternates\n */\nSubstitution.prototype.getAlternates = function (feature, script, language) {\n    var alternates = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 3);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var alternateSets = subtable.alternateSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n            }\n        }\n    }\n    return alternates;\n};\n\n/**\n * List all ligatures (lookup type 4) for a given script, language, and feature.\n * The result is an array of ligature objects like { sub: [ids], by: id }\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} ligatures - The list of ligatures.\n */\nSubstitution.prototype.getLigatures = function (feature, script, language) {\n    var ligatures = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 4);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var ligatureSets = subtable.ligatureSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                var startGlyph = glyphs[j];\n                var ligSet = ligatureSets[j];\n                for (var k = 0; k < ligSet.length; k++) {\n                    var lig = ligSet[k];\n                    ligatures.push({\n                        sub: [startGlyph].concat(lig.components),\n                        by: lig.ligGlyph,\n                    });\n                }\n            }\n        }\n    }\n    return ligatures;\n};\n\n/**\n * Add or modify a single substitution (lookup type 1)\n * Format 2, more flexible, is always used.\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addSingle = function (\n    feature,\n    substitution,\n    script,\n    language\n) {\n    var lookupTable = this.getLookupTables(\n        script,\n        language,\n        feature,\n        1,\n        true\n    )[0];\n    var subtable = getSubstFormat(lookupTable, 2, {\n        // lookup type 1 subtable, format 2, coverage format 1\n        substFormat: 2,\n        coverage: { format: 1, glyphs: [] },\n        substitute: [],\n    });\n    check.assert(\n        subtable.coverage.format === 1,\n        'Single: unable to modify coverage table format ' +\n            subtable.coverage.format\n    );\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.substitute.splice(pos, 0, 0);\n    }\n    subtable.substitute[pos] = substitution.by;\n};\n\n/**\n * Add or modify a multiple substitution (lookup type 2)\n * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addMultiple = function (\n    feature,\n    substitution,\n    script,\n    language\n) {\n    check.assert(\n        substitution.by instanceof Array && substitution.by.length > 1,\n        'Multiple: \"by\" must be an array of two or more ids'\n    );\n    var lookupTable = this.getLookupTables(\n        script,\n        language,\n        feature,\n        2,\n        true\n    )[0];\n    var subtable = getSubstFormat(lookupTable, 1, {\n        // lookup type 2 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: { format: 1, glyphs: [] },\n        sequences: [],\n    });\n    check.assert(\n        subtable.coverage.format === 1,\n        'Multiple: unable to modify coverage table format ' +\n            subtable.coverage.format\n    );\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.sequences.splice(pos, 0, 0);\n    }\n    subtable.sequences[pos] = substitution.by;\n};\n\n/**\n * Add or modify an alternate substitution (lookup type 3)\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: [ids] }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addAlternate = function (\n    feature,\n    substitution,\n    script,\n    language\n) {\n    var lookupTable = this.getLookupTables(\n        script,\n        language,\n        feature,\n        3,\n        true\n    )[0];\n    var subtable = getSubstFormat(lookupTable, 1, {\n        // lookup type 3 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: { format: 1, glyphs: [] },\n        alternateSets: [],\n    });\n    check.assert(\n        subtable.coverage.format === 1,\n        'Alternate: unable to modify coverage table format ' +\n            subtable.coverage.format\n    );\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.alternateSets.splice(pos, 0, 0);\n    }\n    subtable.alternateSets[pos] = substitution.by;\n};\n\n/**\n * Add a ligature (lookup type 4)\n * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} ligature - { sub: [ids], by: id }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addLigature = function (\n    feature,\n    ligature,\n    script,\n    language\n) {\n    var lookupTable = this.getLookupTables(\n        script,\n        language,\n        feature,\n        4,\n        true\n    )[0];\n    var subtable = lookupTable.subtables[0];\n    if (!subtable) {\n        subtable = {\n            // lookup type 4 subtable, format 1, coverage format 1\n            substFormat: 1,\n            coverage: { format: 1, glyphs: [] },\n            ligatureSets: [],\n        };\n        lookupTable.subtables[0] = subtable;\n    }\n    check.assert(\n        subtable.coverage.format === 1,\n        'Ligature: unable to modify coverage table format ' +\n            subtable.coverage.format\n    );\n    var coverageGlyph = ligature.sub[0];\n    var ligComponents = ligature.sub.slice(1);\n    var ligatureTable = {\n        ligGlyph: ligature.by,\n        components: ligComponents,\n    };\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos >= 0) {\n        // ligatureSet already exists\n        var ligatureSet = subtable.ligatureSets[pos];\n        for (var i = 0; i < ligatureSet.length; i++) {\n            // If ligature already exists, return.\n            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                return;\n            }\n        }\n        // ligature does not exist: add it.\n        ligatureSet.push(ligatureTable);\n    } else {\n        // Create a new ligatureSet and add coverage for the first glyph.\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n    }\n};\n\n/**\n * List all feature data for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getFeature = function (feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.getSingle(feature, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            return this.getSingle(feature, script, language).concat(\n                this.getAlternates(feature, script, language)\n            );\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.getLigatures(feature, script, language);\n        case 'ccmp':\n            return this.getMultiple(feature, script, language).concat(\n                this.getLigatures(feature, script, language)\n            );\n        case 'stch':\n            return this.getMultiple(feature, script, language);\n    }\n    return undefined;\n};\n\n/**\n * Add a substitution to a feature for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.add = function (feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.addSingle(feature, sub, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            if (typeof sub.by === 'number') {\n                return this.addSingle(feature, sub, script, language);\n            }\n            return this.addAlternate(feature, sub, script, language);\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.addLigature(feature, sub, script, language);\n        case 'ccmp':\n            if (sub.by instanceof Array) {\n                return this.addMultiple(feature, sub, script, language);\n            }\n            return this.addLigature(feature, sub, script, language);\n    }\n    return undefined;\n};\n\nfunction checkArgument(expression, message) {\n    if (!expression) {\n        throw message;\n    }\n}\n\n// Parsing utility functions\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false);\n    var fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    var tag = '';\n    for (var i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    var v = 0;\n    for (var i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    var bytes = [];\n    for (var i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    var s = '';\n    for (var i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n}\n\nvar typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    var v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    var v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    var v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\nParser.prototype.parseFixed = function() {\n    var v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseString = function(length) {\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    var string = '';\n    this.relativeOffset += length;\n    for (var i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseVersion = function(minorBase) {\n    var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // Default returns the correct number if minor = 0xN000 where N is 0-9\n    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    if (minorBase === undefined) { minorBase = 0x1000; }\n    return major + minor / minorBase / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 32 bit unsigned integers.\nParser.prototype.parseULongList = function(count) {\n    if (count === undefined) { count = this.parseULong(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint32(offset);\n        offset += 4;\n    }\n\n    this.relativeOffset += count * 4;\n    return offsets;\n};\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    if (count === undefined) { count = this.parseUShort(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getUint8(offset++);\n    }\n\n    this.relativeOffset += count;\n    return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\nParser.prototype.parseList32 = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseULong();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\nParser.prototype.parseRecordList32 = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseULong();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === 'function') {\n        return description.call(this);\n    } else {\n        var fields = Object.keys(description);\n        var struct = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n\n/**\n * Parse a GPOS valueRecord\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat is optional, if omitted it is read from the stream.\n */\nParser.prototype.parseValueRecord = function(valueFormat) {\n    if (valueFormat === undefined) {\n        valueFormat = this.parseUShort();\n    }\n    if (valueFormat === 0) {\n        // valueFormat2 in kerning pairs is most often 0\n        // in this case return undefined instead of an empty object, to save space\n        return;\n    }\n    var valueRecord = {};\n\n    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n    return valueRecord;\n};\n\n/**\n * Parse a list of GPOS valueRecords\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat and valueCount are read from the stream.\n */\nParser.prototype.parseValueRecordList = function() {\n    var valueFormat = this.parseUShort();\n    var valueCount = this.parseUShort();\n    var values = new Array(valueCount);\n    for (var i = 0; i < valueCount; i++) {\n        values[i] = this.parseValueRecord(valueFormat);\n    }\n    return values;\n};\n\nParser.prototype.parsePointer = function(description) {\n    var structOffset = this.parseOffset16();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\nParser.prototype.parsePointer32 = function(description) {\n    var structOffset = this.parseOffset32();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function(itemCallback) {\n    var offsets = this.parseOffset16List();\n    var count = offsets.length;\n    var relativeOffset = this.relativeOffset;\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        var start = offsets[i];\n        if (start === 0) {\n            // NULL offset\n            // Add i as owned property to list. Convenient with assert.\n            list[i] = undefined;\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            var subOffsets = this.parseOffset16List();\n            var subList = new Array(subOffsets.length);\n            for (var j = 0; j < subOffsets.length; j++) {\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    var count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        var ranges = new Array(count);\n        for (var i = 0; i < count; i++) {\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\n\nParser.list32 = function(count, itemCallback) {\n    return function() {\n        return this.parseList32(count, itemCallback);\n    };\n};\n\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\n\nParser.recordList32 = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList32(count, recordDescription);\n    };\n};\n\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\n\nParser.pointer32 = function(description) {\n    return function() {\n        return this.parsePointer32(description);\n    };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\nParser.uLongList = Parser.prototype.parseULongList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nvar langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(langSysTable)\n            })\n        })\n    })) || [];\n};\n\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    })) || [];\n};\n\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        var lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n        var lookupFlag = this.parseUShort();\n        var useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    }))) || [];\n};\n\nParser.prototype.parseFeatureVariationsList = function() {\n    return this.parsePointer32(function() {\n        var majorVersion = this.parseUShort();\n        var minorVersion = this.parseUShort();\n        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n        var featureVariations = this.parseRecordList32({\n            conditionSetOffset: Parser.offset32,\n            featureTableSubstitutionOffset: Parser.offset32\n        });\n        return featureVariations;\n    }) || [];\n};\n\nvar parse = {\n    getByte: getByte,\n    getCard8: getByte,\n    getUShort: getUShort,\n    getCard16: getUShort,\n    getShort: getShort,\n    getULong: getULong,\n    getFixed: getFixed,\n    getTag: getTag,\n    getOffset: getOffset,\n    getBytes: getBytes,\n    bytesToString: bytesToString,\n    Parser: Parser,\n};\n\n// The `glyf` table describes the glyphs in TrueType outline format.\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    var flags;\n    var flag;\n\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        var endPointIndices = glyph.endPointIndices = [];\n        for (var i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n                for (var j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i$2 += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            var points = [];\n            var point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n                    flag = flags[i$3];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n                    points.push(point);\n                }\n\n                var px = 0;\n                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n                    flag = flags[i$4];\n                    point = points[i$4];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                var py = 0;\n                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n                    flag = flags[i$5];\n                    point = points[i$5];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        var moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                }\n\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n                }\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        var newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    var p = new Path();\n    if (!points) {\n        return p;\n    }\n\n    var contours = getContours(points);\n\n    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n        var contour = contours[contourIndex];\n\n        var prev = null;\n        var curr = contour[contour.length - 1];\n        var next = contour[0];\n\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                p.moveTo(start.x, start.y);\n            }\n        }\n\n        for (var i = 0; i < contour.length; ++i) {\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                var prev2 = prev;\n                var next2 = next;\n\n                if (!prev.onCurve) {\n                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                }\n\n                if (!next.onCurve) {\n                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                }\n\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n\n        p.closePath();\n    }\n    return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (var j = 0; j < glyph.components.length; j += 1) {\n            var component = glyph.components[j];\n            var componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                var transformedPoints = (void 0);\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                        throw Error('Matched points out of range in ' + glyph.name);\n                    }\n                    var firstPt = glyph.points[component.matchedPoints[0]];\n                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    var transform = {\n                        xScale: component.xScale, scale01: component.scale01,\n                        scale10: component.scale10, yScale: component.yScale,\n                        dx: 0, dy: 0\n                    };\n                    secondPt = transformPoints([secondPt], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\nfunction parseGlyfTableAll(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    // The last element of the loca table is invalid.\n    for (var i = 0; i < loca.length - 1; i += 1) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\nfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    font._push = function(i) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    };\n\n    return glyphs;\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font, opt) {\n    if (opt.lowMemory)\n        { return parseGlyfTableOnLowMemory(data, start, loca, font); }\n    else\n        { return parseGlyfTableAll(data, start, loca, font); }\n}\n\nvar glyf = { getPath: getPath, parse: parseGlyfTable};\n\n/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n\nvar instructionTable;\nvar exec;\nvar execGlyph;\nvar execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n\n    this.getCommands = function (hPoints) {\n        return glyf.getPath(hPoints).commands;\n    };\n\n    // cached states\n    this._fpgmState  =\n    this._prepState  =\n        undefined;\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n    return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nvar roundSuper = function (v) {\n    var period = this.srPeriod;\n    var phase = this.srPhase;\n    var threshold = this.srThreshold;\n    var sign = 1;\n\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n\n    v += threshold - phase;\n\n    v = Math.trunc(v / period) * period;\n\n    v += phase;\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (v < 0) { return phase * sign; }\n\n    return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nvar xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.xTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.xTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.xTouched = false;\n    }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nvar yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.yTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.yTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.yTouched = false;\n    }\n};\n\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return (\n        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n        this.y * yUnitVector.distance(p1, p2, o1, o2)\n    );\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    var dm1;\n    var dm2;\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dt;\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n\n    var pvns = pv.normalSlope;\n    var fvs = this.slope;\n\n    var px = p.x;\n    var py = p.y;\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n    var d = Math.sqrt(x * x + y * y);\n\n    x /= d;\n    y /= d;\n\n    if (x === 1 && y === 0) { return xUnitVector; }\n    else if (x === 0 && y === 1) { return yUnitVector; }\n    else { return new UnitVector(x, y); }\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(\n    x,\n    y,\n    lastPointOfContour,\n    onCurve\n) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n\n    Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function(v) {\n    var p = this.nextPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n    return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function(v) {\n    var p = this.prevPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n    return p;\n};\n\n/*\n* The zero point.\n*/\nvar HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nvar defaultState = {\n    cvCutIn: 17 / 16,    // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,             // loops some instructions\n    minDis: 1,           // minimum distance\n    autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n\n    switch (env) {\n        case 'glyf' :\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n            /* fall through */\n        case 'prep' :\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== 'number') {\n        throw new Error('Point size is not a number!');\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) { return; }\n\n    var font = this.font;\n    var prepState = this._prepState;\n\n    if (!prepState || prepState.ppem !== ppem) {\n        var fpgmState = this._fpgmState;\n\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n\n            fpgmState =\n            this._fpgmState =\n                new State('fpgm', font.tables.fpgm);\n\n            fpgmState.funcs = [ ];\n            fpgmState.font = font;\n\n            if (exports.DEBUG) {\n                console.log('---EXEC FPGM---');\n                fpgmState.step = -1;\n            }\n\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log('Hinting error in FPGM:' + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n\n        State.prototype = fpgmState;\n        prepState =\n        this._prepState =\n            new State('prep', font.tables.prep);\n\n        prepState.ppem = ppem;\n\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        var oCvt = font.tables.cvt;\n        if (oCvt) {\n            var cvt = prepState.cvt = new Array(oCvt.length);\n            var scale = ppem / font.unitsPerEm;\n            for (var c = 0; c < oCvt.length; c++) {\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n\n        if (exports.DEBUG) {\n            console.log('---EXEC PREP---');\n            prepState.step = -1;\n        }\n\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log('Hinting error in PREP:' + e);\n            }\n            this._errorState = 2;\n        }\n    }\n\n    if (this._errorState > 1) { return; }\n\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log('Hinting error:' + e);\n            console.log('Note: further hinting errors are silenced');\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function(glyph, prepState) {\n    // original point positions\n    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n    var yScale = xScale;\n    var components = glyph.components;\n    var contours;\n    var gZone;\n    var state;\n\n    State.prototype = prepState;\n    if (!components) {\n        state = new State('glyf', glyph.instructions);\n        if (exports.DEBUG) {\n            console.log('---EXEC GLYPH---');\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        var font = prepState.font;\n        gZone = [];\n        contours = [];\n        for (var i = 0; i < components.length; i++) {\n            var c = components[i];\n            var cg = font.glyphs.get(c.glyphIndex);\n\n            state = new State('glyf', cg.instructions);\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMP ' + i + '---');\n                state.step = -1;\n            }\n\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            var dx = Math.round(c.dx * xScale);\n            var dy = Math.round(c.dy * yScale);\n            var gz = state.gZone;\n            var cc = state.contours;\n            for (var pi = 0; pi < gz.length; pi++) {\n                var p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n\n            var gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for (var j = 0; j < cc.length; j++) {\n                contours.push(cc[j] + gLen);\n            }\n        }\n\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State('glyf', glyph.instructions);\n\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n            state.contours = contours;\n\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(\n                new HPoint(0, 0),\n                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n            );\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMPOSITE---');\n                state.step = -1;\n            }\n\n            exec(state);\n\n            gZone.length -= 2;\n        }\n    }\n\n    return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself for a non-component glyph.\n*/\nexecComponent = function(glyph, state, xScale, yScale)\n{\n    var points = glyph.points || [];\n    var pLen = points.length;\n    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    var contours = state.contours = [];\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    var cp; // current point\n    for (var i = 0; i < pLen; i++) {\n        cp = points[i];\n\n        gZone[i] = new HPoint(\n            cp.x * xScale,\n            cp.y * yScale,\n            cp.lastPointOfContour,\n            cp.onCurve\n        );\n    }\n\n    // Chain links the contours.\n    var sp; // start point\n    var np; // next point\n\n    for (var i$1 = 0; i$1 < pLen; i$1++) {\n        cp = gZone[i$1];\n\n        if (!sp) {\n            sp = cp;\n            contours.push(i$1);\n        }\n\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i$1 + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n\n    if (state.inhibitGridFit) { return; }\n\n    if (exports.DEBUG) {\n        console.log('PROCESSING GLYPH', state.stack);\n        for (var i$2 = 0; i$2 < pLen; i$2++) {\n            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n        }\n    }\n\n    gZone.push(\n        new HPoint(0, 0),\n        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n    );\n\n    exec(state);\n\n    // Removes the extra points.\n    gZone.length -= 2;\n\n    if (exports.DEBUG) {\n        console.log('FINISHED GLYPH', state.stack);\n        for (var i$3 = 0; i$3 < pLen; i$3++) {\n            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n        }\n    }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function(state) {\n    var prog = state.prog;\n\n    if (!prog) { return; }\n\n    var pLen = prog.length;\n    var ins;\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n        if (exports.DEBUG) { state.step++; }\n        ins = instructionTable[prog[state.ip]];\n\n        if (!ins) {\n            throw new Error(\n                'unknown instruction: 0x' +\n                Number(prog[state.ip]).toString(16)\n            );\n        }\n\n        ins(state);\n\n        // very extensive debugging for each step\n        /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state)\n{\n    var tZone = state.tZone = new Array(state.gZone.length);\n\n    // no idea if this is actually correct...\n    for (var i = 0; i < tZone.length; i++)\n    {\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse)\n{\n    var prog = state.prog;\n    var ip = state.ip;\n    var nesting = 1;\n    var ins;\n\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) // IF\n            { nesting++; }\n        else if (ins === 0x59) // EIF\n            { nesting--; }\n        else if (ins === 0x40) // NPUSHB\n            { ip += prog[ip + 1] + 1; }\n        else if (ins === 0x41) // NPUSHW\n            { ip += 2 * prog[ip + 1] + 1; }\n        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n            { ip += ins - 0xB0 + 1; }\n        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n            { ip += (ins - 0xB8 + 1) * 2; }\n        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n            { break; }\n    } while (nesting > 0);\n\n    state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n    state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n    state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n    state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    var stack = state.stack;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    var stack = state.stack;\n    var fv = state.fv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state)\n{\n    var stack = state.stack;\n    var pa0i = stack.pop();\n    var pa1i = stack.pop();\n    var pb0i = stack.pop();\n    var pb1i = stack.pop();\n    var pi = stack.pop();\n    var z0 = state.z0;\n    var z1 = state.z1;\n    var pa0 = z0[pa0i];\n    var pa1 = z0[pa1i];\n    var pb0 = z1[pb0i];\n    var pb1 = z1[pb1i];\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    var x1 = pa0.x;\n    var y1 = pa0.y;\n    var x2 = pa1.x;\n    var y2 = pa1.y;\n    var x3 = pb0.x;\n    var y3 = pb0.y;\n    var x4 = pb1.x;\n    var y4 = pb1.y;\n\n    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    var f1 = x1 * y2 - y1 * x2;\n    var f2 = x3 * y4 - y3 * x4;\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n    state.zp0 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n    state.zp1 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z1 = state.tZone;\n            break;\n        case 1 :\n            state.z1 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n    state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n    state.zp0 = state.zp1 = state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n    state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n    state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    var d = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n    state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n    skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    var o = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n    state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n    stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n    state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n    state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    var stack = state.stack;\n\n    var a = stack.pop();\n    var b = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n    stack.push(a);\n    stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n    stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    var stack = state.stack;\n    var fn = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    for (var i = 0; i < c; i++) {\n        exec(state);\n\n        if (exports.DEBUG) { console.log(\n            ++state.step,\n            i + 1 < c ? 'next loopcall' : 'done loopcall',\n            i\n        ); }\n    }\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    var fn = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    exec(state);\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n\n    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    var fn = stack.pop();\n    var ipBegin = ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n    while (prog[++ip] !== 0x2D){ }\n\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    var pi = state.stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) { d = state.round(d); }\n\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    var z2 = state.z2;\n    var pLen = z2.length - 2;\n    var cp;\n    var pp;\n    var np;\n\n    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n    for (var i = 0; i < pLen; i++) {\n        cp = z2[i]; // current point\n\n        // if this point has been touched go on\n        if (v.touched(cp)) { continue; }\n\n        pp = cp.prevTouched(v);\n\n        // no point on the contour has been touched?\n        if (pp === cp) { continue; }\n\n        np = cp.nextTouched(v);\n\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n\n        v.interpolate(cp, pp, np, v);\n    }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var loop = state.loop;\n    var z2 = state.z2;\n\n    while (loop--)\n    {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        var d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ?\n                   'loop ' + (state.loop - loop) + ': ' :\n                   ''\n                ) +\n                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n            );\n        }\n    }\n\n    state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var ci = stack.pop();\n    var sp = state.z2[state.contours[ci]];\n    var p = sp;\n\n    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n    var d = pv.distance(rp, rp, false, true);\n\n    do {\n        if (p !== rp) { fv.setRelative(p, p, d, pv); }\n        p = p.nextPointOnContour;\n    } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n    var z;\n    switch (e) {\n        case 0 : z = state.tZone; break;\n        case 1 : z = state.gZone; break;\n        default : throw new Error('Invalid zone');\n    }\n\n    var p;\n    var d = pv.distance(rp, rp, false, true);\n    var pLen = z.length - 2;\n    for (var i = 0; i < pLen; i++)\n    {\n        p = z[i];\n        fv.setRelative(p, p, d, pv);\n        //if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    var stack = state.stack;\n    var loop = state.loop;\n    var fv = state.fv;\n    var d = stack.pop() / 0x40;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'SHPIX[]', pi, d\n            );\n        }\n\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    var stack = state.stack;\n    var rp1i = state.rp1;\n    var rp2i = state.rp2;\n    var loop = state.loop;\n    var rp1 = state.z0[rp1i];\n    var rp2 = state.z1[rp2i];\n    var fv = state.fv;\n    var pv = state.dpv;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'IP[]', pi, rp1i, '<->', rp2i\n            );\n        }\n\n        fv.interpolate(p, rp1, rp2, pv);\n\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    var stack = state.stack;\n    var d = stack.pop() / 64;\n    var pi = stack.pop();\n    var p = state.z1[pi];\n    var rp0 = state.z0[state.rp0];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) { state.rp0 = pi; }\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    var stack = state.stack;\n    var rp0i = state.rp0;\n    var rp0 = state.z0[rp0i];\n    var loop = state.loop;\n    var fv = state.fv;\n    var pv = state.pv;\n    var z1 = state.z1;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z1[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'ALIGNRP[]', pi\n            );\n        }\n\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n    state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var pi = stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var cv = state.cvt[n];\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            'MIAP[' + round + ']',\n            n, '(', cv, ')', pi\n        );\n    }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) {\n        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n        d = state.round(d);\n    }\n\n    fv.setRelative(p, HPZero, d, pv);\n\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    var prog = state.prog;\n    var ip = state.ip;\n    var stack = state.stack;\n\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    if (!store) { store = state.store = []; }\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n    store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n    var v = (store && store[l]) || 0;\n\n    stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    var stack = state.stack;\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n    state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    var stack = state.stack;\n    var cvte = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n    stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    var stack = state.stack;\n    var pi = stack.pop();\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    var stack = state.stack;\n    var pi2 = stack.pop();\n    var pi1 = stack.pop();\n    var p2 = state.z1[pi2];\n    var p1 = state.z0[pi1];\n    var d = state.dpv.distance(p1, p2, a, a);\n\n    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n    state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n    state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n    state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n    stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n    stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n    stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    var test = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n\n        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }\n    }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n    stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n    stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    var stack = state.stack;\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n    stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var fv = state.fv;\n    var pv = state.pv;\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n    var z0 = state.z0;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var pi = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n        var p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n    state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n    state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n    stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n    stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n    stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n    stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n    stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n    stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    var stack = state.stack;\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var c = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n\n        var delta = mag * ds;\n\n        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n        state.cvt[c] += delta;\n    }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error('invalid SROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default: throw new Error('invalid SROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n    state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n    state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n    state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    var n = state.stack.pop();\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    var stack = state.stack;\n    var sel = stack.pop();\n    var r = 0;\n\n    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) { r = 35; }\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) { r |= 0x1000; }\n\n    stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    var stack = state.stack;\n    var a = stack.pop();\n    var b = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n    stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n    stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    var n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    var s = state.stack.pop();\n    var v = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n    switch (s) {\n        case 1 : state.inhibitGridFit = !!v; return;\n        case 2 : state.ignoreCvt = !!v; return;\n        default: throw new Error('invalid INSTCTRL[] selector');\n    }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    var stack = state.stack;\n    var cvte = indirect && stack.pop();\n    var pi = stack.pop();\n    var rp0i = state.rp0;\n    var rp = state.z0[rp0i];\n    var p = state.z1[pi];\n\n    var md = state.minDis;\n    var fv = state.fv;\n    var pv = state.dpv;\n    var od; // original distance\n    var d; // moving distance\n    var sign; // sign of distance\n    var cv;\n\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d);\n\n    if (indirect) {\n        cv = state.cvt[cvte];\n\n        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n    }\n\n    if (keepD && d < md) { d = md; }\n\n    if (ro) { d = state.round(d); }\n\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            (indirect ? 'MIRP[' : 'MDRP[') +\n            (setRp0 ? 'M' : 'm') +\n            (keepD ? '>' : '_') +\n            (ro ? 'R' : '_') +\n            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n            ']',\n            indirect ?\n                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                '',\n            pi,\n            '(d =', od, '->', sign * d, ')'\n        );\n    }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) { state.rp0 = pi; }\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,   // TODO SSWCI\n    /* 0x1F */ undefined,   // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,   // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,   // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,   // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,   // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,   // TODO FLIPOFF\n    /* 0x4F */ undefined,   // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,   // TODO NROUND[ab]\n    /* 0x6D */ undefined,   // TODO NROUND[ab]\n    /* 0x6E */ undefined,   // TODO NROUND[ab]\n    /* 0x6F */ undefined,   // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,   // TODO JROT[]\n    /* 0x79 */ undefined,   // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined,   // TODO FLIPPT\n    /* 0x81 */ undefined,   // TODO FLIPRGON\n    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,   // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n\n/**\n * Converts a string into a list of tokens.\n */\n\n/**\n * Create a new token\n * @param {string} char a single char\n */\nfunction Token(char) {\n    this.char = char;\n    this.state = {};\n    this.activeState = null;\n}\n\n/**\n * Create a new context range\n * @param {number} startIndex range start index\n * @param {number} endOffset range end index offset\n * @param {string} contextName owner context name\n */\nfunction ContextRange(startIndex, endOffset, contextName) {\n    this.contextName = contextName;\n    this.startIndex = startIndex;\n    this.endOffset = endOffset;\n}\n\n/**\n * Check context start and end\n * @param {string} contextName a unique context name\n * @param {function} checkStart a predicate function the indicates a context's start\n * @param {function} checkEnd a predicate function the indicates a context's end\n */\nfunction ContextChecker(contextName, checkStart, checkEnd) {\n    this.contextName = contextName;\n    this.openRange = null;\n    this.ranges = [];\n    this.checkStart = checkStart;\n    this.checkEnd = checkEnd;\n}\n\n/**\n * @typedef ContextParams\n * @type Object\n * @property {array} context context items\n * @property {number} currentIndex current item index\n */\n\n/**\n * Create a context params\n * @param {array} context a list of items\n * @param {number} currentIndex current item index\n */\nfunction ContextParams(context, currentIndex) {\n    this.context = context;\n    this.index = currentIndex;\n    this.length = context.length;\n    this.current = context[currentIndex];\n    this.backtrack = context.slice(0, currentIndex);\n    this.lookahead = context.slice(currentIndex + 1);\n}\n\n/**\n * Create an event instance\n * @param {string} eventId event unique id\n */\nfunction Event(eventId) {\n    this.eventId = eventId;\n    this.subscribers = [];\n}\n\n/**\n * Initialize a core events and auto subscribe required event handlers\n * @param {any} events an object that enlists core events handlers\n */\nfunction initializeCoreEvents(events) {\n    var this$1 = this;\n\n    var coreEvents = [\n        'start', 'end', 'next', 'newToken', 'contextStart',\n        'contextEnd', 'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'\n    ];\n\n    coreEvents.forEach(function (eventId) {\n        Object.defineProperty(this$1.events, eventId, {\n            value: new Event(eventId)\n        });\n    });\n\n    if (!!events) {\n        coreEvents.forEach(function (eventId) {\n            var event = events[eventId];\n            if (typeof event === 'function') {\n                this$1.events[eventId].subscribe(event);\n            }\n        });\n    }\n    var requiresContextUpdate = [\n        'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD'\n    ];\n    requiresContextUpdate.forEach(function (eventId) {\n        this$1.events[eventId].subscribe(\n            this$1.updateContextsRanges\n        );\n    });\n}\n\n/**\n * Converts a string into a list of tokens\n * @param {any} events tokenizer core events\n */\nfunction Tokenizer(events) {\n    this.tokens = [];\n    this.registeredContexts = {};\n    this.contextCheckers = [];\n    this.events = {};\n    this.registeredModifiers = [];\n\n    initializeCoreEvents.call(this, events);\n}\n\n/**\n * Sets the state of a token, usually called by a state modifier.\n * @param {string} key state item key\n * @param {any} value state item value\n */\nToken.prototype.setState = function(key, value) {\n    this.state[key] = value;\n    this.activeState = { key: key, value: this.state[key] };\n    return this.activeState;\n};\n\nToken.prototype.getState = function (stateId) {\n    return this.state[stateId] || null;\n};\n\n/**\n * Checks if an index exists in the tokens list.\n * @param {number} index token index\n */\nTokenizer.prototype.inboundIndex = function(index) {\n    return index >= 0 && index < this.tokens.length;\n};\n\n/**\n * Compose and apply a list of operations (replace, update, delete)\n * @param {array} RUDs replace, update and delete operations\n * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n */\nTokenizer.prototype.composeRUD = function (RUDs) {\n    var this$1 = this;\n\n    var silent = true;\n    var state = RUDs.map(function (RUD) { return (\n        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n    ); });\n    var hasFAILObject = function (obj) { return (\n        typeof obj === 'object' &&\n        obj.hasOwnProperty('FAIL')\n    ); };\n    if (state.every(hasFAILObject)) {\n        return {\n            FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n            report: state.filter(hasFAILObject)\n        };\n    }\n    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);\n};\n\n/**\n * Replace a range of tokens with a list of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {token} tokens a list of tokens to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n    offset = offset !== null ? offset : this.tokens.length;\n    var isTokenType = tokens.every(function (token) { return token instanceof Token; });\n    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n        var replaced = this.tokens.splice.apply(\n            this.tokens, [startIndex, offset].concat(tokens)\n        );\n        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }\n        return [replaced, tokens];\n    } else {\n        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };\n    }\n};\n\n/**\n * Replace a token with another token\n * @param {number} index token index\n * @param {token} token a token to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceToken = function (index, token, silent) {\n    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n        var replaced = this.tokens.splice(index, 1, token);\n        if (!silent) { this.dispatch('replaceToken', [index, token]); }\n        return [replaced[0], token];\n    } else {\n        return { FAIL: 'replaceToken: invalid token or index.' };\n    }\n};\n\n/**\n * Removes a range of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n    offset = !isNaN(offset) ? offset : this.tokens.length;\n    var tokens = this.tokens.splice(startIndex, offset);\n    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }\n    return tokens;\n};\n\n/**\n * Remove a token at a certain index\n * @param {number} index token index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeToken = function(index, silent) {\n    if (!isNaN(index) && this.inboundIndex(index)) {\n        var token = this.tokens.splice(index, 1);\n        if (!silent) { this.dispatch('removeToken', [token, index]); }\n        return token;\n    } else {\n        return { FAIL: 'removeToken: invalid token index.' };\n    }\n};\n\n/**\n * Insert a list of tokens at a certain index\n * @param {array} tokens a list of tokens to insert\n * @param {number} index insert the list of tokens at index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.insertToken = function (tokens, index, silent) {\n    var tokenType = tokens.every(\n        function (token) { return token instanceof Token; }\n    );\n    if (tokenType) {\n        this.tokens.splice.apply(\n            this.tokens, [index, 0].concat(tokens)\n        );\n        if (!silent) { this.dispatch('insertToken', [tokens, index]); }\n        return tokens;\n    } else {\n        return { FAIL: 'insertToken: invalid token(s).' };\n    }\n};\n\n/**\n * A state modifier that is called on 'newToken' event\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a function to update token state\n */\nTokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n    this.events.newToken.subscribe(function(token, contextParams) {\n        var conditionParams = [token, contextParams];\n        var canApplyModifier = (\n            condition === null ||\n            condition.apply(this, conditionParams) === true\n        );\n        var modifierParams = [token, contextParams];\n        if (canApplyModifier) {\n            var newStateValue = modifier.apply(this, modifierParams);\n            token.setState(modifierId, newStateValue);\n        }\n    });\n    this.registeredModifiers.push(modifierId);\n};\n\n/**\n * Subscribe a handler to an event\n * @param {function} eventHandler an event handler function\n */\nEvent.prototype.subscribe = function (eventHandler) {\n    if (typeof eventHandler === 'function') {\n        return ((this.subscribers.push(eventHandler)) - 1);\n    } else {\n        return { FAIL: (\"invalid '\" + (this.eventId) + \"' event handler\")};\n    }\n};\n\n/**\n * Unsubscribe an event handler\n * @param {string} subsId subscription id\n */\nEvent.prototype.unsubscribe = function (subsId) {\n    this.subscribers.splice(subsId, 1);\n};\n\n/**\n * Sets context params current value index\n * @param {number} index context params current value index\n */\nContextParams.prototype.setCurrentIndex = function(index) {\n    this.index = index;\n    this.current = this.context[index];\n    this.backtrack = this.context.slice(0, index);\n    this.lookahead = this.context.slice(index + 1);\n};\n\n/**\n * Get an item at an offset from the current value\n * example (current value is 3):\n *  1    2   [3]   4    5   |   items values\n * -2   -1    0    1    2   |   offset values\n * @param {number} offset an offset from current value index\n */\nContextParams.prototype.get = function (offset) {\n    switch (true) {\n        case (offset === 0):\n            return this.current;\n        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):\n            return this.backtrack.slice(offset)[0];\n        case (offset > 0 && offset <= this.lookahead.length):\n            return this.lookahead[offset - 1];\n        default:\n            return null;\n    }\n};\n\n/**\n * Converts a context range into a string value\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.rangeToText = function (range) {\n    if (range instanceof ContextRange) {\n        return (\n            this.getRangeTokens(range)\n                .map(function (token) { return token.char; }).join('')\n        );\n    }\n};\n\n/**\n * Converts all tokens into a string\n */\nTokenizer.prototype.getText = function () {\n    return this.tokens.map(function (token) { return token.char; }).join('');\n};\n\n/**\n * Get a context by name\n * @param {string} contextName context name to get\n */\nTokenizer.prototype.getContext = function (contextName) {\n    var context = this.registeredContexts[contextName];\n    return !!context ? context : null;\n};\n\n/**\n * Subscribes a new event handler to an event\n * @param {string} eventName event name to subscribe to\n * @param {function} eventHandler a function to be invoked on event\n */\nTokenizer.prototype.on = function(eventName, eventHandler) {\n    var event = this.events[eventName];\n    if (!!event) {\n        return event.subscribe(eventHandler);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Dispatches an event\n * @param {string} eventName event name\n * @param {any} args event handler arguments\n */\nTokenizer.prototype.dispatch = function(eventName, args) {\n    var this$1 = this;\n\n    var event = this.events[eventName];\n    if (event instanceof Event) {\n        event.subscribers.forEach(function (subscriber) {\n            subscriber.apply(this$1, args || []);\n        });\n    }\n};\n\n/**\n * Register a new context checker\n * @param {string} contextName a unique context name\n * @param {function} contextStartCheck a predicate function that returns true on context start\n * @param {function} contextEndCheck  a predicate function that returns true on context end\n * TODO: call tokenize on registration to update context ranges with the new context.\n */\nTokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n    if (!!this.getContext(contextName)) { return {\n        FAIL:\n        (\"context name '\" + contextName + \"' is already registered.\")\n    }; }\n    if (typeof contextStartCheck !== 'function') { return {\n        FAIL:\n        \"missing context start check.\"\n    }; }\n    if (typeof contextEndCheck !== 'function') { return {\n        FAIL:\n        \"missing context end check.\"\n    }; }\n    var contextCheckers = new ContextChecker(\n        contextName, contextStartCheck, contextEndCheck\n    );\n    this.registeredContexts[contextName] = contextCheckers;\n    this.contextCheckers.push(contextCheckers);\n    return contextCheckers;\n};\n\n/**\n * Gets a context range tokens\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.getRangeTokens = function(range) {\n    var endIndex = range.startIndex + range.endOffset;\n    return [].concat(\n        this.tokens\n            .slice(range.startIndex, endIndex)\n    );\n};\n\n/**\n * Gets the ranges of a context\n * @param {string} contextName context name\n */\nTokenizer.prototype.getContextRanges = function(contextName) {\n    var context = this.getContext(contextName);\n    if (!!context) {\n        return context.ranges;\n    } else {\n        return { FAIL: (\"context checker '\" + contextName + \"' is not registered.\") };\n    }\n};\n\n/**\n * Resets context ranges to run context update\n */\nTokenizer.prototype.resetContextsRanges = function () {\n    var registeredContexts = this.registeredContexts;\n    for (var contextName in registeredContexts) {\n        if (registeredContexts.hasOwnProperty(contextName)) {\n            var context = registeredContexts[contextName];\n            context.ranges = [];\n        }\n    }\n};\n\n/**\n * Updates context ranges\n */\nTokenizer.prototype.updateContextsRanges = function () {\n    this.resetContextsRanges();\n    var chars = this.tokens.map(function (token) { return token.char; });\n    for (var i = 0; i < chars.length; i++) {\n        var contextParams = new ContextParams(chars, i);\n        this.runContextCheck(contextParams);\n    }\n    this.dispatch('updateContextsRanges', [this.registeredContexts]);\n};\n\n/**\n * Sets the end offset of an open range\n * @param {number} offset range end offset\n * @param {string} contextName context name\n */\nTokenizer.prototype.setEndOffset = function (offset, contextName) {\n    var startIndex = this.getContext(contextName).openRange.startIndex;\n    var range = new ContextRange(startIndex, offset, contextName);\n    var ranges = this.getContext(contextName).ranges;\n    range.rangeId = contextName + \".\" + (ranges.length);\n    ranges.push(range);\n    this.getContext(contextName).openRange = null;\n    return range;\n};\n\n/**\n * Runs a context check on the current context\n * @param {contextParams} contextParams current context params\n */\nTokenizer.prototype.runContextCheck = function(contextParams) {\n    var this$1 = this;\n\n    var index = contextParams.index;\n    this.contextCheckers.forEach(function (contextChecker) {\n        var contextName = contextChecker.contextName;\n        var openRange = this$1.getContext(contextName).openRange;\n        if (!openRange && contextChecker.checkStart(contextParams)) {\n            openRange = new ContextRange(index, null, contextName);\n            this$1.getContext(contextName).openRange = openRange;\n            this$1.dispatch('contextStart', [contextName, index]);\n        }\n        if (!!openRange && contextChecker.checkEnd(contextParams)) {\n            var offset = (index - openRange.startIndex) + 1;\n            var range = this$1.setEndOffset(offset, contextName);\n            this$1.dispatch('contextEnd', [contextName, range]);\n        }\n    });\n};\n\n/**\n * Converts a text into a list of tokens\n * @param {string} text a text to tokenize\n */\nTokenizer.prototype.tokenize = function (text) {\n    this.tokens = [];\n    this.resetContextsRanges();\n    var chars = Array.from(text);\n    this.dispatch('start');\n    for (var i = 0; i < chars.length; i++) {\n        var char = chars[i];\n        var contextParams = new ContextParams(chars, i);\n        this.dispatch('next', [contextParams]);\n        this.runContextCheck(contextParams);\n        var token = new Token(char);\n        this.tokens.push(token);\n        this.dispatch('newToken', [token, contextParams]);\n    }\n    this.dispatch('end', [this.tokens]);\n    return this.tokens;\n};\n\n// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮\n// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊\n// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯\n// jscs:disable maximumLineLength\n/**\n * Check if a char is Arabic\n * @param {string} c a single char\n */\nfunction isArabicChar(c) {\n    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n}\n\n/**\n * Check if a char is an isolated arabic char\n * @param {string} c a single char\n */\nfunction isIsolatedArabicChar(char) {\n    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n}\n\n/**\n * Check if a char is an Arabic Tashkeel char\n * @param {string} c a single char\n */\nfunction isTashkeelArabicChar(char) {\n    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n}\n\n/**\n * Check if a char is Latin\n * @param {string} c a single char\n */\nfunction isLatinChar(c) {\n    return /[A-z]/.test(c);\n}\n\n/**\n * Check if a char is whitespace char\n * @param {string} c a single char\n */\nfunction isWhiteSpace(c) {\n    return /\\s/.test(c);\n}\n\n/**\n * Query a feature by some of it's properties to lookup a glyph substitution.\n */\n\n/**\n * Create feature query instance\n * @param {Font} font opentype font instance\n */\nfunction FeatureQuery(font) {\n    this.font = font;\n    this.features = {};\n}\n\n/**\n * @typedef SubstitutionAction\n * @type Object\n * @property {number} id substitution type\n * @property {string} tag feature tag\n * @property {any} substitution substitution value(s)\n */\n\n/**\n * Create a substitution action instance\n * @param {SubstitutionAction} action\n */\nfunction SubstitutionAction(action) {\n    this.id = action.id;\n    this.tag = action.tag;\n    this.substitution = action.substitution;\n}\n\n/**\n * Lookup a coverage table\n * @param {number} glyphIndex glyph index\n * @param {CoverageTable} coverage coverage table\n */\nfunction lookupCoverage(glyphIndex, coverage) {\n    if (!glyphIndex) { return -1; }\n    switch (coverage.format) {\n        case 1:\n            return coverage.glyphs.indexOf(glyphIndex);\n\n        case 2:\n            var ranges = coverage.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (glyphIndex >= range.start && glyphIndex <= range.end) {\n                    var offset = glyphIndex - range.start;\n                    return range.index + offset;\n                }\n            }\n            break;\n        default:\n            return -1; // not found\n    }\n    return -1;\n}\n\n/**\n * Handle a single substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return glyphIndex + subtable.deltaGlyphId;\n}\n\n/**\n * Handle a single substitution - format 2\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat2(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.substitute[substituteIndex];\n}\n\n/**\n * Lookup a list of coverage tables\n * @param {any} coverageList a list of coverage tables\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction lookupCoverageList(coverageList, contextParams) {\n    var lookupList = [];\n    for (var i = 0; i < coverageList.length; i++) {\n        var coverage = coverageList[i];\n        var glyphIndex = contextParams.current;\n        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n        var lookupIndex = lookupCoverage(glyphIndex, coverage);\n        if (lookupIndex !== -1) {\n            lookupList.push(lookupIndex);\n        }\n    }\n    if (lookupList.length !== coverageList.length) { return -1; }\n    return lookupList;\n}\n\n/**\n * Handle chaining context substitution - format 3\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction chainingSubstitutionFormat3(contextParams, subtable) {\n    var lookupsCount = (\n        subtable.inputCoverage.length +\n        subtable.lookaheadCoverage.length +\n        subtable.backtrackCoverage.length\n    );\n    if (contextParams.context.length < lookupsCount) { return []; }\n    // INPUT LOOKUP //\n    var inputLookups = lookupCoverageList(\n        subtable.inputCoverage, contextParams\n    );\n    if (inputLookups === -1) { return []; }\n    // LOOKAHEAD LOOKUP //\n    var lookaheadOffset = subtable.inputCoverage.length - 1;\n    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }\n    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n        lookaheadContext.shift();\n    }\n    var lookaheadParams = new ContextParams(lookaheadContext, 0);\n    var lookaheadLookups = lookupCoverageList(\n        subtable.lookaheadCoverage, lookaheadParams\n    );\n    // BACKTRACK LOOKUP //\n    var backtrackContext = [].concat(contextParams.backtrack);\n    backtrackContext.reverse();\n    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n        backtrackContext.shift();\n    }\n    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }\n    var backtrackParams = new ContextParams(backtrackContext, 0);\n    var backtrackLookups = lookupCoverageList(\n        subtable.backtrackCoverage, backtrackParams\n    );\n    var contextRulesMatch = (\n        inputLookups.length === subtable.inputCoverage.length &&\n        lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n        backtrackLookups.length === subtable.backtrackCoverage.length\n    );\n    var substitutions = [];\n    if (contextRulesMatch) {\n        for (var i = 0; i < subtable.lookupRecords.length; i++) {\n            var lookupRecord = subtable.lookupRecords[i];\n            var lookupListIndex = lookupRecord.lookupListIndex;\n            var lookupTable = this.getLookupByIndex(lookupListIndex);\n            for (var s = 0; s < lookupTable.subtables.length; s++) {\n                var subtable$1 = lookupTable.subtables[s];\n                var lookup = this.getLookupMethod(lookupTable, subtable$1);\n                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n                if (substitutionType === '12') {\n                    for (var n = 0; n < inputLookups.length; n++) {\n                        var glyphIndex = contextParams.get(n);\n                        var substitution = lookup(glyphIndex);\n                        if (substitution) { substitutions.push(substitution); }\n                    }\n                }\n            }\n        }\n    }\n    return substitutions;\n}\n\n/**\n * Handle ligature substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction ligatureSubstitutionFormat1(contextParams, subtable) {\n    // COVERAGE LOOKUP //\n    var glyphIndex = contextParams.current;\n    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (ligSetIndex === -1) { return null; }\n    // COMPONENTS LOOKUP\n    // (!) note, components are ordered in the written direction.\n    var ligature;\n    var ligatureSet = subtable.ligatureSets[ligSetIndex];\n    for (var s = 0; s < ligatureSet.length; s++) {\n        ligature = ligatureSet[s];\n        for (var l = 0; l < ligature.components.length; l++) {\n            var lookaheadItem = contextParams.lookahead[l];\n            var component = ligature.components[l];\n            if (lookaheadItem !== component) { break; }\n            if (l === ligature.components.length - 1) { return ligature; }\n        }\n    }\n    return null;\n}\n\n/**\n * Handle decomposition substitution - format 1\n * @param {number} glyphIndex glyph index\n * @param {any} subtable subtable\n */\nfunction decompositionSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.sequences[substituteIndex];\n}\n\n/**\n * Get default script features indexes\n */\nFeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n    var scripts = this.font.tables.gsub.scripts;\n    for (var s = 0; s < scripts.length; s++) {\n        var script = scripts[s];\n        if (script.tag === 'DFLT') { return (\n            script.script.defaultLangSys.featureIndexes\n        ); }\n    }\n    return [];\n};\n\n/**\n * Get feature indexes of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n    var tables = this.font.tables;\n    if (!tables.gsub) { return []; }\n    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }\n    var scripts = this.font.tables.gsub.scripts;\n    for (var i = 0; i < scripts.length; i++) {\n        var script = scripts[i];\n        if (script.tag === scriptTag && script.script.defaultLangSys) {\n            return script.script.defaultLangSys.featureIndexes;\n        } else {\n            var langSysRecords = script.langSysRecords;\n            if (!!langSysRecords) {\n                for (var j = 0; j < langSysRecords.length; j++) {\n                    var langSysRecord = langSysRecords[j];\n                    if (langSysRecord.tag === scriptTag) {\n                        var langSys = langSysRecord.langSys;\n                        return langSys.featureIndexes;\n                    }\n                }\n            }\n        }\n    }\n    return this.getDefaultScriptFeaturesIndexes();\n};\n\n/**\n * Map a feature tag to a gsub feature\n * @param {any} features gsub features\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n    var tags = {};\n    for (var i = 0; i < features.length; i++) {\n        var tag = features[i].tag;\n        var feature = features[i].feature;\n        tags[tag] = feature;\n    }\n    this.features[scriptTag].tags = tags;\n};\n\n/**\n * Get features of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n    var features = this.features[scriptTag];\n    if (this.features.hasOwnProperty(scriptTag)) { return features; }\n    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n    if (!featuresIndexes) { return null; }\n    var gsub = this.font.tables.gsub;\n    features = featuresIndexes.map(function (index) { return gsub.features[index]; });\n    this.features[scriptTag] = features;\n    this.mapTagsToFeatures(features, scriptTag);\n    return features;\n};\n\n/**\n * Get substitution type\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n    var lookupType = lookupTable.lookupType.toString();\n    var substFormat = subtable.substFormat.toString();\n    return lookupType + substFormat;\n};\n\n/**\n * Get lookup method\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n    var this$1 = this;\n\n    var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n    switch (substitutionType) {\n        case '11':\n            return function (glyphIndex) { return singleSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '12':\n            return function (glyphIndex) { return singleSubstitutionFormat2.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '63':\n            return function (contextParams) { return chainingSubstitutionFormat3.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '41':\n            return function (contextParams) { return ligatureSubstitutionFormat1.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '21':\n            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        default:\n            throw new Error(\n                \"lookupType: \" + (lookupTable.lookupType) + \" - \" +\n                \"substFormat: \" + (subtable.substFormat) + \" \" +\n                \"is not yet supported\"\n            );\n    }\n};\n\n/**\n * [ LOOKUP TYPES ]\n * -------------------------------\n * Single                        1;\n * Multiple                      2;\n * Alternate                     3;\n * Ligature                      4;\n * Context                       5;\n * ChainingContext               6;\n * ExtensionSubstitution         7;\n * ReverseChainingContext        8;\n * -------------------------------\n *\n */\n\n/**\n * @typedef FQuery\n * @type Object\n * @param {string} tag feature tag\n * @param {string} script feature script\n * @param {ContextParams} contextParams context params\n */\n\n/**\n * Lookup a feature using a query parameters\n * @param {FQuery} query feature query\n */\nFeatureQuery.prototype.lookupFeature = function (query) {\n    var contextParams = query.contextParams;\n    var currentIndex = contextParams.index;\n    var feature = this.getFeature({\n        tag: query.tag, script: query.script\n    });\n    if (!feature) { return new Error(\n        \"font '\" + (this.font.names.fullName.en) + \"' \" +\n        \"doesn't support feature '\" + (query.tag) + \"' \" +\n        \"for script '\" + (query.script) + \"'.\"\n    ); }\n    var lookups = this.getFeatureLookups(feature);\n    var substitutions = [].concat(contextParams.context);\n    for (var l = 0; l < lookups.length; l++) {\n        var lookupTable = lookups[l];\n        var subtables = this.getLookupSubtables(lookupTable);\n        for (var s = 0; s < subtables.length; s++) {\n            var subtable = subtables[s];\n            var substType = this.getSubstitutionType(lookupTable, subtable);\n            var lookup = this.getLookupMethod(lookupTable, subtable);\n            var substitution = (void 0);\n            switch (substType) {\n                case '11':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 11, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '12':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 12, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '63':\n                    substitution = lookup(contextParams);\n                    if (Array.isArray(substitution) && substitution.length) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 63, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '41':\n                    substitution = lookup(contextParams);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 41, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '21':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 21, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n            }\n            contextParams = new ContextParams(substitutions, currentIndex);\n            if (Array.isArray(substitution) && !substitution.length) { continue; }\n            substitution = null;\n        }\n    }\n    return substitutions.length ? substitutions : null;\n};\n\n/**\n * Checks if a font supports a specific features\n * @param {FQuery} query feature query object\n */\nFeatureQuery.prototype.supports = function (query) {\n    if (!query.script) { return false; }\n    this.getScriptFeatures(query.script);\n    var supportedScript = this.features.hasOwnProperty(query.script);\n    if (!query.tag) { return supportedScript; }\n    var supportedFeature = (\n        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })\n    );\n    return supportedScript && supportedFeature;\n};\n\n/**\n * Get lookup table subtables\n * @param {any} lookupTable lookup table\n */\nFeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n    return lookupTable.subtables || null;\n};\n\n/**\n * Get lookup table by index\n * @param {number} index lookup table index\n */\nFeatureQuery.prototype.getLookupByIndex = function (index) {\n    var lookups = this.font.tables.gsub.lookups;\n    return lookups[index] || null;\n};\n\n/**\n * Get lookup tables for a feature\n * @param {string} feature\n */\nFeatureQuery.prototype.getFeatureLookups = function (feature) {\n    // TODO: memoize\n    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\n\n/**\n * Query a feature by it's properties\n * @param {any} query an object that describes the properties of a query\n */\nFeatureQuery.prototype.getFeature = function getFeature(query) {\n    if (!this.font) { return { FAIL: \"No font was found\"}; }\n    if (!this.features.hasOwnProperty(query.script)) {\n        this.getScriptFeatures(query.script);\n    }\n    var scriptFeatures = this.features[query.script];\n    if (!scriptFeatures) { return (\n        { FAIL: (\"No feature for script \" + (query.script))}\n    ); }\n    if (!scriptFeatures.tags[query.tag]) { return null; }\n    return this.features[query.script].tags[query.tag];\n};\n\n/**\n * Arabic word context checkers\n */\n\nfunction arabicWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? arabic first char\n        (prevChar === null && isArabicChar(char)) ||\n        // ? arabic char preceded with a non arabic char\n        (!isArabicChar(prevChar) && isArabicChar(char))\n    );\n}\n\nfunction arabicWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last arabic char\n        (nextChar === null) ||\n        // ? next char is not arabic\n        (!isArabicChar(nextChar))\n    );\n}\n\nvar arabicWordCheck = {\n    startCheck: arabicWordStartCheck,\n    endCheck: arabicWordEndCheck\n};\n\n/**\n * Arabic sentence context checkers\n */\n\nfunction arabicSentenceStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? an arabic char preceded with a non arabic char\n        (isArabicChar(char) || isTashkeelArabicChar(char)) &&\n        !isArabicChar(prevChar)\n    );\n}\n\nfunction arabicSentenceEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    switch (true) {\n        case nextChar === null:\n            return true;\n        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):\n            var nextIsWhitespace = isWhiteSpace(nextChar);\n            if (!nextIsWhitespace) { return true; }\n            if (nextIsWhitespace) {\n                var arabicCharAhead = false;\n                arabicCharAhead = (\n                    contextParams.lookahead.some(\n                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }\n                    )\n                );\n                if (!arabicCharAhead) { return true; }\n            }\n            break;\n        default:\n            return false;\n    }\n}\n\nvar arabicSentenceCheck = {\n    startCheck: arabicSentenceStartCheck,\n    endCheck: arabicSentenceEndCheck\n};\n\n/**\n * Apply single substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat1$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply single substitution format 2\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat2$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply chaining context substitution format 3\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction chainingSubstitutionFormat3$1(action, tokens, index) {\n    action.substitution.forEach(function (subst, offset) {\n        var token = tokens[index + offset];\n        token.setState(action.tag, subst);\n    });\n}\n\n/**\n * Apply ligature substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction ligatureSubstitutionFormat1$1(action, tokens, index) {\n    var token = tokens[index];\n    token.setState(action.tag, action.substitution.ligGlyph);\n    var compsCount = action.substitution.components.length;\n    for (var i = 0; i < compsCount; i++) {\n        token = tokens[index + i + 1];\n        token.setState('deleted', true);\n    }\n}\n\n/**\n * Supported substitutions\n */\nvar SUBSTITUTIONS = {\n    11: singleSubstitutionFormat1$1,\n    12: singleSubstitutionFormat2$1,\n    63: chainingSubstitutionFormat3$1,\n    41: ligatureSubstitutionFormat1$1\n};\n\n/**\n * Apply substitutions to a list of tokens\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction applySubstitution(action, tokens, index) {\n    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n        SUBSTITUTIONS[action.id](action, tokens, index);\n    }\n}\n\n/**\n * Apply Arabic presentation forms to a range of tokens\n */\n\n/**\n * Check if a char can be connected to it's preceding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectPrev(charContextParams) {\n    var backtrack = [].concat(charContextParams.backtrack);\n    for (var i = backtrack.length - 1; i >= 0; i--) {\n        var prevChar = backtrack[i];\n        var isolated = isIsolatedArabicChar(prevChar);\n        var tashkeel = isTashkeelArabicChar(prevChar);\n        if (!isolated && !tashkeel) { return true; }\n        if (isolated) { return false; }\n    }\n    return false;\n}\n\n/**\n * Check if a char can be connected to it's proceeding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectNext(charContextParams) {\n    if (isIsolatedArabicChar(charContextParams.current)) { return false; }\n    for (var i = 0; i < charContextParams.lookahead.length; i++) {\n        var nextChar = charContextParams.lookahead[i];\n        var tashkeel = isTashkeelArabicChar(nextChar);\n        if (!tashkeel) { return true; }\n    }\n    return false;\n}\n\n/**\n * Apply arabic presentation forms to a list of tokens\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicPresentationForms(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tags = this.featuresTags[script];\n    var tokens = this.tokenizer.getRangeTokens(range);\n    if (tokens.length === 1) { return; }\n    var contextParams = new ContextParams(\n        tokens.map(function (token) { return token.getState('glyphIndex'); }\n    ), 0);\n    var charContextParams = new ContextParams(\n        tokens.map(function (token) { return token.char; }\n    ), 0);\n    tokens.forEach(function (token, index) {\n        if (isTashkeelArabicChar(token.char)) { return; }\n        contextParams.setCurrentIndex(index);\n        charContextParams.setCurrentIndex(index);\n        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }\n        if (willConnectNext(charContextParams)) { CONNECT |= 2; }\n        var tag;\n        switch (CONNECT) {\n            case 1: (tag = 'fina'); break;\n            case 2: (tag = 'init'); break;\n            case 3: (tag = 'medi'); break;\n        }\n        if (tags.indexOf(tag) === -1) { return; }\n        var substitutions = this$1.query.lookupFeature({\n            tag: tag, script: script, contextParams: contextParams\n        });\n        if (substitutions instanceof Error) { return console.info(substitutions.message); }\n        substitutions.forEach(function (action, index) {\n            if (action instanceof SubstitutionAction) {\n                applySubstitution(action, tokens, index);\n                contextParams.context[index] = action.substitution;\n            }\n        });\n    });\n}\n\n/**\n * Apply Arabic required ligatures feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicRequiredLigatures(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'rlig', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams(tokens);\n        }\n    });\n}\n\n/**\n * Latin word context checkers\n */\n\nfunction latinWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? latin first char\n        (prevChar === null && isLatinChar(char)) ||\n        // ? latin char preceded with a non latin char\n        (!isLatinChar(prevChar) && isLatinChar(char))\n    );\n}\n\nfunction latinWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last latin char\n        (nextChar === null) ||\n        // ? next char is not latin\n        (!isLatinChar(nextChar))\n    );\n}\n\nvar latinWordCheck = {\n    startCheck: latinWordStartCheck,\n    endCheck: latinWordEndCheck\n};\n\n/**\n * Apply Latin ligature feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams$1(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction latinLigature(range) {\n    var this$1 = this;\n\n    var script = 'latn';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams$1(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'liga', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams$1(tokens);\n        }\n    });\n}\n\n/**\n * Infer bidirectional properties for a given text and apply\n * the corresponding layout rules.\n */\n\n/**\n * Create Bidi. features\n * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n */\nfunction Bidi(baseDir) {\n    this.baseDir = baseDir || 'ltr';\n    this.tokenizer = new Tokenizer();\n    this.featuresTags = {};\n}\n\n/**\n * Sets Bidi text\n * @param {string} text a text input\n */\nBidi.prototype.setText = function (text) {\n    this.text = text;\n};\n\n/**\n * Store essential context checks:\n * arabic word check for applying gsub features\n * arabic sentence check for adjusting arabic layout\n */\nBidi.prototype.contextChecks = ({\n    latinWordCheck: latinWordCheck,\n    arabicWordCheck: arabicWordCheck,\n    arabicSentenceCheck: arabicSentenceCheck\n});\n\n/**\n * Register arabic word check\n */\nfunction registerContextChecker(checkId) {\n    var check = this.contextChecks[(checkId + \"Check\")];\n    return this.tokenizer.registerContextChecker(\n        checkId, check.startCheck, check.endCheck\n    );\n}\n\n/**\n * Perform pre tokenization procedure then\n * tokenize text input\n */\nfunction tokenizeText() {\n    registerContextChecker.call(this, 'latinWord');\n    registerContextChecker.call(this, 'arabicWord');\n    registerContextChecker.call(this, 'arabicSentence');\n    return this.tokenizer.tokenize(this.text);\n}\n\n/**\n * Reverse arabic sentence layout\n * TODO: check base dir before applying adjustments - priority low\n */\nfunction reverseArabicSentences() {\n    var this$1 = this;\n\n    var ranges = this.tokenizer.getContextRanges('arabicSentence');\n    ranges.forEach(function (range) {\n        var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n        this$1.tokenizer.replaceRange(\n            range.startIndex,\n            range.endOffset,\n            rangeTokens.reverse()\n        );\n    });\n}\n\n/**\n * Register supported features tags\n * @param {script} script script tag\n * @param {Array} tags features tags list\n */\nBidi.prototype.registerFeatures = function (script, tags) {\n    var this$1 = this;\n\n    var supportedTags = tags.filter(\n        function (tag) { return this$1.query.supports({script: script, tag: tag}); }\n    );\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        this.featuresTags[script] = supportedTags;\n    } else {\n        this.featuresTags[script] =\n        this.featuresTags[script].concat(supportedTags);\n    }\n};\n\n/**\n * Apply GSUB features\n * @param {Array} tagsList a list of features tags\n * @param {string} script a script tag\n * @param {Font} font opentype font instance\n */\nBidi.prototype.applyFeatures = function (font, features) {\n    if (!font) { throw new Error(\n        'No valid font was provided to apply features'\n    ); }\n    if (!this.query) { this.query = new FeatureQuery(font); }\n    for (var f = 0; f < features.length; f++) {\n        var feature = features[f];\n        if (!this.query.supports({script: feature.script})) { continue; }\n        this.registerFeatures(feature.script, feature.tags);\n    }\n};\n\n/**\n * Register a state modifier\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a modifier function to set token state\n */\nBidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n    this.tokenizer.registerModifier(modifierId, condition, modifier);\n};\n\n/**\n * Check if 'glyphIndex' is registered\n */\nfunction checkGlyphIndexStatus() {\n    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n        throw new Error(\n            'glyphIndex modifier is required to apply ' +\n            'arabic presentation features.'\n        );\n    }\n}\n\n/**\n * Apply arabic presentation forms features\n */\nfunction applyArabicPresentationForms() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicPresentationForms.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyArabicRequireLigatures() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('rlig') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicRequiredLigatures.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyLatinLigatures() {\n    var this$1 = this;\n\n    var script = 'latn';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('liga') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('latinWord');\n    ranges.forEach(function (range) {\n        latinLigature.call(this$1, range);\n    });\n}\n\n/**\n * Check if a context is registered\n * @param {string} contextId context id\n */\nBidi.prototype.checkContextReady = function (contextId) {\n    return !!this.tokenizer.getContext(contextId);\n};\n\n/**\n * Apply features to registered contexts\n */\nBidi.prototype.applyFeaturesToContexts = function () {\n    if (this.checkContextReady('arabicWord')) {\n        applyArabicPresentationForms.call(this);\n        applyArabicRequireLigatures.call(this);\n    }\n    if (this.checkContextReady('latinWord')) {\n        applyLatinLigatures.call(this);\n    }\n    if (this.checkContextReady('arabicSentence')) {\n        reverseArabicSentences.call(this);\n    }\n};\n\n/**\n * process text input\n * @param {string} text an input text\n */\nBidi.prototype.processText = function(text) {\n    if (!this.text || this.text !== text) {\n        this.setText(text);\n        tokenizeText.call(this);\n        this.applyFeaturesToContexts();\n    }\n};\n\n/**\n * Process a string of text to identify and adjust\n * bidirectional text entities.\n * @param {string} text input text\n */\nBidi.prototype.getBidiText = function (text) {\n    this.processText(text);\n    return this.tokenizer.getText();\n};\n\n/**\n * Get the current state index of each token\n * @param {text} text an input text\n */\nBidi.prototype.getTextGlyphs = function (text) {\n    this.processText(text);\n    var indexes = [];\n    for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n        var token = this.tokenizer.tokens[i];\n        if (token.state.deleted) { continue; }\n        var index = token.activeState.value;\n        indexes.push(Array.isArray(index) ? index[0] : index);\n    }\n    return indexes;\n};\n\n// The Font object\n\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */\n\n/**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */\nfunction Font(options) {\n    options = options || {};\n    options.tables = options.tables || {};\n\n    if (!options.empty) {\n        // Check that we've provided the minimum set of names.\n        checkArgument(\n            options.familyName,\n            'When creating a new Font object, familyName is required.'\n        );\n        checkArgument(\n            options.styleName,\n            'When creating a new Font object, styleName is required.'\n        );\n        checkArgument(\n            options.unitsPerEm,\n            'When creating a new Font object, unitsPerEm is required.'\n        );\n        checkArgument(\n            options.ascender,\n            'When creating a new Font object, ascender is required.'\n        );\n        checkArgument(\n            options.descender <= 0,\n            'When creating a new Font object, negative descender value is required.'\n        );\n\n        this.unitsPerEm = options.unitsPerEm || 1000;\n        this.ascender = options.ascender;\n        this.descender = options.descender;\n        this.createdTimestamp = options.createdTimestamp;\n        this.tables = Object.assign(options.tables, {\n            os2: Object.assign(\n                {\n                    usWeightClass:\n                        options.weightClass || this.usWeightClasses.MEDIUM,\n                    usWidthClass:\n                        options.widthClass || this.usWidthClasses.MEDIUM,\n                    fsSelection:\n                        options.fsSelection || this.fsSelectionValues.REGULAR,\n                },\n                options.tables.os2\n            ),\n        });\n    }\n\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new DefaultEncoding(this);\n    this.position = new Position(this);\n    this.substitution = new Substitution(this);\n    this.tables = this.tables || {};\n\n    // needed for low memory mode only.\n    this._push = null;\n    this._hmtxTableData = {};\n\n    Object.defineProperty(this, 'hinting', {\n        get: function () {\n            if (this._hinting) { return this._hinting; }\n            if (this.outlinesFormat === 'truetype') {\n                return (this._hinting = new Hinting(this));\n            }\n        },\n    });\n}\n\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */\nFont.prototype.hasChar = function (c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.charToGlyphIndex = function (s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.charToGlyph = function (c) {\n    var glyphIndex = this.charToGlyphIndex(c);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * Update features\n * @param {any} options features options\n */\nFont.prototype.updateFeatures = function (options) {\n    // TODO: update all features options not only 'latn'.\n    return this.defaultRenderOptions.features.map(function (feature) {\n        if (feature.script === 'latn') {\n            return {\n                script: 'latn',\n                tags: feature.tags.filter(function (tag) { return options[tag]; }),\n            };\n        } else {\n            return feature;\n        }\n    });\n};\n\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */\nFont.prototype.stringToGlyphs = function (s, options) {\n    var this$1 = this;\n\n    var bidi = new Bidi();\n\n    // Create and register 'glyphIndex' state modifier\n    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };\n    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);\n\n    // roll-back to default features\n    var features = options\n        ? this.updateFeatures(options.features)\n        : this.defaultRenderOptions.features;\n\n    bidi.applyFeatures(this, features);\n\n    var indexes = bidi.getTextGlyphs(s);\n\n    var length = indexes.length;\n\n    // convert glyph indexes to glyph objects\n    var glyphs = new Array(length);\n    var notdef = this.glyphs.get(0);\n    for (var i = 0; i < length; i += 1) {\n        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n    }\n    return glyphs;\n};\n\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * For GPOS kerning, this method uses the default script and language, which covers\n * most use cases. To have greater control, use font.position.getKerningValue .\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */\nFont.prototype.getKerningValue = function (leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    var gposKerning = this.position.defaultKerningTables;\n    if (gposKerning) {\n        return this.position.getKerningValue(\n            gposKerning,\n            leftGlyph,\n            rightGlyph\n        );\n    }\n    // \"kern\" table\n    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n};\n\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */\nFont.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: [\n        /**\n         * these 4 features are required to render Arabic text properly\n         * and shouldn't be turned off when rendering arabic text.\n         */\n        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n        { script: 'latn', tags: ['liga', 'rlig'] } ],\n};\n\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */\nFont.prototype.forEachGlyph = function (\n    text,\n    x,\n    y,\n    fontSize,\n    options,\n    callback\n) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = Object.assign({}, this.defaultRenderOptions, options);\n    var fontScale = (1 / this.unitsPerEm) * fontSize;\n    var glyphs = this.stringToGlyphs(text, options);\n    var kerningLookups;\n    if (options.kerning) {\n        var script = options.script || this.position.getDefaultScriptName();\n        kerningLookups = this.position.getKerningTables(\n            script,\n            options.language\n        );\n    }\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs[i];\n        callback.call(this, glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n\n        if (options.kerning && i < glyphs.length - 1) {\n            // We should apply position adjustment lookups in a more generic way.\n            // Here we only use the xAdvance value.\n            var kerningValue = kerningLookups\n                ? this.position.getKerningValue(\n                      kerningLookups,\n                      glyph.index,\n                      glyphs[i + 1].index\n                  )\n                : this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n\n        if (options.letterSpacing) {\n            x += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n            x += (options.tracking / 1000) * fontSize;\n        }\n    }\n    return x;\n};\n\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */\nFont.prototype.getPath = function (text, x, y, fontSize, options) {\n    var fullPath = new Path();\n    this.forEachGlyph(\n        text,\n        x,\n        y,\n        fontSize,\n        options,\n        function (glyph, gX, gY, gFontSize) {\n            var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n            fullPath.extend(glyphPath);\n        }\n    );\n    return fullPath;\n};\n\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */\nFont.prototype.getPaths = function (text, x, y, fontSize, options) {\n    var glyphPaths = [];\n    this.forEachGlyph(\n        text,\n        x,\n        y,\n        fontSize,\n        options,\n        function (glyph, gX, gY, gFontSize) {\n            var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n            glyphPaths.push(glyphPath);\n        }\n    );\n\n    return glyphPaths;\n};\n\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */\nFont.prototype.getAdvanceWidth = function (text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function () {});\n};\n\n/**\n * @private\n */\nFont.prototype.fsSelectionValues = {\n    ITALIC: 0x001, //1\n    UNDERSCORE: 0x002, //2\n    NEGATIVE: 0x004, //4\n    OUTLINED: 0x008, //8\n    STRIKEOUT: 0x010, //16\n    BOLD: 0x020, //32\n    REGULAR: 0x040, //64\n    USER_TYPO_METRICS: 0x080, //128\n    WWS: 0x100, //256\n    OBLIQUE: 0x200, //512\n};\n\n/**\n * @private\n */\nFont.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9,\n};\n\n/**\n * @private\n */\nFont.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK: 900,\n};\n\n// The `cmap` table stores the mappings from characters to glyphs.\n\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n\n    var groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n\n    for (var i = 0; i < groupCount; i += 1) {\n        var startCharCode = p.parseULong();\n        var endCharCode = p.parseULong();\n        var startGlyphId = p.parseULong();\n\n        for (var c = startCharCode; c <= endCharCode; c += 1) {\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    var segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    var endCountParser = new parse.Parser(data, start + offset + 14);\n    var startCountParser = new parse.Parser(\n        data,\n        start + offset + 16 + segCount * 2\n    );\n    var idDeltaParser = new parse.Parser(\n        data,\n        start + offset + 16 + segCount * 4\n    );\n    var idRangeOffsetParser = new parse.Parser(\n        data,\n        start + offset + 16 + segCount * 6\n    );\n    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (var i = 0; i < segCount - 1; i += 1) {\n        var glyphIndex = (void 0);\n        var endCount = endCountParser.parseUShort();\n        var startCount = startCountParser.parseUShort();\n        var idDelta = idDeltaParser.parseShort();\n        var idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (var c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset =\n                    idRangeOffsetParser.offset +\n                    idRangeOffsetParser.relativeOffset -\n                    2;\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xffff;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xffff;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    var cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    var offset = -1;\n    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n        var platformId = parse.getUShort(data, start + 4 + i * 8);\n        var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);\n        if (\n            (platformId === 3 &&\n                (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n            (platformId === 0 &&\n                (encodingId === 0 ||\n                    encodingId === 1 ||\n                    encodingId === 2 ||\n                    encodingId === 3 ||\n                    encodingId === 4))\n        ) {\n            offset = parse.getULong(data, start + 4 + i * 8 + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error('No valid cmap sub-tables found.');\n    }\n\n    var p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error(\n            'Only format 4 and 12 cmap tables are supported (found format ' +\n                cmap.format +\n                ').'\n        );\n    }\n\n    return cmap;\n}\n\nvar cmap = { parse: parseCmapTable };\n\n// The `CFF` table contains the glyph outlines in PostScript format.\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    var bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    var offsets = [];\n    var objects = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n        var value = parse.getBytes(\n            data,\n            objectOffset + offsets[i$1],\n            objectOffset + offsets[i$1 + 1]\n        );\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return { objects: objects, startOffset: start, endOffset: endOffset };\n}\n\nfunction parseCFFIndexLowMemory(data, start) {\n    var offsets = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    return { offsets: offsets, startOffset: start, endOffset: endOffset };\n}\nfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n    var count = parse.getCard16(data, start);\n    var objectOffset = 0;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n    }\n\n    var value = parse.getBytes(\n        data,\n        objectOffset + offsets[i],\n        objectOffset + offsets[i + 1]\n    );\n    if (conversionFn) {\n        value = conversionFn(value);\n    }\n    return value;\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    var s = '';\n    var eof = 15;\n    var lookup = [\n        '0',\n        '1',\n        '2',\n        '3',\n        '4',\n        '5',\n        '6',\n        '7',\n        '8',\n        '9',\n        '.',\n        'E',\n        'E-',\n        null,\n        '-' ];\n    while (true) {\n        var b = parser.parseByte();\n        var n1 = b >> 4;\n        var n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return (b1 << 8) | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    var o = {};\n    for (var i = 0; i < entries.length; i += 1) {\n        var key = entries[i][0];\n        var values = entries[i][1];\n        var value = (void 0);\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    var parser = new parse.Parser(data, start);\n    var entries = [];\n    var operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        var op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    var newDict = {};\n    var value;\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (var i = 0; i < meta.length; i += 1) {\n        var m = meta[i];\n\n        if (Array.isArray(m.type)) {\n            var values = [];\n            values.length = m.type.length;\n            for (var j = 0; j < m.type.length; j++) {\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value =\n                        m.value !== undefined && m.value[j] !== undefined\n                            ? m.value[j]\n                            : null;\n                }\n                if (m.type[j] === 'SID') {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    var header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nvar TOP_DICT_META = [\n    { name: 'version', op: 0, type: 'SID' },\n    { name: 'notice', op: 1, type: 'SID' },\n    { name: 'copyright', op: 1200, type: 'SID' },\n    { name: 'fullName', op: 2, type: 'SID' },\n    { name: 'familyName', op: 3, type: 'SID' },\n    { name: 'weight', op: 4, type: 'SID' },\n    { name: 'isFixedPitch', op: 1201, type: 'number', value: 0 },\n    { name: 'italicAngle', op: 1202, type: 'number', value: 0 },\n    { name: 'underlinePosition', op: 1203, type: 'number', value: -100 },\n    { name: 'underlineThickness', op: 1204, type: 'number', value: 50 },\n    { name: 'paintType', op: 1205, type: 'number', value: 0 },\n    { name: 'charstringType', op: 1206, type: 'number', value: 2 },\n    {\n        name: 'fontMatrix',\n        op: 1207,\n        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n        value: [0.001, 0, 0, 0.001, 0, 0],\n    },\n    { name: 'uniqueId', op: 13, type: 'number' },\n    {\n        name: 'fontBBox',\n        op: 5,\n        type: ['number', 'number', 'number', 'number'],\n        value: [0, 0, 0, 0],\n    },\n    { name: 'strokeWidth', op: 1208, type: 'number', value: 0 },\n    { name: 'xuid', op: 14, type: [], value: null },\n    { name: 'charset', op: 15, type: 'offset', value: 0 },\n    { name: 'encoding', op: 16, type: 'offset', value: 0 },\n    { name: 'charStrings', op: 17, type: 'offset', value: 0 },\n    { name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0] },\n    { name: 'ros', op: 1230, type: ['SID', 'SID', 'number'] },\n    { name: 'cidFontVersion', op: 1231, type: 'number', value: 0 },\n    { name: 'cidFontRevision', op: 1232, type: 'number', value: 0 },\n    { name: 'cidFontType', op: 1233, type: 'number', value: 0 },\n    { name: 'cidCount', op: 1234, type: 'number', value: 8720 },\n    { name: 'uidBase', op: 1235, type: 'number' },\n    { name: 'fdArray', op: 1236, type: 'offset' },\n    { name: 'fdSelect', op: 1237, type: 'offset' },\n    { name: 'fontName', op: 1238, type: 'SID' } ];\n\nvar PRIVATE_DICT_META = [\n    { name: 'subrs', op: 19, type: 'offset', value: 0 },\n    { name: 'defaultWidthX', op: 20, type: 'number', value: 0 },\n    { name: 'nominalWidthX', op: 21, type: 'number', value: 0 } ];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    var topDictArray = [];\n    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n        var topDictData = new DataView(\n            new Uint8Array(cffIndex[iTopDict]).buffer\n        );\n        var topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        topDict._defaultWidthX = 0;\n        topDict._nominalWidthX = 0;\n        var privateSize = topDict.private[0];\n        var privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            var privateDict = parseCFFPrivateDict(\n                data,\n                privateOffset + start,\n                privateSize,\n                strings\n            );\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                var subrOffset = privateOffset + privateDict.subrs;\n                var subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    var sid;\n    var count;\n    var parser = new parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    var charset = ['.notdef'];\n\n    var format = parser.parseCard8();\n    if (format === 0) {\n        for (var i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    var code;\n    var enc = {};\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        var nCodes = parser.parseCard8();\n        for (var i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        var nRanges = parser.parseCard8();\n        code = 1;\n        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n            var first = parser.parseCard8();\n            var nLeft = parser.parseCard8();\n            for (var j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    var c1x;\n    var c1y;\n    var c2x;\n    var c2y;\n    var p = new Path();\n    var stack = [];\n    var nStems = 0;\n    var haveWidth = false;\n    var open = false;\n    var x = 0;\n    var y = 0;\n    var subrs;\n    var subrsBias;\n    var defaultWidthX;\n    var nominalWidthX;\n    if (font.isCIDFont) {\n        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    var width = defaultWidthX;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        var hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        var b1;\n        var b2;\n        var b3;\n        var b4;\n        var codeIndex;\n        var subrCode;\n        var jpx;\n        var jpy;\n        var c3x;\n        var c3y;\n        var c4x;\n        var c4y;\n\n        var i = 0;\n        while (i < code.length) {\n            var v = code[i];\n            i += 1;\n            switch (v) {\n                case 1: // hstem\n                    parseStems();\n                    break;\n                case 3: // vstem\n                    parseStems();\n                    break;\n                case 4: // vmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5: // rlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 6: // hlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 7: // vlineto\n                    while (stack.length > 0) {\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 8: // rrcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 10: // callsubr\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 11: // return\n                    return;\n                case 12: // flex operators\n                    v = code[i];\n                    i += 1;\n                    switch (v) {\n                        case 35: // flex\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y + stack.shift(); // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = jpy + stack.shift(); // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            x = c4x + stack.shift(); // dx6\n                            y = c4y + stack.shift(); // dy6\n                            stack.shift(); // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34: // hflex\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y; // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y; // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = c2y; // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = y; // dy5\n                            x = c4x + stack.shift(); // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36: // hflex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y; // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = c2y; // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            x = c4x + stack.shift(); // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37: // flex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y + stack.shift(); // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = jpy + stack.shift(); // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log(\n                                'Glyph ' +\n                                    glyph.index +\n                                    ': unknown operator ' +\n                                    1200 +\n                                    v\n                            );\n                            stack.length = 0;\n                    }\n                    break;\n                case 14: // endchar\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n\n                    break;\n                case 18: // hstemhm\n                    parseStems();\n                    break;\n                case 19: // hintmask\n                case 20: // cntrmask\n                    parseStems();\n                    i += (nStems + 7) >> 3;\n                    break;\n                case 21: // rmoveto\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22: // hmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23: // vstemhm\n                    parseStems();\n                    break;\n                case 24: // rcurveline\n                    while (stack.length > 2) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25: // rlinecurve\n                    while (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26: // vvcurveto\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 27: // hhcurveto\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 28: // shortint\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                    i += 2;\n                    break;\n                case 29: // callgsubr\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 30: // vhcurveto\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 31: // hvcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log(\n                            'Glyph ' + glyph.index + ': unknown operator ' + v\n                        );\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push(\n                            ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536\n                        );\n                    }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    var fdSelect = [];\n    var fdIndex;\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for (var iGid = 0; iGid < nGlyphs; iGid++) {\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error(\n                    'CFF table CID Font FDSelect has bad FD index value ' +\n                        fdIndex +\n                        ' (FD count ' +\n                        fdArrayCount +\n                        ')'\n                );\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        var nRanges = parser.parseCard16();\n        var first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error(\n                'CFF Table CID Font FDSelect format 3 range has bad initial GID ' +\n                    first\n            );\n        }\n        var next;\n        for (var iRange = 0; iRange < nRanges; iRange++) {\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error(\n                    'CFF table CID Font FDSelect has bad FD index value ' +\n                        fdIndex +\n                        ' (FD count ' +\n                        fdArrayCount +\n                        ')'\n                );\n            }\n            if (next > nGlyphs) {\n                throw new Error(\n                    'CFF Table CID Font FDSelect format 3 range has bad GID ' +\n                        next\n                );\n            }\n            for (; first < next; first++) {\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error(\n                'CFF Table CID Font FDSelect format 3 range has bad final GID ' +\n                    next\n            );\n        }\n    } else {\n        throw new Error(\n            'CFF Table CID Font FDSelect table has unsupported format ' + format\n        );\n    }\n    return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font, opt) {\n    font.tables.cff = {};\n    var header = parseCFFHeader(data, start);\n    var nameIndex = parseCFFIndex(\n        data,\n        header.endOffset,\n        parse.bytesToString\n    );\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    var stringIndex = parseCFFIndex(\n        data,\n        topDictIndex.endOffset,\n        parse.bytesToString\n    );\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    var topDictArray = gatherCFFTopDicts(\n        data,\n        start,\n        topDictIndex.objects,\n        stringIndex.objects\n    );\n    if (topDictArray.length !== 1) {\n        throw new Error(\n            \"CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = \" +\n                topDictArray.length\n        );\n    }\n\n    var topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n\n    if (font.isCIDFont) {\n        var fdArrayOffset = topDict.fdArray;\n        var fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error(\n                'Font is marked as a CID font, but FDArray and/or FDSelect information is missing'\n            );\n        }\n        fdArrayOffset += start;\n        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        var fdArray = gatherCFFTopDicts(\n            data,\n            start,\n            fdArrayIndex.objects,\n            stringIndex.objects\n        );\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(\n            data,\n            fdSelectOffset,\n            font.numGlyphs,\n            fdArray.length\n        );\n    }\n\n    var privateDictOffset = start + topDict.private[1];\n    var privateDict = parseCFFPrivateDict(\n        data,\n        privateDictOffset,\n        topDict.private[0],\n        stringIndex.objects\n    );\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        var subrOffset = privateDictOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex;\n    if (opt.lowMemory) {\n        charStringsIndex = parseCFFIndexLowMemory(\n            data,\n            start + topDict.charStrings\n        );\n        font.nGlyphs = charStringsIndex.offsets.length;\n    } else {\n        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.objects.length;\n    }\n\n    var charset = parseCFFCharset(\n        data,\n        start + topDict.charset,\n        font.nGlyphs,\n        stringIndex.objects\n    );\n    if (topDict.encoding === 0) {\n        // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) {\n        // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(\n            data,\n            start + topDict.encoding,\n            charset\n        );\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    if (opt.lowMemory) {\n        font._push = function (i) {\n            var charString = getCffIndexObject(\n                i,\n                charStringsIndex.offsets,\n                data,\n                start + topDict.charStrings\n            );\n            font.glyphs.push(\n                i,\n                glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString)\n            );\n        };\n    } else {\n        for (var i = 0; i < font.nGlyphs; i += 1) {\n            var charString = charStringsIndex.objects[i];\n            font.glyphs.push(\n                i,\n                glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString)\n            );\n        }\n    }\n}\n\nvar cff = { parse: parseCFFTable };\n\n// The `fvar` table stores font variation axes and instances.\n\nfunction parseFvarAxis(data, start, names) {\n    var axis = {};\n    var p = new parse.Parser(data, start);\n    axis.tag = p.parseTag();\n    axis.minValue = p.parseFixed();\n    axis.defaultValue = p.parseFixed();\n    axis.maxValue = p.parseFixed();\n    p.skip('uShort', 1); // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {};\n    return axis;\n}\n\nfunction parseFvarInstance(data, start, axes, names) {\n    var inst = {};\n    var p = new parse.Parser(data, start);\n    inst.name = names[p.parseUShort()] || {};\n    p.skip('uShort', 1); // reserved for flags; no values defined\n\n    inst.coordinates = {};\n    for (var i = 0; i < axes.length; ++i) {\n        inst.coordinates[axes[i].tag] = p.parseFixed();\n    }\n\n    return inst;\n}\n\nfunction parseFvarTable(data, start, names) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(\n        tableVersion === 0x00010000,\n        'Unsupported fvar table version.'\n    );\n    var offsetToData = p.parseOffset16();\n    // Skip countSizePairs.\n    p.skip('uShort', 1);\n    var axisCount = p.parseUShort();\n    var axisSize = p.parseUShort();\n    var instanceCount = p.parseUShort();\n    var instanceSize = p.parseUShort();\n\n    var axes = [];\n    for (var i = 0; i < axisCount; i++) {\n        axes.push(\n            parseFvarAxis(data, start + offsetToData + i * axisSize, names)\n        );\n    }\n\n    var instances = [];\n    var instanceStart = start + offsetToData + axisCount * axisSize;\n    for (var j = 0; j < instanceCount; j++) {\n        instances.push(\n            parseFvarInstance(\n                data,\n                instanceStart + j * instanceSize,\n                axes,\n                names\n            )\n        );\n    }\n\n    return { axes: axes, instances: instances };\n}\n\nvar fvar = { parse: parseFvarTable };\n\n// The `GDEF` table contains various glyph properties\n\nvar attachList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n    };\n};\n\nvar caretValue = function() {\n    var format = this.parseUShort();\n    check.argument(format === 1 || format === 2 || format === 3,\n        'Unsupported CaretValue table version.');\n    if (format === 1) {\n        return { coordinate: this.parseShort() };\n    } else if (format === 2) {\n        return { pointindex: this.parseShort() };\n    } else if (format === 3) {\n        // Device / Variation Index tables unsupported\n        return { coordinate: this.parseShort() };\n    }\n};\n\nvar ligGlyph = function() {\n    return this.parseList(Parser.pointer(caretValue));\n};\n\nvar ligCaretList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n    };\n};\n\nvar markGlyphSets = function() {\n    this.parseUShort(); // Version\n    return this.parseList(Parser.pointer(Parser.coverage));\n};\n\nfunction parseGDEFTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n        'Unsupported GDEF table version.');\n    var gdef = {\n        version: tableVersion,\n        classDef: p.parsePointer(Parser.classDef),\n        attachList: p.parsePointer(attachList),\n        ligCaretList: p.parsePointer(ligCaretList),\n        markAttachClassDef: p.parsePointer(Parser.classDef)\n    };\n    if (tableVersion >= 1.2) {\n        gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n    }\n    return gdef;\n}\nvar gdef = { parse: parseGDEFTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\nvar subtableParsers = new Array(10); // subtableParsers[0] is unused\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n// this = Parser instance\nsubtableParsers[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var posformat = this.parseUShort();\n    if (posformat === 1) {\n        return {\n            posFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            value: this.parseValueRecord(),\n        };\n    } else if (posformat === 2) {\n        return {\n            posFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            values: this.parseValueRecordList(),\n        };\n    }\n    check.assert(\n        false,\n        '0x' +\n            start.toString(16) +\n            ': GPOS lookup type 1 format must be 1 or 2.'\n    );\n};\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\nsubtableParsers[2] = function parseLookup2() {\n    var start = this.offset + this.relativeOffset;\n    var posFormat = this.parseUShort();\n    check.assert(\n        posFormat === 1 || posFormat === 2,\n        '0x' +\n            start.toString(16) +\n            ': GPOS lookup type 2 format must be 1 or 2.'\n    );\n    var coverage = this.parsePointer(Parser.coverage);\n    var valueFormat1 = this.parseUShort();\n    var valueFormat2 = this.parseUShort();\n    if (posFormat === 1) {\n        // Adjustments for Glyph Pairs\n        return {\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            pairSets: this.parseList(\n                Parser.pointer(\n                    Parser.list(function () {\n                        return {\n                            // pairValueRecord\n                            secondGlyph: this.parseUShort(),\n                            value1: this.parseValueRecord(valueFormat1),\n                            value2: this.parseValueRecord(valueFormat2),\n                        };\n                    })\n                )\n            ),\n        };\n    } else if (posFormat === 2) {\n        var classDef1 = this.parsePointer(Parser.classDef);\n        var classDef2 = this.parsePointer(Parser.classDef);\n        var class1Count = this.parseUShort();\n        var class2Count = this.parseUShort();\n        return {\n            // Class Pair Adjustment\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            classDef1: classDef1,\n            classDef2: classDef2,\n            class1Count: class1Count,\n            class2Count: class2Count,\n            classRecords: this.parseList(\n                class1Count,\n                Parser.list(class2Count, function () {\n                    return {\n                        value1: this.parseValueRecord(valueFormat1),\n                        value2: this.parseValueRecord(valueFormat2),\n                    };\n                })\n            ),\n        };\n    }\n};\n\nsubtableParsers[3] = function parseLookup3() {\n    return { error: 'GPOS Lookup 3 not supported' };\n};\nsubtableParsers[4] = function parseLookup4() {\n    return { error: 'GPOS Lookup 4 not supported' };\n};\nsubtableParsers[5] = function parseLookup5() {\n    return { error: 'GPOS Lookup 5 not supported' };\n};\nsubtableParsers[6] = function parseLookup6() {\n    return { error: 'GPOS Lookup 6 not supported' };\n};\nsubtableParsers[7] = function parseLookup7() {\n    return { error: 'GPOS Lookup 7 not supported' };\n};\nsubtableParsers[8] = function parseLookup8() {\n    return { error: 'GPOS Lookup 8 not supported' };\n};\nsubtableParsers[9] = function parseLookup9() {\n    return { error: 'GPOS Lookup 9 not supported' };\n};\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\nfunction parseGposTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(\n        tableVersion === 1 || tableVersion === 1.1,\n        'Unsupported GPOS table version ' + tableVersion\n    );\n\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n            variations: p.parseFeatureVariationsList(),\n        };\n    }\n}\n\nvar gpos = { parse: parseGposTable };\n\n// The `GSUB` table contains ligatures, among other things.\n\nvar subtableParsers$1 = new Array(9); // subtableParsers[0] is unused\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\nsubtableParsers$1[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            deltaGlyphId: this.parseUShort(),\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            substitute: this.parseOffset16List(),\n        };\n    }\n    check.assert(\n        false,\n        '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.'\n    );\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\nsubtableParsers$1[2] = function parseLookup2() {\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB Multiple Substitution Subtable identifier-format must be 1'\n    );\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        sequences: this.parseListOfLists(),\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\nsubtableParsers$1[3] = function parseLookup3() {\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB Alternate Substitution Subtable identifier-format must be 1'\n    );\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        alternateSets: this.parseListOfLists(),\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\nsubtableParsers$1[4] = function parseLookup4() {\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB ligature table identifier-format must be 1'\n    );\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ligatureSets: this.parseListOfLists(function () {\n            return {\n                ligGlyph: this.parseUShort(),\n                components: this.parseUShortList(this.parseUShort() - 1),\n            };\n        }),\n    };\n};\n\nvar lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort,\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\nsubtableParsers$1[5] = function parseLookup5() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n\n    if (substFormat === 1) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            ruleSets: this.parseListOfLists(function () {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    input: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(\n                        substCount,\n                        lookupRecordDesc\n                    ),\n                };\n            }),\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            classDef: this.parsePointer(Parser.classDef),\n            classSets: this.parseListOfLists(function () {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    classes: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(\n                        substCount,\n                        lookupRecordDesc\n                    ),\n                };\n            }),\n        };\n    } else if (substFormat === 3) {\n        var glyphCount = this.parseUShort();\n        var substCount = this.parseUShort();\n        return {\n            substFormat: substFormat,\n            coverages: this.parseList(\n                glyphCount,\n                Parser.pointer(Parser.coverage)\n            ),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc),\n        };\n    }\n    check.assert(\n        false,\n        '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.'\n    );\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\nsubtableParsers$1[6] = function parseLookup6() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            chainRuleSets: this.parseListOfLists(function () {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc),\n                };\n            }),\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            backtrackClassDef: this.parsePointer(Parser.classDef),\n            inputClassDef: this.parsePointer(Parser.classDef),\n            lookaheadClassDef: this.parsePointer(Parser.classDef),\n            chainClassSet: this.parseListOfLists(function () {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc),\n                };\n            }),\n        };\n    } else if (substFormat === 3) {\n        return {\n            substFormat: 3,\n            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(lookupRecordDesc),\n        };\n    }\n    check.assert(\n        false,\n        '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.'\n    );\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\nsubtableParsers$1[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB Extension Substitution subtable identifier-format must be 1'\n    );\n    var extensionLookupType = this.parseUShort();\n    var extensionParser = new Parser(\n        this.data,\n        this.offset + this.parseULong()\n    );\n    return {\n        substFormat: 1,\n        lookupType: extensionLookupType,\n        extension: subtableParsers$1[extensionLookupType].call(extensionParser),\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\nsubtableParsers$1[8] = function parseLookup8() {\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1'\n    );\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        substitutes: this.parseUShortList(),\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\nfunction parseGsubTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(\n        tableVersion === 1 || tableVersion === 1.1,\n        'Unsupported GSUB table version.'\n    );\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n            variations: p.parseFeatureVariationsList(),\n        };\n    }\n}\n\nvar gsub = { parse: parseGsubTable };\n\n// The `head` table contains global information about the font.\n\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    var head = {};\n    var p = new parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(\n        head.magicNumber === 0x5f0f3cf5,\n        'Font header has wrong magic number.'\n    );\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\n\nvar head = { parse: parseHeadTable };\n\n// The `hhea` table contains information for horizontal layout.\n\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    var hhea = {};\n    var p = new parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\n\nvar hhea = { parse: parseHheaTable };\n\n// The `hmtx` table contains the horizontal metrics for all glyphs.\n\nfunction parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        var glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\n\nfunction parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n    font._hmtxTableData = {};\n\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        font._hmtxTableData[i] = {\n            advanceWidth: advanceWidth,\n            leftSideBearing: leftSideBearing,\n        };\n    }\n}\n\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n    if (opt.lowMemory)\n        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }\n    else { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }\n}\n\nvar hmtx = { parse: parseHmtxTable };\n\n// The `kern` table contains kerning pairs.\n\nfunction parseWindowsKernTable(p) {\n    var pairs = {};\n    // Skip nTables.\n    p.skip('uShort');\n    var subtableVersion = p.parseUShort();\n    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n    // Skip subtableLength, subtableCoverage\n    p.skip('uShort', 2);\n    var nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n    for (var i = 0; i < nPairs; i += 1) {\n        var leftIndex = p.parseUShort();\n        var rightIndex = p.parseUShort();\n        var value = p.parseShort();\n        pairs[leftIndex + ',' + rightIndex] = value;\n    }\n    return pairs;\n}\n\nfunction parseMacKernTable(p) {\n    var pairs = {};\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip('uShort');\n    var nTables = p.parseULong();\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n        console.warn('Only the first kern subtable is supported.');\n    }\n    p.skip('uLong');\n    var coverage = p.parseUShort();\n    var subtableVersion = coverage & 0xFF;\n    p.skip('uShort');\n    if (subtableVersion === 0) {\n        var nPairs = p.parseUShort();\n        // Skip searchRange, entrySelector, rangeShift.\n        p.skip('uShort', 3);\n        for (var i = 0; i < nPairs; i += 1) {\n            var leftIndex = p.parseUShort();\n            var rightIndex = p.parseUShort();\n            var value = p.parseShort();\n            pairs[leftIndex + ',' + rightIndex] = value;\n        }\n    }\n    return pairs;\n}\n\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseUShort();\n    if (tableVersion === 0) {\n        return parseWindowsKernTable(p);\n    } else if (tableVersion === 1) {\n        return parseMacKernTable(p);\n    } else {\n        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n    }\n}\n\nvar kern = { parse: parseKernTable };\n\n// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\nfunction parseLtagTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip('uLong', 1);\n    var numTags = p.parseULong();\n\n    var tags = [];\n    for (var i = 0; i < numTags; i++) {\n        var tag = '';\n        var offset = start + p.parseUShort();\n        var length = p.parseUShort();\n        for (var j = offset; j < offset + length; ++j) {\n            tag += String.fromCharCode(data.getInt8(j));\n        }\n\n        tags.push(tag);\n    }\n\n    return tags;\n}\n\nvar ltag = { parse: parseLtagTable };\n\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start);\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = [];\n    for (var i = 0; i < numGlyphs + 1; i += 1) {\n        var glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n\n        glyphOffsets.push(glyphOffset);\n    }\n\n    return glyphOffsets;\n}\n\nvar loca = { parse: parseLocaTable };\n\n// The `maxp` table establishes the memory requirements for the font.\n\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    var maxp = {};\n    var p = new parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n\n    return maxp;\n}\n\nvar maxp = { parse: parseMaxpTable };\n\n// The `OS/2` table contains metrics required in OpenType fonts.\n\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    var os2 = {};\n    var p = new parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for (var i = 0; i < 10; i++) {\n        os2.panose[i] = p.parseByte();\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(\n        p.parseByte(),\n        p.parseByte(),\n        p.parseByte(),\n        p.parseByte()\n    );\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n\n    return os2;\n}\n\nvar os2 = { parse: parseOS2Table };\n\n// The `post` table stores additional PostScript information, such as glyph names.\n\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    var post = {};\n    var p = new parse.Parser(data, start);\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    post.names = [];\n    switch (post.version) {\n        case 1:\n            break;\n        case 2:\n            post.numberOfGlyphs = p.parseUShort();\n            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                post.glyphNameIndex[i] = p.parseUShort();\n            }\n            break;\n        case 2.5:\n            post.numberOfGlyphs = p.parseUShort();\n            post.offset = new Array(post.numberOfGlyphs);\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                post.offset[i$1] = p.parseChar();\n            }\n            break;\n    }\n    return post;\n}\n\nvar post = { parse: parsePostTable };\n\n// Data types used in the OpenType font file.\n\n/**\n * @exports opentype.decode\n * @class\n */\nvar decode = {};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes;\n    for (var j = 0; j < numChars; j++, offset += 1) {\n        codePoints[j] = data.getUint8(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes / 2;\n    for (var j = 0; j < numChars; j++, offset += 2) {\n        codePoints[j] = data.getUint16(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nvar eightBitMacEncodings = {\n    'x-mac-croatian':  // Python: 'mac_croatian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +\n    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +\n    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +\n    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n    'x-mac-greek':  // Python: 'mac_greek'\n    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +\n    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\u00AD',\n    'x-mac-icelandic':  // Python: 'mac_iceland'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +\n    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n    'x-mac-ce':  // Python: 'mac_latin2'\n    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +\n    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n    macintosh:  // Python: 'mac_roman'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-romanian':  // Python: 'mac_romanian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-turkish':  // Python: 'mac_turkish'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    var table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = '';\n    for (var i = 0; i < dataLength; i++) {\n        var c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n\n    return result;\n};\n\n// The `GPOS` table contains kerning pairs, among other things.\n\n// Parse the metadata `meta` table.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\nfunction parseMetaTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported META table version.');\n    p.parseULong(); // flags - currently unused and set to 0\n    p.parseULong(); // tableOffset\n    var numDataMaps = p.parseULong();\n\n    var tags = {};\n    for (var i = 0; i < numDataMaps; i++) {\n        var tag = p.parseTag();\n        var dataOffset = p.parseULong();\n        var dataLength = p.parseULong();\n        var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n        tags[tag] = text;\n    }\n    return tags;\n}\n\nvar meta = { parse: parseMetaTable };\n\n// opentype.js\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 12;\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var checksum = parse.getULong(data, p + 4);\n        var offset = parse.getULong(data, p + 8);\n        var length = parse.getULong(data, p + 12);\n        tableEntries.push({\n            tag: tag,\n            checksum: checksum,\n            offset: offset,\n            length: length,\n            compression: false,\n        });\n        p += 16;\n    }\n\n    return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 44; // offset to the first table directory entry.\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var offset = parse.getULong(data, p + 4);\n        var compLength = parse.getULong(data, p + 8);\n        var origLength = parse.getULong(data, p + 12);\n        var compression = (void 0);\n        if (compLength < origLength) {\n            compression = 'WOFF';\n        } else {\n            compression = false;\n        }\n\n        tableEntries.push({\n            tag: tag,\n            offset: offset,\n            compression: compression,\n            compressedLength: compLength,\n            length: origLength,\n        });\n        p += 20;\n    }\n\n    return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n        var inBuffer = new Uint8Array(\n            data.buffer,\n            tableEntry.offset + 2,\n            tableEntry.compressedLength - 2\n        );\n        var outBuffer = new Uint8Array(tableEntry.length);\n        inflateSync(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error(\n                'Decompression error: ' +\n                    tableEntry.tag +\n                    \" decompressed length doesn't match recorded length\"\n            );\n        }\n\n        var view = new DataView(outBuffer.buffer, 0);\n        return { data: view, offset: 0 };\n    } else {\n        return { data: data, offset: tableEntry.offset };\n    }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @param  {Object} opt - options for parsing\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer, opt) {\n    opt = opt === undefined || opt === null ? {} : opt;\n\n    var indexToLocFormat;\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    var font = new Font({ empty: true });\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    var data = new DataView(buffer, 0);\n    var numTables;\n    var tableEntries = [];\n    var signature = parse.getTag(data, 0);\n    if (\n        signature === String.fromCharCode(0, 1, 0, 0) ||\n        signature === 'true' ||\n        signature === 'typ1'\n    ) {\n        font.outlinesFormat = 'truetype';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'OTTO') {\n        font.outlinesFormat = 'cff';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'wOFF') {\n        var flavor = parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = 'truetype';\n        } else if (flavor === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType flavor ' + signature);\n        }\n\n        numTables = parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error('Unsupported OpenType signature ' + signature);\n    }\n\n    var cffTableEntry;\n    var fvarTableEntry;\n    var glyfTableEntry;\n    var gdefTableEntry;\n    var gposTableEntry;\n    var gsubTableEntry;\n    var hmtxTableEntry;\n    var kernTableEntry;\n    var locaTableEntry;\n    var metaTableEntry;\n    var p;\n\n    for (var i = 0; i < numTables; i += 1) {\n        var tableEntry = tableEntries[i];\n        var table = (void 0);\n        switch (tableEntry.tag) {\n            case 'cmap':\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case 'cvt ':\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case 'fvar':\n                fvarTableEntry = tableEntry;\n                break;\n            case 'fpgm':\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case 'head':\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case 'hhea':\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case 'hmtx':\n                hmtxTableEntry = tableEntry;\n                break;\n            case 'ltag':\n                table = uncompressTable(data, tableEntry);\n                ltagTable = ltag.parse(table.data, table.offset);\n                break;\n            case 'maxp':\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case 'OS/2':\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = os2.parse(table.data, table.offset);\n                break;\n            case 'post':\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = post.parse(table.data, table.offset);\n                break;\n            case 'prep':\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case 'glyf':\n                glyfTableEntry = tableEntry;\n                break;\n            case 'loca':\n                locaTableEntry = tableEntry;\n                break;\n            case 'CFF ':\n                cffTableEntry = tableEntry;\n                break;\n            case 'kern':\n                kernTableEntry = tableEntry;\n                break;\n            case 'GDEF':\n                gdefTableEntry = tableEntry;\n                break;\n            case 'GPOS':\n                gposTableEntry = tableEntry;\n                break;\n            case 'GSUB':\n                gsubTableEntry = tableEntry;\n                break;\n            case 'meta':\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n\n    if (glyfTableEntry && locaTableEntry) {\n        var shortVersion = indexToLocFormat === 0;\n        var locaTable = uncompressTable(data, locaTableEntry);\n        var locaOffsets = loca.parse(\n            locaTable.data,\n            locaTable.offset,\n            font.numGlyphs,\n            shortVersion\n        );\n        var glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(\n            glyfTable.data,\n            glyfTable.offset,\n            locaOffsets,\n            font,\n            opt\n        );\n    } else if (cffTableEntry) {\n        var cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font, opt);\n    } else {\n        throw new Error(\"Font doesn't contain TrueType or CFF outlines.\");\n    }\n\n    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(\n        font,\n        hmtxTable.data,\n        hmtxTable.offset,\n        font.numberOfHMetrics,\n        font.numGlyphs,\n        font.glyphs,\n        opt\n    );\n    addGlyphNames(font, opt);\n\n    if (kernTableEntry) {\n        var kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gdefTableEntry) {\n        var gdefTable = uncompressTable(data, gdefTableEntry);\n        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n    }\n\n    if (gposTableEntry) {\n        var gposTable = uncompressTable(data, gposTableEntry);\n        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n        font.position.init();\n    }\n\n    if (gsubTableEntry) {\n        var gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n\n    if (fvarTableEntry) {\n        var fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = fvar.parse(\n            fvarTable.data,\n            fvarTable.offset,\n            font.names\n        );\n    }\n\n    if (metaTableEntry) {\n        var metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n\n    return font;\n}\n\nfunction load() {}\nfunction loadSync() {}\n\nvar opentype = /*#__PURE__*/Object.freeze({\n   __proto__: null,\n   Font: Font,\n   Glyph: Glyph,\n   Path: Path,\n   _parse: parse,\n   parse: parseBuffer,\n   load: load,\n   loadSync: loadSync\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (opentype);\n\n//# sourceMappingURL=opentype.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL0BzaHVkaW5nL29wZW50eXBlLmpzL2Rpc3Qvb3BlbnR5cGUubW9kdWxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QiwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsTUFBTTtBQUNOLGtCQUFrQixTQUFTO0FBQzNCLE1BQU07QUFDTixrQkFBa0IsU0FBUztBQUMzQixNQUFNO0FBQ04sa0JBQWtCLFNBQVM7QUFDM0IsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixNQUFNO0FBQ047QUFDQTtB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QUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QixtQ0FBbUM7QUFDbkMsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCLG9CQUFvQixVQUFVO0FBQzlCLG9CQUFvQjs7QUFFcEI7QUFDQSw2QkFBNkI7O0FBRTdCOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCOztBQUV6QixvQkFBb0IsT0FBTyxPQUFPOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSx3QkFBd0I7QUFDeEIsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUI7QUFDbkIsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CO0FBQ25CLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0EsNkNBQTZDO0FBQzdDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekIsb0JBQW9CLE9BQU8sT0FBTzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixXQUFXO0FBQ1gsY0FBYztBQUNkOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REOztBQUVBLDJCQUEyQjs7QUFFM0IsY0FBYzs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNB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QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFDQUFxQztBQUNyQyx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1Q0FBdUM7QUFDdkMsdURBQXVEO0FBQ3ZELHVDQUF1QztBQUN2Qyx1REFBdUQ7QUFDdkQscUNBQXFDO0FBQ3JDLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1Q0FBdUM7QUFDdkMsdURBQXVEO0FBQ3ZELHVDQUF1QztBQUN2Qyx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1Qjs7QUFFaEQ7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTixpQkFBaUI7QUFDakIsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxRQUFRLEVBQUM7QUFDNEQ7QUFDcEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaHVkaW5nL29wZW50eXBlLmpzL2Rpc3Qvb3BlbnR5cGUubW9kdWxlLmpzP2EwNDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL29wZW50eXBlLmpzLm9yZyB2MS4zLjUgfCAoYykgRnJlZGVyaWsgRGUgQmxlc2VyIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBNSVQgTGljZW5zZSB8IFVzZXMgZmZsYXRlIGJ5IDEwMWFycm93eiBhbmQgc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdCBwb2x5ZmlsbCBieSBNYXRoaWFzIEJ5bmVuc1xuICovXG5cbi8vIERFRkxBVEUgaXMgYSBjb21wbGV4IGZvcm1hdDsgdG8gcmVhZCB0aGlzIGNvZGUsIHlvdSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhlIFJGQyBmaXJzdDpcblxuLy8gYWxpYXNlcyBmb3Igc2hvcnRlciBjb21wcmVzc2VkIGNvZGUgKG1vc3QgbWluaWZlcnMgZG9uJ3QgZG8gdGhpcylcbnZhciB1OCA9IFVpbnQ4QXJyYXksIHUxNiA9IFVpbnQxNkFycmF5LCB1MzIgPSBVaW50MzJBcnJheTtcbi8vIGZpeGVkIGxlbmd0aCBleHRyYSBiaXRzXG52YXIgZmxlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgLyogdW51c2VkICovIDAsIDAsIC8qIGltcG9zc2libGUgKi8gMF0pO1xuLy8gZml4ZWQgZGlzdGFuY2UgZXh0cmEgYml0c1xuLy8gc2VlIGZsZWIgbm90ZVxudmFyIGZkZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgLyogdW51c2VkICovIDAsIDBdKTtcbi8vIGNvZGUgbGVuZ3RoIGluZGV4IG1hcFxudmFyIGNsaW0gPSBuZXcgdTgoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbi8vIGdldCBiYXNlLCByZXZlcnNlIGluZGV4IG1hcCBmcm9tIGV4dHJhIGJpdHNcbnZhciBmcmViID0gZnVuY3Rpb24gKGViLCBzdGFydCkge1xuICAgIHZhciBiID0gbmV3IHUxNigzMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMTsgKytpKSB7XG4gICAgICAgIGJbaV0gPSBzdGFydCArPSAxIDw8IGViW2kgLSAxXTtcbiAgICB9XG4gICAgLy8gbnVtYmVycyBoZXJlIGFyZSBhdCBtYXggMTggYml0c1xuICAgIHZhciByID0gbmV3IHUzMihiWzMwXSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAzMDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBiW2ldOyBqIDwgYltpICsgMV07ICsraikge1xuICAgICAgICAgICAgcltqXSA9ICgoaiAtIGJbaV0pIDw8IDUpIHwgaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2IsIHJdO1xufTtcbnZhciBfYSA9IGZyZWIoZmxlYiwgMiksIGZsID0gX2FbMF0sIHJldmZsID0gX2FbMV07XG4vLyB3ZSBjYW4gaWdub3JlIHRoZSBmYWN0IHRoYXQgdGhlIG90aGVyIG51bWJlcnMgYXJlIHdyb25nOyB0aGV5IG5ldmVyIGhhcHBlbiBhbnl3YXlcbmZsWzI4XSA9IDI1OCwgcmV2ZmxbMjU4XSA9IDI4O1xudmFyIF9iID0gZnJlYihmZGViLCAwKSwgZmQgPSBfYlswXTtcbi8vIG1hcCBvZiB2YWx1ZSB0byByZXZlcnNlIChhc3N1bWluZyAxNiBiaXRzKVxudmFyIHJldiA9IG5ldyB1MTYoMzI3NjgpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjc2ODsgKytpKSB7XG4gICAgLy8gcmV2ZXJzZSB0YWJsZSBhbGdvcml0aG0gZnJvbSBTT1xuICAgIHZhciB4ID0gKChpICYgMHhBQUFBKSA+Pj4gMSkgfCAoKGkgJiAweDU1NTUpIDw8IDEpO1xuICAgIHggPSAoKHggJiAweENDQ0MpID4+PiAyKSB8ICgoeCAmIDB4MzMzMykgPDwgMik7XG4gICAgeCA9ICgoeCAmIDB4RjBGMCkgPj4+IDQpIHwgKCh4ICYgMHgwRjBGKSA8PCA0KTtcbiAgICByZXZbaV0gPSAoKCh4ICYgMHhGRjAwKSA+Pj4gOCkgfCAoKHggJiAweDAwRkYpIDw8IDgpKSA+Pj4gMTtcbn1cbi8vIGNyZWF0ZSBodWZmbWFuIHRyZWUgZnJvbSB1OCBcIm1hcFwiOiBpbmRleCAtPiBjb2RlIGxlbmd0aCBmb3IgY29kZSBpbmRleFxuLy8gbWIgKG1heCBiaXRzKSBtdXN0IGJlIGF0IG1vc3QgMTVcbi8vIFRPRE86IG9wdGltaXplL3NwbGl0IHVwP1xudmFyIGhNYXAgPSAoZnVuY3Rpb24gKGNkLCBtYiwgcikge1xuICAgIHZhciBzID0gY2QubGVuZ3RoO1xuICAgIC8vIGluZGV4XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiAjIG9mIGNvZGVzIHdpdGggYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGwgPSBuZXcgdTE2KG1iKTtcbiAgICAvLyBsZW5ndGggb2YgY2QgbXVzdCBiZSAyODggKHRvdGFsICMgb2YgY29kZXMpXG4gICAgZm9yICg7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgaWYgKGNkW2ldKVxuICAgICAgICAgICAgeyArK2xbY2RbaV0gLSAxXTsgfVxuICAgIH1cbiAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbWluaW11bSBjb2RlIGZvciBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbGUgPSBuZXcgdTE2KG1iKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWI7ICsraSkge1xuICAgICAgICBsZVtpXSA9IChsZVtpIC0gMV0gKyBsW2kgLSAxXSkgPDwgMTtcbiAgICB9XG4gICAgdmFyIGNvO1xuICAgIGlmIChyKSB7XG4gICAgICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBudW1iZXIgb2YgYWN0dWFsIGJpdHMsIHN5bWJvbCBmb3IgY29kZVxuICAgICAgICBjbyA9IG5ldyB1MTYoMSA8PCBtYik7XG4gICAgICAgIC8vIGJpdHMgdG8gcmVtb3ZlIGZvciByZXZlcnNlclxuICAgICAgICB2YXIgcnZiID0gMTUgLSBtYjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIDAgbGVuZ3Roc1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtIGVuY29kaW5nIGJvdGggc3ltYm9sIGFuZCBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICB2YXIgc3YgPSAoaSA8PCA0KSB8IGNkW2ldO1xuICAgICAgICAgICAgICAgIC8vIGZyZWUgYml0c1xuICAgICAgICAgICAgICAgIHZhciByXzEgPSBtYiAtIGNkW2ldO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBsZVtjZFtpXSAtIDFdKysgPDwgcl8xO1xuICAgICAgICAgICAgICAgIC8vIG0gaXMgZW5kIHZhbHVlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IHYgfCAoKDEgPDwgcl8xKSAtIDEpOyB2IDw9IG07ICsrdikge1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVyeSAxNiBiaXQgdmFsdWUgc3RhcnRpbmcgd2l0aCB0aGUgY29kZSB5aWVsZHMgdGhlIHNhbWUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGNvW3Jldlt2XSA+Pj4gcnZiXSA9IHN2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY28gPSBuZXcgdTE2KHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY2RbaV0pIHtcbiAgICAgICAgICAgICAgICBjb1tpXSA9IHJldltsZVtjZFtpXSAtIDFdKytdID4+PiAoMTUgLSBjZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvO1xufSk7XG4vLyBmaXhlZCBsZW5ndGggdHJlZVxudmFyIGZsdCA9IG5ldyB1OCgyODgpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxNDQ7ICsraSlcbiAgICB7IGZsdFtpXSA9IDg7IH1cbmZvciAodmFyIGkgPSAxNDQ7IGkgPCAyNTY7ICsraSlcbiAgICB7IGZsdFtpXSA9IDk7IH1cbmZvciAodmFyIGkgPSAyNTY7IGkgPCAyODA7ICsraSlcbiAgICB7IGZsdFtpXSA9IDc7IH1cbmZvciAodmFyIGkgPSAyODA7IGkgPCAyODg7ICsraSlcbiAgICB7IGZsdFtpXSA9IDg7IH1cbi8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbnZhciBmZHQgPSBuZXcgdTgoMzIpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKVxuICAgIHsgZmR0W2ldID0gNTsgfVxuLy8gZml4ZWQgbGVuZ3RoIG1hcFxudmFyIGZscm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAxKTtcbi8vIGZpeGVkIGRpc3RhbmNlIG1hcFxudmFyIGZkcm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmR0LCA1LCAxKTtcbi8vIGZpbmQgbWF4IG9mIGFycmF5XG52YXIgbWF4ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgbSA9IGFbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhW2ldID4gbSlcbiAgICAgICAgICAgIHsgbSA9IGFbaV07IH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbnZhciBiaXRzID0gZnVuY3Rpb24gKGQsIHAsIG0pIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkpID4+IChwICYgNykpICYgbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbnZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSB8IChkW28gKyAyXSA8PCAxNikpID4+IChwICYgNykpO1xufTtcbi8vIGdldCBlbmQgb2YgYnl0ZVxudmFyIHNoZnQgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gKChwICsgNykgLyA4KSB8IDA7IH07XG4vLyB0eXBlZCBhcnJheSBzbGljZSAtIGFsbG93cyBnYXJiYWdlIGNvbGxlY3RvciB0byBmcmVlIG9yaWdpbmFsIHJlZmVyZW5jZSxcbi8vIHdoaWxlIGJlaW5nIG1vcmUgY29tcGF0aWJsZSB0aGFuIC5zbGljZVxudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgeyBzID0gMDsgfVxuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICB7IGUgPSB2Lmxlbmd0aDsgfVxuICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgdmFyIG4gPSBuZXcgKHYuQllURVNfUEVSX0VMRU1FTlQgPT0gMiA/IHUxNiA6IHYuQllURVNfUEVSX0VMRU1FTlQgPT0gNCA/IHUzMiA6IHU4KShlIC0gcyk7XG4gICAgbi5zZXQodi5zdWJhcnJheShzLCBlKSk7XG4gICAgcmV0dXJuIG47XG59O1xuLy8gZXJyb3IgY29kZXNcbnZhciBlYyA9IFtcbiAgICAndW5leHBlY3RlZCBFT0YnLFxuICAgICdpbnZhbGlkIGJsb2NrIHR5cGUnLFxuICAgICdpbnZhbGlkIGxlbmd0aC9saXRlcmFsJyxcbiAgICAnaW52YWxpZCBkaXN0YW5jZScsXG4gICAgJ3N0cmVhbSBmaW5pc2hlZCcsXG4gICAgJ25vIHN0cmVhbSBoYW5kbGVyJyxcbiAgICAsXG4gICAgJ25vIGNhbGxiYWNrJyxcbiAgICAnaW52YWxpZCBVVEYtOCBkYXRhJyxcbiAgICAnZXh0cmEgZmllbGQgdG9vIGxvbmcnLFxuICAgICdkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTknLFxuICAgICdmaWxlbmFtZSB0b28gbG9uZycsXG4gICAgJ3N0cmVhbSBmaW5pc2hpbmcnLFxuICAgICdpbnZhbGlkIHppcCBkYXRhJ1xuICAgIC8vIGRldGVybWluZWQgYnkgdW5rbm93biBjb21wcmVzc2lvbiBtZXRob2Rcbl07XG52YXIgZXJyID0gZnVuY3Rpb24gKGluZCwgbXNnLCBudCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyB8fCBlY1tpbmRdKTtcbiAgICBlLmNvZGUgPSBpbmQ7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgICB7IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGUsIGVycik7IH1cbiAgICBpZiAoIW50KVxuICAgICAgICB7IHRocm93IGU7IH1cbiAgICByZXR1cm4gZTtcbn07XG4vLyBleHBhbmRzIHJhdyBERUZMQVRFIGRhdGFcbnZhciBpbmZsdCA9IGZ1bmN0aW9uIChkYXQsIGJ1Ziwgc3QpIHtcbiAgICAvLyBzb3VyY2UgbGVuZ3RoXG4gICAgdmFyIHNsID0gZGF0Lmxlbmd0aDtcbiAgICBpZiAoIXNsIHx8IChzdCAmJiBzdC5mICYmICFzdC5sKSlcbiAgICAgICAgeyByZXR1cm4gYnVmIHx8IG5ldyB1OCgwKTsgfVxuICAgIC8vIGhhdmUgdG8gZXN0aW1hdGUgc2l6ZVxuICAgIHZhciBub0J1ZiA9ICFidWYgfHwgc3Q7XG4gICAgLy8gbm8gc3RhdGVcbiAgICB2YXIgbm9TdCA9ICFzdCB8fCBzdC5pO1xuICAgIGlmICghc3QpXG4gICAgICAgIHsgc3QgPSB7fTsgfVxuICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgIGlmICghYnVmKVxuICAgICAgICB7IGJ1ZiA9IG5ldyB1OChzbCAqIDMpOyB9XG4gICAgLy8gZW5zdXJlIGJ1ZmZlciBjYW4gZml0IGF0IGxlYXN0IGwgZWxlbWVudHNcbiAgICB2YXIgY2J1ZiA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHZhciBibCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugc2l6ZSB0byBmaXRcbiAgICAgICAgaWYgKGwgPiBibCkge1xuICAgICAgICAgICAgLy8gRG91YmxlIG9yIHNldCB0byBuZWNlc3NhcnksIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgICAgICB2YXIgbmJ1ZiA9IG5ldyB1OChNYXRoLm1heChibCAqIDIsIGwpKTtcbiAgICAgICAgICAgIG5idWYuc2V0KGJ1Zik7XG4gICAgICAgICAgICBidWYgPSBuYnVmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAgbGFzdCBjaHVuayAgICAgICAgIGJpdHBvcyAgICAgICAgICAgYnl0ZXNcbiAgICB2YXIgZmluYWwgPSBzdC5mIHx8IDAsIHBvcyA9IHN0LnAgfHwgMCwgYnQgPSBzdC5iIHx8IDAsIGxtID0gc3QubCwgZG0gPSBzdC5kLCBsYnQgPSBzdC5tLCBkYnQgPSBzdC5uO1xuICAgIC8vIHRvdGFsIGJpdHNcbiAgICB2YXIgdGJ0cyA9IHNsICogODtcbiAgICBkbyB7XG4gICAgICAgIGlmICghbG0pIHtcbiAgICAgICAgICAgIC8vIEJGSU5BTCAtIHRoaXMgaXMgb25seSAxIHdoZW4gbGFzdCBjaHVuayBpcyBuZXh0XG4gICAgICAgICAgICBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAgICAgLy8gdHlwZTogMCA9IG5vIGNvbXByZXNzaW9uLCAxID0gZml4ZWQgaHVmZm1hbiwgMiA9IGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIGVuZCBvZiBieXRlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzaGZ0KHBvcykgKyA0LCBsID0gZGF0W3MgLSA0XSB8IChkYXRbcyAtIDNdIDw8IDgpLCB0ID0gcyArIGw7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiBzbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgZXJyKDApOyB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgeyBjYnVmKGJ0ICsgbCk7IH1cbiAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdW5jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICAgICAgICBidWYuc2V0KGRhdC5zdWJhcnJheShzLCB0KSwgYnQpO1xuICAgICAgICAgICAgICAgIC8vIEdldCBuZXcgYml0cG9zLCB1cGRhdGUgYnl0ZSBjb3VudFxuICAgICAgICAgICAgICAgIHN0LmIgPSBidCArPSBsLCBzdC5wID0gcG9zID0gdCAqIDgsIHN0LmYgPSBmaW5hbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICB7IGxtID0gZmxybSwgZG0gPSBmZHJtLCBsYnQgPSA5LCBkYnQgPSA1OyB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyAgbGl0ZXJhbCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzXG4gICAgICAgICAgICAgICAgdmFyIGhMaXQgPSBiaXRzKGRhdCwgcG9zLCAzMSkgKyAyNTcsIGhjTGVuID0gYml0cyhkYXQsIHBvcyArIDEwLCAxNSkgKyA0O1xuICAgICAgICAgICAgICAgIHZhciB0bCA9IGhMaXQgKyBiaXRzKGRhdCwgcG9zICsgNSwgMzEpICsgMTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTQ7XG4gICAgICAgICAgICAgICAgLy8gbGVuZ3RoK2Rpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgbGR0ID0gbmV3IHU4KHRsKTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGNsdCA9IG5ldyB1OCgxOSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoY0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbmRleCBtYXAgdG8gZ2V0IHJlYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICBjbHRbY2xpbVtpXV0gPSBiaXRzKGRhdCwgcG9zICsgaSAqIDMsIDcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gaGNMZW4gKiAzO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIGNsYiA9IG1heChjbHQpLCBjbGJtc2sgPSAoMSA8PCBjbGIpIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgbWFwXG4gICAgICAgICAgICAgICAgdmFyIGNsbSA9IGhNYXAoY2x0LCBjbGIsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGw7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gY2xtW2JpdHMoZGF0LCBwb3MsIGNsYm1zayldO1xuICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHIgJiAxNTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gciA+Pj4gNDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdG8gY29weVxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZHRbaSsrXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29weSAgIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDAsIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT0gMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtpIC0gMV07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDcpLCBwb3MgKz0gMzsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG4gPSAxMSArIGJpdHMoZGF0LCBwb3MsIDEyNyksIHBvcyArPSA3OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbGR0W2krK10gPSBjOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgbGVuZ3RoIHRyZWUgICAgICAgICAgICAgICAgIGRpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSBsZHQuc3ViYXJyYXkoMCwgaExpdCksIGR0ID0gbGR0LnN1YmFycmF5KGhMaXQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBsZW5ndGggYml0c1xuICAgICAgICAgICAgICAgIGxidCA9IG1heChsdCk7XG4gICAgICAgICAgICAgICAgLy8gbWF4IGRpc3QgYml0c1xuICAgICAgICAgICAgICAgIGRidCA9IG1heChkdCk7XG4gICAgICAgICAgICAgICAgbG0gPSBoTWFwKGx0LCBsYnQsIDEpO1xuICAgICAgICAgICAgICAgIGRtID0gaE1hcChkdCwgZGJ0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7IGVycigxKTsgfVxuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgeyBlcnIoMCk7IH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGJ1ZmZlciBjYW4gaG9sZCB0aGlzICsgdGhlIGxhcmdlc3QgcG9zc2libGUgYWRkaXRpb25cbiAgICAgICAgLy8gTWF4aW11bSBjaHVuayBzaXplIChwcmFjdGljYWxseSwgdGhlb3JldGljYWxseSBpbmZpbml0ZSkgaXMgMl4xNztcbiAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgeyBjYnVmKGJ0ICsgMTMxMDcyKTsgfVxuICAgICAgICB2YXIgbG1zID0gKDEgPDwgbGJ0KSAtIDEsIGRtcyA9ICgxIDw8IGRidCkgLSAxO1xuICAgICAgICB2YXIgbHBvcyA9IHBvcztcbiAgICAgICAgZm9yICg7OyBscG9zID0gcG9zKSB7XG4gICAgICAgICAgICAvLyBiaXRzIHJlYWQsIGNvZGVcbiAgICAgICAgICAgIHZhciBjID0gbG1bYml0czE2KGRhdCwgcG9zKSAmIGxtc10sIHN5bSA9IGMgPj4+IDQ7XG4gICAgICAgICAgICBwb3MgKz0gYyAmIDE1O1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgeyBlcnIoMCk7IH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYylcbiAgICAgICAgICAgICAgICB7IGVycigyKTsgfVxuICAgICAgICAgICAgaWYgKHN5bSA8IDI1NilcbiAgICAgICAgICAgICAgICB7IGJ1ZltidCsrXSA9IHN5bTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ltID09IDI1Nikge1xuICAgICAgICAgICAgICAgIGxwb3MgPSBwb3MsIGxtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgICAgICAgICAgLy8gbm8gZXh0cmEgYml0cyBuZWVkZWQgaWYgbGVzc1xuICAgICAgICAgICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBzeW0gLSAyNTcsIGIgPSBmbGViW2ldO1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSBiaXRzKGRhdCwgcG9zLCAoMSA8PCBiKSAtIDEpICsgZmxbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXN0XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkbVtiaXRzMTYoZGF0LCBwb3MpICYgZG1zXSwgZHN5bSA9IGQgPj4+IDQ7XG4gICAgICAgICAgICAgICAgaWYgKCFkKVxuICAgICAgICAgICAgICAgICAgICB7IGVycigzKTsgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBkICYgMTU7XG4gICAgICAgICAgICAgICAgdmFyIGR0ID0gZmRbZHN5bV07XG4gICAgICAgICAgICAgICAgaWYgKGRzeW0gPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gZmRlYltkc3ltXTtcbiAgICAgICAgICAgICAgICAgICAgZHQgKz0gYml0czE2KGRhdCwgcG9zKSAmICgoMSA8PCBiKSAtIDEpLCBwb3MgKz0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGVycigwKTsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgICAgICAgICB7IGNidWYoYnQgKyAxMzEwNzIpOyB9XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGJ0ICsgYWRkO1xuICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgYnQgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAxXSA9IGJ1ZltidCArIDEgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDJdID0gYnVmW2J0ICsgMiAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgM10gPSBidWZbYnQgKyAzIC0gZHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQsIHN0LmYgPSBmaW5hbDtcbiAgICAgICAgaWYgKGxtKVxuICAgICAgICAgICAgeyBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDsgfVxuICAgIH0gd2hpbGUgKCFmaW5hbCk7XG4gICAgcmV0dXJuIGJ0ID09IGJ1Zi5sZW5ndGggPyBidWYgOiBzbGMoYnVmLCAwLCBidCk7XG59O1xuLy8gZW1wdHlcbnZhciBldCA9IC8qI19fUFVSRV9fKi8gbmV3IHU4KDApO1xuLyoqXG4gKiBFeHBhbmRzIERFRkxBVEUgZGF0YSB3aXRoIG5vIHdyYXBwZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5mdW5jdGlvbiBpbmZsYXRlU3luYyhkYXRhLCBvdXQpIHtcbiAgICByZXR1cm4gaW5mbHQoZGF0YSwgb3V0KTtcbn1cbi8vIHRleHQgZGVjb2RlclxudmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXIgc3RyZWFtXG52YXIgdGRzID0gMDtcbnRyeSB7XG4gICAgdGQuZGVjb2RlKGV0LCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB0ZHMgPSAxO1xufVxuY2F0Y2ggKGUpIHsgfVxuXG4vLyBHZW9tZXRyaWMgb2JqZWN0c1xuXG4vLyBpbXBvcnQgQm91bmRpbmdCb3ggZnJvbSAnLi9iYm94JztcblxuLyoqXG4gKiBBIGLDqXppZXIgcGF0aCBjb250YWluaW5nIGEgc2V0IG9mIHBhdGggY29tbWFuZHMgc2ltaWxhciB0byBhIFNWRyBwYXRoLlxuICogUGF0aHMgY2FuIGJlIGRyYXduIG9uIGEgY29udGV4dCB1c2luZyBgZHJhd2AuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5QYXRoXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYXRoKCkge1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgIHRoaXMuc3Ryb2tlID0gbnVsbDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSAge251bWJlcn0geVxuICovXG5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdNJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAqL1xuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnTCcsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYXdzIGN1YmljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIGN1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geDIgLSB4IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB5MiAtIHkgb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICovXG5cbi8qKlxuICogRHJhd3MgY3ViaWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogYmV6aWVyQ3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB4MiAtIHggb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkyIC0geSBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKiBAc2VlIGN1cnZlVG9cbiAqL1xuUGF0aC5wcm90b3R5cGUuY3VydmVUbyA9IFBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoXG4gICAgeDEsXG4gICAgeTEsXG4gICAgeDIsXG4gICAgeTIsXG4gICAgeCxcbiAgICB5XG4pIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkyOiB5MixcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIHF1YWRyYXRpY0N1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuXG4vKipcbiAqIERyYXdzIHF1YWRyYXRpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBxdWFkVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuUGF0aC5wcm90b3R5cGUucXVhZFRvID0gUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uIChcbiAgICB4MSxcbiAgICB5MSxcbiAgICB4LFxuICAgIHlcbikge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdRJyxcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgcGF0aFxuICogQGZ1bmN0aW9uIGNsb3NlUGF0aFxuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKi9cblxuLyoqXG4gKiBDbG9zZSB0aGUgcGF0aFxuICogQGZ1bmN0aW9uIGNsb3NlXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqL1xuUGF0aC5wcm90b3R5cGUuY2xvc2UgPSBQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ1onLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHBhdGggb3IgbGlzdCBvZiBjb21tYW5kcyB0byB0aGUgY29tbWFuZHMgb2YgdGhpcyBwYXRoLlxuICogQHBhcmFtICB7QXJyYXl9IHBhdGhPckNvbW1hbmRzIC0gYW5vdGhlciBvcGVudHlwZS5QYXRoLCBhbiBvcGVudHlwZS5Cb3VuZGluZ0JveCwgb3IgYW4gYXJyYXkgb2YgY29tbWFuZHMuXG4gKi9cblBhdGgucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChwYXRoT3JDb21tYW5kcykge1xuICAgIGlmIChwYXRoT3JDb21tYW5kcy5jb21tYW5kcykge1xuICAgICAgICBwYXRoT3JDb21tYW5kcyA9IHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzO1xuICAgIH1cbiAgICAvLyBlbHNlIGlmIChwYXRoT3JDb21tYW5kcyBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG4gICAgLy8gICAgIGNvbnN0IGJveCA9IHBhdGhPckNvbW1hbmRzO1xuICAgIC8vICAgICB0aGlzLm1vdmVUbyhib3gueDEsIGJveC55MSk7XG4gICAgLy8gICAgIHRoaXMubGluZVRvKGJveC54MiwgYm94LnkxKTtcbiAgICAvLyAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTIpO1xuICAgIC8vICAgICB0aGlzLmxpbmVUbyhib3gueDEsIGJveC55Mik7XG4gICAgLy8gICAgIHRoaXMuY2xvc2UoKTtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuY29tbWFuZHMsIHBhdGhPckNvbW1hbmRzKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUGF0aC5wcm90b3R5cGUudG9QYXRoRGF0YSA9IGZ1bmN0aW9uIChkZWNpbWFsUGxhY2VzKSB7XG4gICAgZGVjaW1hbFBsYWNlcyA9IGRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxQbGFjZXMgOiAyO1xuXG4gICAgZnVuY3Rpb24gZmxvYXRUb1N0cmluZyh2KSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHYpID09PSB2KSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9GaXhlZChkZWNpbWFsUGxhY2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhY2tWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHYgPSBhcmd1bWVudHMkMVtpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDAgJiYgaSA+IDApIHtcbiAgICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcyArPSBmbG9hdFRvU3RyaW5nKHYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgdmFyIGQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBkICs9ICdDJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBkICs9ICdaJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLy8gR2x5cGggZW5jb2RpbmdcblxudmFyIGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcbiAgICAnLm5vdGRlZicsXG4gICAgJ3NwYWNlJyxcbiAgICAnZXhjbGFtJyxcbiAgICAncXVvdGVkYmwnLFxuICAgICdudW1iZXJzaWduJyxcbiAgICAnZG9sbGFyJyxcbiAgICAncGVyY2VudCcsXG4gICAgJ2FtcGVyc2FuZCcsXG4gICAgJ3F1b3RlcmlnaHQnLFxuICAgICdwYXJlbmxlZnQnLFxuICAgICdwYXJlbnJpZ2h0JyxcbiAgICAnYXN0ZXJpc2snLFxuICAgICdwbHVzJyxcbiAgICAnY29tbWEnLFxuICAgICdoeXBoZW4nLFxuICAgICdwZXJpb2QnLFxuICAgICdzbGFzaCcsXG4gICAgJ3plcm8nLFxuICAgICdvbmUnLFxuICAgICd0d28nLFxuICAgICd0aHJlZScsXG4gICAgJ2ZvdXInLFxuICAgICdmaXZlJyxcbiAgICAnc2l4JyxcbiAgICAnc2V2ZW4nLFxuICAgICdlaWdodCcsXG4gICAgJ25pbmUnLFxuICAgICdjb2xvbicsXG4gICAgJ3NlbWljb2xvbicsXG4gICAgJ2xlc3MnLFxuICAgICdlcXVhbCcsXG4gICAgJ2dyZWF0ZXInLFxuICAgICdxdWVzdGlvbicsXG4gICAgJ2F0JyxcbiAgICAnQScsXG4gICAgJ0InLFxuICAgICdDJyxcbiAgICAnRCcsXG4gICAgJ0UnLFxuICAgICdGJyxcbiAgICAnRycsXG4gICAgJ0gnLFxuICAgICdJJyxcbiAgICAnSicsXG4gICAgJ0snLFxuICAgICdMJyxcbiAgICAnTScsXG4gICAgJ04nLFxuICAgICdPJyxcbiAgICAnUCcsXG4gICAgJ1EnLFxuICAgICdSJyxcbiAgICAnUycsXG4gICAgJ1QnLFxuICAgICdVJyxcbiAgICAnVicsXG4gICAgJ1cnLFxuICAgICdYJyxcbiAgICAnWScsXG4gICAgJ1onLFxuICAgICdicmFja2V0bGVmdCcsXG4gICAgJ2JhY2tzbGFzaCcsXG4gICAgJ2JyYWNrZXRyaWdodCcsXG4gICAgJ2FzY2lpY2lyY3VtJyxcbiAgICAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsXG4gICAgJ2EnLFxuICAgICdiJyxcbiAgICAnYycsXG4gICAgJ2QnLFxuICAgICdlJyxcbiAgICAnZicsXG4gICAgJ2cnLFxuICAgICdoJyxcbiAgICAnaScsXG4gICAgJ2onLFxuICAgICdrJyxcbiAgICAnbCcsXG4gICAgJ20nLFxuICAgICduJyxcbiAgICAnbycsXG4gICAgJ3AnLFxuICAgICdxJyxcbiAgICAncicsXG4gICAgJ3MnLFxuICAgICd0JyxcbiAgICAndScsXG4gICAgJ3YnLFxuICAgICd3JyxcbiAgICAneCcsXG4gICAgJ3knLFxuICAgICd6JyxcbiAgICAnYnJhY2VsZWZ0JyxcbiAgICAnYmFyJyxcbiAgICAnYnJhY2VyaWdodCcsXG4gICAgJ2FzY2lpdGlsZGUnLFxuICAgICdleGNsYW1kb3duJyxcbiAgICAnY2VudCcsXG4gICAgJ3N0ZXJsaW5nJyxcbiAgICAnZnJhY3Rpb24nLFxuICAgICd5ZW4nLFxuICAgICdmbG9yaW4nLFxuICAgICdzZWN0aW9uJyxcbiAgICAnY3VycmVuY3knLFxuICAgICdxdW90ZXNpbmdsZScsXG4gICAgJ3F1b3RlZGJsbGVmdCcsXG4gICAgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICdndWlsc2luZ2xsZWZ0JyxcbiAgICAnZ3VpbHNpbmdscmlnaHQnLFxuICAgICdmaScsXG4gICAgJ2ZsJyxcbiAgICAnZW5kYXNoJyxcbiAgICAnZGFnZ2VyJyxcbiAgICAnZGFnZ2VyZGJsJyxcbiAgICAncGVyaW9kY2VudGVyZWQnLFxuICAgICdwYXJhZ3JhcGgnLFxuICAgICdidWxsZXQnLFxuICAgICdxdW90ZXNpbmdsYmFzZScsXG4gICAgJ3F1b3RlZGJsYmFzZScsXG4gICAgJ3F1b3RlZGJscmlnaHQnLFxuICAgICdndWlsbGVtb3RyaWdodCcsXG4gICAgJ2VsbGlwc2lzJyxcbiAgICAncGVydGhvdXNhbmQnLFxuICAgICdxdWVzdGlvbmRvd24nLFxuICAgICdncmF2ZScsXG4gICAgJ2FjdXRlJyxcbiAgICAnY2lyY3VtZmxleCcsXG4gICAgJ3RpbGRlJyxcbiAgICAnbWFjcm9uJyxcbiAgICAnYnJldmUnLFxuICAgICdkb3RhY2NlbnQnLFxuICAgICdkaWVyZXNpcycsXG4gICAgJ3JpbmcnLFxuICAgICdjZWRpbGxhJyxcbiAgICAnaHVuZ2FydW1sYXV0JyxcbiAgICAnb2dvbmVrJyxcbiAgICAnY2Fyb24nLFxuICAgICdlbWRhc2gnLFxuICAgICdBRScsXG4gICAgJ29yZGZlbWluaW5lJyxcbiAgICAnTHNsYXNoJyxcbiAgICAnT3NsYXNoJyxcbiAgICAnT0UnLFxuICAgICdvcmRtYXNjdWxpbmUnLFxuICAgICdhZScsXG4gICAgJ2RvdGxlc3NpJyxcbiAgICAnbHNsYXNoJyxcbiAgICAnb3NsYXNoJyxcbiAgICAnb2UnLFxuICAgICdnZXJtYW5kYmxzJyxcbiAgICAnb25lc3VwZXJpb3InLFxuICAgICdsb2dpY2Fsbm90JyxcbiAgICAnbXUnLFxuICAgICd0cmFkZW1hcmsnLFxuICAgICdFdGgnLFxuICAgICdvbmVoYWxmJyxcbiAgICAncGx1c21pbnVzJyxcbiAgICAnVGhvcm4nLFxuICAgICdvbmVxdWFydGVyJyxcbiAgICAnZGl2aWRlJyxcbiAgICAnYnJva2VuYmFyJyxcbiAgICAnZGVncmVlJyxcbiAgICAndGhvcm4nLFxuICAgICd0aHJlZXF1YXJ0ZXJzJyxcbiAgICAndHdvc3VwZXJpb3InLFxuICAgICdyZWdpc3RlcmVkJyxcbiAgICAnbWludXMnLFxuICAgICdldGgnLFxuICAgICdtdWx0aXBseScsXG4gICAgJ3RocmVlc3VwZXJpb3InLFxuICAgICdjb3B5cmlnaHQnLFxuICAgICdBYWN1dGUnLFxuICAgICdBY2lyY3VtZmxleCcsXG4gICAgJ0FkaWVyZXNpcycsXG4gICAgJ0FncmF2ZScsXG4gICAgJ0FyaW5nJyxcbiAgICAnQXRpbGRlJyxcbiAgICAnQ2NlZGlsbGEnLFxuICAgICdFYWN1dGUnLFxuICAgICdFY2lyY3VtZmxleCcsXG4gICAgJ0VkaWVyZXNpcycsXG4gICAgJ0VncmF2ZScsXG4gICAgJ0lhY3V0ZScsXG4gICAgJ0ljaXJjdW1mbGV4JyxcbiAgICAnSWRpZXJlc2lzJyxcbiAgICAnSWdyYXZlJyxcbiAgICAnTnRpbGRlJyxcbiAgICAnT2FjdXRlJyxcbiAgICAnT2NpcmN1bWZsZXgnLFxuICAgICdPZGllcmVzaXMnLFxuICAgICdPZ3JhdmUnLFxuICAgICdPdGlsZGUnLFxuICAgICdTY2Fyb24nLFxuICAgICdVYWN1dGUnLFxuICAgICdVY2lyY3VtZmxleCcsXG4gICAgJ1VkaWVyZXNpcycsXG4gICAgJ1VncmF2ZScsXG4gICAgJ1lhY3V0ZScsXG4gICAgJ1lkaWVyZXNpcycsXG4gICAgJ1pjYXJvbicsXG4gICAgJ2FhY3V0ZScsXG4gICAgJ2FjaXJjdW1mbGV4JyxcbiAgICAnYWRpZXJlc2lzJyxcbiAgICAnYWdyYXZlJyxcbiAgICAnYXJpbmcnLFxuICAgICdhdGlsZGUnLFxuICAgICdjY2VkaWxsYScsXG4gICAgJ2VhY3V0ZScsXG4gICAgJ2VjaXJjdW1mbGV4JyxcbiAgICAnZWRpZXJlc2lzJyxcbiAgICAnZWdyYXZlJyxcbiAgICAnaWFjdXRlJyxcbiAgICAnaWNpcmN1bWZsZXgnLFxuICAgICdpZGllcmVzaXMnLFxuICAgICdpZ3JhdmUnLFxuICAgICdudGlsZGUnLFxuICAgICdvYWN1dGUnLFxuICAgICdvY2lyY3VtZmxleCcsXG4gICAgJ29kaWVyZXNpcycsXG4gICAgJ29ncmF2ZScsXG4gICAgJ290aWxkZScsXG4gICAgJ3NjYXJvbicsXG4gICAgJ3VhY3V0ZScsXG4gICAgJ3VjaXJjdW1mbGV4JyxcbiAgICAndWRpZXJlc2lzJyxcbiAgICAndWdyYXZlJyxcbiAgICAneWFjdXRlJyxcbiAgICAneWRpZXJlc2lzJyxcbiAgICAnemNhcm9uJyxcbiAgICAnZXhjbGFtc21hbGwnLFxuICAgICdIdW5nYXJ1bWxhdXRzbWFsbCcsXG4gICAgJ2RvbGxhcm9sZHN0eWxlJyxcbiAgICAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsXG4gICAgJ0FjdXRlc21hbGwnLFxuICAgICdwYXJlbmxlZnRzdXBlcmlvcicsXG4gICAgJ3BhcmVucmlnaHRzdXBlcmlvcicsXG4gICAgJzI2NiBmZicsXG4gICAgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnemVyb29sZHN0eWxlJyxcbiAgICAnb25lb2xkc3R5bGUnLFxuICAgICd0d29vbGRzdHlsZScsXG4gICAgJ3RocmVlb2xkc3R5bGUnLFxuICAgICdmb3Vyb2xkc3R5bGUnLFxuICAgICdmaXZlb2xkc3R5bGUnLFxuICAgICdzaXhvbGRzdHlsZScsXG4gICAgJ3NldmVub2xkc3R5bGUnLFxuICAgICdlaWdodG9sZHN0eWxlJyxcbiAgICAnbmluZW9sZHN0eWxlJyxcbiAgICAnY29tbWFzdXBlcmlvcicsXG4gICAgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLFxuICAgICdwZXJpb2RzdXBlcmlvcicsXG4gICAgJ3F1ZXN0aW9uc21hbGwnLFxuICAgICdhc3VwZXJpb3InLFxuICAgICdic3VwZXJpb3InLFxuICAgICdjZW50c3VwZXJpb3InLFxuICAgICdkc3VwZXJpb3InLFxuICAgICdlc3VwZXJpb3InLFxuICAgICdpc3VwZXJpb3InLFxuICAgICdsc3VwZXJpb3InLFxuICAgICdtc3VwZXJpb3InLFxuICAgICduc3VwZXJpb3InLFxuICAgICdvc3VwZXJpb3InLFxuICAgICdyc3VwZXJpb3InLFxuICAgICdzc3VwZXJpb3InLFxuICAgICd0c3VwZXJpb3InLFxuICAgICdmZicsXG4gICAgJ2ZmaScsXG4gICAgJ2ZmbCcsXG4gICAgJ3BhcmVubGVmdGluZmVyaW9yJyxcbiAgICAncGFyZW5yaWdodGluZmVyaW9yJyxcbiAgICAnQ2lyY3VtZmxleHNtYWxsJyxcbiAgICAnaHlwaGVuc3VwZXJpb3InLFxuICAgICdHcmF2ZXNtYWxsJyxcbiAgICAnQXNtYWxsJyxcbiAgICAnQnNtYWxsJyxcbiAgICAnQ3NtYWxsJyxcbiAgICAnRHNtYWxsJyxcbiAgICAnRXNtYWxsJyxcbiAgICAnRnNtYWxsJyxcbiAgICAnR3NtYWxsJyxcbiAgICAnSHNtYWxsJyxcbiAgICAnSXNtYWxsJyxcbiAgICAnSnNtYWxsJyxcbiAgICAnS3NtYWxsJyxcbiAgICAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJyxcbiAgICAnTnNtYWxsJyxcbiAgICAnT3NtYWxsJyxcbiAgICAnUHNtYWxsJyxcbiAgICAnUXNtYWxsJyxcbiAgICAnUnNtYWxsJyxcbiAgICAnU3NtYWxsJyxcbiAgICAnVHNtYWxsJyxcbiAgICAnVXNtYWxsJyxcbiAgICAnVnNtYWxsJyxcbiAgICAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJyxcbiAgICAnWXNtYWxsJyxcbiAgICAnWnNtYWxsJyxcbiAgICAnY29sb25tb25ldGFyeScsXG4gICAgJ29uZWZpdHRlZCcsXG4gICAgJ3J1cGlhaCcsXG4gICAgJ1RpbGRlc21hbGwnLFxuICAgICdleGNsYW1kb3duc21hbGwnLFxuICAgICdjZW50b2xkc3R5bGUnLFxuICAgICdMc2xhc2hzbWFsbCcsXG4gICAgJ1NjYXJvbnNtYWxsJyxcbiAgICAnWmNhcm9uc21hbGwnLFxuICAgICdEaWVyZXNpc3NtYWxsJyxcbiAgICAnQnJldmVzbWFsbCcsXG4gICAgJ0Nhcm9uc21hbGwnLFxuICAgICdEb3RhY2NlbnRzbWFsbCcsXG4gICAgJ01hY3JvbnNtYWxsJyxcbiAgICAnZmlndXJlZGFzaCcsXG4gICAgJ2h5cGhlbmluZmVyaW9yJyxcbiAgICAnT2dvbmVrc21hbGwnLFxuICAgICdSaW5nc21hbGwnLFxuICAgICdDZWRpbGxhc21hbGwnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsXG4gICAgJ29uZWVpZ2h0aCcsXG4gICAgJ3RocmVlZWlnaHRocycsXG4gICAgJ2ZpdmVlaWdodGhzJyxcbiAgICAnc2V2ZW5laWdodGhzJyxcbiAgICAnb25ldGhpcmQnLFxuICAgICd0d290aGlyZHMnLFxuICAgICd6ZXJvc3VwZXJpb3InLFxuICAgICdmb3Vyc3VwZXJpb3InLFxuICAgICdmaXZlc3VwZXJpb3InLFxuICAgICdzaXhzdXBlcmlvcicsXG4gICAgJ3NldmVuc3VwZXJpb3InLFxuICAgICdlaWdodHN1cGVyaW9yJyxcbiAgICAnbmluZXN1cGVyaW9yJyxcbiAgICAnemVyb2luZmVyaW9yJyxcbiAgICAnb25laW5mZXJpb3InLFxuICAgICd0d29pbmZlcmlvcicsXG4gICAgJ3RocmVlaW5mZXJpb3InLFxuICAgICdmb3VyaW5mZXJpb3InLFxuICAgICdmaXZlaW5mZXJpb3InLFxuICAgICdzaXhpbmZlcmlvcicsXG4gICAgJ3NldmVuaW5mZXJpb3InLFxuICAgICdlaWdodGluZmVyaW9yJyxcbiAgICAnbmluZWluZmVyaW9yJyxcbiAgICAnY2VudGluZmVyaW9yJyxcbiAgICAnZG9sbGFyaW5mZXJpb3InLFxuICAgICdwZXJpb2RpbmZlcmlvcicsXG4gICAgJ2NvbW1haW5mZXJpb3InLFxuICAgICdBZ3JhdmVzbWFsbCcsXG4gICAgJ0FhY3V0ZXNtYWxsJyxcbiAgICAnQWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ0F0aWxkZXNtYWxsJyxcbiAgICAnQWRpZXJlc2lzc21hbGwnLFxuICAgICdBcmluZ3NtYWxsJyxcbiAgICAnQUVzbWFsbCcsXG4gICAgJ0NjZWRpbGxhc21hbGwnLFxuICAgICdFZ3JhdmVzbWFsbCcsXG4gICAgJ0VhY3V0ZXNtYWxsJyxcbiAgICAnRWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ0VkaWVyZXNpc3NtYWxsJyxcbiAgICAnSWdyYXZlc21hbGwnLFxuICAgICdJYWN1dGVzbWFsbCcsXG4gICAgJ0ljaXJjdW1mbGV4c21hbGwnLFxuICAgICdJZGllcmVzaXNzbWFsbCcsXG4gICAgJ0V0aHNtYWxsJyxcbiAgICAnTnRpbGRlc21hbGwnLFxuICAgICdPZ3JhdmVzbWFsbCcsXG4gICAgJ09hY3V0ZXNtYWxsJyxcbiAgICAnT2NpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ090aWxkZXNtYWxsJyxcbiAgICAnT2RpZXJlc2lzc21hbGwnLFxuICAgICdPRXNtYWxsJyxcbiAgICAnT3NsYXNoc21hbGwnLFxuICAgICdVZ3JhdmVzbWFsbCcsXG4gICAgJ1VhY3V0ZXNtYWxsJyxcbiAgICAnVWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ1VkaWVyZXNpc3NtYWxsJyxcbiAgICAnWWFjdXRlc21hbGwnLFxuICAgICdUaG9ybnNtYWxsJyxcbiAgICAnWWRpZXJlc2lzc21hbGwnLFxuICAgICcwMDEuMDAwJyxcbiAgICAnMDAxLjAwMScsXG4gICAgJzAwMS4wMDInLFxuICAgICcwMDEuMDAzJyxcbiAgICAnQmxhY2snLFxuICAgICdCb2xkJyxcbiAgICAnQm9vaycsXG4gICAgJ0xpZ2h0JyxcbiAgICAnTWVkaXVtJyxcbiAgICAnUmVndWxhcicsXG4gICAgJ1JvbWFuJyxcbiAgICAnU2VtaWJvbGQnIF07XG5cbnZhciBjZmZTdGFuZGFyZEVuY29kaW5nID0gW1xuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdzcGFjZScsXG4gICAgJ2V4Y2xhbScsXG4gICAgJ3F1b3RlZGJsJyxcbiAgICAnbnVtYmVyc2lnbicsXG4gICAgJ2RvbGxhcicsXG4gICAgJ3BlcmNlbnQnLFxuICAgICdhbXBlcnNhbmQnLFxuICAgICdxdW90ZXJpZ2h0JyxcbiAgICAncGFyZW5sZWZ0JyxcbiAgICAncGFyZW5yaWdodCcsXG4gICAgJ2FzdGVyaXNrJyxcbiAgICAncGx1cycsXG4gICAgJ2NvbW1hJyxcbiAgICAnaHlwaGVuJyxcbiAgICAncGVyaW9kJyxcbiAgICAnc2xhc2gnLFxuICAgICd6ZXJvJyxcbiAgICAnb25lJyxcbiAgICAndHdvJyxcbiAgICAndGhyZWUnLFxuICAgICdmb3VyJyxcbiAgICAnZml2ZScsXG4gICAgJ3NpeCcsXG4gICAgJ3NldmVuJyxcbiAgICAnZWlnaHQnLFxuICAgICduaW5lJyxcbiAgICAnY29sb24nLFxuICAgICdzZW1pY29sb24nLFxuICAgICdsZXNzJyxcbiAgICAnZXF1YWwnLFxuICAgICdncmVhdGVyJyxcbiAgICAncXVlc3Rpb24nLFxuICAgICdhdCcsXG4gICAgJ0EnLFxuICAgICdCJyxcbiAgICAnQycsXG4gICAgJ0QnLFxuICAgICdFJyxcbiAgICAnRicsXG4gICAgJ0cnLFxuICAgICdIJyxcbiAgICAnSScsXG4gICAgJ0onLFxuICAgICdLJyxcbiAgICAnTCcsXG4gICAgJ00nLFxuICAgICdOJyxcbiAgICAnTycsXG4gICAgJ1AnLFxuICAgICdRJyxcbiAgICAnUicsXG4gICAgJ1MnLFxuICAgICdUJyxcbiAgICAnVScsXG4gICAgJ1YnLFxuICAgICdXJyxcbiAgICAnWCcsXG4gICAgJ1knLFxuICAgICdaJyxcbiAgICAnYnJhY2tldGxlZnQnLFxuICAgICdiYWNrc2xhc2gnLFxuICAgICdicmFja2V0cmlnaHQnLFxuICAgICdhc2NpaWNpcmN1bScsXG4gICAgJ3VuZGVyc2NvcmUnLFxuICAgICdxdW90ZWxlZnQnLFxuICAgICdhJyxcbiAgICAnYicsXG4gICAgJ2MnLFxuICAgICdkJyxcbiAgICAnZScsXG4gICAgJ2YnLFxuICAgICdnJyxcbiAgICAnaCcsXG4gICAgJ2knLFxuICAgICdqJyxcbiAgICAnaycsXG4gICAgJ2wnLFxuICAgICdtJyxcbiAgICAnbicsXG4gICAgJ28nLFxuICAgICdwJyxcbiAgICAncScsXG4gICAgJ3InLFxuICAgICdzJyxcbiAgICAndCcsXG4gICAgJ3UnLFxuICAgICd2JyxcbiAgICAndycsXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAneicsXG4gICAgJ2JyYWNlbGVmdCcsXG4gICAgJ2JhcicsXG4gICAgJ2JyYWNlcmlnaHQnLFxuICAgICdhc2NpaXRpbGRlJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnZXhjbGFtZG93bicsXG4gICAgJ2NlbnQnLFxuICAgICdzdGVybGluZycsXG4gICAgJ2ZyYWN0aW9uJyxcbiAgICAneWVuJyxcbiAgICAnZmxvcmluJyxcbiAgICAnc2VjdGlvbicsXG4gICAgJ2N1cnJlbmN5JyxcbiAgICAncXVvdGVzaW5nbGUnLFxuICAgICdxdW90ZWRibGxlZnQnLFxuICAgICdndWlsbGVtb3RsZWZ0JyxcbiAgICAnZ3VpbHNpbmdsbGVmdCcsXG4gICAgJ2d1aWxzaW5nbHJpZ2h0JyxcbiAgICAnZmknLFxuICAgICdmbCcsXG4gICAgJycsXG4gICAgJ2VuZGFzaCcsXG4gICAgJ2RhZ2dlcicsXG4gICAgJ2RhZ2dlcmRibCcsXG4gICAgJ3BlcmlvZGNlbnRlcmVkJyxcbiAgICAnJyxcbiAgICAncGFyYWdyYXBoJyxcbiAgICAnYnVsbGV0JyxcbiAgICAncXVvdGVzaW5nbGJhc2UnLFxuICAgICdxdW90ZWRibGJhc2UnLFxuICAgICdxdW90ZWRibHJpZ2h0JyxcbiAgICAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICdlbGxpcHNpcycsXG4gICAgJ3BlcnRob3VzYW5kJyxcbiAgICAnJyxcbiAgICAncXVlc3Rpb25kb3duJyxcbiAgICAnJyxcbiAgICAnZ3JhdmUnLFxuICAgICdhY3V0ZScsXG4gICAgJ2NpcmN1bWZsZXgnLFxuICAgICd0aWxkZScsXG4gICAgJ21hY3JvbicsXG4gICAgJ2JyZXZlJyxcbiAgICAnZG90YWNjZW50JyxcbiAgICAnZGllcmVzaXMnLFxuICAgICcnLFxuICAgICdyaW5nJyxcbiAgICAnY2VkaWxsYScsXG4gICAgJycsXG4gICAgJ2h1bmdhcnVtbGF1dCcsXG4gICAgJ29nb25laycsXG4gICAgJ2Nhcm9uJyxcbiAgICAnZW1kYXNoJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnQUUnLFxuICAgICcnLFxuICAgICdvcmRmZW1pbmluZScsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ0xzbGFzaCcsXG4gICAgJ09zbGFzaCcsXG4gICAgJ09FJyxcbiAgICAnb3JkbWFzY3VsaW5lJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnYWUnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdkb3RsZXNzaScsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ2xzbGFzaCcsXG4gICAgJ29zbGFzaCcsXG4gICAgJ29lJyxcbiAgICAnZ2VybWFuZGJscycgXTtcblxudmFyIGNmZkV4cGVydEVuY29kaW5nID0gW1xuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdzcGFjZScsXG4gICAgJ2V4Y2xhbXNtYWxsJyxcbiAgICAnSHVuZ2FydW1sYXV0c21hbGwnLFxuICAgICcnLFxuICAgICdkb2xsYXJvbGRzdHlsZScsXG4gICAgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLFxuICAgICdBY3V0ZXNtYWxsJyxcbiAgICAncGFyZW5sZWZ0c3VwZXJpb3InLFxuICAgICdwYXJlbnJpZ2h0c3VwZXJpb3InLFxuICAgICd0d29kb3RlbmxlYWRlcicsXG4gICAgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnY29tbWEnLFxuICAgICdoeXBoZW4nLFxuICAgICdwZXJpb2QnLFxuICAgICdmcmFjdGlvbicsXG4gICAgJ3plcm9vbGRzdHlsZScsXG4gICAgJ29uZW9sZHN0eWxlJyxcbiAgICAndHdvb2xkc3R5bGUnLFxuICAgICd0aHJlZW9sZHN0eWxlJyxcbiAgICAnZm91cm9sZHN0eWxlJyxcbiAgICAnZml2ZW9sZHN0eWxlJyxcbiAgICAnc2l4b2xkc3R5bGUnLFxuICAgICdzZXZlbm9sZHN0eWxlJyxcbiAgICAnZWlnaHRvbGRzdHlsZScsXG4gICAgJ25pbmVvbGRzdHlsZScsXG4gICAgJ2NvbG9uJyxcbiAgICAnc2VtaWNvbG9uJyxcbiAgICAnY29tbWFzdXBlcmlvcicsXG4gICAgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLFxuICAgICdwZXJpb2RzdXBlcmlvcicsXG4gICAgJ3F1ZXN0aW9uc21hbGwnLFxuICAgICcnLFxuICAgICdhc3VwZXJpb3InLFxuICAgICdic3VwZXJpb3InLFxuICAgICdjZW50c3VwZXJpb3InLFxuICAgICdkc3VwZXJpb3InLFxuICAgICdlc3VwZXJpb3InLFxuICAgICcnLFxuICAgICcnLFxuICAgICdpc3VwZXJpb3InLFxuICAgICcnLFxuICAgICcnLFxuICAgICdsc3VwZXJpb3InLFxuICAgICdtc3VwZXJpb3InLFxuICAgICduc3VwZXJpb3InLFxuICAgICdvc3VwZXJpb3InLFxuICAgICcnLFxuICAgICcnLFxuICAgICdyc3VwZXJpb3InLFxuICAgICdzc3VwZXJpb3InLFxuICAgICd0c3VwZXJpb3InLFxuICAgICcnLFxuICAgICdmZicsXG4gICAgJ2ZpJyxcbiAgICAnZmwnLFxuICAgICdmZmknLFxuICAgICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsXG4gICAgJycsXG4gICAgJ3BhcmVucmlnaHRpbmZlcmlvcicsXG4gICAgJ0NpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ2h5cGhlbnN1cGVyaW9yJyxcbiAgICAnR3JhdmVzbWFsbCcsXG4gICAgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsXG4gICAgJ0NzbWFsbCcsXG4gICAgJ0RzbWFsbCcsXG4gICAgJ0VzbWFsbCcsXG4gICAgJ0ZzbWFsbCcsXG4gICAgJ0dzbWFsbCcsXG4gICAgJ0hzbWFsbCcsXG4gICAgJ0lzbWFsbCcsXG4gICAgJ0pzbWFsbCcsXG4gICAgJ0tzbWFsbCcsXG4gICAgJ0xzbWFsbCcsXG4gICAgJ01zbWFsbCcsXG4gICAgJ05zbWFsbCcsXG4gICAgJ09zbWFsbCcsXG4gICAgJ1BzbWFsbCcsXG4gICAgJ1FzbWFsbCcsXG4gICAgJ1JzbWFsbCcsXG4gICAgJ1NzbWFsbCcsXG4gICAgJ1RzbWFsbCcsXG4gICAgJ1VzbWFsbCcsXG4gICAgJ1ZzbWFsbCcsXG4gICAgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsXG4gICAgJ1lzbWFsbCcsXG4gICAgJ1pzbWFsbCcsXG4gICAgJ2NvbG9ubW9uZXRhcnknLFxuICAgICdvbmVmaXR0ZWQnLFxuICAgICdydXBpYWgnLFxuICAgICdUaWxkZXNtYWxsJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAnY2VudG9sZHN0eWxlJyxcbiAgICAnTHNsYXNoc21hbGwnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdTY2Fyb25zbWFsbCcsXG4gICAgJ1pjYXJvbnNtYWxsJyxcbiAgICAnRGllcmVzaXNzbWFsbCcsXG4gICAgJ0JyZXZlc21hbGwnLFxuICAgICdDYXJvbnNtYWxsJyxcbiAgICAnJyxcbiAgICAnRG90YWNjZW50c21hbGwnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdNYWNyb25zbWFsbCcsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ2ZpZ3VyZWRhc2gnLFxuICAgICdoeXBoZW5pbmZlcmlvcicsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ09nb25la3NtYWxsJyxcbiAgICAnUmluZ3NtYWxsJyxcbiAgICAnQ2VkaWxsYXNtYWxsJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnb25lcXVhcnRlcicsXG4gICAgJ29uZWhhbGYnLFxuICAgICd0aHJlZXF1YXJ0ZXJzJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLFxuICAgICdvbmVlaWdodGgnLFxuICAgICd0aHJlZWVpZ2h0aHMnLFxuICAgICdmaXZlZWlnaHRocycsXG4gICAgJ3NldmVuZWlnaHRocycsXG4gICAgJ29uZXRoaXJkJyxcbiAgICAndHdvdGhpcmRzJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnemVyb3N1cGVyaW9yJyxcbiAgICAnb25lc3VwZXJpb3InLFxuICAgICd0d29zdXBlcmlvcicsXG4gICAgJ3RocmVlc3VwZXJpb3InLFxuICAgICdmb3Vyc3VwZXJpb3InLFxuICAgICdmaXZlc3VwZXJpb3InLFxuICAgICdzaXhzdXBlcmlvcicsXG4gICAgJ3NldmVuc3VwZXJpb3InLFxuICAgICdlaWdodHN1cGVyaW9yJyxcbiAgICAnbmluZXN1cGVyaW9yJyxcbiAgICAnemVyb2luZmVyaW9yJyxcbiAgICAnb25laW5mZXJpb3InLFxuICAgICd0d29pbmZlcmlvcicsXG4gICAgJ3RocmVlaW5mZXJpb3InLFxuICAgICdmb3VyaW5mZXJpb3InLFxuICAgICdmaXZlaW5mZXJpb3InLFxuICAgICdzaXhpbmZlcmlvcicsXG4gICAgJ3NldmVuaW5mZXJpb3InLFxuICAgICdlaWdodGluZmVyaW9yJyxcbiAgICAnbmluZWluZmVyaW9yJyxcbiAgICAnY2VudGluZmVyaW9yJyxcbiAgICAnZG9sbGFyaW5mZXJpb3InLFxuICAgICdwZXJpb2RpbmZlcmlvcicsXG4gICAgJ2NvbW1haW5mZXJpb3InLFxuICAgICdBZ3JhdmVzbWFsbCcsXG4gICAgJ0FhY3V0ZXNtYWxsJyxcbiAgICAnQWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ0F0aWxkZXNtYWxsJyxcbiAgICAnQWRpZXJlc2lzc21hbGwnLFxuICAgICdBcmluZ3NtYWxsJyxcbiAgICAnQUVzbWFsbCcsXG4gICAgJ0NjZWRpbGxhc21hbGwnLFxuICAgICdFZ3JhdmVzbWFsbCcsXG4gICAgJ0VhY3V0ZXNtYWxsJyxcbiAgICAnRWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ0VkaWVyZXNpc3NtYWxsJyxcbiAgICAnSWdyYXZlc21hbGwnLFxuICAgICdJYWN1dGVzbWFsbCcsXG4gICAgJ0ljaXJjdW1mbGV4c21hbGwnLFxuICAgICdJZGllcmVzaXNzbWFsbCcsXG4gICAgJ0V0aHNtYWxsJyxcbiAgICAnTnRpbGRlc21hbGwnLFxuICAgICdPZ3JhdmVzbWFsbCcsXG4gICAgJ09hY3V0ZXNtYWxsJyxcbiAgICAnT2NpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ090aWxkZXNtYWxsJyxcbiAgICAnT2RpZXJlc2lzc21hbGwnLFxuICAgICdPRXNtYWxsJyxcbiAgICAnT3NsYXNoc21hbGwnLFxuICAgICdVZ3JhdmVzbWFsbCcsXG4gICAgJ1VhY3V0ZXNtYWxsJyxcbiAgICAnVWNpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ1VkaWVyZXNpc3NtYWxsJyxcbiAgICAnWWFjdXRlc21hbGwnLFxuICAgICdUaG9ybnNtYWxsJyxcbiAgICAnWWRpZXJlc2lzc21hbGwnIF07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZW5jb2RpbmcgdXNlZCBmb3IgZm9udHMgY3JlYXRlZCBmcm9tIHNjcmF0Y2guXG4gKiBJdCBsb29wcyB0aHJvdWdoIGFsbCBnbHlwaHMgYW5kIGZpbmRzIHRoZSBhcHByb3ByaWF0ZSB1bmljb2RlIHZhbHVlLlxuICogU2luY2UgaXQncyBsaW5lYXIgdGltZSwgb3RoZXIgZW5jb2RpbmdzIHdpbGwgYmUgZmFzdGVyLlxuICogQGV4cG9ydHMgb3BlbnR5cGUuRGVmYXVsdEVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBEZWZhdWx0RW5jb2RpbmcoZm9udCkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG59XG5cbkRlZmF1bHRFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIGNvZGUgPSBjLmNvZGVQb2ludEF0KDApO1xuICAgIHZhciBnbHlwaHMgPSB0aGlzLmZvbnQuZ2x5cGhzO1xuICAgIGlmIChnbHlwaHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoLnVuaWNvZGVzW2pdID09PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ21hcEVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGNtYXAgLSBhIG9iamVjdCB3aXRoIHRoZSBjbWFwIGVuY29kZWQgZGF0YVxuICovXG5mdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgIHRoaXMuY21hcCA9IGNtYXA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBjIC0gdGhlIGNoYXJhY3RlclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ2x5cGggaW5kZXguXG4gKi9cbkNtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIHRoaXMuY21hcC5nbHlwaEluZGV4TWFwW2MuY29kZVBvaW50QXQoMCldIHx8IDA7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkNmZkVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIC0gVGhlIGVuY29kaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBjaGFyc2V0IC0gVGhlIGNoYXJhY3RlciBzZXQuXG4gKi9cbmZ1bmN0aW9uIENmZkVuY29kaW5nKGVuY29kaW5nLCBjaGFyc2V0KSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIHRoaXMuY2hhcnNldCA9IGNoYXJzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBzIC0gVGhlIGNoYXJhY3RlclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXguXG4gKi9cbkNmZkVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgY29kZSA9IHMuY29kZVBvaW50QXQoMCk7XG4gICAgdmFyIGNoYXJOYW1lID0gdGhpcy5lbmNvZGluZ1tjb2RlXTtcbiAgICByZXR1cm4gdGhpcy5jaGFyc2V0LmluZGV4T2YoY2hhck5hbWUpO1xufTtcblxuZnVuY3Rpb24gYWRkR2x5cGhOYW1lc0FsbChmb250KSB7XG4gICAgdmFyIGdseXBoO1xuICAgIHZhciBnbHlwaEluZGV4TWFwID0gZm9udC50YWJsZXMuY21hcC5nbHlwaEluZGV4TWFwO1xuICAgIHZhciBjaGFyQ29kZXMgPSBPYmplY3Qua2V5cyhnbHlwaEluZGV4TWFwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gY2hhckNvZGVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGdseXBoSW5kZXhNYXBbY107XG4gICAgICAgIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuICAgICAgICBnbHlwaC5hZGRVbmljb2RlKHBhcnNlSW50KGMpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXNUb1VuaWNvZGVNYXAoZm9udCkge1xuICAgIGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwID0ge307XG5cbiAgICB2YXIgZ2x5cGhJbmRleE1hcCA9IGZvbnQudGFibGVzLmNtYXAuZ2x5cGhJbmRleE1hcDtcbiAgICB2YXIgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IGNoYXJDb2Rlc1tpXTtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuICAgICAgICBpZiAoZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgdW5pY29kZXM6IFtwYXJzZUludChjKV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0udW5pY29kZXMucHVzaChwYXJzZUludChjKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGFsaWFzIG9wZW50eXBlLmFkZEdseXBoTmFtZXNcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBhZGRHbHlwaE5hbWVzKGZvbnQsIG9wdCkge1xuICAgIGlmIChvcHQubG93TWVtb3J5KSB7XG4gICAgICAgIGFkZEdseXBoTmFtZXNUb1VuaWNvZGVNYXAoZm9udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWRkR2x5cGhOYW1lc0FsbChmb250KTtcbiAgICB9XG59XG5cbi8vIFJ1bi10aW1lIGNoZWNraW5nIG9mIHByZWNvbmRpdGlvbnMuXG5cbmZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLy8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBwcmVkaWNhdGUgaXMgdHJ1ZS5cbi8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbmZ1bmN0aW9uIGFyZ3VtZW50KHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgIGZhaWwobWVzc2FnZSk7XG4gICAgfVxufVxudmFyIGNoZWNrID0geyBmYWlsOiBmYWlsLCBhcmd1bWVudDogYXJndW1lbnQsIGFzc2VydDogYXJndW1lbnQgfTtcblxuLy8gVGhlIEdseXBoIG9iamVjdFxuLy8gaW1wb3J0IGdseWYgZnJvbSAnLi90YWJsZXMvZ2x5ZicgQ2FuJ3QgYmUgaW1wb3J0ZWQgaGVyZSwgYmVjYXVzZSBpdCdzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuXG5mdW5jdGlvbiBnZXRQYXRoRGVmaW5pdGlvbihnbHlwaCwgcGF0aCkge1xuICAgIHZhciBfcGF0aCA9IHBhdGggfHwgbmV3IFBhdGgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF9wYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgX3BhdGggPSBfcGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX3BhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgX3BhdGggPSBwO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEB0eXBlZGVmIEdseXBoT3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIC0gVGhlIGdseXBoIG5hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdW5pY29kZV1cbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt1bmljb2Rlc11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeE1pbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeU1pbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeE1heF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeU1heF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYWR2YW5jZVdpZHRoXVxuICovXG5cbi8vIEEgR2x5cGggaXMgYW4gaW5kaXZpZHVhbCBtYXJrIHRoYXQgb2Z0ZW4gY29ycmVzcG9uZHMgdG8gYSBjaGFyYWN0ZXIuXG4vLyBTb21lIGdseXBocywgc3VjaCBhcyBsaWdhdHVyZXMsIGFyZSBhIGNvbWJpbmF0aW9uIG9mIG1hbnkgY2hhcmFjdGVycy5cbi8vIEdseXBocyBhcmUgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrcyBvZiBhIGZvbnQuXG4vL1xuLy8gVGhlIGBHbHlwaGAgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBkcmF3aW5nIHRoZSBwYXRoIGFuZCBpdHMgcG9pbnRzLlxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0dseXBoT3B0aW9uc31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBHbHlwaChvcHRpb25zKSB7XG4gICAgLy8gQnkgcHV0dGluZyBhbGwgdGhlIGNvZGUgb24gYSBwcm90b3R5cGUgZnVuY3Rpb24gKHdoaWNoIGlzIG9ubHkgZGVjbGFyZWQgb25jZSlcbiAgICAvLyB3ZSByZWR1Y2UgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIGxhcmdlciBmb250cyBieSBzb21lIDIlXG4gICAgdGhpcy5iaW5kQ29uc3RydWN0b3JWYWx1ZXMob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtICB7R2x5cGhPcHRpb25zfVxuICovXG5HbHlwaC5wcm90b3R5cGUuYmluZENvbnN0cnVjdG9yVmFsdWVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuXG4gICAgLy8gVGhlc2UgdGhyZWUgdmFsdWVzIGNhbm5vdCBiZSBkZWZlcnJlZCBmb3IgbWVtb3J5IG9wdGltaXphdGlvbjpcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLnVuaWNvZGUgPSBvcHRpb25zLnVuaWNvZGUgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMudW5pY29kZXMgPVxuICAgICAgICBvcHRpb25zLnVuaWNvZGVzIHx8IG9wdGlvbnMudW5pY29kZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IFtvcHRpb25zLnVuaWNvZGVdXG4gICAgICAgICAgICA6IFtdO1xuXG4gICAgLy8gQnV0IGJ5IGJpbmRpbmcgdGhlc2UgdmFsdWVzIG9ubHkgd2hlbiBuZWNlc3NhcnksIHdlIHJlZHVjZSBjYW5cbiAgICAvLyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBieSBhbG1vc3QgMyUgZm9yIGxhcmdlciBmb250cy5cbiAgICBpZiAoJ3hNaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy54TWluID0gb3B0aW9ucy54TWluO1xuICAgIH1cblxuICAgIGlmICgneU1pbicgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnlNaW4gPSBvcHRpb25zLnlNaW47XG4gICAgfVxuXG4gICAgaWYgKCd4TWF4JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMueE1heCA9IG9wdGlvbnMueE1heDtcbiAgICB9XG5cbiAgICBpZiAoJ3lNYXgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy55TWF4ID0gb3B0aW9ucy55TWF4O1xuICAgIH1cblxuICAgIGlmICgnYWR2YW5jZVdpZHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZVdpZHRoID0gb3B0aW9ucy5hZHZhbmNlV2lkdGg7XG4gICAgfVxuXG4gICAgLy8gVGhlIHBhdGggZm9yIGEgZ2x5cGggaXMgdGhlIG1vc3QgbWVtb3J5IGludGVuc2l2ZSwgYW5kIGlzIGJvdW5kIGFzIGEgdmFsdWVcbiAgICAvLyB3aXRoIGEgZ2V0dGVyL3NldHRlciB0byBlbnN1cmUgd2UgYWN0dWFsbHkgZG8gcGF0aCBwYXJzaW5nIG9ubHkgb25jZSB0aGVcbiAgICAvLyBwYXRoIGlzIGFjdHVhbGx5IG5lZWRlZCBieSBhbnl0aGluZy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BhdGgnLCBnZXRQYXRoRGVmaW5pdGlvbih0aGlzLCBvcHRpb25zLnBhdGgpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5hZGRVbmljb2RlID0gZnVuY3Rpb24gKHVuaWNvZGUpIHtcbiAgICBpZiAodGhpcy51bmljb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy51bmljb2RlID0gdW5pY29kZTtcbiAgICB9XG5cbiAgICB0aGlzLnVuaWNvZGVzLnB1c2godW5pY29kZSk7XG59O1xuXG4vLyAvKipcbi8vICAqIENhbGN1bGF0ZSB0aGUgbWluaW11bSBib3VuZGluZyBib3ggZm9yIHRoaXMgZ2x5cGguXG4vLyAgKiBAcmV0dXJuIHtvcGVudHlwZS5Cb3VuZGluZ0JveH1cbi8vICAqL1xuLy8gR2x5cGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4vLyAgICAgcmV0dXJuIHRoaXMucGF0aC5nZXRCb3VuZGluZ0JveCgpO1xuLy8gfTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnbHlwaCB0byBhIFBhdGggd2UgY2FuIGRyYXcgb24gYSBkcmF3aW5nIGNvbnRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGlmIGhpbnRpbmcgaXMgdG8gYmUgdXNlZCwgdGhlIGZvbnRcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGh9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmb250KSB7XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIHZhciBjb21tYW5kcztcbiAgICB2YXIgaFBvaW50cztcbiAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHhTY2FsZSA9IG9wdGlvbnMueFNjYWxlO1xuICAgIHZhciB5U2NhbGUgPSBvcHRpb25zLnlTY2FsZTtcblxuICAgIGlmIChvcHRpb25zLmhpbnRpbmcgJiYgZm9udCAmJiBmb250LmhpbnRpbmcpIHtcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBoaW50aW5nLCB0aGUgaGludGluZyBlbmdpbmUgdGFrZXMgY2FyZVxuICAgICAgICAvLyBvZiBzY2FsaW5nIHRoZSBwb2ludHMgKG5vdCB0aGUgcGF0aCkgYmVmb3JlIGhpbnRpbmcuXG4gICAgICAgIGhQb2ludHMgPSB0aGlzLnBhdGggJiYgZm9udC5oaW50aW5nLmV4ZWModGhpcywgZm9udFNpemUpO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBoaW50aW5nIGVuZ2luZSBmYWlsZWQgaFBvaW50cyBpcyB1bmRlZmluZWRcbiAgICAgICAgLy8gYW5kIHRodXMgcmV2ZXJ0cyB0byBwbGFpbiByZW5kaW5nXG4gICAgfVxuXG4gICAgaWYgKGhQb2ludHMpIHtcbiAgICAgICAgLy8gQ2FsbCBmb250LmhpbnRpbmcuZ2V0Q29tbWFuZHMgaW5zdGVhZCBvZiBgZ2x5Zi5nZXRQYXRoKGhQb2ludHMpLmNvbW1hbmRzYCB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICAgICAgY29tbWFuZHMgPSBmb250LmhpbnRpbmcuZ2V0Q29tbWFuZHMoaFBvaW50cyk7XG4gICAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgLy8gVE9ETyBpbiBjYXNlIG9mIGhpbnRpbmcgeHlTY2FsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgICAgIHhTY2FsZSA9IHlTY2FsZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgICAgIHZhciBzY2FsZSA9ICgxIC8gKHRoaXMucGF0aC51bml0c1BlckVtIHx8IDEwMDApKSAqIGZvbnRTaXplO1xuICAgICAgICBpZiAoeFNjYWxlID09PSB1bmRlZmluZWQpIHsgeFNjYWxlID0gc2NhbGU7IH1cbiAgICAgICAgaWYgKHlTY2FsZSA9PT0gdW5kZWZpbmVkKSB7IHlTY2FsZSA9IHNjYWxlOyB9XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgcC5tb3ZlVG8oeCArIGNtZC54ICogeFNjYWxlLCB5ICsgLWNtZC55ICogeVNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBwLmxpbmVUbyh4ICsgY21kLnggKiB4U2NhbGUsIHkgKyAtY21kLnkgKiB5U2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgY21kLngxICogeFNjYWxlLFxuICAgICAgICAgICAgICAgIHkgKyAtY21kLnkxICogeVNjYWxlLFxuICAgICAgICAgICAgICAgIHggKyBjbWQueCAqIHhTY2FsZSxcbiAgICAgICAgICAgICAgICB5ICsgLWNtZC55ICogeVNjYWxlXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHAuY3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgY21kLngxICogeFNjYWxlLFxuICAgICAgICAgICAgICAgIHkgKyAtY21kLnkxICogeVNjYWxlLFxuICAgICAgICAgICAgICAgIHggKyBjbWQueDIgKiB4U2NhbGUsXG4gICAgICAgICAgICAgICAgeSArIC1jbWQueTIgKiB5U2NhbGUsXG4gICAgICAgICAgICAgICAgeCArIGNtZC54ICogeFNjYWxlLFxuICAgICAgICAgICAgICAgIHkgKyAtY21kLnkgKiB5U2NhbGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgZ2x5cGggaW50byBjb250b3Vycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB0b1xuICogcHJvdmlkZSByYXcgYWNjZXNzIHRvIHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lcy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0Q29udG91cnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBjb250b3VycyA9IFtdO1xuICAgIHZhciBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgY3VycmVudENvbnRvdXIubGVuZ3RoID09PSAwLFxuICAgICAgICAnVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuJ1xuICAgICk7XG4gICAgcmV0dXJuIGNvbnRvdXJzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHhNaW4veU1pbi94TWF4L3lNYXgvbHNiL3JzYiBmb3IgYSBHbHlwaC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmdldE1ldHJpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgIHZhciB4Q29vcmRzID0gW107XG4gICAgdmFyIHlDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlICE9PSAnWicpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueCk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScgfHwgY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1ldHJpY3MgPSB7XG4gICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IHRoaXMubGVmdFNpZGVCZWFyaW5nLFxuICAgIH07XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1pbikpIHtcbiAgICAgICAgbWV0cmljcy54TWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1heCkpIHtcbiAgICAgICAgbWV0cmljcy54TWF4ID0gdGhpcy5hZHZhbmNlV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNaW4pKSB7XG4gICAgICAgIG1ldHJpY3MueU1pbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNYXgpKSB7XG4gICAgICAgIG1ldHJpY3MueU1heCA9IDA7XG4gICAgfVxuXG4gICAgbWV0cmljcy5yaWdodFNpZGVCZWFyaW5nID1cbiAgICAgICAgdGhpcy5hZHZhbmNlV2lkdGggLVxuICAgICAgICBtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyAtXG4gICAgICAgIChtZXRyaWNzLnhNYXggLSBtZXRyaWNzLnhNaW4pO1xuICAgIHJldHVybiBtZXRyaWNzO1xufTtcblxuLy8gVGhlIEdseXBoU2V0IG9iamVjdFxuXG4vLyBEZWZpbmUgYSBwcm9wZXJ0eSBvbiB0aGUgZ2x5cGggdGhhdCBkZXBlbmRzIG9uIHRoZSBwYXRoIGJlaW5nIGxvYWRlZC5cbmZ1bmN0aW9uIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmVxdWVzdCB0aGUgcGF0aCBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhlIHBhdGggaXMgbG9hZGVkLlxuICAgICAgICAgICAgZ2x5cGgucGF0aDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICByZXR1cm4gZ2x5cGhbaW50ZXJuYWxOYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGdseXBoW2ludGVybmFsTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEEgR2x5cGhTZXQgcmVwcmVzZW50cyBhbGwgZ2x5cGhzIGF2YWlsYWJsZSBpbiB0aGUgZm9udCwgYnV0IG1vZGVsbGVkIHVzaW5nXG4gKiBhIGRlZmVycmVkIGdseXBoIGxvYWRlciwgZm9yIHJldHJpZXZpbmcgZ2x5cGhzIG9ubHkgb25jZSB0aGV5IGFyZSBhYnNvbHV0ZWx5XG4gKiBuZWNlc3NhcnksIHRvIGtlZXAgdGhlIG1lbW9yeSBmb290cHJpbnQgZG93bi5cbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoU2V0XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBwYXJhbSB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIEdseXBoU2V0KGZvbnQsIGdseXBocykge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy5nbHlwaHMgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShnbHlwaHMpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgICAgICBnbHlwaC5wYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tpXSA9IGdseXBoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSAoZ2x5cGhzICYmIGdseXBocy5sZW5ndGgpIHx8IDA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbkdseXBoU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAvLyB0aGlzLmdseXBoc1tpbmRleF0gaXMgJ3VuZGVmaW5lZCcgd2hlbiBsb3cgbWVtb3J5IG1vZGUgaXMgb24uIGdseXBoIGlzIHB1c2hlZCBvbiByZXF1ZXN0IG9ubHkuXG4gICAgaWYgKHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZm9udC5fcHVzaChpbmRleCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0gPSB0aGlzLmdseXBoc1tpbmRleF0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzW2luZGV4XTtcbiAgICAgICAgdmFyIHVuaWNvZGVPYmogPSB0aGlzLmZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2luZGV4XTtcblxuICAgICAgICBpZiAodW5pY29kZU9iaikge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB1bmljb2RlT2JqLnVuaWNvZGVzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIHsgZ2x5cGguYWRkVW5pY29kZSh1bmljb2RlT2JqLnVuaWNvZGVzW2pdKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdLmFkdmFuY2VXaWR0aCA9XG4gICAgICAgICAgICB0aGlzLmZvbnQuX2htdHhUYWJsZURhdGFbaW5kZXhdLmFkdmFuY2VXaWR0aDtcbiAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdLmxlZnRTaWRlQmVhcmluZyA9XG4gICAgICAgICAgICB0aGlzLmZvbnQuX2htdHhUYWJsZURhdGFbaW5kZXhdLmxlZnRTaWRlQmVhcmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdID0gdGhpcy5nbHlwaHNbaW5kZXhdKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbHlwaHNbaW5kZXhdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtPYmplY3R9XG4gKi9cbkdseXBoU2V0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGluZGV4LCBsb2FkZXIpIHtcbiAgICB0aGlzLmdseXBoc1tpbmRleF0gPSBsb2FkZXI7XG4gICAgdGhpcy5sZW5ndGgrKztcbn07XG5cbi8qKlxuICogQGFsaWFzIG9wZW50eXBlLmdseXBoTG9hZGVyXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuZnVuY3Rpb24gZ2x5cGhMb2FkZXIoZm9udCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IEdseXBoKHsgaW5kZXg6IGluZGV4LCBmb250OiBmb250IH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3R1YiBnbHlwaCB0aGF0IGNhbiBiZSBmaWxsZWQgd2l0aCBhbGwgbWV0YWRhdGEgKmV4Y2VwdCpcbiAqIHRoZSBcInBvaW50c1wiIGFuZCBcInBhdGhcIiBwcm9wZXJ0aWVzLCB3aGljaCBtdXN0IGJlIGxvYWRlZCBvbmx5IG9uY2VcbiAqIHRoZSBnbHlwaCdzIHBhdGggaXMgYWN0dWFsbHkgcmVxdWVzdGVkIGZvciB0ZXh0IHNoYXBpbmcuXG4gKiBAYWxpYXMgb3BlbnR5cGUudHRmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUdseXBoXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBidWlsZFBhdGhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiB0dGZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VHbHlwaCwgZGF0YSwgcG9zaXRpb24sIGJ1aWxkUGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IG5ldyBHbHlwaCh7IGluZGV4OiBpbmRleCwgZm9udDogZm9udCB9KTtcblxuICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBidWlsZFBhdGgoZm9udC5nbHlwaHMsIGdseXBoKTtcbiAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneE1pbicsICdfeE1pbicpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNYXgnLCAnX3hNYXgnKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWluJywgJ195TWluJyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneU1heCcsICdfeU1heCcpO1xuXG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9O1xufVxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuY2ZmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUNGRkNoYXJzdHJpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gY2hhcnN0cmluZ1xuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIGNmZkdseXBoTG9hZGVyKGZvbnQsIGluZGV4LCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2x5cGggPSBuZXcgR2x5cGgoeyBpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnQgfSk7XG5cbiAgICAgICAgZ2x5cGgucGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjaGFyc3RyaW5nKTtcbiAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9O1xufVxuXG52YXIgZ2x5cGhzZXQgPSB7IEdseXBoU2V0OiBHbHlwaFNldCwgZ2x5cGhMb2FkZXI6IGdseXBoTG9hZGVyLCB0dGZHbHlwaExvYWRlcjogdHRmR2x5cGhMb2FkZXIsIGNmZkdseXBoTG9hZGVyOiBjZmZHbHlwaExvYWRlciB9O1xuXG4vLyBUaGUgTGF5b3V0IG9iamVjdCBpcyB0aGUgcHJvdG90eXBlIG9mIFN1YnN0aXR1dGlvbiBvYmplY3RzLCBhbmQgcHJvdmlkZXNcblxuZnVuY3Rpb24gc2VhcmNoVGFnKGFyciwgdGFnKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF0udGFnO1xuICAgICAgICBpZiAodmFsID09PSB0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWlkO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IHRhZykge1xuICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1heCA9IGltaWQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgIHJldHVybiAtaW1pbiAtIDE7XG59XG5cbmZ1bmN0aW9uIGJpblNlYXJjaChhcnIsIHZhbHVlKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF07XG4gICAgICAgIGlmICh2YWwgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1pZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB2YWx1ZSkge1xuICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1heCA9IGltaWQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgIHJldHVybiAtaW1pbiAtIDE7XG59XG5cbi8vIGJpbmFyeSBzZWFyY2ggaW4gYSBsaXN0IG9mIHJhbmdlcyAoY292ZXJhZ2UsIGNsYXNzIGRlZmluaXRpb24pXG5mdW5jdGlvbiBzZWFyY2hSYW5nZShyYW5nZXMsIHZhbHVlKSB7XG4gICAgLy8ganNoaW50IGJpdHdpc2U6IGZhbHNlXG4gICAgdmFyIHJhbmdlO1xuICAgIHZhciBpbWluID0gMDtcbiAgICB2YXIgaW1heCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcbiAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuICAgICAgICByYW5nZSA9IHJhbmdlc1tpbWlkXTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA8IHZhbHVlKSB7XG4gICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWF4ID0gaW1pZCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGltaW4gPiAwKSB7XG4gICAgICAgIHJhbmdlID0gcmFuZ2VzW2ltaW4gLSAxXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmFuZ2UuZW5kKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuTGF5b3V0XG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gTGF5b3V0KGZvbnQsIHRhYmxlTmFtZSkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWU7XG59XG5cbkxheW91dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQmluYXJ5IHNlYXJjaCBhbiBvYmplY3QgYnkgXCJ0YWdcIiBwcm9wZXJ0eVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBzZWFyY2hUYWdcbiAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNlYXJjaFRhZzogc2VhcmNoVGFnLFxuXG4gICAgLyoqXG4gICAgICogQmluYXJ5IHNlYXJjaCBpbiBhIGxpc3Qgb2YgbnVtYmVyc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBiaW5TZWFyY2hcbiAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgYmluU2VhcmNoOiBiaW5TZWFyY2gsXG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIHRoZSBMYXlvdXQgdGFibGUgKEdTVUIsIEdQT1MgZXRjKS5cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjcmVhdGUgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgR1NVQiBvciBHUE9TIHRhYmxlLlxuICAgICAqL1xuICAgIGdldFRhYmxlOiBmdW5jdGlvbiAoY3JlYXRlKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXTtcbiAgICAgICAgaWYgKCFsYXlvdXQgJiYgY3JlYXRlKSB7XG4gICAgICAgICAgICBsYXlvdXQgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVEZWZhdWx0VGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiZXN0IGJldCBmb3IgYSBzY3JpcHQgbmFtZS5cbiAgICAgKiBSZXR1cm5zICdERkxUJyBpZiBpdCBleGlzdHMuXG4gICAgICogSWYgbm90LCByZXR1cm5zICdsYXRuJyBpZiBpdCBleGlzdHMuXG4gICAgICogSWYgbmVpdGhlciBleGlzdCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFNjcmlwdE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoKTtcbiAgICAgICAgaWYgKCFsYXlvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzTGF0biA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dC5zY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGxheW91dC5zY3JpcHRzW2ldLnRhZztcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnREZMVCcpIHsgcmV0dXJuIG5hbWU7IH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbGF0bicpIHsgaGFzTGF0biA9IHRydWU7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzTGF0bikgeyByZXR1cm4gJ2xhdG4nOyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIExhbmdTeXNSZWNvcmRzIGluIHRoZSBnaXZlbiBzY3JpcHQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGlzIHNjcmlwdCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGFnIGFuZCBzY3JpcHQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXRTY3JpcHRUYWJsZTogZnVuY3Rpb24gKHNjcmlwdCwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKGNyZWF0ZSk7XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgIHNjcmlwdCA9IHNjcmlwdCB8fCAnREZMVCc7XG4gICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGxheW91dC5zY3JpcHRzO1xuICAgICAgICAgICAgdmFyIHBvcyA9IHNlYXJjaFRhZyhsYXlvdXQuc2NyaXB0cywgc2NyaXB0KTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRzW3Bvc10uc2NyaXB0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NyID0ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHNjcmlwdCxcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2VydmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY3JpcHRzLnNwbGljZSgtMSAtIHBvcywgMCwgc2NyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyLnNjcmlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGFuZ3VhZ2Ugc3lzdGVtIHRhYmxlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGlzIGxhbmdTeXNUYWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMYW5nU3lzVGFibGU6IGZ1bmN0aW9uIChzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIHNjcmlwdFRhYmxlID0gdGhpcy5nZXRTY3JpcHRUYWJsZShzY3JpcHQsIGNyZWF0ZSk7XG4gICAgICAgIGlmIChzY3JpcHRUYWJsZSkge1xuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZSB8fCBsYW5ndWFnZSA9PT0gJ2RmbHQnIHx8IGxhbmd1YWdlID09PSAnREZMVCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0VGFibGUuZGVmYXVsdExhbmdTeXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG9zID0gc2VhcmNoVGFnKHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHNbcG9zXS5sYW5nU3lzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZ1N5czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLnNwbGljZSgtMSAtIHBvcywgMCwgbGFuZ1N5c1JlY29yZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdTeXNSZWNvcmQubGFuZ1N5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzcGVjaWZpYyBmZWF0dXJlIHRhYmxlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIE9uZSBvZiB0aGUgY29kZXMgbGlzdGVkIGF0IGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZmVhdHVyZWxpc3QuaHRtXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBmZWF0dXJlIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldEZlYXR1cmVUYWJsZTogZnVuY3Rpb24gKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgbGFuZ1N5c1RhYmxlID0gdGhpcy5nZXRMYW5nU3lzVGFibGUoc2NyaXB0LCBsYW5ndWFnZSwgY3JlYXRlKTtcbiAgICAgICAgaWYgKGxhbmdTeXNUYWJsZSkge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmVSZWNvcmQ7XG4gICAgICAgICAgICB2YXIgZmVhdEluZGV4ZXMgPSBsYW5nU3lzVGFibGUuZmVhdHVyZUluZGV4ZXM7XG4gICAgICAgICAgICB2YXIgYWxsRmVhdHVyZXMgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXS5mZWF0dXJlcztcbiAgICAgICAgICAgIC8vIFRoZSBGZWF0dXJlSW5kZXggYXJyYXkgb2YgaW5kaWNlcyBpcyBpbiBhcmJpdHJhcnkgb3JkZXIsXG4gICAgICAgICAgICAvLyBldmVuIGlmIGFsbEZlYXR1cmVzIGlzIHNvcnRlZCBhbHBoYWJldGljYWxseSBieSBmZWF0dXJlIHRhZy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0gYWxsRmVhdHVyZXNbZmVhdEluZGV4ZXNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlUmVjb3JkLnRhZyA9PT0gZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxGZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gQXV0b21hdGljIG9yZGVyaW5nIG9mIGZlYXR1cmVzIHdvdWxkIHJlcXVpcmUgdG8gc2hpZnQgZmVhdHVyZSBpbmRleGVzIGluIHRoZSBzY3JpcHQgbGlzdC5cbiAgICAgICAgICAgICAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID09PSAwIHx8IGZlYXR1cmUgPj0gYWxsRmVhdHVyZXNbaW5kZXggLSAxXS50YWcsXG4gICAgICAgICAgICAgICAgICAgICdGZWF0dXJlcyBtdXN0IGJlIGFkZGVkIGluIGFscGhhYmV0aWNhbCBvcmRlci4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IGZlYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IHsgcGFyYW1zOiAwLCBsb29rdXBMaXN0SW5kZXhlczogW10gfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnB1c2goZmVhdHVyZVJlY29yZCk7XG4gICAgICAgICAgICAgICAgZmVhdEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxvb2t1cCB0YWJsZXMgb2YgYSBnaXZlbiB0eXBlIGZvciBhIHNjcmlwdC9sYW5ndWFnZS9mZWF0dXJlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgY29kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb29rdXBUeXBlIC0gMSB0byA5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBsb29rdXAgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdCwgd2l0aCBubyBzdWJ0YWJsZXMuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0TG9va3VwVGFibGVzOiBmdW5jdGlvbiAoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgbG9va3VwVHlwZSwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBmZWF0dXJlVGFibGUgPSB0aGlzLmdldEZlYXR1cmVUYWJsZShcbiAgICAgICAgICAgIHNjcmlwdCxcbiAgICAgICAgICAgIGxhbmd1YWdlLFxuICAgICAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgICAgIGNyZWF0ZVxuICAgICAgICApO1xuICAgICAgICB2YXIgdGFibGVzID0gW107XG4gICAgICAgIGlmIChmZWF0dXJlVGFibGUpIHtcbiAgICAgICAgICAgIHZhciBsb29rdXBUYWJsZTtcbiAgICAgICAgICAgIHZhciBsb29rdXBMaXN0SW5kZXhlcyA9IGZlYXR1cmVUYWJsZS5sb29rdXBMaXN0SW5kZXhlcztcbiAgICAgICAgICAgIHZhciBhbGxMb29rdXBzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0ubG9va3VwcztcbiAgICAgICAgICAgIC8vIGxvb2t1cExpc3RJbmRleGVzIGFyZSBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyLCBzbyB1c2UgbmFpdmUgc2VhcmNoLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb29rdXBMaXN0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlID0gYWxsTG9va3Vwc1tsb29rdXBMaXN0SW5kZXhlc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgPT09IGxvb2t1cFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWJsZXMubGVuZ3RoID09PSAwICYmIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlID0ge1xuICAgICAgICAgICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBGbGFnOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0YWJsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxMb29rdXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBhbGxMb29rdXBzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbG9va3VwVGFibGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBnbHlwaCBpbiBhIGNsYXNzIGRlZmluaXRpb24gdGFibGVcbiAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjY2xhc3MtZGVmaW5pdGlvbi10YWJsZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbGFzc0RlZlRhYmxlIC0gYW4gT3BlblR5cGUgTGF5b3V0IGNsYXNzIGRlZmluaXRpb24gdGFibGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgZ2x5cGggdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldEdseXBoQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc0RlZlRhYmxlLCBnbHlwaEluZGV4KSB7XG4gICAgICAgIHN3aXRjaCAoY2xhc3NEZWZUYWJsZS5mb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaCA8PSBnbHlwaEluZGV4ICYmXG4gICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoICsgY2xhc3NEZWZUYWJsZS5jbGFzc2VzLmxlbmd0aFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NEZWZUYWJsZS5jbGFzc2VzW1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCAtIGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWFyY2hSYW5nZShjbGFzc0RlZlRhYmxlLnJhbmdlcywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuY2xhc3NJZCA6IDA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGdseXBoIGluIGEgY292ZXJhZ2UgdGFibGVcbiAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjY292ZXJhZ2UtdGFibGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY292ZXJhZ2VUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjb3ZlcmFnZSB0YWJsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBnbHlwaCB0byBmaW5kXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0Q292ZXJhZ2VJbmRleDogZnVuY3Rpb24gKGNvdmVyYWdlVGFibGUsIGdseXBoSW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJpblNlYXJjaChjb3ZlcmFnZVRhYmxlLmdseXBocywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IC0xO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlYXJjaFJhbmdlKGNvdmVyYWdlVGFibGUucmFuZ2VzLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5pbmRleCArIGdseXBoSW5kZXggLSByYW5nZS5zdGFydCA6IC0xO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZ2x5cGggaW5kZXhlcyBvZiBhIGNvdmVyYWdlIHRhYmxlLlxuICAgICAqIEZvcm1hdCAxOiB0aGUgbGlzdCBpcyBzdG9yZWQgcmF3XG4gICAgICogRm9ybWF0IDI6IGNvbXBhY3QgbGlzdCBhcyByYW5nZSByZWNvcmRzLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY292ZXJhZ2VUYWJsZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGV4cGFuZENvdmVyYWdlOiBmdW5jdGlvbiAoY292ZXJhZ2VUYWJsZSkge1xuICAgICAgICBpZiAoY292ZXJhZ2VUYWJsZS5mb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3ZlcmFnZVRhYmxlLmdseXBocztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSBbXTtcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSBjb3ZlcmFnZVRhYmxlLnJhbmdlcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBocy5wdXNoKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnbHlwaHM7XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuLy8gVGhlIFBvc2l0aW9uIG9iamVjdCBwcm92aWRlcyB1dGlsaXR5IG1ldGhvZHMgdG8gbWFuaXB1bGF0ZVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLlBvc2l0aW9uXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvc2l0aW9uKGZvbnQpIHtcbiAgICBMYXlvdXQuY2FsbCh0aGlzLCBmb250LCAnZ3BvcycpO1xufVxuXG5Qb3NpdGlvbi5wcm90b3R5cGUgPSBMYXlvdXQucHJvdG90eXBlO1xuXG4vKipcbiAqIEluaXQgc29tZSBkYXRhIGZvciBmYXN0ZXIgYW5kIGVhc2llciBhY2Nlc3MgbGF0ZXIuXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKTtcbiAgICB0aGlzLmRlZmF1bHRLZXJuaW5nVGFibGVzID0gdGhpcy5nZXRLZXJuaW5nVGFibGVzKHNjcmlwdCk7XG59O1xuXG4vKipcbiAqIEZpbmQgYSBnbHlwaCBwYWlyIGluIGEgbGlzdCBvZiBsb29rdXAgdGFibGVzIG9mIHR5cGUgMiBhbmQgcmV0cmlldmUgdGhlIHhBZHZhbmNlIGtlcm5pbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZWZ0SW5kZXggLSBsZWZ0IGdseXBoIGluZGV4XG4gKiBAcGFyYW0ge2ludGVnZXJ9IHJpZ2h0SW5kZXggLSByaWdodCBnbHlwaCBpbmRleFxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihrZXJuaW5nTG9va3VwcywgbGVmdEluZGV4LCByaWdodEluZGV4KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuaW5nTG9va3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0ga2VybmluZ0xvb2t1cHNbaV0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YnRhYmxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2pdO1xuICAgICAgICAgICAgdmFyIGNvdkluZGV4ID0gdGhpcy5nZXRDb3ZlcmFnZUluZGV4KHN1YnRhYmxlLmNvdmVyYWdlLCBsZWZ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNvdkluZGV4IDwgMCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgc3dpdGNoIChzdWJ0YWJsZS5wb3NGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBQYWlyIEFkanVzdG1lbnQgUG9zaXRpb25pbmcgRm9ybWF0IDFcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXJTZXQgPSBzdWJ0YWJsZS5wYWlyU2V0c1tjb3ZJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcGFpclNldC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyU2V0W2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIuc2Vjb25kR2x5cGggPT09IHJpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpci52YWx1ZTEgJiYgcGFpci52YWx1ZTEueEFkdmFuY2UgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAvLyBsZWZ0IGdseXBoIGZvdW5kLCBub3QgcmlnaHQgZ2x5cGggLSB0cnkgbmV4dCBzdWJ0YWJsZVxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIFBhaXIgQWRqdXN0bWVudCBQb3NpdGlvbmluZyBGb3JtYXQgMlxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3MxID0gdGhpcy5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMSwgbGVmdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzMiA9IHRoaXMuZ2V0R2x5cGhDbGFzcyhzdWJ0YWJsZS5jbGFzc0RlZjIsIHJpZ2h0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciQxID0gc3VidGFibGUuY2xhc3NSZWNvcmRzW2NsYXNzMV1bY2xhc3MyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIkMS52YWx1ZTEgJiYgcGFpciQxLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBrZXJuaW5nIGxvb2t1cCB0YWJsZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXSAtIHVzZSBmb250LnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCkgZm9yIGEgYmV0dGVyIGRlZmF1bHQgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7b2JqZWN0W119IFRoZSBsaXN0IG9mIGtlcm5pbmcgbG9va3VwIHRhYmxlcyAobWF5IGJlIGVtcHR5KSwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIEdQT1MgdGFibGUgKGFuZCB3ZSBzaG91bGQgdXNlIHRoZSBrZXJuIHRhYmxlKVxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0S2VybmluZ1RhYmxlcyA9IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAodGhpcy5mb250LnRhYmxlcy5ncG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCAna2VybicsIDIpO1xuICAgIH1cbn07XG5cbi8vIFRoZSBTdWJzdGl0dXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuU3Vic3RpdHV0aW9uXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN1YnN0aXR1dGlvbihmb250KSB7XG4gICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dzdWInKTtcbn1cblxuLy8gQ2hlY2sgaWYgMiBhcnJheXMgb2YgcHJpbWl0aXZlcyBhcmUgZXF1YWwuXG5mdW5jdGlvbiBhcnJheXNFcXVhbChhcjEsIGFyMikge1xuICAgIHZhciBuID0gYXIxLmxlbmd0aDtcbiAgICBpZiAobiAhPT0gYXIyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChhcjFbaV0gIT09IGFyMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBGaW5kIHRoZSBmaXJzdCBzdWJ0YWJsZSBvZiBhIGxvb2t1cCB0YWJsZSBpbiBhIHBhcnRpY3VsYXIgZm9ybWF0LlxuZnVuY3Rpb24gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIGZvcm1hdCwgZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gc3VidGFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTdWJ0YWJsZSkge1xuICAgICAgICBzdWJ0YWJsZXMucHVzaChkZWZhdWx0U3VidGFibGUpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFN1YnRhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlID0gTGF5b3V0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBkZWZhdWx0IEdTVUIgdGFibGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdzdWIgLSBUaGUgR1NVQiB0YWJsZS5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gR2VuZXJhdGUgYSBkZWZhdWx0IGVtcHR5IEdTVUIgdGFibGUgd2l0aCBqdXN0IGEgREZMVCBzY3JpcHQgYW5kIGRmbHQgbGFuZyBzeXMuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgc2NyaXB0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ0RGTFQnLFxuICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9IF0sXG4gICAgICAgIGZlYXR1cmVzOiBbXSxcbiAgICAgICAgbG9va3VwczogW10sXG4gICAgfTtcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgc2luZ2xlIHN1YnN0aXR1dGlvbnMgKGxvb2t1cCB0eXBlIDEpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcsICdzczAxJy4uLilcbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRTaW5nbGUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDEpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgaiA9ICh2b2lkIDApO1xuICAgICAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gc3VidGFibGUuZGVsdGFHbHlwaElkO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoLCBieTogZ2x5cGggKyBkZWx0YSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRlID0gc3VidGFibGUuc3Vic3RpdHV0ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogc3Vic3RpdHV0ZVtqXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIG11bHRpcGxlIHN1YnN0aXR1dGlvbnMgKGxvb2t1cCB0eXBlIDIpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2NjbXAnLCAnc3RjaCcpXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0TXVsdGlwbGUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDIpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgaiA9ICh2b2lkIDApO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudHMgPSBzdWJ0YWJsZS5zZXF1ZW5jZXNbal07XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaCwgYnk6IHJlcGxhY2VtZW50cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic3RpdHV0aW9ucztcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgYWx0ZXJuYXRlcyAobG9va3VwIHR5cGUgMykgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnYWFsdCcsICdzYWx0Jy4uLilcbiAqIEByZXR1cm4ge0FycmF5fSBhbHRlcm5hdGVzIC0gVGhlIGxpc3Qgb2YgYWx0ZXJuYXRlc1xuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldEFsdGVybmF0ZXMgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBhbHRlcm5hdGVzID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDMpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgYWx0ZXJuYXRlU2V0cyA9IHN1YnRhYmxlLmFsdGVybmF0ZVNldHM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGFsdGVybmF0ZXMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogYWx0ZXJuYXRlU2V0c1tqXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWx0ZXJuYXRlcztcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgbGlnYXR1cmVzIChsb29rdXAgdHlwZSA0KSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIFRoZSByZXN1bHQgaXMgYW4gYXJyYXkgb2YgbGlnYXR1cmUgb2JqZWN0cyBsaWtlIHsgc3ViOiBbaWRzXSwgYnk6IGlkIH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtBcnJheX0gbGlnYXR1cmVzIC0gVGhlIGxpc3Qgb2YgbGlnYXR1cmVzLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldExpZ2F0dXJlcyA9IGZ1bmN0aW9uIChmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxpZ2F0dXJlcyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCA0KTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGxpZ2F0dXJlU2V0cyA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0cztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0R2x5cGggPSBnbHlwaHNbal07XG4gICAgICAgICAgICAgICAgdmFyIGxpZ1NldCA9IGxpZ2F0dXJlU2V0c1tqXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpZ1NldC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlnID0gbGlnU2V0W2tdO1xuICAgICAgICAgICAgICAgICAgICBsaWdhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWI6IFtzdGFydEdseXBoXS5jb25jYXQobGlnLmNvbXBvbmVudHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnk6IGxpZy5saWdHbHlwaCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaWdhdHVyZXM7XG59O1xuXG4vKipcbiAqIEFkZCBvciBtb2RpZnkgYSBzaW5nbGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAxKVxuICogRm9ybWF0IDIsIG1vcmUgZmxleGlibGUsIGlzIGFsd2F5cyB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBieTogaWQgfSAoZm9ybWF0IDEgaXMgbm90IHN1cHBvcnRlZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZFNpbmdsZSA9IGZ1bmN0aW9uIChcbiAgICBmZWF0dXJlLFxuICAgIHN1YnN0aXR1dGlvbixcbiAgICBzY3JpcHQsXG4gICAgbGFuZ3VhZ2Vcbikge1xuICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKFxuICAgICAgICBzY3JpcHQsXG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICBmZWF0dXJlLFxuICAgICAgICAxLFxuICAgICAgICB0cnVlXG4gICAgKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMiwge1xuICAgICAgICAvLyBsb29rdXAgdHlwZSAxIHN1YnRhYmxlLCBmb3JtYXQgMiwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LFxuICAgICAgICBzdWJzdGl0dXRlOiBbXSxcbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ1NpbmdsZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArXG4gICAgICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXRcbiAgICApO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5zdWJzdGl0dXRlLnNwbGljZShwb3MsIDAsIDApO1xuICAgIH1cbiAgICBzdWJ0YWJsZS5zdWJzdGl0dXRlW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG59O1xuXG4vKipcbiAqIEFkZCBvciBtb2RpZnkgYSBtdWx0aXBsZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDIpXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2NjbXAnLCAnc3RjaCcpXG4gKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBieTogW2lkXSB9IGZvciBmb3JtYXQgMi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZE11bHRpcGxlID0gZnVuY3Rpb24gKFxuICAgIGZlYXR1cmUsXG4gICAgc3Vic3RpdHV0aW9uLFxuICAgIHNjcmlwdCxcbiAgICBsYW5ndWFnZVxuKSB7XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBzdWJzdGl0dXRpb24uYnkgaW5zdGFuY2VvZiBBcnJheSAmJiBzdWJzdGl0dXRpb24uYnkubGVuZ3RoID4gMSxcbiAgICAgICAgJ011bHRpcGxlOiBcImJ5XCIgbXVzdCBiZSBhbiBhcnJheSBvZiB0d28gb3IgbW9yZSBpZHMnXG4gICAgKTtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhcbiAgICAgICAgc2NyaXB0LFxuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgMixcbiAgICAgICAgdHJ1ZVxuICAgIClbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDEsIHtcbiAgICAgICAgLy8gbG9va3VwIHR5cGUgMiBzdWJ0YWJsZSwgZm9ybWF0IDEsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgc2VxdWVuY2VzOiBbXSxcbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ011bHRpcGxlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICtcbiAgICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdFxuICAgICk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLnNlcXVlbmNlcy5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuc2VxdWVuY2VzW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG59O1xuXG4vKipcbiAqIEFkZCBvciBtb2RpZnkgYW4gYWx0ZXJuYXRlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMylcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgYnk6IFtpZHNdIH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZEFsdGVybmF0ZSA9IGZ1bmN0aW9uIChcbiAgICBmZWF0dXJlLFxuICAgIHN1YnN0aXR1dGlvbixcbiAgICBzY3JpcHQsXG4gICAgbGFuZ3VhZ2Vcbikge1xuICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKFxuICAgICAgICBzY3JpcHQsXG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICBmZWF0dXJlLFxuICAgICAgICAzLFxuICAgICAgICB0cnVlXG4gICAgKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMSwge1xuICAgICAgICAvLyBsb29rdXAgdHlwZSAzIHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LFxuICAgICAgICBhbHRlcm5hdGVTZXRzOiBbXSxcbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ0FsdGVybmF0ZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArXG4gICAgICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXRcbiAgICApO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzLnNwbGljZShwb3MsIDAsIDApO1xuICAgIH1cbiAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpZ2F0dXJlIChsb29rdXAgdHlwZSA0KVxuICogTGlnYXR1cmVzIHdpdGggbW9yZSBjb21wb25lbnRzIG11c3QgYmUgc3RvcmVkIGFoZWFkIG9mIHRob3NlIHdpdGggZmV3ZXIgY29tcG9uZW50cyBpbiBvcmRlciB0byBiZSBmb3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gbGlnYXR1cmUgLSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRMaWdhdHVyZSA9IGZ1bmN0aW9uIChcbiAgICBmZWF0dXJlLFxuICAgIGxpZ2F0dXJlLFxuICAgIHNjcmlwdCxcbiAgICBsYW5ndWFnZVxuKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoXG4gICAgICAgIHNjcmlwdCxcbiAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIDQsXG4gICAgICAgIHRydWVcbiAgICApWzBdO1xuICAgIHZhciBzdWJ0YWJsZSA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXTtcbiAgICBpZiAoIXN1YnRhYmxlKSB7XG4gICAgICAgIHN1YnRhYmxlID0ge1xuICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgNCBzdWJ0YWJsZSwgZm9ybWF0IDEsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LFxuICAgICAgICAgICAgbGlnYXR1cmVTZXRzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgbG9va3VwVGFibGUuc3VidGFibGVzWzBdID0gc3VidGFibGU7XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLFxuICAgICAgICAnTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgK1xuICAgICAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0XG4gICAgKTtcbiAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IGxpZ2F0dXJlLnN1YlswXTtcbiAgICB2YXIgbGlnQ29tcG9uZW50cyA9IGxpZ2F0dXJlLnN1Yi5zbGljZSgxKTtcbiAgICB2YXIgbGlnYXR1cmVUYWJsZSA9IHtcbiAgICAgICAgbGlnR2x5cGg6IGxpZ2F0dXJlLmJ5LFxuICAgICAgICBjb21wb25lbnRzOiBsaWdDb21wb25lbnRzLFxuICAgIH07XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIC8vIGxpZ2F0dXJlU2V0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1twb3NdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBJZiBsaWdhdHVyZSBhbHJlYWR5IGV4aXN0cywgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKGFycmF5c0VxdWFsKGxpZ2F0dXJlU2V0W2ldLmNvbXBvbmVudHMsIGxpZ0NvbXBvbmVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxpZ2F0dXJlIGRvZXMgbm90IGV4aXN0OiBhZGQgaXQuXG4gICAgICAgIGxpZ2F0dXJlU2V0LnB1c2gobGlnYXR1cmVUYWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpZ2F0dXJlU2V0IGFuZCBhZGQgY292ZXJhZ2UgZm9yIHRoZSBmaXJzdCBnbHlwaC5cbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUubGlnYXR1cmVTZXRzLnNwbGljZShwb3MsIDAsIFtsaWdhdHVyZVRhYmxlXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBmZWF0dXJlIGRhdGEgZm9yIGEgZ2l2ZW4gc2NyaXB0IGFuZCBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRGZWF0dXJlID0gZnVuY3Rpb24gKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG4gICAgICAgIC8vIHNzMDEgLSBzczIwXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKS5jb25jYXQoXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBbHRlcm5hdGVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpXG4gICAgICAgICAgICApO1xuICAgICAgICBjYXNlICdkbGlnJzpcbiAgICAgICAgY2FzZSAnbGlnYSc6XG4gICAgICAgIGNhc2UgJ3JsaWcnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGlnYXR1cmVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICBjYXNlICdjY21wJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE11bHRpcGxlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpLmNvbmNhdChcbiAgICAgICAgICAgICAgICB0aGlzLmdldExpZ2F0dXJlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAnc3RjaCc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNdWx0aXBsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQWRkIGEgc3Vic3RpdHV0aW9uIHRvIGEgZmVhdHVyZSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWIgLSB0aGUgc3Vic3RpdHV0aW9uIHRvIGFkZCAoYW4gb2JqZWN0IGxpa2UgeyBzdWI6IGlkIG9yIFtpZHNdLCBieTogaWQgb3IgW2lkc10gfSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG4gICAgICAgIC8vIHNzMDEgLSBzczIwXG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICAgICAgY2FzZSAnYWFsdCc6XG4gICAgICAgIGNhc2UgJ3NhbHQnOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWIuYnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2luZ2xlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBbHRlcm5hdGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgY2FzZSAnZGxpZyc6XG4gICAgICAgIGNhc2UgJ2xpZ2EnOlxuICAgICAgICBjYXNlICdybGlnJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZExpZ2F0dXJlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgIGNhc2UgJ2NjbXAnOlxuICAgICAgICAgICAgaWYgKHN1Yi5ieSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTXVsdGlwbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZExpZ2F0dXJlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5mdW5jdGlvbiBjaGVja0FyZ3VtZW50KGV4cHJlc3Npb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG59XG5cbi8vIFBhcnNpbmcgdXRpbGl0eSBmdW5jdGlvbnNcblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgYnl0ZSBmcm9tIHRoZSBEYXRhVmlldy5cbmZ1bmN0aW9uIGdldEJ5dGUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpO1xufVxuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRVU2hvcnQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBmYWxzZSk7XG59XG5cbi8vIFJldHJpZXZlIGEgc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldFNob3J0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG59XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDMyLWJpdCBsb25nIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0VUxvbmcoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG59XG5cbi8vIFJldHJpZXZlIGEgMzItYml0IHNpZ25lZCBmaXhlZC1wb2ludCBudW1iZXIgKDE2LjE2KSBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldEZpeGVkKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICB2YXIgZGVjaW1hbCA9IGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xuICAgIHZhciBmcmFjdGlvbiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGRlY2ltYWwgKyBmcmFjdGlvbiAvIDY1NTM1O1xufVxuXG4vLyBSZXRyaWV2ZSBhIDQtY2hhcmFjdGVyIHRhZyBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRhZ3MgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGFibGVzLlxuZnVuY3Rpb24gZ2V0VGFnKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICB2YXIgdGFnID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDQ7IGkgKz0gMSkge1xuICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRJbnQ4KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnO1xufVxuXG4vLyBSZXRyaWV2ZSBhbiBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBPZmZzZXRzIGFyZSAxIHRvIDQgYnl0ZXMgaW4gbGVuZ3RoLCBkZXBlbmRpbmcgb24gdGhlIG9mZlNpemUgYXJndW1lbnQuXG5mdW5jdGlvbiBnZXRPZmZzZXQoZGF0YVZpZXcsIG9mZnNldCwgb2ZmU2l6ZSkge1xuICAgIHZhciB2ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZlNpemU7IGkgKz0gMSkge1xuICAgICAgICB2IDw8PSA4O1xuICAgICAgICB2ICs9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpO1xuICAgIH1cblxuICAgIHJldHVybiB2O1xufVxuXG4vLyBSZXRyaWV2ZSBhIG51bWJlciBvZiBieXRlcyBmcm9tIHN0YXJ0IG9mZnNldCB0byB0aGUgZW5kIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbmZ1bmN0aW9uIGdldEJ5dGVzKGRhdGFWaWV3LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0T2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaChkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBsaXN0IG9mIGJ5dGVzIHRvIGEgc3RyaW5nLlxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgIHZhciBzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xufVxuXG52YXIgdHlwZU9mZnNldHMgPSB7XG4gICAgYnl0ZTogMSxcbiAgICB1U2hvcnQ6IDIsXG4gICAgc2hvcnQ6IDIsXG4gICAgdUxvbmc6IDQsXG4gICAgZml4ZWQ6IDQsXG4gICAgbG9uZ0RhdGVUaW1lOiA4LFxuICAgIHRhZzogNFxufTtcblxuLy8gQSBzdGF0ZWZ1bCBwYXJzZXIgdGhhdCBjaGFuZ2VzIHRoZSBvZmZzZXQgd2hlbmV2ZXIgYSB2YWx1ZSBpcyByZXRyaWV2ZWQuXG4vLyBUaGUgZGF0YSBpcyBhIERhdGFWaWV3LlxuZnVuY3Rpb24gUGFyc2VyKGRhdGEsIG9mZnNldCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IDA7XG59XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2hhciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDggPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkMTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNJRCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGMkRvdDE0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KSAvIDE2Mzg0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQzMiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZztcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpeGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBnZXRGaXhlZCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdHJpbmcgPSAnJztcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKDQpO1xufTtcblxuLy8gTE9OR0RBVEVUSU1FIGlzIGEgNjQtYml0IGludGVnZXIuXG4vLyBKYXZhU2NyaXB0IGFuZCB1bml4IHRpbWVzdGFtcHMgdHJhZGl0aW9uYWxseSB1c2UgMzIgYml0cywgc28gd2Vcbi8vIG9ubHkgdGFrZSB0aGUgbGFzdCAzMiBiaXRzLlxuLy8gKyBTaW5jZSB1bnRpbCAyMDM4IHRob3NlIGJpdHMgd2lsbCBiZSBmaWxsZWQgYnkgemVyb3Mgd2UgY2FuIGlnbm9yZSB0aGVtLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvbmdEYXRlVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyA0KTtcbiAgICAvLyBTdWJ0cmFjdCBzZWNvbmRzIGJldHdlZW4gMDEvMDEvMTkwNCBhbmQgMDEvMDEvMTk3MFxuICAgIC8vIHRvIGNvbnZlcnQgQXBwbGUgTWFjIHRpbWVzdGFtcCB0byBTdGFuZGFyZCBVbml4IHRpbWVzdGFtcFxuICAgIHYgLT0gMjA4Mjg0NDgwMDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmVyc2lvbiA9IGZ1bmN0aW9uKG1pbm9yQmFzZSkge1xuICAgIHZhciBtYWpvciA9IGdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG5cbiAgICAvLyBIb3cgdG8gaW50ZXJwcmV0IHRoZSBtaW5vciB2ZXJzaW9uIGlzIHZlcnkgdmFndWUgaW4gdGhlIHNwZWMuIDB4NTAwMCBpcyA1LCAweDEwMDAgaXMgMVxuICAgIC8vIERlZmF1bHQgcmV0dXJucyB0aGUgY29ycmVjdCBudW1iZXIgaWYgbWlub3IgPSAweE4wMDAgd2hlcmUgTiBpcyAwLTlcbiAgICAvLyBTZXQgbWlub3JCYXNlIHRvIDEgZm9yIHRhYmxlcyB0aGF0IHVzZSBtaW5vciA9IE4gd2hlcmUgTiBpcyAwLTlcbiAgICB2YXIgbWlub3IgPSBnZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyAyKTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgaWYgKG1pbm9yQmFzZSA9PT0gdW5kZWZpbmVkKSB7IG1pbm9yQmFzZSA9IDB4MTAwMDsgfVxuICAgIHJldHVybiBtYWpvciArIG1pbm9yIC8gbWlub3JCYXNlIC8gMTA7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbih0eXBlLCBhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW1vdW50ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IHR5cGVPZmZzZXRzW3R5cGVdICogYW1vdW50O1xufTtcblxuLy8vLy8gUGFyc2luZyBsaXN0cyBhbmQgcmVjb3JkcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFBhcnNlIGEgbGlzdCBvZiAzMiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmdMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgeyBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpOyB9XG4gICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBvZmZzZXRzW2ldID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiA0O1xuICAgIHJldHVybiBvZmZzZXRzO1xufTtcblxuLy8gUGFyc2UgYSBsaXN0IG9mIDE2IGJpdCB1bnNpZ25lZCBpbnRlZ2Vycy4gVGhlIGxlbmd0aCBvZiB0aGUgbGlzdCBjYW4gYmUgcmVhZCBvbiB0aGUgc3RyZWFtXG4vLyBvciBwcm92aWRlZCBhcyBhbiBhcmd1bWVudC5cblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNkxpc3QgPVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7IGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpOyB9XG4gICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBvZmZzZXRzW2ldID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuICAgIHJldHVybiBvZmZzZXRzO1xufTtcblxuLy8gUGFyc2VzIGEgbGlzdCBvZiAxNiBiaXQgc2lnbmVkIGludGVnZXJzLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNob3J0TGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vLyBQYXJzZXMgYSBsaXN0IG9mIGJ5dGVzLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGVMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQrKyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudDtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIGl0ZW1zLlxuICogUmVjb3JkIGNvdW50IGlzIG9wdGlvbmFsLCBpZiBvbWl0dGVkIGl0IGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICogaXRlbUNhbGxiYWNrIGlzIG9uZSBvZiB0aGUgUGFyc2VyIG1ldGhvZHMuXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0ID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIGlmICghaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZW1DYWxsYmFjayA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICBpZiAoIWl0ZW1DYWxsYmFjaykge1xuICAgICAgICBpdGVtQ2FsbGJhY2sgPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTtcbiAgICB9XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgcmVjb3Jkcy5cbiAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqIEV4YW1wbGUgb2YgcmVjb3JkRGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFyZWNvcmREZXNjcmlwdGlvbikge1xuICAgICAgICByZWNvcmREZXNjcmlwdGlvbiA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmREZXNjcmlwdGlvbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciByZWMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbal07XG4gICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcmVjb3JkRGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgIHJlY1tmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3Jkc1tpXSA9IHJlYztcbiAgICB9XG4gICAgcmV0dXJuIHJlY29yZHM7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUmVjb3JkTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgLy8gSWYgdGhlIGNvdW50IGFyZ3VtZW50IGlzIGFic2VudCwgcmVhZCBpdCBpbiB0aGUgc3RyZWFtLlxuICAgIGlmICghcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTtcbiAgICB9XG4gICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmREZXNjcmlwdGlvbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciByZWMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbal07XG4gICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcmVjb3JkRGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgIHJlY1tmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3Jkc1tpXSA9IHJlYztcbiAgICB9XG4gICAgcmV0dXJuIHJlY29yZHM7XG59O1xuXG4vLyBQYXJzZSBhIGRhdGEgc3RydWN0dXJlIGludG8gYW4gb2JqZWN0XG4vLyBFeGFtcGxlIG9mIGRlc2NyaXB0aW9uOiB7IHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydCB9XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhkZXNjcmlwdGlvbik7XG4gICAgICAgIHZhciBzdHJ1Y3QgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbal07XG4gICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gZGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgIHN0cnVjdFtmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgR1BPUyB2YWx1ZVJlY29yZFxuICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjdmFsdWUtcmVjb3JkXG4gKiB2YWx1ZUZvcm1hdCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhbHVlUmVjb3JkID0gZnVuY3Rpb24odmFsdWVGb3JtYXQpIHtcbiAgICBpZiAodmFsdWVGb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZUZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ID09PSAwKSB7XG4gICAgICAgIC8vIHZhbHVlRm9ybWF0MiBpbiBrZXJuaW5nIHBhaXJzIGlzIG1vc3Qgb2Z0ZW4gMFxuICAgICAgICAvLyBpbiB0aGlzIGNhc2UgcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGFuIGVtcHR5IG9iamVjdCwgdG8gc2F2ZSBzcGFjZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2YWx1ZVJlY29yZCA9IHt9O1xuXG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDAxKSB7IHZhbHVlUmVjb3JkLnhQbGFjZW1lbnQgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwMikgeyB2YWx1ZVJlY29yZC55UGxhY2VtZW50ID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDQpIHsgdmFsdWVSZWNvcmQueEFkdmFuY2UgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwOCkgeyB2YWx1ZVJlY29yZC55QWR2YW5jZSA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cbiAgICAvLyBEZXZpY2UgdGFibGUgKG5vbi12YXJpYWJsZSBmb250KSAvIFZhcmlhdGlvbkluZGV4IHRhYmxlICh2YXJpYWJsZSBmb250KSBub3Qgc3VwcG9ydGVkXG4gICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZnItZnIvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2RldlZhcklkeFRibHNcbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMTApIHsgdmFsdWVSZWNvcmQueFBsYURldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMjApIHsgdmFsdWVSZWNvcmQueVBsYURldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwNDApIHsgdmFsdWVSZWNvcmQueEFkdkRldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwODApIHsgdmFsdWVSZWNvcmQueUFkdkRldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cblxuICAgIHJldHVybiB2YWx1ZVJlY29yZDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIEdQT1MgdmFsdWVSZWNvcmRzXG4gKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyN2YWx1ZS1yZWNvcmRcbiAqIHZhbHVlRm9ybWF0IGFuZCB2YWx1ZUNvdW50IGFyZSByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhbHVlUmVjb3JkTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZUZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgdmFsdWVDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KHZhbHVlQ291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUG9pbnRlciA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHN0cnVjdE9mZnNldCA9IHRoaXMucGFyc2VPZmZzZXQxNigpO1xuICAgIGlmIChzdHJ1Y3RPZmZzZXQgPiAwKSB7XG4gICAgICAgIC8vIE5VTEwgb2Zmc2V0ID0+IHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHN0cnVjdE9mZnNldCkucGFyc2VTdHJ1Y3QoZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBvaW50ZXIzMiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHN0cnVjdE9mZnNldCA9IHRoaXMucGFyc2VPZmZzZXQzMigpO1xuICAgIGlmIChzdHJ1Y3RPZmZzZXQgPiAwKSB7XG4gICAgICAgIC8vIE5VTEwgb2Zmc2V0ID0+IHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHN0cnVjdE9mZnNldCkucGFyc2VTdHJ1Y3QoZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2Ygb2Zmc2V0cyB0byBsaXN0cyBvZiAxNi1iaXQgaW50ZWdlcnMsXG4gKiBvciBhIGxpc3Qgb2Ygb2Zmc2V0cyB0byBsaXN0cyBvZiBvZmZzZXRzIHRvIGFueSBraW5kIG9mIGl0ZW1zLlxuICogSWYgaXRlbUNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZCwgYSBsaXN0IG9mIGxpc3Qgb2YgVVNob3J0IGlzIGFzc3VtZWQuXG4gKiBJZiBwcm92aWRlZCwgaXRlbUNhbGxiYWNrIGlzIGNhbGxlZCBvbiBlYWNoIGl0ZW0gYW5kIG11c3QgcGFyc2UgdGhlIGl0ZW0uXG4gKiBTZWUgZXhhbXBsZXMgaW4gdGFibGVzL2dzdWIuanNcbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3RPZkxpc3RzID0gZnVuY3Rpb24oaXRlbUNhbGxiYWNrKSB7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG4gICAgdmFyIGNvdW50ID0gb2Zmc2V0cy5sZW5ndGg7XG4gICAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbaV07XG4gICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTlVMTCBvZmZzZXRcbiAgICAgICAgICAgIC8vIEFkZCBpIGFzIG93bmVkIHByb3BlcnR5IHRvIGxpc3QuIENvbnZlbmllbnQgd2l0aCBhc3NlcnQuXG4gICAgICAgICAgICBsaXN0W2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBpZiAoaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgc3ViT2Zmc2V0cyA9IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKTtcbiAgICAgICAgICAgIHZhciBzdWJMaXN0ID0gbmV3IEFycmF5KHN1Yk9mZnNldHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViT2Zmc2V0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSBzdGFydCArIHN1Yk9mZnNldHNbal07XG4gICAgICAgICAgICAgICAgc3ViTGlzdFtqXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdFtpXSA9IHN1Ykxpc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0W2ldID0gdGhpcy5wYXJzZVVTaG9ydExpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gcmVsYXRpdmVPZmZzZXQ7XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vLy8vLyBDb21wbGV4IHRhYmxlcyBwYXJzaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUGFyc2UgYSBjb3ZlcmFnZSB0YWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG4vLyBwYXJzZXIub2Zmc2V0IG11c3QgcG9pbnQgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZSBjb250YWluaW5nIHRoZSBjb3ZlcmFnZS5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDEsXG4gICAgICAgICAgICBnbHlwaHM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGNvdW50KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHJhbmdlc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIGVuZDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLnBhcnNlVVNob3J0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMixcbiAgICAgICAgICAgIHJhbmdlczogcmFuZ2VzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ292ZXJhZ2UgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8gUGFyc2UgYSBDbGFzcyBEZWZpbml0aW9uIFRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMSxcbiAgICAgICAgICAgIHN0YXJ0R2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgcmFuZ2VzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFBhcnNlci51U2hvcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBQYXJzZXIudVNob3J0LFxuICAgICAgICAgICAgICAgIGNsYXNzSWQ6IFBhcnNlci51U2hvcnRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ2xhc3NEZWYgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8vLy8gU3RhdGljIG1ldGhvZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRoZXNlIGNvbnZlbmllbmNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYXMgY2FsbGJhY2tzIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggXCJ0aGlzXCIgY29udGV4dCBzZXQgdG8gYSBQYXJzZXIgaW5zdGFuY2UuXG5cblBhcnNlci5saXN0ID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KGNvdW50LCBpdGVtQ2FsbGJhY2spO1xuICAgIH07XG59O1xuXG5QYXJzZXIubGlzdDMyID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0MzIoY291bnQsIGl0ZW1DYWxsYmFjayk7XG4gICAgfTtcbn07XG5cblBhcnNlci5yZWNvcmRMaXN0ID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlY29yZExpc3QoY291bnQsIHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnJlY29yZExpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0MzIoY291bnQsIHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnBvaW50ZXIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKGRlc2NyaXB0aW9uKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnBvaW50ZXIzMiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihkZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci50YWcgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnO1xuUGFyc2VyLmJ5dGUgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblBhcnNlci51U2hvcnQgPSBQYXJzZXIub2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnVTaG9ydExpc3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdDtcblBhcnNlci51TG9uZyA9IFBhcnNlci5vZmZzZXQzMiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZztcblBhcnNlci51TG9uZ0xpc3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmdMaXN0O1xuUGFyc2VyLnN0cnVjdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3Q7XG5QYXJzZXIuY292ZXJhZ2UgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2U7XG5QYXJzZXIuY2xhc3NEZWYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWY7XG5cbi8vLy8vIFNjcmlwdCwgRmVhdHVyZSwgTG9va3VwIGxpc3RzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuXG52YXIgbGFuZ1N5c1RhYmxlID0ge1xuICAgIHJlc2VydmVkOiBQYXJzZXIudVNob3J0LFxuICAgIHJlcUZlYXR1cmVJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICBmZWF0dXJlSW5kZXhlczogUGFyc2VyLnVTaG9ydExpc3Rcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTY3JpcHRMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICBzY3JpcHQ6IFBhcnNlci5wb2ludGVyKHtcbiAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiBQYXJzZXIucG9pbnRlcihsYW5nU3lzVGFibGUpLFxuICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgICAgICAgICAgbGFuZ1N5czogUGFyc2VyLnBvaW50ZXIobGFuZ1N5c1RhYmxlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KSkgfHwgW107XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZUxpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgIGZlYXR1cmU6IFBhcnNlci5wb2ludGVyKHtcbiAgICAgICAgICAgIGZlYXR1cmVQYXJhbXM6IFBhcnNlci5vZmZzZXQxNixcbiAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxuICAgICAgICB9KVxuICAgIH0pKSB8fCBbXTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMb29rdXBMaXN0ID0gZnVuY3Rpb24obG9va3VwVGFibGVQYXJzZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5saXN0KFBhcnNlci5wb2ludGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoMSA8PSBsb29rdXBUeXBlICYmIGxvb2t1cFR5cGUgPD0gOSwgJ0dQT1MvR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVHlwZSArICcgdW5rbm93bi4nKTtcbiAgICAgICAgdmFyIGxvb2t1cEZsYWcgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICAgICAgbG9va3VwRmxhZzogbG9va3VwRmxhZyxcbiAgICAgICAgICAgIHN1YnRhYmxlczogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIobG9va3VwVGFibGVQYXJzZXJzW2xvb2t1cFR5cGVdKSksXG4gICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gdGhpcy5wYXJzZVVTaG9ydCgpIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfSkpKSB8fCBbXTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1ham9yVmVyc2lvbiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIG1pbm9yVmVyc2lvbiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQobWFqb3JWZXJzaW9uID09PSAxICYmIG1pbm9yVmVyc2lvbiA8IDEsICdHUE9TL0dTVUIgZmVhdHVyZSB2YXJpYXRpb25zIHRhYmxlIHVua25vd24uJyk7XG4gICAgICAgIHZhciBmZWF0dXJlVmFyaWF0aW9ucyA9IHRoaXMucGFyc2VSZWNvcmRMaXN0MzIoe1xuICAgICAgICAgICAgY29uZGl0aW9uU2V0T2Zmc2V0OiBQYXJzZXIub2Zmc2V0MzIsXG4gICAgICAgICAgICBmZWF0dXJlVGFibGVTdWJzdGl0dXRpb25PZmZzZXQ6IFBhcnNlci5vZmZzZXQzMlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVWYXJpYXRpb25zO1xuICAgIH0pIHx8IFtdO1xufTtcblxudmFyIHBhcnNlID0ge1xuICAgIGdldEJ5dGU6IGdldEJ5dGUsXG4gICAgZ2V0Q2FyZDg6IGdldEJ5dGUsXG4gICAgZ2V0VVNob3J0OiBnZXRVU2hvcnQsXG4gICAgZ2V0Q2FyZDE2OiBnZXRVU2hvcnQsXG4gICAgZ2V0U2hvcnQ6IGdldFNob3J0LFxuICAgIGdldFVMb25nOiBnZXRVTG9uZyxcbiAgICBnZXRGaXhlZDogZ2V0Rml4ZWQsXG4gICAgZ2V0VGFnOiBnZXRUYWcsXG4gICAgZ2V0T2Zmc2V0OiBnZXRPZmZzZXQsXG4gICAgZ2V0Qnl0ZXM6IGdldEJ5dGVzLFxuICAgIGJ5dGVzVG9TdHJpbmc6IGJ5dGVzVG9TdHJpbmcsXG4gICAgUGFyc2VyOiBQYXJzZXIsXG59O1xuXG4vLyBUaGUgYGdseWZgIHRhYmxlIGRlc2NyaWJlcyB0aGUgZ2x5cGhzIGluIFRydWVUeXBlIG91dGxpbmUgZm9ybWF0LlxuXG4vLyBQYXJzZSB0aGUgY29vcmRpbmF0ZSBkYXRhIGZvciBhIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHJldmlvdXNWYWx1ZSwgc2hvcnRWZWN0b3JCaXRNYXNrLCBzYW1lQml0TWFzaykge1xuICAgIHZhciB2O1xuICAgIGlmICgoZmxhZyAmIHNob3J0VmVjdG9yQml0TWFzaykgPiAwKSB7XG4gICAgICAgIC8vIFRoZSBjb29yZGluYXRlIGlzIDEgYnl0ZSBsb25nLlxuICAgICAgICB2ID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgLy8gVGhlIGBzYW1lYCBiaXQgaXMgcmUtdXNlZCBmb3Igc2hvcnQgdmFsdWVzIHRvIHNpZ25pZnkgdGhlIHNpZ24gb2YgdGhlIHZhbHVlLlxuICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPT09IDApIHtcbiAgICAgICAgICAgIHYgPSAtdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgdjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgVGhlIGNvb3JkaW5hdGUgaXMgMiBieXRlcyBsb25nLlxuICAgICAgICAvLyBJZiB0aGUgYHNhbWVgIGJpdCBpcyBzZXQsIHRoZSBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBjb29yZGluYXRlLlxuICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPiAwKSB7XG4gICAgICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGFzIGEgc2lnbmVkIDE2LWJpdCBkZWx0YSB2YWx1ZS5cbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGgoZ2x5cGgsIGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBnbHlwaC5udW1iZXJPZkNvbnRvdXJzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3hNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl94TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3lNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICB2YXIgZmxhZ3M7XG4gICAgdmFyIGZsYWc7XG5cbiAgICBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA+IDApIHtcbiAgICAgICAgLy8gVGhpcyBnbHlwaCBpcyBub3QgYSBjb21wb3NpdGUuXG4gICAgICAgIHZhciBlbmRQb2ludEluZGljZXMgPSBnbHlwaC5lbmRQb2ludEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaC5udW1iZXJPZkNvbnRvdXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGVuZFBvaW50SW5kaWNlcy5wdXNoKHAucGFyc2VVU2hvcnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zLnB1c2gocC5wYXJzZUJ5dGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICBmbGFncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgZmxhZyA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgLy8gSWYgYml0IDMgaXMgc2V0LCB3ZSByZXBlYXQgdGhpcyBmbGFnIG4gdGltZXMsIHdoZXJlIG4gaXMgdGhlIG5leHQgYnl0ZS5cbiAgICAgICAgICAgIGlmICgoZmxhZyAmIDgpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciByZXBlYXRDb3VudCA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBlYXRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIGkkMiArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KGZsYWdzLmxlbmd0aCA9PT0gbnVtYmVyT2ZDb29yZGluYXRlcywgJ0JhZCBmbGFncy4nKTtcblxuICAgICAgICBpZiAoZW5kUG9pbnRJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgICAgIC8vIFgvWSBjb29yZGluYXRlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIHBvaW50LCBleGNlcHQgZm9yIHRoZSBmaXJzdCBwb2ludCB3aGljaCBpcyByZWxhdGl2ZSB0byAwLDAuXG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZDb29yZGluYXRlcyA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDMgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQzXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQub25DdXJ2ZSA9ICEhKGZsYWcgJiAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQubGFzdFBvaW50T2ZDb250b3VyID0gZW5kUG9pbnRJbmRpY2VzLmluZGV4T2YoaSQzKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDQgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB4LCAyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNSA9IDA7IGkkNSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkNSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHksIDQsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPT09IDApIHtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2x5cGguaXNDb21wb3NpdGUgPSB0cnVlO1xuICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICAgICAgZ2x5cGguY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgbW9yZUNvbXBvbmVudHMgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobW9yZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4OiBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIHNjYWxlMDE6IDAsXG4gICAgICAgICAgICAgICAgc2NhbGUxMDogMCxcbiAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgZHg6IDAsXG4gICAgICAgICAgICAgICAgZHk6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgd29yZHNcbiAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG1hdGNoZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID0gW3AucGFyc2VVU2hvcnQoKSwgcC5wYXJzZVVTaG9ydCgpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9IFtwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiA4KSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc2NhbGVcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIDY0KSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFuIFggLyBZIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIDEyOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIDJ4MiB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTAxID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUxMCA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdseXBoLmNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgbW9yZUNvbXBvbmVudHMgPSAhIShmbGFncyAmIDMyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiAweDEwMCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpJDYgPSAwOyBpJDYgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSQ2ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVHJhbnNmb3JtIGFuIGFycmF5IG9mIHBvaW50cyBhbmQgcmV0dXJuIGEgbmV3IGFycmF5LlxuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgdHJhbnNmb3JtKSB7XG4gICAgdmFyIG5ld1BvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIG5ld1B0ID0ge1xuICAgICAgICAgICAgeDogdHJhbnNmb3JtLnhTY2FsZSAqIHB0LnggKyB0cmFuc2Zvcm0uc2NhbGUwMSAqIHB0LnkgKyB0cmFuc2Zvcm0uZHgsXG4gICAgICAgICAgICB5OiB0cmFuc2Zvcm0uc2NhbGUxMCAqIHB0LnggKyB0cmFuc2Zvcm0ueVNjYWxlICogcHQueSArIHRyYW5zZm9ybS5keSxcbiAgICAgICAgICAgIG9uQ3VydmU6IHB0Lm9uQ3VydmUsXG4gICAgICAgICAgICBsYXN0UG9pbnRPZkNvbnRvdXI6IHB0Lmxhc3RQb2ludE9mQ29udG91clxuICAgICAgICB9O1xuICAgICAgICBuZXdQb2ludHMucHVzaChuZXdQdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0Q29udG91cnMocG9pbnRzKSB7XG4gICAgdmFyIGNvbnRvdXJzID0gW107XG4gICAgdmFyIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICBjdXJyZW50Q29udG91ci5wdXNoKHB0KTtcbiAgICAgICAgaWYgKHB0Lmxhc3RQb2ludE9mQ29udG91cikge1xuICAgICAgICAgICAgY29udG91cnMucHVzaChjdXJyZW50Q29udG91cik7XG4gICAgICAgICAgICBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2suYXJndW1lbnQoY3VycmVudENvbnRvdXIubGVuZ3RoID09PSAwLCAnVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuJyk7XG4gICAgcmV0dXJuIGNvbnRvdXJzO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lIHRvIGEgUGF0aC5cbmZ1bmN0aW9uIGdldFBhdGgocG9pbnRzKSB7XG4gICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHZhciBjb250b3VycyA9IGdldENvbnRvdXJzKHBvaW50cyk7XG5cbiAgICBmb3IgKHZhciBjb250b3VySW5kZXggPSAwOyBjb250b3VySW5kZXggPCBjb250b3Vycy5sZW5ndGg7ICsrY29udG91ckluZGV4KSB7XG4gICAgICAgIHZhciBjb250b3VyID0gY29udG91cnNbY29udG91ckluZGV4XTtcblxuICAgICAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgICAgIHZhciBjdXJyID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV4dCA9IGNvbnRvdXJbMF07XG5cbiAgICAgICAgaWYgKGN1cnIub25DdXJ2ZSkge1xuICAgICAgICAgICAgcC5tb3ZlVG8oY3Vyci54LCBjdXJyLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5leHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIHAubW92ZVRvKG5leHQueCwgbmV4dC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYm90aCBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9mZi1jdXJ2ZSwgc3RhcnQgYXQgdGhlaXIgbWlkZGxlLlxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHt4OiAoY3Vyci54ICsgbmV4dC54KSAqIDAuNSwgeTogKGN1cnIueSArIG5leHQueSkgKiAwLjV9O1xuICAgICAgICAgICAgICAgIHAubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250b3VyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwcmV2ID0gY3VycjtcbiAgICAgICAgICAgIGN1cnIgPSBuZXh0O1xuICAgICAgICAgICAgbmV4dCA9IGNvbnRvdXJbKGkgKyAxKSAlIGNvbnRvdXIubGVuZ3RoXTtcblxuICAgICAgICAgICAgaWYgKGN1cnIub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzdHJhaWdodCBsaW5lLlxuICAgICAgICAgICAgICAgIHAubGluZVRvKGN1cnIueCwgY3Vyci55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXYyID0gcHJldjtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dDIgPSBuZXh0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldjIgPSB7IHg6IChjdXJyLnggKyBwcmV2LngpICogMC41LCB5OiAoY3Vyci55ICsgcHJldi55KSAqIDAuNSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbmV4dC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQyID0geyB4OiAoY3Vyci54ICsgbmV4dC54KSAqIDAuNSwgeTogKGN1cnIueSArIG5leHQueSkgKiAwLjUgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3Vyci54LCBjdXJyLnksIG5leHQyLngsIG5leHQyLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChnbHlwaHMsIGdseXBoKSB7XG4gICAgaWYgKGdseXBoLmlzQ29tcG9zaXRlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGguY29tcG9uZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGdseXBoLmNvbXBvbmVudHNbal07XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50R2x5cGggPSBnbHlwaHMuZ2V0KGNvbXBvbmVudC5nbHlwaEluZGV4KTtcbiAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB0dGZHbHlwaExvYWRlciB0byBwYXJzZSB0aGUgZ2x5cGguXG4gICAgICAgICAgICBjb21wb25lbnRHbHlwaC5nZXRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50R2x5cGgucG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgcG9zaXRpb25lZCBieSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdID4gZ2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMV0gPiBjb21wb25lbnRHbHlwaC5wb2ludHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdNYXRjaGVkIHBvaW50cyBvdXQgb2YgcmFuZ2UgaW4gJyArIGdseXBoLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFB0ID0gZ2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZFB0ID0gY29tcG9uZW50R2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhTY2FsZTogY29tcG9uZW50LnhTY2FsZSwgc2NhbGUwMTogY29tcG9uZW50LnNjYWxlMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTEwOiBjb21wb25lbnQuc2NhbGUxMCwgeVNjYWxlOiBjb21wb25lbnQueVNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHg6IDAsIGR5OiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZFB0ID0gdHJhbnNmb3JtUG9pbnRzKFtzZWNvbmRQdF0sIHRyYW5zZm9ybSlbMF07XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keCA9IGZpcnN0UHQueCAtIHNlY29uZFB0Lng7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keSA9IGZpcnN0UHQueSAtIHNlY29uZFB0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gZ2x5cGgucG9pbnRzLmNvbmNhdCh0cmFuc2Zvcm1lZFBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZUFsbChkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cbiAgICAvLyBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb2NhIHRhYmxlIGlzIGludmFsaWQuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuZ2x5cGhMb2FkZXIoZm9udCwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBocztcbn1cblxuZnVuY3Rpb24gcGFyc2VHbHlmVGFibGVPbkxvd01lbW9yeShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cbiAgICBmb250Ll9wdXNoID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuZ2x5cGhMb2FkZXIoZm9udCwgaSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBnbHlwaHM7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCwgb3B0KSB7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpXG4gICAgICAgIHsgcmV0dXJuIHBhcnNlR2x5ZlRhYmxlT25Mb3dNZW1vcnkoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpOyB9XG4gICAgZWxzZVxuICAgICAgICB7IHJldHVybiBwYXJzZUdseWZUYWJsZUFsbChkYXRhLCBzdGFydCwgbG9jYSwgZm9udCk7IH1cbn1cblxudmFyIGdseWYgPSB7IGdldFBhdGg6IGdldFBhdGgsIHBhcnNlOiBwYXJzZUdseWZUYWJsZX07XG5cbi8qIEEgVHJ1ZVR5cGUgZm9udCBoaW50aW5nIGludGVycHJldGVyLlxuKlxuKiAoYykgMjAxNyBBeGVsIEtpdHRlbmJlcmdlclxuKlxuKiBUaGlzIGludGVycHJldGVyIGhhcyBiZWVuIGltcGxlbWVudGVkIGFjY29yZGluZyB0byB0aGlzIGRvY3VtZW50YXRpb246XG4qIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDUvQ2hhcDUuaHRtbFxuKlxuKiBBY2NvcmRpbmcgdG8gdGhlIGRvY3VtZW50YXRpb24gRjI0RE9UNiB2YWx1ZXMgYXJlIHVzZWQgZm9yIHBpeGVscy5cbiogVGhhdCBtZWFucyBjYWxjdWxhdGlvbiBpcyAxLzY0IHBpeGVsIGFjY3VyYXRlIGFuZCB1c2VzIGludGVnZXIgb3BlcmF0aW9ucy5cbiogSG93ZXZlciwgSmF2YXNjcmlwdCBoYXMgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9ucyBieSBkZWZhdWx0IGFuZCBvbmx5XG4qIHRob3NlIGFyZSBhdmFpbGFibGUuIE9uZSBjb3VsZCBtYWtlIGEgY2FzZSB0byBzaW11bGF0ZSB0aGUgMS82NCBhY2N1cmFjeVxuKiBleGFjdGx5IGJ5IHRydW5jYXRpbmcgYWZ0ZXIgZXZlcnkgZGl2aXNpb24gb3BlcmF0aW9uXG4qIChmb3IgZXhhbXBsZSB3aXRoIDw8IDApIHRvIGdldCBwaXhlbCBleGFjdGx5IHJlc3VsdHMgYXMgb3RoZXIgVHJ1ZVR5cGVcbiogaW1wbGVtZW50YXRpb25zLiBJdCBtYXkgbWFrZSBzZW5zZSBzaW5jZSBzb21lIGZvbnRzIGFyZSBwaXhlbCBvcHRpbWl6ZWRcbiogYnkgaGFuZCB1c2luZyBERUxUQVAgaW5zdHJ1Y3Rpb25zLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0XG4qIGFuZCByYXRoZXIgdXNlcyBmdWxsIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cbipcbiogeFNjYWxlLCB5U2NhbGUgYW5kIHJvdGF0aW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuKlxuKiBBIGZldyBub24tdHJpdmlhbCBpbnN0cnVjdGlvbnMgYXJlIG1pc3NpbmcgYXMgSSBkaWRuJ3QgZW5jb3VudGVyIHlldFxuKiBhIGZvbnQgdGhhdCB1c2VkIHRoZW0gdG8gdGVzdCBhIHBvc3NpYmxlIGltcGxlbWVudGF0aW9uLlxuKlxuKiBTb21lIGZvbnRzIHNlZW0gdG8gdXNlIHVuZG9jdW1lbnRlZCBmZWF0dXJlcyByZWdhcmRpbmcgdGhlIHR3aWxpZ2h0IHpvbmUuXG4qIE9ubHkgc29tZSBvZiB0aGVtIGFyZSBpbXBsZW1lbnRlZCBhcyB0aGV5IHdlcmUgZW5jb3VudGVyZWQuXG4qXG4qIFRoZSBleHBvcnRzLkRFQlVHIHN0YXRlbWVudHMgYXJlIHJlbW92ZWQgb24gdGhlIG1pbmlmaWVkIGRpc3RyaWJ1dGlvbiBmaWxlLlxuKi9cblxudmFyIGluc3RydWN0aW9uVGFibGU7XG52YXIgZXhlYztcbnZhciBleGVjR2x5cGg7XG52YXIgZXhlY0NvbXBvbmVudDtcblxuLypcbiogQ3JlYXRlcyBhIGhpbnRpbmcgb2JqZWN0LlxuKlxuKiBUaGVyZSBvdWdodCB0byBiZSBleGFjdGx5IG9uZVxuKiBmb3IgZWFjaCB0cnVldHlwZSBmb250IHRoYXQgaXMgdXNlZCBmb3IgaGludGluZy5cbiovXG5mdW5jdGlvbiBIaW50aW5nKGZvbnQpIHtcbiAgICAvLyB0aGUgZm9udCB0aGlzIGhpbnRpbmcgb2JqZWN0IGlzIGZvclxuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cbiAgICB0aGlzLmdldENvbW1hbmRzID0gZnVuY3Rpb24gKGhQb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIGdseWYuZ2V0UGF0aChoUG9pbnRzKS5jb21tYW5kcztcbiAgICB9O1xuXG4gICAgLy8gY2FjaGVkIHN0YXRlc1xuICAgIHRoaXMuX2ZwZ21TdGF0ZSAgPVxuICAgIHRoaXMuX3ByZXBTdGF0ZSAgPVxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAvLyBlcnJvclN0YXRlXG4gICAgLy8gMCAuLi4gYWxsIG9rYXlcbiAgICAvLyAxIC4uLiBoYWQgYW4gZXJyb3IgaW4gYSBnbHlmLFxuICAgIC8vICAgICAgIGNvbnRpbnVlIHdvcmtpbmcgYnV0IHN0b3Agc3BhbW1pbmdcbiAgICAvLyAgICAgICB0aGUgY29uc29sZVxuICAgIC8vIDIgLi4uIGVycm9yIGF0IHByZXAsIHN0b3AgaGludGluZyBhdCB0aGlzIHBwZW1cbiAgICAvLyAzIC4uLiBlcnJvciBhdCBmcGVnLCBzdG9wIGhpbnRpbmcgZm9yIHRoaXMgZm9udCBhdCBhbGxcbiAgICB0aGlzLl9lcnJvclN0YXRlID0gMDtcbn1cblxuLypcbiogTm90IHJvdW5kaW5nLlxuKi9cbmZ1bmN0aW9uIHJvdW5kT2ZmKHYpIHtcbiAgICByZXR1cm4gdjtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvR3JpZCh2KSB7XG4gICAgLy9Sb3VuZGluZyBpbiBUVCBpcyBzdXBwb3NlZCB0byBcInN5bW1ldHJpY2FsIGFyb3VuZCB6ZXJvXCJcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5yb3VuZChNYXRoLmFicyh2KSk7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGRvdWJsZSBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVG9Eb3VibGVHcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5yb3VuZChNYXRoLmFicyh2ICogMikpIC8gMjtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gaGFsZiBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVG9IYWxmR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIChNYXRoLnJvdW5kKE1hdGguYWJzKHYpICsgMC41KSAtIDAuNSk7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIHVwIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRVcFRvR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGguY2VpbChNYXRoLmFicyh2KSk7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGRvd24gdG8gZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZERvd25Ub0dyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLmZsb29yKE1hdGguYWJzKHYpKTtcbn1cblxuLypcbiogU3VwZXIgcm91bmRpbmcuXG4qL1xudmFyIHJvdW5kU3VwZXIgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBwZXJpb2QgPSB0aGlzLnNyUGVyaW9kO1xuICAgIHZhciBwaGFzZSA9IHRoaXMuc3JQaGFzZTtcbiAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5zclRocmVzaG9sZDtcbiAgICB2YXIgc2lnbiA9IDE7XG5cbiAgICBpZiAodiA8IDApIHtcbiAgICAgICAgdiA9IC12O1xuICAgICAgICBzaWduID0gLTE7XG4gICAgfVxuXG4gICAgdiArPSB0aHJlc2hvbGQgLSBwaGFzZTtcblxuICAgIHYgPSBNYXRoLnRydW5jKHYgLyBwZXJpb2QpICogcGVyaW9kO1xuXG4gICAgdiArPSBwaGFzZTtcblxuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8veGdyaWRmaXQuc291cmNlZm9yZ2UubmV0L3JvdW5kLmh0bWxcbiAgICBpZiAodiA8IDApIHsgcmV0dXJuIHBoYXNlICogc2lnbjsgfVxuXG4gICAgcmV0dXJuIHYgKiBzaWduO1xufTtcblxuLypcbiogVW5pdCB2ZWN0b3Igb2YgeC1heGlzLlxuKi9cbnZhciB4VW5pdFZlY3RvciA9IHtcbiAgICB4OiAxLFxuXG4gICAgeTogMCxcblxuICAgIGF4aXM6ICd4JyxcblxuICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgLy8gbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgICAgIHJldHVybiAobzEgPyBwMS54byA6IHAxLngpIC0gKG8yID8gcDIueG8gOiBwMi54KTtcbiAgICB9LFxuXG4gICAgLy8gTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4gICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuICAgIC8vIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwLCBycDEsIHJwMiwgcHYpIHtcbiAgICAgICAgdmFyIGRvMTtcbiAgICAgICAgdmFyIGRvMjtcbiAgICAgICAgdmFyIGRvYTE7XG4gICAgICAgIHZhciBkb2EyO1xuICAgICAgICB2YXIgZG0xO1xuICAgICAgICB2YXIgZG0yO1xuICAgICAgICB2YXIgZHQ7XG5cbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgZG8xID0gcC54byAtIHJwMS54bztcbiAgICAgICAgICAgIGRvMiA9IHAueG8gLSBycDIueG87XG4gICAgICAgICAgICBkbTEgPSBycDEueCAtIHJwMS54bztcbiAgICAgICAgICAgIGRtMiA9IHJwMi54IC0gcnAyLnhvO1xuICAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAueCA9IHAueG8gKyAoZG0xICsgZG0yKSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnggPSBwLnhvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgeFVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB4VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgbGluZSBub3JtYWwgdG8gdGhpc1xuICAgIG5vcm1hbFNsb3BlOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG5cbiAgICAvLyBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuICAgIC8vIGJ5IHRoZSBkaXN0YW5jZSAnZCcuXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgLy9cbiAgICAvLyBwICAgLi4uIHBvaW50IHRvIHNldFxuICAgIC8vIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG4gICAgLy8gZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuICAgIC8vIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG4gICAgLy8gb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG4gICAgc2V0UmVsYXRpdmU6IGZ1bmN0aW9uIChwLCBycCwgZCwgcHYsIG9yZykge1xuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBwLnggPSAob3JnID8gcnAueG8gOiBycC54KSArIGQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuICAgICAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgICAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuICAgICAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG4gICAgICAgIHAueCA9IHJwZHggKyAocC55IC0gcnBkeSkgLyBwdi5ub3JtYWxTbG9wZTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgdmVjdG9yIGxpbmUuXG4gICAgc2xvcGU6IDAsXG5cbiAgICAvLyBUb3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnhUb3VjaGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gVGVzdHMgaWYgYSBwb2ludCBwIGlzIHRvdWNoZWQuXG4gICAgdG91Y2hlZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAueFRvdWNoZWQ7XG4gICAgfSxcblxuICAgIC8vIFVudG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB1bnRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnhUb3VjaGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuLypcbiogVW5pdCB2ZWN0b3Igb2YgeS1heGlzLlxuKi9cbnZhciB5VW5pdFZlY3RvciA9IHtcbiAgICB4OiAwLFxuXG4gICAgeTogMSxcblxuICAgIGF4aXM6ICd5JyxcblxuICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgLy8gbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgICAgIHJldHVybiAobzEgPyBwMS55byA6IHAxLnkpIC0gKG8yID8gcDIueW8gOiBwMi55KTtcbiAgICB9LFxuXG4gICAgLy8gTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4gICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuICAgIC8vIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwLCBycDEsIHJwMiwgcHYpIHtcbiAgICAgICAgdmFyIGRvMTtcbiAgICAgICAgdmFyIGRvMjtcbiAgICAgICAgdmFyIGRvYTE7XG4gICAgICAgIHZhciBkb2EyO1xuICAgICAgICB2YXIgZG0xO1xuICAgICAgICB2YXIgZG0yO1xuICAgICAgICB2YXIgZHQ7XG5cbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgZG8xID0gcC55byAtIHJwMS55bztcbiAgICAgICAgICAgIGRvMiA9IHAueW8gLSBycDIueW87XG4gICAgICAgICAgICBkbTEgPSBycDEueSAtIHJwMS55bztcbiAgICAgICAgICAgIGRtMiA9IHJwMi55IC0gcnAyLnlvO1xuICAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAueSA9IHAueW8gKyAoZG0xICsgZG0yKSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnkgPSBwLnlvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB5VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgbGluZSBub3JtYWwgdG8gdGhpcy5cbiAgICBub3JtYWxTbG9wZTogMCxcblxuICAgIC8vIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4gICAgLy8gYnkgdGhlIGRpc3RhbmNlICdkJ1xuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIC8vXG4gICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcbiAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuICAgIC8vIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuICAgIHNldFJlbGF0aXZlOiBmdW5jdGlvbiAocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgcC55ID0gKG9yZyA/IHJwLnlvIDogcnAueSkgKyBkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICAgICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICAgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgICAgICBwLnkgPSBycGR5ICsgcHYubm9ybWFsU2xvcGUgKiAocC54IC0gcnBkeCk7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuICAgIHNsb3BlOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG5cbiAgICAvLyBUb3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnlUb3VjaGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gVGVzdHMgaWYgYSBwb2ludCBwIGlzIHRvdWNoZWQuXG4gICAgdG91Y2hlZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAueVRvdWNoZWQ7XG4gICAgfSxcblxuICAgIC8vIFVudG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB1bnRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnlUb3VjaGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuT2JqZWN0LmZyZWV6ZSh4VW5pdFZlY3Rvcik7XG5PYmplY3QuZnJlZXplKHlVbml0VmVjdG9yKTtcblxuLypcbiogQ3JlYXRlcyBhIHVuaXQgdmVjdG9yIHRoYXQgaXMgbm90IHgtIG9yIHktYXhpcy5cbiovXG5mdW5jdGlvbiBVbml0VmVjdG9yKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2xvcGUgPSB5IC8geDtcbiAgICB0aGlzLm5vcm1hbFNsb3BlID0gLXggLyB5O1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG59XG5cbi8qXG4qIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4qIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihwMSwgcDIsIG8xLCBvMikge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMueCAqIHhVbml0VmVjdG9yLmRpc3RhbmNlKHAxLCBwMiwgbzEsIG8yKSArXG4gICAgICAgIHRoaXMueSAqIHlVbml0VmVjdG9yLmRpc3RhbmNlKHAxLCBwMiwgbzEsIG8yKVxuICAgICk7XG59O1xuXG4vKlxuKiBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcbiogcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuKiBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuKlxuKiBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihwLCBycDEsIHJwMiwgcHYpIHtcbiAgICB2YXIgZG0xO1xuICAgIHZhciBkbTI7XG4gICAgdmFyIGRvMTtcbiAgICB2YXIgZG8yO1xuICAgIHZhciBkb2ExO1xuICAgIHZhciBkb2EyO1xuICAgIHZhciBkdDtcblxuICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbn07XG5cbi8qXG4qIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4qIGJ5IHRoZSBkaXN0YW5jZSAnZCdcbipcbiogU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuKlxuKiBwICAgLi4uICBwb2ludCB0byBzZXRcbiogcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiogZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuKiBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuKiBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS5zZXRSZWxhdGl2ZSA9IGZ1bmN0aW9uKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgcHYgPSBwdiB8fCB0aGlzO1xuXG4gICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgIHZhciBwdm5zID0gcHYubm9ybWFsU2xvcGU7XG4gICAgdmFyIGZ2cyA9IHRoaXMuc2xvcGU7XG5cbiAgICB2YXIgcHggPSBwLng7XG4gICAgdmFyIHB5ID0gcC55O1xuXG4gICAgcC54ID0gKGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHkpIC8gKGZ2cyAtIHB2bnMpO1xuICAgIHAueSA9IGZ2cyAqIChwLnggLSBweCkgKyBweTtcbn07XG5cbi8qXG4qIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbihwKSB7XG4gICAgcC54VG91Y2hlZCA9IHRydWU7XG4gICAgcC55VG91Y2hlZCA9IHRydWU7XG59O1xuXG4vKlxuKiBSZXR1cm5zIGEgdW5pdCB2ZWN0b3Igd2l0aCB4L3kgY29vcmRpbmF0ZXMuXG4qL1xuZnVuY3Rpb24gZ2V0VW5pdFZlY3Rvcih4LCB5KSB7XG4gICAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgICB4IC89IGQ7XG4gICAgeSAvPSBkO1xuXG4gICAgaWYgKHggPT09IDEgJiYgeSA9PT0gMCkgeyByZXR1cm4geFVuaXRWZWN0b3I7IH1cbiAgICBlbHNlIGlmICh4ID09PSAwICYmIHkgPT09IDEpIHsgcmV0dXJuIHlVbml0VmVjdG9yOyB9XG4gICAgZWxzZSB7IHJldHVybiBuZXcgVW5pdFZlY3Rvcih4LCB5KTsgfVxufVxuXG4vKlxuKiBDcmVhdGVzIGEgcG9pbnQgaW4gdGhlIGhpbnRpbmcgZW5naW5lLlxuKi9cbmZ1bmN0aW9uIEhQb2ludChcbiAgICB4LFxuICAgIHksXG4gICAgbGFzdFBvaW50T2ZDb250b3VyLFxuICAgIG9uQ3VydmVcbikge1xuICAgIHRoaXMueCA9IHRoaXMueG8gPSBNYXRoLnJvdW5kKHggKiA2NCkgLyA2NDsgLy8gaGludGVkIHggdmFsdWUgYW5kIG9yaWdpbmFsIHgtdmFsdWVcbiAgICB0aGlzLnkgPSB0aGlzLnlvID0gTWF0aC5yb3VuZCh5ICogNjQpIC8gNjQ7IC8vIGhpbnRlZCB5IHZhbHVlIGFuZCBvcmlnaW5hbCB5LXZhbHVlXG5cbiAgICB0aGlzLmxhc3RQb2ludE9mQ29udG91ciA9IGxhc3RQb2ludE9mQ29udG91cjtcbiAgICB0aGlzLm9uQ3VydmUgPSBvbkN1cnZlO1xuICAgIHRoaXMucHJldlBvaW50T25Db250b3VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubmV4dFBvaW50T25Db250b3VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueFRvdWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLnlUb3VjaGVkID0gZmFsc2U7XG5cbiAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG59XG5cbi8qXG4qIFJldHVybnMgdGhlIG5leHQgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91ci5cbipcbiogdiAgLi4uIHVuaXQgdmVjdG9yIHRvIHRlc3QgdG91Y2ggYXhpcy5cbiovXG5IUG9pbnQucHJvdG90eXBlLm5leHRUb3VjaGVkID0gZnVuY3Rpb24odikge1xuICAgIHZhciBwID0gdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXI7XG5cbiAgICB3aGlsZSAoIXYudG91Y2hlZChwKSAmJiBwICE9PSB0aGlzKSB7IHAgPSBwLm5leHRQb2ludE9uQ29udG91cjsgfVxuXG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKlxuKiBSZXR1cm5zIHRoZSBwcmV2aW91cyB0b3VjaGVkIHBvaW50IG9uIHRoZSBjb250b3VyXG4qXG4qIHYgIC4uLiB1bml0IHZlY3RvciB0byB0ZXN0IHRvdWNoIGF4aXMuXG4qL1xuSFBvaW50LnByb3RvdHlwZS5wcmV2VG91Y2hlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcCA9IHRoaXMucHJldlBvaW50T25Db250b3VyO1xuXG4gICAgd2hpbGUgKCF2LnRvdWNoZWQocCkgJiYgcCAhPT0gdGhpcykgeyBwID0gcC5wcmV2UG9pbnRPbkNvbnRvdXI7IH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLypcbiogVGhlIHplcm8gcG9pbnQuXG4qL1xudmFyIEhQWmVybyA9IE9iamVjdC5mcmVlemUobmV3IEhQb2ludCgwLCAwKSk7XG5cbi8qXG4qIFRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSBpbnRlcnByZXRlci5cbipcbiogTm90ZTogRnJlZXppbmcgdGhlIGRlZmF1bHRTdGF0ZSBhbmQgdGhlbiBkZXJpdmluZyBmcm9tIGl0XG4qIG1ha2VzIHRoZSBWOCBKYXZhc2NyaXB0IGVuZ2luZSBnb2luZyBhd2t3YXJkLFxuKiBzbyB0aGlzIGlzIGF2b2lkZWQsIGFsYmVpdCB0aGUgZGVmYXVsdFN0YXRlIHNob3VsZG4ndFxuKiBldmVyIGNoYW5nZS5cbiovXG52YXIgZGVmYXVsdFN0YXRlID0ge1xuICAgIGN2Q3V0SW46IDE3IC8gMTYsICAgIC8vIGNvbnRyb2wgdmFsdWUgY3V0IGluXG4gICAgZGVsdGFCYXNlOiA5LFxuICAgIGRlbHRhU2hpZnQ6IDAuMTI1LFxuICAgIGxvb3A6IDEsICAgICAgICAgICAgIC8vIGxvb3BzIHNvbWUgaW5zdHJ1Y3Rpb25zXG4gICAgbWluRGlzOiAxLCAgICAgICAgICAgLy8gbWluaW11bSBkaXN0YW5jZVxuICAgIGF1dG9GbGlwOiB0cnVlXG59O1xuXG4vKlxuKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaW50ZXJwcmV0ZXIuXG4qXG4qIGVudiAgLi4uICdmcGdtJyBvciAncHJlcCcgb3IgJ2dseWYnXG4qIHByb2cgLi4uIHRoZSBwcm9ncmFtXG4qL1xuZnVuY3Rpb24gU3RhdGUoZW52LCBwcm9nKSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMucHJvZyA9IHByb2c7XG5cbiAgICBzd2l0Y2ggKGVudikge1xuICAgICAgICBjYXNlICdnbHlmJyA6XG4gICAgICAgICAgICB0aGlzLnpwMCA9IHRoaXMuenAxID0gdGhpcy56cDIgPSAxO1xuICAgICAgICAgICAgdGhpcy5ycDAgPSB0aGlzLnJwMSA9IHRoaXMucnAyID0gMDtcbiAgICAgICAgICAgIC8qIGZhbGwgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdwcmVwJyA6XG4gICAgICAgICAgICB0aGlzLmZ2ID0gdGhpcy5wdiA9IHRoaXMuZHB2ID0geFVuaXRWZWN0b3I7XG4gICAgICAgICAgICB0aGlzLnJvdW5kID0gcm91bmRUb0dyaWQ7XG4gICAgfVxufVxuXG4vKlxuKiBFeGVjdXRlcyBhIGdseXBoIHByb2dyYW0uXG4qXG4qIFRoaXMgZG9lcyB0aGUgaGludGluZyBmb3IgZWFjaCBnbHlwaC5cbipcbiogUmV0dXJucyBhbiBhcnJheSBvZiBtb3ZlZCBwb2ludHMuXG4qXG4qIGdseXBoOiB0aGUgZ2x5cGggdG8gaGludFxuKiBwcGVtOiB0aGUgc2l6ZSB0aGUgZ2x5cGggaXMgcmVuZGVyZWQgZm9yXG4qL1xuSGludGluZy5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGdseXBoLCBwcGVtKSB7XG4gICAgaWYgKHR5cGVvZiBwcGVtICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IHNpemUgaXMgbm90IGEgbnVtYmVyIScpO1xuICAgIH1cblxuICAgIC8vIFJlY2VpdmVkIGEgZmF0YWwgZXJyb3IsIGRvbid0IGRvIGFueSBoaW50aW5nIGFueW1vcmUuXG4gICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPiAyKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgdmFyIHByZXBTdGF0ZSA9IHRoaXMuX3ByZXBTdGF0ZTtcblxuICAgIGlmICghcHJlcFN0YXRlIHx8IHByZXBTdGF0ZS5wcGVtICE9PSBwcGVtKSB7XG4gICAgICAgIHZhciBmcGdtU3RhdGUgPSB0aGlzLl9mcGdtU3RhdGU7XG5cbiAgICAgICAgaWYgKCFmcGdtU3RhdGUpIHtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGVzIHRoZSBmcGdtIHN0YXRlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IGZvbnRzIHRvIGRlZmluZSBmdW5jdGlvbnMuXG4gICAgICAgICAgICBTdGF0ZS5wcm90b3R5cGUgPSBkZWZhdWx0U3RhdGU7XG5cbiAgICAgICAgICAgIGZwZ21TdGF0ZSA9XG4gICAgICAgICAgICB0aGlzLl9mcGdtU3RhdGUgPVxuICAgICAgICAgICAgICAgIG5ldyBTdGF0ZSgnZnBnbScsIGZvbnQudGFibGVzLmZwZ20pO1xuXG4gICAgICAgICAgICBmcGdtU3RhdGUuZnVuY3MgPSBbIF07XG4gICAgICAgICAgICBmcGdtU3RhdGUuZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgRlBHTS0tLScpO1xuICAgICAgICAgICAgICAgIGZwZ21TdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXhlYyhmcGdtU3RhdGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yIGluIEZQR006JyArIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4ZWN1dGVzIHRoZSBwcmVwIHByb2dyYW0gZm9yIHRoaXMgcHBlbSBzZXR0aW5nLlxuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgZm9udHMgdG8gc2V0IGN2dCB2YWx1ZXNcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRvIGJlIHJlbmRlcmVkIGZvbnQgc2l6ZS5cblxuICAgICAgICBTdGF0ZS5wcm90b3R5cGUgPSBmcGdtU3RhdGU7XG4gICAgICAgIHByZXBTdGF0ZSA9XG4gICAgICAgIHRoaXMuX3ByZXBTdGF0ZSA9XG4gICAgICAgICAgICBuZXcgU3RhdGUoJ3ByZXAnLCBmb250LnRhYmxlcy5wcmVwKTtcblxuICAgICAgICBwcmVwU3RhdGUucHBlbSA9IHBwZW07XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGN2dCB0YWJsZVxuICAgICAgICAvLyBhbmQgc2NhbGVzIGl0IHRvIHRoZSBjdXJyZW50IHBwZW0gc2V0dGluZy5cbiAgICAgICAgdmFyIG9DdnQgPSBmb250LnRhYmxlcy5jdnQ7XG4gICAgICAgIGlmIChvQ3Z0KSB7XG4gICAgICAgICAgICB2YXIgY3Z0ID0gcHJlcFN0YXRlLmN2dCA9IG5ldyBBcnJheShvQ3Z0Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBwcGVtIC8gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvQ3Z0Lmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgY3Z0W2NdID0gb0N2dFtjXSAqIHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlcFN0YXRlLmN2dCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIFBSRVAtLS0nKTtcbiAgICAgICAgICAgIHByZXBTdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXhlYyhwcmVwU3RhdGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvciBpbiBQUkVQOicgKyBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPiAxKSB7IHJldHVybjsgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV4ZWNHbHlwaChnbHlwaCwgcHJlcFN0YXRlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnJvclN0YXRlIDwgMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3I6JyArIGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vdGU6IGZ1cnRoZXIgaGludGluZyBlcnJvcnMgYXJlIHNpbGVuY2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDE7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLypcbiogRXhlY3V0ZXMgdGhlIGhpbnRpbmcgcHJvZ3JhbSBmb3IgYSBnbHlwaC5cbiovXG5leGVjR2x5cGggPSBmdW5jdGlvbihnbHlwaCwgcHJlcFN0YXRlKSB7XG4gICAgLy8gb3JpZ2luYWwgcG9pbnQgcG9zaXRpb25zXG4gICAgdmFyIHhTY2FsZSA9IHByZXBTdGF0ZS5wcGVtIC8gcHJlcFN0YXRlLmZvbnQudW5pdHNQZXJFbTtcbiAgICB2YXIgeVNjYWxlID0geFNjYWxlO1xuICAgIHZhciBjb21wb25lbnRzID0gZ2x5cGguY29tcG9uZW50cztcbiAgICB2YXIgY29udG91cnM7XG4gICAgdmFyIGdab25lO1xuICAgIHZhciBzdGF0ZTtcblxuICAgIFN0YXRlLnByb3RvdHlwZSA9IHByZXBTdGF0ZTtcbiAgICBpZiAoIWNvbXBvbmVudHMpIHtcbiAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBnbHlwaC5pbnN0cnVjdGlvbnMpO1xuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgR0xZUEgtLS0nKTtcbiAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBleGVjQ29tcG9uZW50KGdseXBoLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpO1xuICAgICAgICBnWm9uZSA9IHN0YXRlLmdab25lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb250ID0gcHJlcFN0YXRlLmZvbnQ7XG4gICAgICAgIGdab25lID0gW107XG4gICAgICAgIGNvbnRvdXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIGNnID0gZm9udC5nbHlwaHMuZ2V0KGMuZ2x5cGhJbmRleCk7XG5cbiAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgY2cuaW5zdHJ1Y3Rpb25zKTtcblxuICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBDT01QICcgKyBpICsgJy0tLScpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhlY0NvbXBvbmVudChjZywgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKTtcbiAgICAgICAgICAgIC8vIGFwcGVuZHMgdGhlIGNvbXB1dGVkIHBvaW50cyB0byB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICAvLyBwb3N0IHByb2Nlc3NlcyB0aGUgY29tcG9uZW50IHBvaW50c1xuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5yb3VuZChjLmR4ICogeFNjYWxlKTtcbiAgICAgICAgICAgIHZhciBkeSA9IE1hdGgucm91bmQoYy5keSAqIHlTY2FsZSk7XG4gICAgICAgICAgICB2YXIgZ3ogPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIHZhciBjYyA9IHN0YXRlLmNvbnRvdXJzO1xuICAgICAgICAgICAgZm9yICh2YXIgcGkgPSAwOyBwaSA8IGd6Lmxlbmd0aDsgcGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gZ3pbcGldO1xuICAgICAgICAgICAgICAgIHAueFRvdWNoZWQgPSBwLnlUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcC54byA9IHAueCA9IHAueCArIGR4O1xuICAgICAgICAgICAgICAgIHAueW8gPSBwLnkgPSBwLnkgKyBkeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdMZW4gPSBnWm9uZS5sZW5ndGg7XG4gICAgICAgICAgICBnWm9uZS5wdXNoLmFwcGx5KGdab25lLCBneik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNjLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29udG91cnMucHVzaChjY1tqXSArIGdMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdseXBoLmluc3RydWN0aW9ucyAmJiAhc3RhdGUuaW5oaWJpdEdyaWRGaXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb3NpdGUgaGFzIGluc3RydWN0aW9ucyBvbiBpdHMgb3duXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGdseXBoLmluc3RydWN0aW9ucyk7XG5cbiAgICAgICAgICAgIHN0YXRlLmdab25lID0gc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gZ1pvbmU7XG5cbiAgICAgICAgICAgIHN0YXRlLmNvbnRvdXJzID0gY29udG91cnM7XG5cbiAgICAgICAgICAgIC8vIG5vdGU6IEhQWmVybyBjYW5ub3QgYmUgdXNlZCBoZXJlLCBzaW5jZVxuICAgICAgICAgICAgLy8gICAgICAgdGhlIHBvaW50IG1pZ2h0IGJlIG1vZGlmaWVkXG4gICAgICAgICAgICBnWm9uZS5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG4gICAgICAgICAgICAgICAgbmV3IEhQb2ludChNYXRoLnJvdW5kKGdseXBoLmFkdmFuY2VXaWR0aCAqIHhTY2FsZSksIDApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIENPTVBPU0lURS0tLScpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAgICAgICAgIGdab25lLmxlbmd0aCAtPSAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdab25lO1xufTtcblxuLypcbiogRXhlY3V0ZXMgdGhlIGhpbnRpbmcgcHJvZ3JhbSBmb3IgYSBjb21wb25lbnQgb2YgYSBtdWx0aS1jb21wb25lbnQgZ2x5cGhcbiogb3Igb2YgdGhlIGdseXBoIGl0c2VsZiBmb3IgYSBub24tY29tcG9uZW50IGdseXBoLlxuKi9cbmV4ZWNDb21wb25lbnQgPSBmdW5jdGlvbihnbHlwaCwgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKVxue1xuICAgIHZhciBwb2ludHMgPSBnbHlwaC5wb2ludHMgfHwgW107XG4gICAgdmFyIHBMZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBnWm9uZSA9IHN0YXRlLmdab25lID0gc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gW107XG4gICAgdmFyIGNvbnRvdXJzID0gc3RhdGUuY29udG91cnMgPSBbXTtcblxuICAgIC8vIFNjYWxlcyB0aGUgb3JpZ2luYWwgcG9pbnRzIGFuZFxuICAgIC8vIG1ha2VzIGNvcGllcyBmb3IgdGhlIGhpbnRlZCBwb2ludHMuXG4gICAgdmFyIGNwOyAvLyBjdXJyZW50IHBvaW50XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcbiAgICAgICAgY3AgPSBwb2ludHNbaV07XG5cbiAgICAgICAgZ1pvbmVbaV0gPSBuZXcgSFBvaW50KFxuICAgICAgICAgICAgY3AueCAqIHhTY2FsZSxcbiAgICAgICAgICAgIGNwLnkgKiB5U2NhbGUsXG4gICAgICAgICAgICBjcC5sYXN0UG9pbnRPZkNvbnRvdXIsXG4gICAgICAgICAgICBjcC5vbkN1cnZlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2hhaW4gbGlua3MgdGhlIGNvbnRvdXJzLlxuICAgIHZhciBzcDsgLy8gc3RhcnQgcG9pbnRcbiAgICB2YXIgbnA7IC8vIG5leHQgcG9pbnRcblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBMZW47IGkkMSsrKSB7XG4gICAgICAgIGNwID0gZ1pvbmVbaSQxXTtcblxuICAgICAgICBpZiAoIXNwKSB7XG4gICAgICAgICAgICBzcCA9IGNwO1xuICAgICAgICAgICAgY29udG91cnMucHVzaChpJDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNwLmxhc3RQb2ludE9mQ29udG91cikge1xuICAgICAgICAgICAgY3AubmV4dFBvaW50T25Db250b3VyID0gc3A7XG4gICAgICAgICAgICBzcC5wcmV2UG9pbnRPbkNvbnRvdXIgPSBjcDtcbiAgICAgICAgICAgIHNwID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnAgPSBnWm9uZVtpJDEgKyAxXTtcbiAgICAgICAgICAgIGNwLm5leHRQb2ludE9uQ29udG91ciA9IG5wO1xuICAgICAgICAgICAgbnAucHJldlBvaW50T25Db250b3VyID0gY3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuaW5oaWJpdEdyaWRGaXQpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZygnUFJPQ0VTU0lORyBHTFlQSCcsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcExlbjsgaSQyKyspIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGkkMiwgZ1pvbmVbaSQyXS54LCBnWm9uZVtpJDJdLnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ1pvbmUucHVzaChcbiAgICAgICAgbmV3IEhQb2ludCgwLCAwKSxcbiAgICAgICAgbmV3IEhQb2ludChNYXRoLnJvdW5kKGdseXBoLmFkdmFuY2VXaWR0aCAqIHhTY2FsZSksIDApXG4gICAgKTtcblxuICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgLy8gUmVtb3ZlcyB0aGUgZXh0cmEgcG9pbnRzLlxuICAgIGdab25lLmxlbmd0aCAtPSAyO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZJTklTSEVEIEdMWVBIJywgc3RhdGUuc3RhY2spO1xuICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBwTGVuOyBpJDMrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coaSQzLCBnWm9uZVtpJDNdLngsIGdab25lW2kkM10ueSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKlxuKiBFeGVjdXRlcyB0aGUgcHJvZ3JhbSBsb2FkZWQgaW4gc3RhdGUuXG4qL1xuZXhlYyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuXG4gICAgaWYgKCFwcm9nKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIHBMZW4gPSBwcm9nLmxlbmd0aDtcbiAgICB2YXIgaW5zO1xuXG4gICAgZm9yIChzdGF0ZS5pcCA9IDA7IHN0YXRlLmlwIDwgcExlbjsgc3RhdGUuaXArKykge1xuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBzdGF0ZS5zdGVwKys7IH1cbiAgICAgICAgaW5zID0gaW5zdHJ1Y3Rpb25UYWJsZVtwcm9nW3N0YXRlLmlwXV07XG5cbiAgICAgICAgaWYgKCFpbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAndW5rbm93biBpbnN0cnVjdGlvbjogMHgnICtcbiAgICAgICAgICAgICAgICBOdW1iZXIocHJvZ1tzdGF0ZS5pcF0pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucyhzdGF0ZSk7XG5cbiAgICAgICAgLy8gdmVyeSBleHRlbnNpdmUgZGVidWdnaW5nIGZvciBlYWNoIHN0ZXBcbiAgICAgICAgLypcbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIHZhciBkYTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5nWm9uZSkge1xuICAgICAgICAgICAgICAgIGRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5nWm9uZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nWm9uZVtpXS54ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ1pvbmVbaV0ueSAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5nWm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueVRvdWNoZWQgPyAneScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0daJywgZGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdGUudFpvbmUpIHtcbiAgICAgICAgICAgICAgICBkYSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudFpvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGEucHVzaChpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRab25lW2ldLnggKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50Wm9uZVtpXS55ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLnRab25lW2ldLnhUb3VjaGVkID8gJ3gnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS55VG91Y2hlZCA/ICd5JyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVFonLCBkYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFjay5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICcuLi4nLCBzdGF0ZS5zdGFjay5zbGljZShzdGF0ZS5zdGFjay5sZW5ndGggLSAxMClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5zdGFjay5sZW5ndGgsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgIH1cbn07XG5cbi8qXG4qIEluaXRpYWxpemVzIHRoZSB0d2lsaWdodCB6b25lLlxuKlxuKiBUaGlzIGlzIG9ubHkgZG9uZSBpZiBhIFNaUHggaW5zdHJ1Y3Rpb25cbiogcmVmZXJzIHRvIHRoZSB0d2lsaWdodCB6b25lLlxuKi9cbmZ1bmN0aW9uIGluaXRUWm9uZShzdGF0ZSlcbntcbiAgICB2YXIgdFpvbmUgPSBzdGF0ZS50Wm9uZSA9IG5ldyBBcnJheShzdGF0ZS5nWm9uZS5sZW5ndGgpO1xuXG4gICAgLy8gbm8gaWRlYSBpZiB0aGlzIGlzIGFjdHVhbGx5IGNvcnJlY3QuLi5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRab25lLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdFpvbmVbaV0gPSBuZXcgSFBvaW50KDAsIDApO1xuICAgIH1cbn1cblxuLypcbiogU2tpcHMgdGhlIGluc3RydWN0aW9uIHBvaW50ZXIgYWhlYWQgb3ZlciBhbiBJRi9FTFNFIGJsb2NrLlxuKiBoYW5kbGVFbHNlIC4uIGlmIHRydWUgYnJlYWtzIG9uIG1hdGNoaW5nIEVMU0VcbiovXG5mdW5jdGlvbiBza2lwKHN0YXRlLCBoYW5kbGVFbHNlKVxue1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgbmVzdGluZyA9IDE7XG4gICAgdmFyIGlucztcblxuICAgIGRvIHtcbiAgICAgICAgaW5zID0gcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKGlucyA9PT0gMHg1OCkgLy8gSUZcbiAgICAgICAgICAgIHsgbmVzdGluZysrOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg1OSkgLy8gRUlGXG4gICAgICAgICAgICB7IG5lc3RpbmctLTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDApIC8vIE5QVVNIQlxuICAgICAgICAgICAgeyBpcCArPSBwcm9nW2lwICsgMV0gKyAxOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg0MSkgLy8gTlBVU0hXXG4gICAgICAgICAgICB7IGlwICs9IDIgKiBwcm9nW2lwICsgMV0gKyAxOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA+PSAweEIwICYmIGlucyA8PSAweEI3KSAvLyBQVVNIQlxuICAgICAgICAgICAgeyBpcCArPSBpbnMgLSAweEIwICsgMTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCOCAmJiBpbnMgPD0gMHhCRikgLy8gUFVTSFdcbiAgICAgICAgICAgIHsgaXAgKz0gKGlucyAtIDB4QjggKyAxKSAqIDI7IH1cbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlRWxzZSAmJiBuZXN0aW5nID09PSAxICYmIGlucyA9PT0gMHgxQikgLy8gRUxTRVxuICAgICAgICAgICAgeyBicmVhazsgfVxuICAgIH0gd2hpbGUgKG5lc3RpbmcgPiAwKTtcblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcbiogICAgICAgICAgQW5kIHRoZW4gYSBsb3Qgb2YgaW5zdHJ1Y3Rpb25zLi4uICAgICAgICAgICAgICAgICpcbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy8gU1ZUQ0FbYV0gU2V0IGZyZWVkb20gYW5kIHByb2plY3Rpb24gVmVjdG9ycyBUbyBDb29yZGluYXRlIEF4aXNcbi8vIDB4MDAtMHgwMVxuZnVuY3Rpb24gU1ZUQ0Eodiwgc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1ZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIHN0YXRlLmZ2ID0gc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xufVxuXG4vLyBTUFZUQ0FbYV0gU2V0IFByb2plY3Rpb24gVmVjdG9yIHRvIENvb3JkaW5hdGUgQXhpc1xuLy8gMHgwMi0weDAzXG5mdW5jdGlvbiBTUFZUQ0Eodiwgc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IHY7XG59XG5cbi8vIFNGVlRDQVthXSBTZXQgRnJlZWRvbSBWZWN0b3IgdG8gQ29vcmRpbmF0ZSBBeGlzXG4vLyAweDA0LTB4MDVcbmZ1bmN0aW9uIFNGVlRDQSh2LCBzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIHN0YXRlLmZ2ID0gdjtcbn1cblxuLy8gU1BWVExbYV0gU2V0IFByb2plY3Rpb24gVmVjdG9yIFRvIExpbmVcbi8vIDB4MDYtMHgwN1xuZnVuY3Rpb24gU1BWVEwoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdTUFZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuXG4gICAgaWYgKCFhKSB7XG4gICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICB9XG5cbiAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcbn1cblxuLy8gU0ZWVExbYV0gU2V0IEZyZWVkb20gVmVjdG9yIFRvIExpbmVcbi8vIDB4MDgtMHgwOVxuZnVuY3Rpb24gU0ZWVEwoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdTRlZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuXG4gICAgaWYgKCFhKSB7XG4gICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICB9XG5cbiAgICBzdGF0ZS5mdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcbn1cblxuLy8gU1BWRlNbXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgRnJvbSBTdGFja1xuLy8gMHgwQVxuZnVuY3Rpb24gU1BWRlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgeSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB4ID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWRlNbXScsIHksIHgpOyB9XG5cbiAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG59XG5cbi8vIFNGVkZTW10gU2V0IEZyZWVkb20gVmVjdG9yIEZyb20gU3RhY2tcbi8vIDB4MEJcbmZ1bmN0aW9uIFNGVkZTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgeCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVkZTW10nLCB5LCB4KTsgfVxuXG4gICAgc3RhdGUuZnYgPSBnZXRVbml0VmVjdG9yKHgsIHkpO1xufVxuXG4vLyBHUFZbXSBHZXQgUHJvamVjdGlvbiBWZWN0b3Jcbi8vIDB4MENcbmZ1bmN0aW9uIEdQVihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dQVltdJyk7IH1cblxuICAgIHN0YWNrLnB1c2gocHYueCAqIDB4NDAwMCk7XG4gICAgc3RhY2sucHVzaChwdi55ICogMHg0MDAwKTtcbn1cblxuLy8gR0ZWW10gR2V0IEZyZWVkb20gVmVjdG9yXG4vLyAweDBDXG5mdW5jdGlvbiBHRlYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHRlZbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKGZ2LnggKiAweDQwMDApO1xuICAgIHN0YWNrLnB1c2goZnYueSAqIDB4NDAwMCk7XG59XG5cbi8vIFNGVlRQVltdIFNldCBGcmVlZG9tIFZlY3RvciBUbyBQcm9qZWN0aW9uIFZlY3RvclxuLy8gMHgwRVxuZnVuY3Rpb24gU0ZWVFBWKHN0YXRlKSB7XG4gICAgc3RhdGUuZnYgPSBzdGF0ZS5wdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUUFZbXScpOyB9XG59XG5cbi8vIElTRUNUW10gbW92ZXMgcG9pbnQgcCB0byB0aGUgSW50ZXJTRUNUaW9uIG9mIHR3byBsaW5lc1xuLy8gMHgwRlxuZnVuY3Rpb24gSVNFQ1Qoc3RhdGUpXG57XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHBhMGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGExaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwYjBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBiMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgejAgPSBzdGF0ZS56MDtcbiAgICB2YXIgejEgPSBzdGF0ZS56MTtcbiAgICB2YXIgcGEwID0gejBbcGEwaV07XG4gICAgdmFyIHBhMSA9IHowW3BhMWldO1xuICAgIHZhciBwYjAgPSB6MVtwYjBpXTtcbiAgICB2YXIgcGIxID0gejFbcGIxaV07XG4gICAgdmFyIHAgPSBzdGF0ZS56MltwaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnSVNFQ1RbXSwgJywgcGEwaSwgcGExaSwgcGIwaSwgcGIxaSwgcGkpOyB9XG5cbiAgICAvLyBtYXRoIGZyb21cbiAgICAvLyBlbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZSVFMiU4MCU5M2xpbmVfaW50ZXJzZWN0aW9uI0dpdmVuX3R3b19wb2ludHNfb25fZWFjaF9saW5lXG5cbiAgICB2YXIgeDEgPSBwYTAueDtcbiAgICB2YXIgeTEgPSBwYTAueTtcbiAgICB2YXIgeDIgPSBwYTEueDtcbiAgICB2YXIgeTIgPSBwYTEueTtcbiAgICB2YXIgeDMgPSBwYjAueDtcbiAgICB2YXIgeTMgPSBwYjAueTtcbiAgICB2YXIgeDQgPSBwYjEueDtcbiAgICB2YXIgeTQgPSBwYjEueTtcblxuICAgIHZhciBkaXYgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG4gICAgdmFyIGYxID0geDEgKiB5MiAtIHkxICogeDI7XG4gICAgdmFyIGYyID0geDMgKiB5NCAtIHkzICogeDQ7XG5cbiAgICBwLnggPSAoZjEgKiAoeDMgLSB4NCkgLSBmMiAqICh4MSAtIHgyKSkgLyBkaXY7XG4gICAgcC55ID0gKGYxICogKHkzIC0geTQpIC0gZjIgKiAoeTEgLSB5MikpIC8gZGl2O1xufVxuXG4vLyBTUlAwW10gU2V0IFJlZmVyZW5jZSBQb2ludCAwXG4vLyAweDEwXG5mdW5jdGlvbiBTUlAwKHN0YXRlKSB7XG4gICAgc3RhdGUucnAwID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMFtdJywgc3RhdGUucnAwKTsgfVxufVxuXG4vLyBTUlAxW10gU2V0IFJlZmVyZW5jZSBQb2ludCAxXG4vLyAweDExXG5mdW5jdGlvbiBTUlAxKHN0YXRlKSB7XG4gICAgc3RhdGUucnAxID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMVtdJywgc3RhdGUucnAxKTsgfVxufVxuXG4vLyBTUlAxW10gU2V0IFJlZmVyZW5jZSBQb2ludCAyXG4vLyAweDEyXG5mdW5jdGlvbiBTUlAyKHN0YXRlKSB7XG4gICAgc3RhdGUucnAyID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMltdJywgc3RhdGUucnAyKTsgfVxufVxuXG4vLyBTWlAwW10gU2V0IFpvbmUgUG9pbnRlciAwXG4vLyAweDEzXG5mdW5jdGlvbiBTWlAwKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAwW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAwID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlAxW10gU2V0IFpvbmUgUG9pbnRlciAxXG4vLyAweDE0XG5mdW5jdGlvbiBTWlAxKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAxW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAxID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlAyW10gU2V0IFpvbmUgUG9pbnRlciAyXG4vLyAweDE1XG5mdW5jdGlvbiBTWlAyKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAyW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAyID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlBTW10gU2V0IFpvbmUgUG9pbnRlclNcbi8vIDB4MTZcbmZ1bmN0aW9uIFNaUFMoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUFNbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS56cDAgPSBzdGF0ZS56cDEgPSBzdGF0ZS56cDIgPSBuO1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU0xPT1BbXSBTZXQgTE9PUCB2YXJpYWJsZVxuLy8gMHgxN1xuZnVuY3Rpb24gU0xPT1Aoc3RhdGUpIHtcbiAgICBzdGF0ZS5sb29wID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0xPT1BbXScsIHN0YXRlLmxvb3ApOyB9XG59XG5cbi8vIFJUR1tdIFJvdW5kIFRvIEdyaWRcbi8vIDB4MThcbmZ1bmN0aW9uIFJURyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9HcmlkO1xufVxuXG4vLyBSVEhHW10gUm91bmQgVG8gSGFsZiBHcmlkXG4vLyAweDE5XG5mdW5jdGlvbiBSVEhHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUSEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9IYWxmR3JpZDtcbn1cblxuLy8gU01EW10gU2V0IE1pbmltdW0gRGlzdGFuY2Vcbi8vIDB4MUFcbmZ1bmN0aW9uIFNNRChzdGF0ZSkge1xuICAgIHZhciBkID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU01EW10nLCBkKTsgfVxuXG4gICAgc3RhdGUubWluRGlzID0gZCAvIDB4NDA7XG59XG5cbi8vIEVMU0VbXSBFTFNFIGNsYXVzZVxuLy8gMHgxQlxuZnVuY3Rpb24gRUxTRShzdGF0ZSkge1xuICAgIC8vIFRoaXMgaW5zdHJ1Y3Rpb24gaGFzIGJlZW4gcmVhY2hlZCBieSBleGVjdXRpbmcgYSB0aGVuIGJyYW5jaFxuICAgIC8vIHNvIGl0IGp1c3Qgc2tpcHMgYWhlYWQgdW50aWwgbWF0Y2hpbmcgRUlGLlxuICAgIC8vXG4gICAgLy8gSW4gY2FzZSB0aGUgSUYgd2FzIG5lZ2F0aXZlIHRoZSBJRltdIGluc3RydWN0aW9uIGFscmVhZHlcbiAgICAvLyBza2lwcGVkIGZvcndhcmQgb3ZlciB0aGUgRUxTRVtdXG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRUxTRVtdJyk7IH1cblxuICAgIHNraXAoc3RhdGUsIGZhbHNlKTtcbn1cblxuLy8gSk1QUltdIEp1TVAgUmVsYXRpdmVcbi8vIDB4MUNcbmZ1bmN0aW9uIEpNUFIoc3RhdGUpIHtcbiAgICB2YXIgbyA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0pNUFJbXScsIG8pOyB9XG5cbiAgICAvLyBBIGp1bXAgYnkgMSB3b3VsZCBkbyBub3RoaW5nLlxuICAgIHN0YXRlLmlwICs9IG8gLSAxO1xufVxuXG4vLyBTQ1ZUQ0lbXSBTZXQgQ29udHJvbCBWYWx1ZSBUYWJsZSBDdXQtSW5cbi8vIDB4MURcbmZ1bmN0aW9uIFNDVlRDSShzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NWVENJW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuY3ZDdXRJbiA9IG4gLyAweDQwO1xufVxuXG4vLyBEVVBbXSBEVVBsaWNhdGUgdG9wIHN0YWNrIGVsZW1lbnRcbi8vIDB4MjBcbmZ1bmN0aW9uIERVUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RVUFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pO1xufVxuXG4vLyBQT1BbXSBQT1AgdG9wIHN0YWNrIGVsZW1lbnRcbi8vIDB4MjFcbmZ1bmN0aW9uIFBPUChzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdQT1BbXScpOyB9XG5cbiAgICBzdGF0ZS5zdGFjay5wb3AoKTtcbn1cblxuLy8gQ0xFQVJbXSBDTEVBUiB0aGUgc3RhY2tcbi8vIDB4MjJcbmZ1bmN0aW9uIENMRUFSKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NMRUFSW10nKTsgfVxuXG4gICAgc3RhdGUuc3RhY2subGVuZ3RoID0gMDtcbn1cblxuLy8gU1dBUFtdIFNXQVAgdGhlIHRvcCB0d28gZWxlbWVudHMgb24gdGhlIHN0YWNrXG4vLyAweDIzXG5mdW5jdGlvbiBTV0FQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICB2YXIgYSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBiID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1dBUFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goYSk7XG4gICAgc3RhY2sucHVzaChiKTtcbn1cblxuLy8gREVQVEhbXSBERVBUSCBvZiB0aGUgc3RhY2tcbi8vIDB4MjRcbmZ1bmN0aW9uIERFUFRIKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVQVEhbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YWNrLmxlbmd0aCk7XG59XG5cbi8vIExPT1BDQUxMW10gTE9PUENBTEwgZnVuY3Rpb25cbi8vIDB4MkFcbmZ1bmN0aW9uIExPT1BDQUxMKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGZuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMT09QQ0FMTFtdJywgZm4sIGMpOyB9XG5cbiAgICAvLyBzYXZlcyBjYWxsZXJzIHByb2dyYW1cbiAgICB2YXIgY2lwID0gc3RhdGUuaXA7XG4gICAgdmFyIGNwcm9nID0gc3RhdGUucHJvZztcblxuICAgIHN0YXRlLnByb2cgPSBzdGF0ZS5mdW5jc1tmbl07XG5cbiAgICAvLyBleGVjdXRlcyB0aGUgZnVuY3Rpb25cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7IGkrKykge1xuICAgICAgICBleGVjKHN0YXRlKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICsrc3RhdGUuc3RlcCxcbiAgICAgICAgICAgIGkgKyAxIDwgYyA/ICduZXh0IGxvb3BjYWxsJyA6ICdkb25lIGxvb3BjYWxsJyxcbiAgICAgICAgICAgIGlcbiAgICAgICAgKTsgfVxuICAgIH1cblxuICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cbiAgICBzdGF0ZS5pcCA9IGNpcDtcbiAgICBzdGF0ZS5wcm9nID0gY3Byb2c7XG59XG5cbi8vIENBTExbXSBDQUxMIGZ1bmN0aW9uXG4vLyAweDJCXG5mdW5jdGlvbiBDQUxMKHN0YXRlKSB7XG4gICAgdmFyIGZuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0FMTFtdJywgZm4pOyB9XG5cbiAgICAvLyBzYXZlcyBjYWxsZXJzIHByb2dyYW1cbiAgICB2YXIgY2lwID0gc3RhdGUuaXA7XG4gICAgdmFyIGNwcm9nID0gc3RhdGUucHJvZztcblxuICAgIHN0YXRlLnByb2cgPSBzdGF0ZS5mdW5jc1tmbl07XG5cbiAgICAvLyBleGVjdXRlcyB0aGUgZnVuY3Rpb25cbiAgICBleGVjKHN0YXRlKTtcblxuICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cbiAgICBzdGF0ZS5pcCA9IGNpcDtcbiAgICBzdGF0ZS5wcm9nID0gY3Byb2c7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygrK3N0YXRlLnN0ZXAsICdyZXR1cm5pbmcgZnJvbScsIGZuKTsgfVxufVxuXG4vLyBDSU5ERVhbXSBDb3B5IHRoZSBJTkRFWGVkIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbi8vIDB4MjVcbmZ1bmN0aW9uIENJTkRFWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBrID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0lOREVYW10nLCBrKTsgfVxuXG4gICAgLy8gSW4gY2FzZSBvZiBrID09IDEsIGl0IGNvcGllcyB0aGUgbGFzdCBlbGVtZW50IGFmdGVyIHBvcHBpbmdcbiAgICAvLyB0aHVzIHN0YWNrLmxlbmd0aCAtIGsuXG4gICAgc3RhY2sucHVzaChzdGFja1tzdGFjay5sZW5ndGggLSBrXSk7XG59XG5cbi8vIE1JTkRFWFtdIE1vdmUgdGhlIElOREVYZWQgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuLy8gMHgyNlxuZnVuY3Rpb24gTUlOREVYKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGsgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5ERVhbXScsIGspOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBrLCAxKVswXSk7XG59XG5cbi8vIEZERUZbXSBGdW5jdGlvbiBERUZpbml0aW9uXG4vLyAweDJDXG5mdW5jdGlvbiBGREVGKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVudiAhPT0gJ2ZwZ20nKSB7IHRocm93IG5ldyBFcnJvcignRkRFRiBub3QgYWxsb3dlZCBoZXJlJyk7IH1cbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG5cbiAgICB2YXIgZm4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgaXBCZWdpbiA9IGlwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZERUZbXScsIGZuKTsgfVxuXG4gICAgd2hpbGUgKHByb2dbKytpcF0gIT09IDB4MkQpeyB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xuICAgIHN0YXRlLmZ1bmNzW2ZuXSA9IHByb2cuc2xpY2UoaXBCZWdpbiArIDEsIGlwKTtcbn1cblxuLy8gTURBUFthXSBNb3ZlIERpcmVjdCBBYnNvbHV0ZSBQb2ludFxuLy8gMHgyRS0weDJGXG5mdW5jdGlvbiBNREFQKHJvdW5kLCBzdGF0ZSkge1xuICAgIHZhciBwaSA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejBbcGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01EQVBbJyArIHJvdW5kICsgJ10nLCBwaSk7IH1cblxuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuICAgIGlmIChyb3VuZCkgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIEhQWmVybywgZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgc3RhdGUucnAwID0gc3RhdGUucnAxID0gcGk7XG59XG5cbi8vIElVUFthXSBJbnRlcnBvbGF0ZSBVbnRvdWNoZWQgUG9pbnRzIHRocm91Z2ggdGhlIG91dGxpbmVcbi8vIDB4MzBcbmZ1bmN0aW9uIElVUCh2LCBzdGF0ZSkge1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuICAgIHZhciBwTGVuID0gejIubGVuZ3RoIC0gMjtcbiAgICB2YXIgY3A7XG4gICAgdmFyIHBwO1xuICAgIHZhciBucDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJVVBbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICAgIGNwID0gejJbaV07IC8vIGN1cnJlbnQgcG9pbnRcblxuICAgICAgICAvLyBpZiB0aGlzIHBvaW50IGhhcyBiZWVuIHRvdWNoZWQgZ28gb25cbiAgICAgICAgaWYgKHYudG91Y2hlZChjcCkpIHsgY29udGludWU7IH1cblxuICAgICAgICBwcCA9IGNwLnByZXZUb3VjaGVkKHYpO1xuXG4gICAgICAgIC8vIG5vIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWQ/XG4gICAgICAgIGlmIChwcCA9PT0gY3ApIHsgY29udGludWU7IH1cblxuICAgICAgICBucCA9IGNwLm5leHRUb3VjaGVkKHYpO1xuXG4gICAgICAgIGlmIChwcCA9PT0gbnApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgb25lIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWRcbiAgICAgICAgICAgIC8vIHNvIHNpbXBseSBtb3ZlcyB0aGUgcG9pbnQgbGlrZSB0aGF0XG5cbiAgICAgICAgICAgIHYuc2V0UmVsYXRpdmUoY3AsIGNwLCB2LmRpc3RhbmNlKHBwLCBwcCwgZmFsc2UsIHRydWUpLCB2LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHYuaW50ZXJwb2xhdGUoY3AsIHBwLCBucCwgdik7XG4gICAgfVxufVxuXG4vLyBTSFBbXSBTSGlmdCBQb2ludCB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzItMHgzM1xuZnVuY3Rpb24gU0hQKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuICAgIHdoaWxlIChsb29wLS0pXG4gICAge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICBmdi50b3VjaChwKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6XG4gICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAnU0hQWycgKyAoYSA/ICdycDEnIDogJ3JwMicpICsgJ10nLCBwaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBTSENbXSBTSGlmdCBDb250b3VyIHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuLy8gMHgzNi0weDM3XG5mdW5jdGlvbiBTSEMoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcbiAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIGNpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHNwID0gc3RhdGUuejJbc3RhdGUuY29udG91cnNbY2ldXTtcbiAgICB2YXIgcCA9IHNwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NIQ1snICsgYSArICddJywgY2kpOyB9XG5cbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAocCAhPT0gcnApIHsgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpOyB9XG4gICAgICAgIHAgPSBwLm5leHRQb2ludE9uQ29udG91cjtcbiAgICB9IHdoaWxlIChwICE9PSBzcCk7XG59XG5cbi8vIFNIWltdIFNIaWZ0IFpvbmUgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG4vLyAweDM2LTB4MzdcbmZ1bmN0aW9uIFNIWihhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0haWycgKyBhICsgJ10nLCBlKTsgfVxuXG4gICAgdmFyIHo7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgMCA6IHogPSBzdGF0ZS50Wm9uZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6IHogPSBzdGF0ZS5nWm9uZTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZScpO1xuICAgIH1cblxuICAgIHZhciBwO1xuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdmFyIHBMZW4gPSB6Lmxlbmd0aCAtIDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspXG4gICAge1xuICAgICAgICBwID0geltpXTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICAvL2lmIChwICE9PSBycCkgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgIH1cbn1cblxuLy8gU0hQSVhbXSBTSGlmdCBwb2ludCBieSBhIFBJWGVsIGFtb3VudFxuLy8gMHgzOFxuZnVuY3Rpb24gU0hQSVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIGQgPSBzdGFjay5wb3AoKSAvIDB4NDA7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICdTSFBJWFtdJywgcGksIGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkKTtcbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIElQW10gSW50ZXJwb2xhdGUgUG9pbnRcbi8vIDB4MzlcbmZ1bmN0aW9uIElQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwMWkgPSBzdGF0ZS5ycDE7XG4gICAgdmFyIHJwMmkgPSBzdGF0ZS5ycDI7XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciBycDEgPSBzdGF0ZS56MFtycDFpXTtcbiAgICB2YXIgcnAyID0gc3RhdGUuejFbcnAyaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUuZHB2O1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnSVBbXScsIHBpLCBycDFpLCAnPC0+JywgcnAyaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ2LmludGVycG9sYXRlKHAsIHJwMSwgcnAyLCBwdik7XG5cbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIE1TSVJQW2FdIE1vdmUgU3RhY2sgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4M0EtMHgzQlxuZnVuY3Rpb24gTVNJUlAoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZCA9IHN0YWNrLnBvcCgpIC8gNjQ7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MVtwaV07XG4gICAgdmFyIHJwMCA9IHN0YXRlLnowW3N0YXRlLnJwMF07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIGQsIHB2KTtcbiAgICBmdi50b3VjaChwKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNU0lSUFsnICsgYSArICddJywgZCwgcGkpOyB9XG5cbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG4gICAgc3RhdGUucnAyID0gcGk7XG4gICAgaWYgKGEpIHsgc3RhdGUucnAwID0gcGk7IH1cbn1cblxuLy8gQUxJR05SUFtdIEFsaWduIHRvIHJlZmVyZW5jZSBwb2ludC5cbi8vIDB4M0NcbmZ1bmN0aW9uIEFMSUdOUlAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnAwaSA9IHN0YXRlLnJwMDtcbiAgICB2YXIgcnAwID0gc3RhdGUuejBbcnAwaV07XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciB6MSA9IHN0YXRlLnoxO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MVtwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnQUxJR05SUFtdJywgcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIDAsIHB2KTtcbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIFJUR1tdIFJvdW5kIFRvIERvdWJsZSBHcmlkXG4vLyAweDNEXG5mdW5jdGlvbiBSVERHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUREdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9Eb3VibGVHcmlkO1xufVxuXG4vLyBNSUFQW2FdIE1vdmUgSW5kaXJlY3QgQWJzb2x1dGUgUG9pbnRcbi8vIDB4M0UtMHgzRlxuZnVuY3Rpb24gTUlBUChyb3VuZCwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejBbcGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBjdiA9IHN0YXRlLmN2dFtuXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICdNSUFQWycgKyByb3VuZCArICddJyxcbiAgICAgICAgICAgIG4sICcoJywgY3YsICcpJywgcGlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHAsIEhQWmVybyk7XG5cbiAgICBpZiAocm91bmQpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGQgLSBjdikgPCBzdGF0ZS5jdkN1dEluKSB7IGQgPSBjdjsgfVxuXG4gICAgICAgIGQgPSBzdGF0ZS5yb3VuZChkKTtcbiAgICB9XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBIUFplcm8sIGQsIHB2KTtcblxuICAgIGlmIChzdGF0ZS56cDAgPT09IDApIHtcbiAgICAgICAgcC54byA9IHAueDtcbiAgICAgICAgcC55byA9IHAueTtcbiAgICB9XG5cbiAgICBmdi50b3VjaChwKTtcblxuICAgIHN0YXRlLnJwMCA9IHN0YXRlLnJwMSA9IHBpO1xufVxuXG4vLyBOUFVTQltdIFBVU0ggTiBCeXRlc1xuLy8gMHg0MFxuZnVuY3Rpb24gTlBVU0hCKHN0YXRlKSB7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgdmFyIG4gPSBwcm9nWysraXBdO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIQltdJywgbik7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIE5QVVNIV1tdIFBVU0ggTiBXb3Jkc1xuLy8gMHg0MVxuZnVuY3Rpb24gTlBVU0hXKHN0YXRlKSB7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gcHJvZ1srK2lwXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOUFVTSFdbXScsIG4pOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cbiAgICAgICAgc3RhY2sucHVzaCh3KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBXU1tdIFdyaXRlIFN0b3JlXG4vLyAweDQyXG5mdW5jdGlvbiBXUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBzdG9yZSA9IHN0YXRlLnN0b3JlO1xuXG4gICAgaWYgKCFzdG9yZSkgeyBzdG9yZSA9IHN0YXRlLnN0b3JlID0gW107IH1cblxuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXUycsIHYsIGwpOyB9XG5cbiAgICBzdG9yZVtsXSA9IHY7XG59XG5cbi8vIFJTW10gUmVhZCBTdG9yZVxuLy8gMHg0M1xuZnVuY3Rpb24gUlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlMnLCBsKTsgfVxuXG4gICAgdmFyIHYgPSAoc3RvcmUgJiYgc3RvcmVbbF0pIHx8IDA7XG5cbiAgICBzdGFjay5wdXNoKHYpO1xufVxuXG4vLyBXQ1ZUUFtdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gUGl4ZWwgdW5pdHNcbi8vIDB4NDRcbmZ1bmN0aW9uIFdDVlRQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV0NWVFAnLCB2LCBsKTsgfVxuXG4gICAgc3RhdGUuY3Z0W2xdID0gdiAvIDB4NDA7XG59XG5cbi8vIFJDVlRbXSBSZWFkIENvbnRyb2wgVmFsdWUgVGFibGUgZW50cnlcbi8vIDB4NDVcbmZ1bmN0aW9uIFJDVlQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgY3Z0ZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JDVlQnLCBjdnRlKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGF0ZS5jdnRbY3Z0ZV0gKiAweDQwKTtcbn1cblxuLy8gR0NbXSBHZXQgQ29vcmRpbmF0ZSBwcm9qZWN0ZWQgb250byB0aGUgcHJvamVjdGlvbiB2ZWN0b3Jcbi8vIDB4NDYtMHg0N1xuZnVuY3Rpb24gR0MoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnoyW3BpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHQ1snICsgYSArICddJywgcGkpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YXRlLmRwdi5kaXN0YW5jZShwLCBIUFplcm8sIGEsIGZhbHNlKSAqIDB4NDApO1xufVxuXG4vLyBNRFthXSBNZWFzdXJlIERpc3RhbmNlXG4vLyAweDQ5LTB4NEFcbmZ1bmN0aW9uIE1EKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHBpMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaTEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MVtwaTJdO1xuICAgIHZhciBwMSA9IHN0YXRlLnowW3BpMV07XG4gICAgdmFyIGQgPSBzdGF0ZS5kcHYuZGlzdGFuY2UocDEsIHAyLCBhLCBhKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNRFsnICsgYSArICddJywgcGkyLCBwaTEsICctPicsIGQpOyB9XG5cbiAgICBzdGF0ZS5zdGFjay5wdXNoKE1hdGgucm91bmQoZCAqIDY0KSk7XG59XG5cbi8vIE1QUEVNW10gTWVhc3VyZSBQaXhlbHMgUGVyIEVNXG4vLyAweDRCXG5mdW5jdGlvbiBNUFBFTShzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNUFBFTVtdJyk7IH1cbiAgICBzdGF0ZS5zdGFjay5wdXNoKHN0YXRlLnBwZW0pO1xufVxuXG4vLyBGTElQT05bXSBzZXQgdGhlIGF1dG8gRkxJUCBCb29sZWFuIHRvIE9OXG4vLyAweDREXG5mdW5jdGlvbiBGTElQT04oc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxJUE9OW10nKTsgfVxuICAgIHN0YXRlLmF1dG9GbGlwID0gdHJ1ZTtcbn1cblxuLy8gTFRbXSBMZXNzIFRoYW5cbi8vIDB4NTBcbmZ1bmN0aW9uIExUKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTFRbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPCBlMiA/IDEgOiAwKTtcbn1cblxuLy8gTFRFUVtdIExlc3MgVGhhbiBvciBFUXVhbFxuLy8gMHg1M1xuZnVuY3Rpb24gTFRFUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xURVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPD0gZTIgPyAxIDogMCk7XG59XG5cbi8vIEdURVFbXSBHcmVhdGVyIFRoYW5cbi8vIDB4NTJcbmZ1bmN0aW9uIEdUKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPiBlMiA/IDEgOiAwKTtcbn1cblxuLy8gR1RFUVtdIEdyZWF0ZXIgVGhhbiBvciBFUXVhbFxuLy8gMHg1M1xuZnVuY3Rpb24gR1RFUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dURVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPj0gZTIgPyAxIDogMCk7XG59XG5cbi8vIEVRW10gRVF1YWxcbi8vIDB4NTRcbmZ1bmN0aW9uIEVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgPT09IGUxID8gMSA6IDApO1xufVxuXG4vLyBORVFbXSBOb3QgRVF1YWxcbi8vIDB4NTVcbmZ1bmN0aW9uIE5FUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiAhPT0gZTEgPyAxIDogMCk7XG59XG5cbi8vIE9ERFtdIE9ERFxuLy8gMHg1NlxuZnVuY3Rpb24gT0REKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPRERbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMSA6IDApO1xufVxuXG4vLyBFVkVOW10gRVZFTlxuLy8gMHg1N1xuZnVuY3Rpb24gRVZFTihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVZFTltdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC50cnVuYyhuKSAlIDIgPyAwIDogMSk7XG59XG5cbi8vIElGW10gSUYgdGVzdFxuLy8gMHg1OFxuZnVuY3Rpb24gSUYoc3RhdGUpIHtcbiAgICB2YXIgdGVzdCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lGW10nLCB0ZXN0KTsgfVxuXG4gICAgLy8gaWYgdGVzdCBpcyB0cnVlIGl0IGp1c3QgY29udGludWVzXG4gICAgLy8gaWYgbm90IHRoZSBpcCBpcyBza2lwcGVkIHVudGlsIG1hdGNoaW5nIEVMU0Ugb3IgRUlGXG4gICAgaWYgKCF0ZXN0KSB7XG4gICAgICAgIHNraXAoc3RhdGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICAnRUlGW10nKTsgfVxuICAgIH1cbn1cblxuLy8gRUlGW10gRW5kIElGXG4vLyAweDU5XG5mdW5jdGlvbiBFSUYoc3RhdGUpIHtcbiAgICAvLyB0aGlzIGNhbiBiZSByZWFjaGVkIG5vcm1hbGx5IHdoZW5cbiAgICAvLyBleGVjdXRpbmcgYW4gZWxzZSBicmFuY2guXG4gICAgLy8gLT4ganVzdCBpZ25vcmUgaXRcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFSUZbXScpOyB9XG59XG5cbi8vIEFORFtdIGxvZ2ljYWwgQU5EXG4vLyAweDVBXG5mdW5jdGlvbiBBTkQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBTkRbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgJiYgZTEgPyAxIDogMCk7XG59XG5cbi8vIE9SW10gbG9naWNhbCBPUlxuLy8gMHg1QlxuZnVuY3Rpb24gT1Ioc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPUltdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiB8fCBlMSA/IDEgOiAwKTtcbn1cblxuLy8gTk9UW10gbG9naWNhbCBOT1Rcbi8vIDB4NUNcbmZ1bmN0aW9uIE5PVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTk9UW10nLCBlKTsgfVxuXG4gICAgc3RhY2sucHVzaChlID8gMCA6IDEpO1xufVxuXG4vLyBERUxUQVAxW10gREVMVEEgZXhjZXB0aW9uIFAxXG4vLyBERUxUQVAyW10gREVMVEEgZXhjZXB0aW9uIFAyXG4vLyBERUxUQVAzW10gREVMVEEgZXhjZXB0aW9uIFAzXG4vLyAweDVELCAweDcxLCAweDcyXG5mdW5jdGlvbiBERUxUQVAxMjMoYiwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBwcGVtID0gc3RhdGUucHBlbTtcbiAgICB2YXIgYmFzZSA9IHN0YXRlLmRlbHRhQmFzZSArIChiIC0gMSkgKiAxNjtcbiAgICB2YXIgZHMgPSBzdGF0ZS5kZWx0YVNoaWZ0O1xuICAgIHZhciB6MCA9IHN0YXRlLnowO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBUFsnICsgYiArICddJywgbiwgc3RhY2spOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFyZyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcbiAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG1hZyA9IChhcmcgJiAweDBGKSAtIDg7XG4gICAgICAgIGlmIChtYWcgPj0gMCkgeyBtYWcrKzsgfVxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQRklYJywgcGksICdieScsIG1hZyAqIGRzKTsgfVxuXG4gICAgICAgIHZhciBwID0gejBbcGldO1xuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBtYWcgKiBkcywgcHYpO1xuICAgIH1cbn1cblxuLy8gU0RCW10gU2V0IERlbHRhIEJhc2UgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG4vLyAweDVFXG5mdW5jdGlvbiBTREIoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEQltdJywgbik7IH1cblxuICAgIHN0YXRlLmRlbHRhQmFzZSA9IG47XG59XG5cbi8vIFNEU1tdIFNldCBEZWx0YSBTaGlmdCBpbiB0aGUgZ3JhcGhpY3Mgc3RhdGVcbi8vIDB4NUZcbmZ1bmN0aW9uIFNEUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RTW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuZGVsdGFTaGlmdCA9IE1hdGgucG93KDAuNSwgbik7XG59XG5cbi8vIEFERFtdIEFERFxuLy8gMHg2MFxuZnVuY3Rpb24gQUREKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUREW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xICsgbjIpO1xufVxuXG4vLyBTVUJbXSBTVUJcbi8vIDB4NjFcbmZ1bmN0aW9uIFNVQihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NVQltdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSAtIG4yKTtcbn1cblxuLy8gRElWW10gRElWXG4vLyAweDYyXG5mdW5jdGlvbiBESVYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdESVZbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgKiA2NCAvIG4yKTtcbn1cblxuLy8gTVVMW10gTVVMXG4vLyAweDYzXG5mdW5jdGlvbiBNVUwoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNVUxbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgKiBuMiAvIDY0KTtcbn1cblxuLy8gQUJTW10gQUJTb2x1dGUgdmFsdWVcbi8vIDB4NjRcbmZ1bmN0aW9uIEFCUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUJTW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLmFicyhuKSk7XG59XG5cbi8vIE5FR1tdIE5FR2F0ZVxuLy8gMHg2NVxuZnVuY3Rpb24gTkVHKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdORUdbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKC1uKTtcbn1cblxuLy8gRkxPT1JbXSBGTE9PUlxuLy8gMHg2NlxuZnVuY3Rpb24gRkxPT1Ioc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZMT09SW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLmZsb29yKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBDRUlMSU5HW10gQ0VJTElOR1xuLy8gMHg2N1xuZnVuY3Rpb24gQ0VJTElORyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0VJTElOR1tdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5jZWlsKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBST1VORFthYl0gUk9VTkQgdmFsdWVcbi8vIDB4NjgtMHg2QlxuZnVuY3Rpb24gUk9VTkQoZHQsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST1VORFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhdGUucm91bmQobiAvIDB4NDApICogMHg0MCk7XG59XG5cbi8vIFdDVlRGW10gV3JpdGUgQ29udHJvbCBWYWx1ZSBUYWJsZSBpbiBGdW5pdHNcbi8vIDB4NzBcbmZ1bmN0aW9uIFdDVlRGKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dDVlRGW10nLCB2LCBsKTsgfVxuXG4gICAgc3RhdGUuY3Z0W2xdID0gdiAqIHN0YXRlLnBwZW0gLyBzdGF0ZS5mb250LnVuaXRzUGVyRW07XG59XG5cbi8vIERFTFRBQzFbXSBERUxUQSBleGNlcHRpb24gQzFcbi8vIERFTFRBQzJbXSBERUxUQSBleGNlcHRpb24gQzJcbi8vIERFTFRBQzNbXSBERUxUQSBleGNlcHRpb24gQzNcbi8vIDB4NzMsIDB4NzQsIDB4NzVcbmZ1bmN0aW9uIERFTFRBQzEyMyhiLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBwZW0gPSBzdGF0ZS5wcGVtO1xuICAgIHZhciBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuICAgIHZhciBkcyA9IHN0YXRlLmRlbHRhU2hpZnQ7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDWycgKyBiICsgJ10nLCBuLCBzdGFjayk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcmcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG4gICAgICAgIGlmIChhcHBlbSAhPT0gcHBlbSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtYWcgPSAoYXJnICYgMHgwRikgLSA4O1xuICAgICAgICBpZiAobWFnID49IDApIHsgbWFnKys7IH1cblxuICAgICAgICB2YXIgZGVsdGEgPSBtYWcgKiBkcztcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDRklYJywgYywgJ2J5JywgZGVsdGEpOyB9XG5cbiAgICAgICAgc3RhdGUuY3Z0W2NdICs9IGRlbHRhO1xuICAgIH1cbn1cblxuLy8gU1JPVU5EW10gU3VwZXIgUk9VTkRcbi8vIDB4NzZcbmZ1bmN0aW9uIFNST1VORChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JPVU5EW10nLCBuKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG4gICAgdmFyIHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4QzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgcGVyaW9kID0gMC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg0MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDgwOlxuICAgICAgICAgICAgcGVyaW9kID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU1JPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbiAmPSAweDBGO1xuXG4gICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG4gICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxufVxuXG4vLyBTNDVST1VORFtdIFN1cGVyIFJPVU5EIDQ1IGRlZ3JlZXNcbi8vIDB4NzdcbmZ1bmN0aW9uIFM0NVJPVU5EKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTNDVST1VORFtdJywgbik7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuICAgIHZhciBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHBlcmlvZCA9IE1hdGguc3FydCgyKSAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDQwOlxuICAgICAgICAgICAgcGVyaW9kID0gTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg4MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDIgKiBNYXRoLnNxcnQoMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTNDVST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbiAmPSAweDBGO1xuXG4gICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG4gICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxufVxuXG4vLyBST0ZGW10gUm91bmQgT2ZmXG4vLyAweDdBXG5mdW5jdGlvbiBST0ZGKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPRkZbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kT2ZmO1xufVxuXG4vLyBSVVRHW10gUm91bmQgVXAgVG8gR3JpZFxuLy8gMHg3Q1xuZnVuY3Rpb24gUlVURyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVVRHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFVwVG9HcmlkO1xufVxuXG4vLyBSRFRHW10gUm91bmQgRG93biBUbyBHcmlkXG4vLyAweDdEXG5mdW5jdGlvbiBSRFRHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JEVEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kRG93blRvR3JpZDtcbn1cblxuLy8gU0NBTkNUUkxbXSBTQ0FOIGNvbnZlcnNpb24gQ29uVFJvTFxuLy8gMHg4NVxuZnVuY3Rpb24gU0NBTkNUUkwoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5DVFJMW10nLCBuKTsgfVxufVxuXG4vLyBTRFBWVExbYV0gU2V0IER1YWwgUHJvamVjdGlvbiBWZWN0b3IgVG8gTGluZVxuLy8gMHg4Ni0weDg3XG5mdW5jdGlvbiBTRFBWVEwoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFBWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xufVxuXG4vLyBHRVRJTkZPW10gR0VUIElORk9ybWF0aW9uXG4vLyAweDg4XG5mdW5jdGlvbiBHRVRJTkZPKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHNlbCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciByID0gMDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHRVRJTkZPW10nLCBzZWwpOyB9XG5cbiAgICAvLyB2MzUgYXMgaW4gbm8gc3VicGl4ZWwgaGludGluZ1xuICAgIGlmIChzZWwgJiAweDAxKSB7IHIgPSAzNTsgfVxuXG4gICAgLy8gVE9ETyByb3RhdGlvbiBhbmQgc3RyZXRjaCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFxuICAgIC8vIGFuZCB0aHVzIHRob3NlIEdFVElORk8gYXJlIGFsd2F5cyAwLlxuXG4gICAgLy8gb3BlbnR5cGUuanMgaXMgYWx3YXlzIGdyYXkgc2NhbGluZ1xuICAgIGlmIChzZWwgJiAweDIwKSB7IHIgfD0gMHgxMDAwOyB9XG5cbiAgICBzdGFjay5wdXNoKHIpO1xufVxuXG4vLyBST0xMW10gUk9MTCB0aGUgdG9wIHRocmVlIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhBXG5mdW5jdGlvbiBST0xMKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9MTFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goYik7XG4gICAgc3RhY2sucHVzaChhKTtcbiAgICBzdGFjay5wdXNoKGMpO1xufVxuXG4vLyBNQVhbXSBNQVhpbXVtIG9mIHRvcCB0d28gc3RhY2sgZWxlbWVudHNcbi8vIDB4OEJcbmZ1bmN0aW9uIE1BWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01BWFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLm1heChlMSwgZTIpKTtcbn1cblxuLy8gTUlOW10gTUlOaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhDXG5mdW5jdGlvbiBNSU4oc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5bXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5taW4oZTEsIGUyKSk7XG59XG5cbi8vIFNDQU5UWVBFW10gU0NBTlRZUEVcbi8vIDB4OERcbmZ1bmN0aW9uIFNDQU5UWVBFKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAvLyBpZ25vcmVkIGJ5IG9wZW50eXBlLmpzXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5UWVBFW10nLCBuKTsgfVxufVxuXG4vLyBJTlNUQ1RSTFtdIElOU1RDVFJMXG4vLyAweDhEXG5mdW5jdGlvbiBJTlNUQ1RSTChzdGF0ZSkge1xuICAgIHZhciBzID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJTlNUQ1RSTFtdJywgcywgdik7IH1cblxuICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIDEgOiBzdGF0ZS5pbmhpYml0R3JpZEZpdCA9ICEhdjsgcmV0dXJuO1xuICAgICAgICBjYXNlIDIgOiBzdGF0ZS5pZ25vcmVDdnQgPSAhIXY7IHJldHVybjtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIElOU1RDVFJMW10gc2VsZWN0b3InKTtcbiAgICB9XG59XG5cbi8vIFBVU0hCW2FiY10gUFVTSCBCeXRlc1xuLy8gMHhCMC0weEI3XG5mdW5jdGlvbiBQVVNIQihuLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdQVVNIQlsnICsgbiArICddJyk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIFBVU0hXW2FiY10gUFVTSCBXb3Jkc1xuLy8gMHhCOC0weEJGXG5mdW5jdGlvbiBQVVNIVyhuLCBzdGF0ZSkge1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLmlwLCAnUFVTSFdbJyArIG4gKyAnXScpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cbiAgICAgICAgc3RhY2sucHVzaCh3KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBNRFJQW2FiY2RlXSBNb3ZlIERpcmVjdCBSZWxhdGl2ZSBQb2ludFxuLy8gMHhEMC0weEVGXG4vLyAoaWYgaW5kaXJlY3QgaXMgMClcbi8vXG4vLyBhbmRcbi8vXG4vLyBNSVJQW2FiY2RlXSBNb3ZlIEluZGlyZWN0IFJlbGF0aXZlIFBvaW50XG4vLyAweEUwLTB4RkZcbi8vIChpZiBpbmRpcmVjdCBpcyAxKVxuXG5mdW5jdGlvbiBNRFJQX01JUlAoaW5kaXJlY3QsIHNldFJwMCwga2VlcEQsIHJvLCBkdCwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgY3Z0ZSA9IGluZGlyZWN0ICYmIHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBycDBpID0gc3RhdGUucnAwO1xuICAgIHZhciBycCA9IHN0YXRlLnowW3JwMGldO1xuICAgIHZhciBwID0gc3RhdGUuejFbcGldO1xuXG4gICAgdmFyIG1kID0gc3RhdGUubWluRGlzO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLmRwdjtcbiAgICB2YXIgb2Q7IC8vIG9yaWdpbmFsIGRpc3RhbmNlXG4gICAgdmFyIGQ7IC8vIG1vdmluZyBkaXN0YW5jZVxuICAgIHZhciBzaWduOyAvLyBzaWduIG9mIGRpc3RhbmNlXG4gICAgdmFyIGN2O1xuXG4gICAgZCA9IG9kID0gcHYuZGlzdGFuY2UocCwgcnAsIHRydWUsIHRydWUpO1xuICAgIHNpZ24gPSBkID49IDAgPyAxIDogLTE7IC8vIE1hdGguc2lnbiB3b3VsZCBiZSAwIGluIGNhc2Ugb2YgMFxuXG4gICAgLy8gVE9ETyBjb25zaWRlciBhdXRvRmxpcFxuICAgIGQgPSBNYXRoLmFicyhkKTtcblxuICAgIGlmIChpbmRpcmVjdCkge1xuICAgICAgICBjdiA9IHN0YXRlLmN2dFtjdnRlXTtcblxuICAgICAgICBpZiAocm8gJiYgTWF0aC5hYnMoZCAtIGN2KSA8IHN0YXRlLmN2Q3V0SW4pIHsgZCA9IGN2OyB9XG4gICAgfVxuXG4gICAgaWYgKGtlZXBEICYmIGQgPCBtZCkgeyBkID0gbWQ7IH1cblxuICAgIGlmIChybykgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwLCBzaWduICogZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgKGluZGlyZWN0ID8gJ01JUlBbJyA6ICdNRFJQWycpICtcbiAgICAgICAgICAgIChzZXRScDAgPyAnTScgOiAnbScpICtcbiAgICAgICAgICAgIChrZWVwRCA/ICc+JyA6ICdfJykgK1xuICAgICAgICAgICAgKHJvID8gJ1InIDogJ18nKSArXG4gICAgICAgICAgICAoZHQgPT09IDAgPyAnR3InIDogKGR0ID09PSAxID8gJ0JsJyA6IChkdCA9PT0gMiA/ICdXaCcgOiAnJykpKSArXG4gICAgICAgICAgICAnXScsXG4gICAgICAgICAgICBpbmRpcmVjdCA/XG4gICAgICAgICAgICAgICAgY3Z0ZSArICcoJyArIHN0YXRlLmN2dFtjdnRlXSArICcsJyArICBjdiArICcpJyA6XG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBwaSxcbiAgICAgICAgICAgICcoZCA9Jywgb2QsICctPicsIHNpZ24gKiBkLCAnKSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG4gICAgc3RhdGUucnAyID0gcGk7XG4gICAgaWYgKHNldFJwMCkgeyBzdGF0ZS5ycDAgPSBwaTsgfVxufVxuXG4vKlxuKiBUaGUgaW5zdHJ1Y3Rpb24gdGFibGUuXG4qL1xuaW5zdHJ1Y3Rpb25UYWJsZSA9IFtcbiAgICAvKiAweDAwICovIFNWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgwMSAqLyBTVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDIgKi8gU1BWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgwMyAqLyBTUFZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDA0ICovIFNGVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDUgKi8gU0ZWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgwNiAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgwNyAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgwOCAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgwOSAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgwQSAqLyBTUFZGUyxcbiAgICAvKiAweDBCICovIFNGVkZTLFxuICAgIC8qIDB4MEMgKi8gR1BWLFxuICAgIC8qIDB4MEQgKi8gR0ZWLFxuICAgIC8qIDB4MEUgKi8gU0ZWVFBWLFxuICAgIC8qIDB4MEYgKi8gSVNFQ1QsXG4gICAgLyogMHgxMCAqLyBTUlAwLFxuICAgIC8qIDB4MTEgKi8gU1JQMSxcbiAgICAvKiAweDEyICovIFNSUDIsXG4gICAgLyogMHgxMyAqLyBTWlAwLFxuICAgIC8qIDB4MTQgKi8gU1pQMSxcbiAgICAvKiAweDE1ICovIFNaUDIsXG4gICAgLyogMHgxNiAqLyBTWlBTLFxuICAgIC8qIDB4MTcgKi8gU0xPT1AsXG4gICAgLyogMHgxOCAqLyBSVEcsXG4gICAgLyogMHgxOSAqLyBSVEhHLFxuICAgIC8qIDB4MUEgKi8gU01ELFxuICAgIC8qIDB4MUIgKi8gRUxTRSxcbiAgICAvKiAweDFDICovIEpNUFIsXG4gICAgLyogMHgxRCAqLyBTQ1ZUQ0ksXG4gICAgLyogMHgxRSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTU1dDSVxuICAgIC8qIDB4MUYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU1NXXG4gICAgLyogMHgyMCAqLyBEVVAsXG4gICAgLyogMHgyMSAqLyBQT1AsXG4gICAgLyogMHgyMiAqLyBDTEVBUixcbiAgICAvKiAweDIzICovIFNXQVAsXG4gICAgLyogMHgyNCAqLyBERVBUSCxcbiAgICAvKiAweDI1ICovIENJTkRFWCxcbiAgICAvKiAweDI2ICovIE1JTkRFWCxcbiAgICAvKiAweDI3ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEFMSUdOUFRTXG4gICAgLyogMHgyOCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHgyOSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBVVFBcbiAgICAvKiAweDJBICovIExPT1BDQUxMLFxuICAgIC8qIDB4MkIgKi8gQ0FMTCxcbiAgICAvKiAweDJDICovIEZERUYsXG4gICAgLyogMHgyRCAqLyB1bmRlZmluZWQsICAgLy8gRU5ERiAoZWF0ZW4gYnkgRkRFRilcbiAgICAvKiAweDJFICovIE1EQVAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MkYgKi8gTURBUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzMCAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDMxICovIElVUC5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MzIgKi8gU0hQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDMzICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzNCAqLyBTSEMuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MzUgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDM2ICovIFNIWi5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzNyAqLyBTSFouYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzggKi8gU0hQSVgsXG4gICAgLyogMHgzOSAqLyBJUCxcbiAgICAvKiAweDNBICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDNCICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDNDICovIEFMSUdOUlAsXG4gICAgLyogMHgzRCAqLyBSVERHLFxuICAgIC8qIDB4M0UgKi8gTUlBUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzRiAqLyBNSUFQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDQwICovIE5QVVNIQixcbiAgICAvKiAweDQxICovIE5QVVNIVyxcbiAgICAvKiAweDQyICovIFdTLFxuICAgIC8qIDB4NDMgKi8gUlMsXG4gICAgLyogMHg0NCAqLyBXQ1ZUUCxcbiAgICAvKiAweDQ1ICovIFJDVlQsXG4gICAgLyogMHg0NiAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg0NyAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0OCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTQ0ZTXG4gICAgLyogMHg0OSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg0QSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0QiAqLyBNUFBFTSxcbiAgICAvKiAweDRDICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE1QU1xuICAgIC8qIDB4NEQgKi8gRkxJUE9OLFxuICAgIC8qIDB4NEUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUE9GRlxuICAgIC8qIDB4NEYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gREVCVUdcbiAgICAvKiAweDUwICovIExULFxuICAgIC8qIDB4NTEgKi8gTFRFUSxcbiAgICAvKiAweDUyICovIEdULFxuICAgIC8qIDB4NTMgKi8gR1RFUSxcbiAgICAvKiAweDU0ICovIEVRLFxuICAgIC8qIDB4NTUgKi8gTkVRLFxuICAgIC8qIDB4NTYgKi8gT0RELFxuICAgIC8qIDB4NTcgKi8gRVZFTixcbiAgICAvKiAweDU4ICovIElGLFxuICAgIC8qIDB4NTkgKi8gRUlGLFxuICAgIC8qIDB4NUEgKi8gQU5ELFxuICAgIC8qIDB4NUIgKi8gT1IsXG4gICAgLyogMHg1QyAqLyBOT1QsXG4gICAgLyogMHg1RCAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NUUgKi8gU0RCLFxuICAgIC8qIDB4NUYgKi8gU0RTLFxuICAgIC8qIDB4NjAgKi8gQURELFxuICAgIC8qIDB4NjEgKi8gU1VCLFxuICAgIC8qIDB4NjIgKi8gRElWLFxuICAgIC8qIDB4NjMgKi8gTVVMLFxuICAgIC8qIDB4NjQgKi8gQUJTLFxuICAgIC8qIDB4NjUgKi8gTkVHLFxuICAgIC8qIDB4NjYgKi8gRkxPT1IsXG4gICAgLyogMHg2NyAqLyBDRUlMSU5HLFxuICAgIC8qIDB4NjggKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NjkgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NkEgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NkIgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4NkMgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkQgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NzAgKi8gV0NWVEYsXG4gICAgLyogMHg3MSAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NzIgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDczICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg3NCAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NzUgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDc2ICovIFNST1VORCxcbiAgICAvKiAweDc3ICovIFM0NVJPVU5ELFxuICAgIC8qIDB4NzggKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPVFtdXG4gICAgLyogMHg3OSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBKUk9GW11cbiAgICAvKiAweDdBICovIFJPRkYsXG4gICAgLyogMHg3QiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg3QyAqLyBSVVRHLFxuICAgIC8qIDB4N0QgKi8gUkRURyxcbiAgICAvKiAweDdFICovIFBPUCwgLy8gYWN0dWFsbHkgU0FOR1csIHN1cHBvc2VkIHRvIGRvIG9ubHkgYSBwb3AgdGhvdWdoXG4gICAgLyogMHg3RiAqLyBQT1AsIC8vIGFjdHVhbGx5IEFBLCBzdXBwb3NlZCB0byBkbyBvbmx5IGEgcG9wIHRob3VnaFxuICAgIC8qIDB4ODAgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFBUXG4gICAgLyogMHg4MSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUkdPTlxuICAgIC8qIDB4ODIgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFJHT0ZGXG4gICAgLyogMHg4MyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg4NCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg4NSAqLyBTQ0FOQ1RSTCxcbiAgICAvKiAweDg2ICovIFNEUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg4NyAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4ODggKi8gR0VUSU5GTyxcbiAgICAvKiAweDg5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIElERUZcbiAgICAvKiAweDhBICovIFJPTEwsXG4gICAgLyogMHg4QiAqLyBNQVgsXG4gICAgLyogMHg4QyAqLyBNSU4sXG4gICAgLyogMHg4RCAqLyBTQ0FOVFlQRSxcbiAgICAvKiAweDhFICovIElOU1RDVFJMLFxuICAgIC8qIDB4OEYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTAgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTcgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTkgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTAgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTcgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTkgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QjAgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4QjEgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4QjIgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4QjMgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDQpLFxuICAgIC8qIDB4QjQgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDUpLFxuICAgIC8qIDB4QjUgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDYpLFxuICAgIC8qIDB4QjYgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDcpLFxuICAgIC8qIDB4QjcgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDgpLFxuICAgIC8qIDB4QjggKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4QjkgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4QkEgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4QkIgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDQpLFxuICAgIC8qIDB4QkMgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDUpLFxuICAgIC8qIDB4QkQgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDYpLFxuICAgIC8qIDB4QkUgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDcpLFxuICAgIC8qIDB4QkYgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDgpLFxuICAgIC8qIDB4QzAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAvKiAweEMxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMSksXG4gICAgLyogMHhDMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDIpLFxuICAgIC8qIDB4QzMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAzKSxcbiAgICAvKiAweEM0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMCksXG4gICAgLyogMHhDNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDEpLFxuICAgIC8qIDB4QzYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAyKSxcbiAgICAvKiAweEM3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMyksXG4gICAgLyogMHhDOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDApLFxuICAgIC8qIDB4QzkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAxKSxcbiAgICAvKiAweENBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMiksXG4gICAgLyogMHhDQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDMpLFxuICAgIC8qIDB4Q0MgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAwKSxcbiAgICAvKiAweENEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMSksXG4gICAgLyogMHhDRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDIpLFxuICAgIC8qIDB4Q0YgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAzKSxcbiAgICAvKiAweEQwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMCksXG4gICAgLyogMHhEMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDEpLFxuICAgIC8qIDB4RDIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAyKSxcbiAgICAvKiAweEQzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMyksXG4gICAgLyogMHhENCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDApLFxuICAgIC8qIDB4RDUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAxKSxcbiAgICAvKiAweEQ2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMiksXG4gICAgLyogMHhENyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDMpLFxuICAgIC8qIDB4RDggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAwKSxcbiAgICAvKiAweEQ5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMSksXG4gICAgLyogMHhEQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDIpLFxuICAgIC8qIDB4REIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAzKSxcbiAgICAvKiAweERDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMCksXG4gICAgLyogMHhERCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDEpLFxuICAgIC8qIDB4REUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAyKSxcbiAgICAvKiAweERGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMyksXG4gICAgLyogMHhFMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDApLFxuICAgIC8qIDB4RTEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAxKSxcbiAgICAvKiAweEUyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMiksXG4gICAgLyogMHhFMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDMpLFxuICAgIC8qIDB4RTQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAwKSxcbiAgICAvKiAweEU1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMSksXG4gICAgLyogMHhFNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDIpLFxuICAgIC8qIDB4RTcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAzKSxcbiAgICAvKiAweEU4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMCksXG4gICAgLyogMHhFOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDEpLFxuICAgIC8qIDB4RUEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAyKSxcbiAgICAvKiAweEVCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMyksXG4gICAgLyogMHhFQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDApLFxuICAgIC8qIDB4RUQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAxKSxcbiAgICAvKiAweEVFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMiksXG4gICAgLyogMHhFRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDMpLFxuICAgIC8qIDB4RjAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAwKSxcbiAgICAvKiAweEYxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMSksXG4gICAgLyogMHhGMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDIpLFxuICAgIC8qIDB4RjMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAzKSxcbiAgICAvKiAweEY0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMCksXG4gICAgLyogMHhGNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDEpLFxuICAgIC8qIDB4RjYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAyKSxcbiAgICAvKiAweEY3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMyksXG4gICAgLyogMHhGOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDApLFxuICAgIC8qIDB4RjkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAxKSxcbiAgICAvKiAweEZBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMiksXG4gICAgLyogMHhGQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDMpLFxuICAgIC8qIDB4RkMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAwKSxcbiAgICAvKiAweEZEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMSksXG4gICAgLyogMHhGRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDIpLFxuICAgIC8qIDB4RkYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAzKVxuXTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIE1hdGhlbWF0aWNhbCBDb25zaWRlcmF0aW9uc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbmZ2IC4uLiByZWZlcnMgdG8gZnJlZWRvbSB2ZWN0b3JcbnB2IC4uLiByZWZlcnMgdG8gcHJvamVjdGlvbiB2ZWN0b3JcbnJwIC4uLiByZWZlcnMgdG8gcmVmZXJlbmNlIHBvaW50XG5wICAuLi4gcmVmZXJzIHRvIHRvIHBvaW50IGJlaW5nIG9wZXJhdGVkIG9uXG5kICAuLi4gcmVmZXJzIHRvIGRpc3RhbmNlXG5cblNFVFJFTEFUSVZFOlxuPT09PT09PT09PT09XG5cbmNhc2UgZnJlZWRvbSB2ZWN0b3IgPT0geC1heGlzOlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIChwdilcbiAgICAgICAgICAgICAgICAgICAgIC4tJ1xuICAgICAgICAgICAgICBycGQgLi0nXG4gICAgICAgICAgICAgICAuLSpcbiAgICAgICAgICBkIC4tJzkwwrAnXG4gICAgICAgICAuLScgICAgICAgJ1xuICAgICAgLi0nICAgICAgICAgICAnXG4gICAqLScgICAgICAgICAgICAgICAnIGJcbiAgcnAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgIHAgKi0tLS0tLS0tLS0qLS0tLS0tLS0tLS0tLS0gKGZ2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbVxuXG4gIHJwZHggPSBycHggKyBkICogcHYueFxuICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuICBlcXVhdGlvbiBvZiBsaW5lIGJcblxuICAgeSAtIHJwZHkgPSBwdm5zICogKHgtIHJwZHgpXG5cbiAgIHkgPSBwLnlcblxuICAgeCA9IHJwZHggKyAoIHAueSAtIHJwZHkgKSAvIHB2bnNcblxuXG5jYXNlIGZyZWVkb20gdmVjdG9yID09IHktYXhpczpcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgKiBwbVxuICAgIHxcXFxuICAgIHwgXFxcbiAgICB8ICBcXFxuICAgIHwgICBcXFxuICAgIHwgICAgXFxcbiAgICB8ICAgICBcXFxuICAgIHwgICAgICBcXFxuICAgIHwgICAgICAgXFxcbiAgICB8ICAgICAgICBcXFxuICAgIHwgICAgICAgICBcXCBiXG4gICAgfCAgICAgICAgICBcXFxuICAgIHwgICAgICAgICAgIFxcXG4gICAgfCAgICAgICAgICAgIFxcICAgIC4tJyAocHYpXG4gICAgfCAgICAgICAgIDkwwrAgXFwuLSdcbiAgICB8ICAgICAgICAgICAuLScqIHJwZFxuICAgIHwgICAgICAgIC4tJ1xuICAgICogICAgICotJyAgZFxuICAgIHAgICAgIHJwXG5cbiAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gIGVxdWF0aW9uIG9mIGxpbmUgYjpcbiAgICAgICAgICAgcHZucyAuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cbiAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgeCA9IHAueFxuXG4gICB5ID0gcnBkeSArICBwdm5zICogKHAueCAtIHJwZHgpXG5cblxuXG5nZW5lcmljIGNhc2U6XG4tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLicoZnYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLiogcG1cbiAgICAgICAgICAgICAgICAgICAgICAgIC4nICFcbiAgICAgICAgICAgICAgICAgICAgICAuJyAgICAuXG4gICAgICAgICAgICAgICAgICAgIC4nICAgICAgIVxuICAgICAgICAgICAgICAgICAgLicgICAgICAgICAuIGJcbiAgICAgICAgICAgICAgICAuJyAgICAgICAgICAgIVxuICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICBwICAgICAgICAgICAgICAgIVxuICAgICAgICAgICAgICAgICAgICAgICAgIDkwwrAgICAuICAgIC4uLiAocHYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4tKi0nJydcbiAgICAgICAgICAgICAgICAgIC4uLi0tLScnJyAgICBycGRcbiAgICAgICAgIC4uLi0tLScnJyAgIGRcbiAgICotLScnJ1xuICBycFxuXG4gICAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gICAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiBlcXVhdGlvbiBvZiBsaW5lIGI6XG4gICAgcHZucy4uLiBub3JtYWwgc2xvcGUgdG8gcHZcblxuICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuIGVxdWF0aW9uIG9mIGZyZWVkb20gdmVjdG9yIGxpbmU6XG4gICAgZnZzIC4uLiBzbG9wZSBvZiBmcmVlZG9tIHZlY3RvciAoPWZ5L2Z4KVxuXG4gICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuXG4gIG9uIHBtIGJvdGggZXF1YXRpb25zIGFyZSB0cnVlIGZvciBzYW1lIHgveVxuXG4gICAgeSAtIHJwZHkgPSBwdm5zICogKHggLSBycGR4KVxuXG4gICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuICBmb3JtIHRvIHkgYW5kIHNldCBlcXVhbDpcblxuICAgIHB2bnMgKiAoeCAtIHJwZHgpICsgcnBkeSA9IGZ2cyAqICh4IC0gcHgpICsgcHlcblxuICBleHBhbmQ6XG5cbiAgICBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeSA9IGZ2cyAqIHggLSBmdnMgKiBweCArIHB5XG5cbiAgc3dpdGNoOlxuXG4gICAgZnZzICogeCAtIGZ2cyAqIHB4ICsgcHkgPSBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeVxuXG4gIHNvbHZlIGZvciB4OlxuXG4gICAgZnZzICogeCAtIHB2bnMgKiB4ID0gZnZzICogcHggLSBwdm5zICogcnBkeCAtIHB5ICsgcnBkeVxuXG5cblxuICAgICAgICAgIGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHlcbiAgICB4ID0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgIGZ2cyAtIHB2bnNcblxuICBhbmQ6XG5cbiAgICB5ID0gZnZzICogKHggLSBweCkgKyBweVxuXG5cblxuSU5URVJQT0xBVEU6XG49PT09PT09PT09PT1cblxuRXhhbXBsZXMgb2YgcG9pbnQgaW50ZXJwb2xhdGlvbi5cblxuVGhlIHdlaWdodCBvZiB0aGUgbW92ZW1lbnQgb2YgdGhlIHJlZmVyZW5jZSBwb2ludCBnZXRzIGJpZ2dlclxudGhlIGZ1cnRoZXIgdGhlIG90aGVyIHJlZmVyZW5jZSBwb2ludCBpcyBhd2F5LCB0aHVzIHRoZSBzYWZlc3Rcbm9wdGlvbiAodGhhdCBpcyBhdm9pZGluZyAwLzAgZGl2aXNpb25zKSBpcyB0byB3ZWlnaHQgdGhlXG5vcmlnaW5hbCBkaXN0YW5jZSBvZiB0aGUgb3RoZXIgcG9pbnQgYnkgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcy5cblxuSWYgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcyBpcyAwLCB0aGVuIG1vdmUgdGhlIHBvaW50IGJ5IHRoZVxuYXJpdGhtZXRpYyBhdmVyYWdlIG9mIHRoZSBtb3ZlbWVudCBvZiBib3RoIHJlZmVyZW5jZSBwb2ludHMuXG5cblxuXG5cbiAgICAgICAgICAgKCs2KVxuICAgIHJwMW8gKi0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMilcbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICBycDJvICotLS0tLS0tLS0tPiogcnAyXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAuICAgIDEwICAgICAgICAgIDIwICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi58ICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgLiAoKzgpICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgcG8gKi0tLS0tLT4qcCAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgIDEyICAgICAuICAgICAgICAgIDI0ICAgICAgICAgICAuXG4gICAgICAgICAgICAgICB8Li4uLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzZcblxuXG4tLS0tLS0tXG5cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgICAgKC0xMClcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICBycDIgKjwtLS0tLS0tLS0qIHJwbzJcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAxMCAgIC4gICAgICAgICAgMzAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIHwuLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAoKzUpICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgcG8gKi0tLT4qIHAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAgICAuICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAgICAuICAgMjAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgfC4uLi58Li4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICA1ICAgICAgICAxNVxuXG5cbi0tLS0tLS1cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgcnAybyAqLS0tLS0tLS0+KnJwMlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKzEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbyAqLS0tLS0tLS0+KiBwXG5cbi0tLS0tLS1cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgICAgICAuKCszMClcbiAgICBycDJvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPipycDJcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsyNSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPiogcFxuXG5cblxudmltOiBzZXQgdHM9NCBzdz00IGV4cGFuZHRhYjpcbioqKioqL1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBsaXN0IG9mIHRva2Vucy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBUb2tlbihjaGFyKSB7XG4gICAgdGhpcy5jaGFyID0gY2hhcjtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5hY3RpdmVTdGF0ZSA9IG51bGw7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbnRleHQgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IHJhbmdlIHN0YXJ0IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IHJhbmdlIGVuZCBpbmRleCBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBvd25lciBjb250ZXh0IG5hbWVcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFJhbmdlKHN0YXJ0SW5kZXgsIGVuZE9mZnNldCwgY29udGV4dE5hbWUpIHtcbiAgICB0aGlzLmNvbnRleHROYW1lID0gY29udGV4dE5hbWU7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICB0aGlzLmVuZE9mZnNldCA9IGVuZE9mZnNldDtcbn1cblxuLyoqXG4gKiBDaGVjayBjb250ZXh0IHN0YXJ0IGFuZCBlbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBhIHVuaXF1ZSBjb250ZXh0IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNoZWNrU3RhcnQgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhlIGluZGljYXRlcyBhIGNvbnRleHQncyBzdGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2hlY2tFbmQgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhlIGluZGljYXRlcyBhIGNvbnRleHQncyBlbmRcbiAqL1xuZnVuY3Rpb24gQ29udGV4dENoZWNrZXIoY29udGV4dE5hbWUsIGNoZWNrU3RhcnQsIGNoZWNrRW5kKSB7XG4gICAgdGhpcy5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuICAgIHRoaXMub3BlblJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgIHRoaXMuY2hlY2tTdGFydCA9IGNoZWNrU3RhcnQ7XG4gICAgdGhpcy5jaGVja0VuZCA9IGNoZWNrRW5kO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIENvbnRleHRQYXJhbXNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHthcnJheX0gY29udGV4dCBjb250ZXh0IGl0ZW1zXG4gKiBAcHJvcGVydHkge251bWJlcn0gY3VycmVudEluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgY29udGV4dCBwYXJhbXNcbiAqIEBwYXJhbSB7YXJyYXl9IGNvbnRleHQgYSBsaXN0IG9mIGl0ZW1zXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICovXG5mdW5jdGlvbiBDb250ZXh0UGFyYW1zKGNvbnRleHQsIGN1cnJlbnRJbmRleCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5pbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICB0aGlzLmxlbmd0aCA9IGNvbnRleHQubGVuZ3RoO1xuICAgIHRoaXMuY3VycmVudCA9IGNvbnRleHRbY3VycmVudEluZGV4XTtcbiAgICB0aGlzLmJhY2t0cmFjayA9IGNvbnRleHQuc2xpY2UoMCwgY3VycmVudEluZGV4KTtcbiAgICB0aGlzLmxvb2thaGVhZCA9IGNvbnRleHQuc2xpY2UoY3VycmVudEluZGV4ICsgMSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV2ZW50IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRJZCBldmVudCB1bmlxdWUgaWRcbiAqL1xuZnVuY3Rpb24gRXZlbnQoZXZlbnRJZCkge1xuICAgIHRoaXMuZXZlbnRJZCA9IGV2ZW50SWQ7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IFtdO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBjb3JlIGV2ZW50cyBhbmQgYXV0byBzdWJzY3JpYmUgcmVxdWlyZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7YW55fSBldmVudHMgYW4gb2JqZWN0IHRoYXQgZW5saXN0cyBjb3JlIGV2ZW50cyBoYW5kbGVyc1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQ29yZUV2ZW50cyhldmVudHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjb3JlRXZlbnRzID0gW1xuICAgICAgICAnc3RhcnQnLCAnZW5kJywgJ25leHQnLCAnbmV3VG9rZW4nLCAnY29udGV4dFN0YXJ0JyxcbiAgICAgICAgJ2NvbnRleHRFbmQnLCAnaW5zZXJ0VG9rZW4nLCAncmVtb3ZlVG9rZW4nLCAncmVtb3ZlUmFuZ2UnLFxuICAgICAgICAncmVwbGFjZVRva2VuJywgJ3JlcGxhY2VSYW5nZScsICdjb21wb3NlUlVEJywgJ3VwZGF0ZUNvbnRleHRzUmFuZ2VzJ1xuICAgIF07XG5cbiAgICBjb3JlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMkMS5ldmVudHMsIGV2ZW50SWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRXZlbnQoZXZlbnRJZClcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoISFldmVudHMpIHtcbiAgICAgICAgY29yZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbZXZlbnRJZF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcyQxLmV2ZW50c1tldmVudElkXS5zdWJzY3JpYmUoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlcXVpcmVzQ29udGV4dFVwZGF0ZSA9IFtcbiAgICAgICAgJ2luc2VydFRva2VuJywgJ3JlbW92ZVRva2VuJywgJ3JlbW92ZVJhbmdlJyxcbiAgICAgICAgJ3JlcGxhY2VUb2tlbicsICdyZXBsYWNlUmFuZ2UnLCAnY29tcG9zZVJVRCdcbiAgICBdO1xuICAgIHJlcXVpcmVzQ29udGV4dFVwZGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG4gICAgICAgIHRoaXMkMS5ldmVudHNbZXZlbnRJZF0uc3Vic2NyaWJlKFxuICAgICAgICAgICAgdGhpcyQxLnVwZGF0ZUNvbnRleHRzUmFuZ2VzXG4gICAgICAgICk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge2FueX0gZXZlbnRzIHRva2VuaXplciBjb3JlIGV2ZW50c1xuICovXG5mdW5jdGlvbiBUb2tlbml6ZXIoZXZlbnRzKSB7XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRDb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuY29udGV4dENoZWNrZXJzID0gW107XG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRNb2RpZmllcnMgPSBbXTtcblxuICAgIGluaXRpYWxpemVDb3JlRXZlbnRzLmNhbGwodGhpcywgZXZlbnRzKTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGF0ZSBvZiBhIHRva2VuLCB1c3VhbGx5IGNhbGxlZCBieSBhIHN0YXRlIG1vZGlmaWVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdGF0ZSBpdGVtIGtleVxuICogQHBhcmFtIHthbnl9IHZhbHVlIHN0YXRlIGl0ZW0gdmFsdWVcbiAqL1xuVG9rZW4ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSB7IGtleToga2V5LCB2YWx1ZTogdGhpcy5zdGF0ZVtrZXldIH07XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlU3RhdGU7XG59O1xuXG5Ub2tlbi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGVJZCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW3N0YXRlSWRdIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBpbmRleCBleGlzdHMgaW4gdGhlIHRva2VucyBsaXN0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuaW5ib3VuZEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ29tcG9zZSBhbmQgYXBwbHkgYSBsaXN0IG9mIG9wZXJhdGlvbnMgKHJlcGxhY2UsIHVwZGF0ZSwgZGVsZXRlKVxuICogQHBhcmFtIHthcnJheX0gUlVEcyByZXBsYWNlLCB1cGRhdGUgYW5kIGRlbGV0ZSBvcGVyYXRpb25zXG4gKiBUT0RPOiBQZXJmLiBPcHRpbWl6YXRpb24gKGxlbmd0aEJlZm9yZSA9PT0gbGVuZ3RoQWZ0ZXIgPyBkaXNwYXRjaCBvbmNlKVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmNvbXBvc2VSVUQgPSBmdW5jdGlvbiAoUlVEcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNpbGVudCA9IHRydWU7XG4gICAgdmFyIHN0YXRlID0gUlVEcy5tYXAoZnVuY3Rpb24gKFJVRCkgeyByZXR1cm4gKFxuICAgICAgICB0aGlzJDFbUlVEWzBdXS5hcHBseSh0aGlzJDEsIFJVRC5zbGljZSgxKS5jb25jYXQoc2lsZW50KSlcbiAgICApOyB9KTtcbiAgICB2YXIgaGFzRkFJTE9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KCdGQUlMJylcbiAgICApOyB9O1xuICAgIGlmIChzdGF0ZS5ldmVyeShoYXNGQUlMT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRkFJTDogXCJjb21wb3NlUlVEOiBvbmUgb3IgbW9yZSBvcGVyYXRpb25zIGhhc24ndCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIsXG4gICAgICAgICAgICByZXBvcnQ6IHN0YXRlLmZpbHRlcihoYXNGQUlMT2JqZWN0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoKCdjb21wb3NlUlVEJywgW3N0YXRlLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuICFoYXNGQUlMT2JqZWN0KG9wKTsgfSldKTtcbn07XG5cbi8qKlxuICogUmVwbGFjZSBhIHJhbmdlIG9mIHRva2VucyB3aXRoIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IHJhbmdlIHN0YXJ0IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHJhbmdlIG9mZnNldFxuICogQHBhcmFtIHt0b2tlbn0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnMgdG8gcmVwbGFjZVxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZXBsYWNlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgb2Zmc2V0LCB0b2tlbnMsIHNpbGVudCkge1xuICAgIG9mZnNldCA9IG9mZnNldCAhPT0gbnVsbCA/IG9mZnNldCA6IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICB2YXIgaXNUb2tlblR5cGUgPSB0b2tlbnMuZXZlcnkoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbiBpbnN0YW5jZW9mIFRva2VuOyB9KTtcbiAgICBpZiAoIWlzTmFOKHN0YXJ0SW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KHN0YXJ0SW5kZXgpICYmIGlzVG9rZW5UeXBlKSB7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IHRoaXMudG9rZW5zLnNwbGljZS5hcHBseShcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLCBbc3RhcnRJbmRleCwgb2Zmc2V0XS5jb25jYXQodG9rZW5zKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZXBsYWNlVG9rZW4nLCBbc3RhcnRJbmRleCwgb2Zmc2V0LCB0b2tlbnNdKTsgfVxuICAgICAgICByZXR1cm4gW3JlcGxhY2VkLCB0b2tlbnNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IEZBSUw6ICdyZXBsYWNlUmFuZ2U6IGludmFsaWQgdG9rZW5zIG9yIHN0YXJ0SW5kZXguJyB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZSBhIHRva2VuIHdpdGggYW5vdGhlciB0b2tlblxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKiBAcGFyYW0ge3Rva2VufSB0b2tlbiBhIHRva2VuIHRvIHJlcGxhY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVwbGFjZVRva2VuID0gZnVuY3Rpb24gKGluZGV4LCB0b2tlbiwgc2lsZW50KSB7XG4gICAgaWYgKCFpc05hTihpbmRleCkgJiYgdGhpcy5pbmJvdW5kSW5kZXgoaW5kZXgpICYmIHRva2VuIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gdGhpcy50b2tlbnMuc3BsaWNlKGluZGV4LCAxLCB0b2tlbik7XG4gICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlcGxhY2VUb2tlbicsIFtpbmRleCwgdG9rZW5dKTsgfVxuICAgICAgICByZXR1cm4gW3JlcGxhY2VkWzBdLCB0b2tlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogJ3JlcGxhY2VUb2tlbjogaW52YWxpZCB0b2tlbiBvciBpbmRleC4nIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBvZmZzZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbihzdGFydEluZGV4LCBvZmZzZXQsIHNpbGVudCkge1xuICAgIG9mZnNldCA9ICFpc05hTihvZmZzZXQpID8gb2Zmc2V0IDogdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2Vucy5zcGxpY2Uoc3RhcnRJbmRleCwgb2Zmc2V0KTtcbiAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZW1vdmVSYW5nZScsIFt0b2tlbnMsIHN0YXJ0SW5kZXgsIG9mZnNldF0pOyB9XG4gICAgcmV0dXJuIHRva2Vucztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgdG9rZW4gYXQgYSBjZXJ0YWluIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVtb3ZlVG9rZW4gPSBmdW5jdGlvbihpbmRleCwgc2lsZW50KSB7XG4gICAgaWYgKCFpc05hTihpbmRleCkgJiYgdGhpcy5pbmJvdW5kSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlbW92ZVRva2VuJywgW3Rva2VuLCBpbmRleF0pOyB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAncmVtb3ZlVG9rZW46IGludmFsaWQgdG9rZW4gaW5kZXguJyB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogSW5zZXJ0IGEgbGlzdCBvZiB0b2tlbnMgYXQgYSBjZXJ0YWluIGluZGV4XG4gKiBAcGFyYW0ge2FycmF5fSB0b2tlbnMgYSBsaXN0IG9mIHRva2VucyB0byBpbnNlcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbnNlcnQgdGhlIGxpc3Qgb2YgdG9rZW5zIGF0IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmluc2VydFRva2VuID0gZnVuY3Rpb24gKHRva2VucywgaW5kZXgsIHNpbGVudCkge1xuICAgIHZhciB0b2tlblR5cGUgPSB0b2tlbnMuZXZlcnkoXG4gICAgICAgIGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gaW5zdGFuY2VvZiBUb2tlbjsgfVxuICAgICk7XG4gICAgaWYgKHRva2VuVHlwZSkge1xuICAgICAgICB0aGlzLnRva2Vucy5zcGxpY2UuYXBwbHkoXG4gICAgICAgICAgICB0aGlzLnRva2VucywgW2luZGV4LCAwXS5jb25jYXQodG9rZW5zKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdpbnNlcnRUb2tlbicsIFt0b2tlbnMsIGluZGV4XSk7IH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAnaW5zZXJ0VG9rZW46IGludmFsaWQgdG9rZW4ocykuJyB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogQSBzdGF0ZSBtb2RpZmllciB0aGF0IGlzIGNhbGxlZCBvbiAnbmV3VG9rZW4nIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kaWZpZXJJZCBzdGF0ZSBtb2RpZmllciBpZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb2RpZmllciBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0b2tlbiBzdGF0ZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlZ2lzdGVyTW9kaWZpZXIgPSBmdW5jdGlvbihtb2RpZmllcklkLCBjb25kaXRpb24sIG1vZGlmaWVyKSB7XG4gICAgdGhpcy5ldmVudHMubmV3VG9rZW4uc3Vic2NyaWJlKGZ1bmN0aW9uKHRva2VuLCBjb250ZXh0UGFyYW1zKSB7XG4gICAgICAgIHZhciBjb25kaXRpb25QYXJhbXMgPSBbdG9rZW4sIGNvbnRleHRQYXJhbXNdO1xuICAgICAgICB2YXIgY2FuQXBwbHlNb2RpZmllciA9IChcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgY29uZGl0aW9uLmFwcGx5KHRoaXMsIGNvbmRpdGlvblBhcmFtcykgPT09IHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIG1vZGlmaWVyUGFyYW1zID0gW3Rva2VuLCBjb250ZXh0UGFyYW1zXTtcbiAgICAgICAgaWYgKGNhbkFwcGx5TW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZVZhbHVlID0gbW9kaWZpZXIuYXBwbHkodGhpcywgbW9kaWZpZXJQYXJhbXMpO1xuICAgICAgICAgICAgdG9rZW4uc2V0U3RhdGUobW9kaWZpZXJJZCwgbmV3U3RhdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRNb2RpZmllcnMucHVzaChtb2RpZmllcklkKTtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIGEgaGFuZGxlciB0byBhbiBldmVudFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnRIYW5kbGVyIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAqL1xuRXZlbnQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnN1YnNjcmliZXJzLnB1c2goZXZlbnRIYW5kbGVyKSkgLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAoXCJpbnZhbGlkICdcIiArICh0aGlzLmV2ZW50SWQpICsgXCInIGV2ZW50IGhhbmRsZXJcIil9O1xuICAgIH1cbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtzdHJpbmd9IHN1YnNJZCBzdWJzY3JpcHRpb24gaWRcbiAqL1xuRXZlbnQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNJZCkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuc3BsaWNlKHN1YnNJZCwgMSk7XG59O1xuXG4vKipcbiAqIFNldHMgY29udGV4dCBwYXJhbXMgY3VycmVudCB2YWx1ZSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGNvbnRleHQgcGFyYW1zIGN1cnJlbnQgdmFsdWUgaW5kZXhcbiAqL1xuQ29udGV4dFBhcmFtcy5wcm90b3R5cGUuc2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jb250ZXh0W2luZGV4XTtcbiAgICB0aGlzLmJhY2t0cmFjayA9IHRoaXMuY29udGV4dC5zbGljZSgwLCBpbmRleCk7XG4gICAgdGhpcy5sb29rYWhlYWQgPSB0aGlzLmNvbnRleHQuc2xpY2UoaW5kZXggKyAxKTtcbn07XG5cbi8qKlxuICogR2V0IGFuIGl0ZW0gYXQgYW4gb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgdmFsdWVcbiAqIGV4YW1wbGUgKGN1cnJlbnQgdmFsdWUgaXMgMyk6XG4gKiAgMSAgICAyICAgWzNdICAgNCAgICA1ICAgfCAgIGl0ZW1zIHZhbHVlc1xuICogLTIgICAtMSAgICAwICAgIDEgICAgMiAgIHwgICBvZmZzZXQgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IGFuIG9mZnNldCBmcm9tIGN1cnJlbnQgdmFsdWUgaW5kZXhcbiAqL1xuQ29udGV4dFBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIChvZmZzZXQgPT09IDApOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICAgICAgY2FzZSAob2Zmc2V0IDwgMCAmJiBNYXRoLmFicyhvZmZzZXQpIDw9IHRoaXMuYmFja3RyYWNrLmxlbmd0aCk6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrdHJhY2suc2xpY2Uob2Zmc2V0KVswXTtcbiAgICAgICAgY2FzZSAob2Zmc2V0ID4gMCAmJiBvZmZzZXQgPD0gdGhpcy5sb29rYWhlYWQubGVuZ3RoKTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZFtvZmZzZXQgLSAxXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBjb250ZXh0IHJhbmdlIGludG8gYSBzdHJpbmcgdmFsdWVcbiAqIEBwYXJhbSB7Y29udGV4dFJhbmdlfSByYW5nZSBhIGNvbnRleHQgcmFuZ2VcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yYW5nZVRvVGV4dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbnRleHRSYW5nZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5nZXRSYW5nZVRva2VucyhyYW5nZSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfSkuam9pbignJylcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFsbCB0b2tlbnMgaW50byBhIHN0cmluZ1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH0pLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBjb250ZXh0IGJ5IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBjb250ZXh0IG5hbWUgdG8gZ2V0XG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0TmFtZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdO1xuICAgIHJldHVybiAhIWNvbnRleHQgPyBjb250ZXh0IDogbnVsbDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyBhIG5ldyBldmVudCBoYW5kbGVyIHRvIGFuIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWUgdG8gc3Vic2NyaWJlIHRvXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBldmVudEhhbmRsZXIgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIGV2ZW50XG4gKi9cblRva2VuaXplci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHZhciBldmVudCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgaWYgKCEhZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnN1YnNjcmliZShldmVudEhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge2FueX0gYXJncyBldmVudCBoYW5kbGVyIGFyZ3VtZW50c1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24oZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuYXBwbHkodGhpcyQxLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBjb250ZXh0IGNoZWNrZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBhIHVuaXF1ZSBjb250ZXh0IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnRleHRTdGFydENoZWNrIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9uIGNvbnRleHQgc3RhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnRleHRFbmRDaGVjayAgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb24gY29udGV4dCBlbmRcbiAqIFRPRE86IGNhbGwgdG9rZW5pemUgb24gcmVnaXN0cmF0aW9uIHRvIHVwZGF0ZSBjb250ZXh0IHJhbmdlcyB3aXRoIHRoZSBuZXcgY29udGV4dC5cbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZWdpc3RlckNvbnRleHRDaGVja2VyID0gZnVuY3Rpb24oY29udGV4dE5hbWUsIGNvbnRleHRTdGFydENoZWNrLCBjb250ZXh0RW5kQ2hlY2spIHtcbiAgICBpZiAoISF0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpKSB7IHJldHVybiB7XG4gICAgICAgIEZBSUw6XG4gICAgICAgIChcImNvbnRleHQgbmFtZSAnXCIgKyBjb250ZXh0TmFtZSArIFwiJyBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuXCIpXG4gICAgfTsgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dFN0YXJ0Q2hlY2sgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHtcbiAgICAgICAgRkFJTDpcbiAgICAgICAgXCJtaXNzaW5nIGNvbnRleHQgc3RhcnQgY2hlY2suXCJcbiAgICB9OyB9XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0RW5kQ2hlY2sgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHtcbiAgICAgICAgRkFJTDpcbiAgICAgICAgXCJtaXNzaW5nIGNvbnRleHQgZW5kIGNoZWNrLlwiXG4gICAgfTsgfVxuICAgIHZhciBjb250ZXh0Q2hlY2tlcnMgPSBuZXcgQ29udGV4dENoZWNrZXIoXG4gICAgICAgIGNvbnRleHROYW1lLCBjb250ZXh0U3RhcnRDaGVjaywgY29udGV4dEVuZENoZWNrXG4gICAgKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRDb250ZXh0c1tjb250ZXh0TmFtZV0gPSBjb250ZXh0Q2hlY2tlcnM7XG4gICAgdGhpcy5jb250ZXh0Q2hlY2tlcnMucHVzaChjb250ZXh0Q2hlY2tlcnMpO1xuICAgIHJldHVybiBjb250ZXh0Q2hlY2tlcnM7XG59O1xuXG4vKipcbiAqIEdldHMgYSBjb250ZXh0IHJhbmdlIHRva2Vuc1xuICogQHBhcmFtIHtjb250ZXh0UmFuZ2V9IHJhbmdlIGEgY29udGV4dCByYW5nZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldFJhbmdlVG9rZW5zID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICB2YXIgZW5kSW5kZXggPSByYW5nZS5zdGFydEluZGV4ICsgcmFuZ2UuZW5kT2Zmc2V0O1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAgIHRoaXMudG9rZW5zXG4gICAgICAgICAgICAuc2xpY2UocmFuZ2Uuc3RhcnRJbmRleCwgZW5kSW5kZXgpXG4gICAgKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcmFuZ2VzIG9mIGEgY29udGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGNvbnRleHQgbmFtZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldENvbnRleHRSYW5nZXMgPSBmdW5jdGlvbihjb250ZXh0TmFtZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKTtcbiAgICBpZiAoISFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnJhbmdlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAoXCJjb250ZXh0IGNoZWNrZXIgJ1wiICsgY29udGV4dE5hbWUgKyBcIicgaXMgbm90IHJlZ2lzdGVyZWQuXCIpIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXNldHMgY29udGV4dCByYW5nZXMgdG8gcnVuIGNvbnRleHQgdXBkYXRlXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVzZXRDb250ZXh0c1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZENvbnRleHRzID0gdGhpcy5yZWdpc3RlcmVkQ29udGV4dHM7XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gcmVnaXN0ZXJlZENvbnRleHRzKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkQ29udGV4dHMuaGFzT3duUHJvcGVydHkoY29udGV4dE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHJlZ2lzdGVyZWRDb250ZXh0c1tjb250ZXh0TmFtZV07XG4gICAgICAgICAgICBjb250ZXh0LnJhbmdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUudXBkYXRlQ29udGV4dHNSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldENvbnRleHRzUmFuZ2VzKCk7XG4gICAgdmFyIGNoYXJzID0gdGhpcy50b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGNoYXJzLCBpKTtcbiAgICAgICAgdGhpcy5ydW5Db250ZXh0Q2hlY2soY29udGV4dFBhcmFtcyk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2goJ3VwZGF0ZUNvbnRleHRzUmFuZ2VzJywgW3RoaXMucmVnaXN0ZXJlZENvbnRleHRzXSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGVuZCBvZmZzZXQgb2YgYW4gb3BlbiByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBlbmQgb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgY29udGV4dCBuYW1lXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuc2V0RW5kT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCwgY29udGV4dE5hbWUpIHtcbiAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgdmFyIHJhbmdlID0gbmV3IENvbnRleHRSYW5nZShzdGFydEluZGV4LCBvZmZzZXQsIGNvbnRleHROYW1lKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5yYW5nZXM7XG4gICAgcmFuZ2UucmFuZ2VJZCA9IGNvbnRleHROYW1lICsgXCIuXCIgKyAocmFuZ2VzLmxlbmd0aCk7XG4gICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgIHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlID0gbnVsbDtcbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuXG4vKipcbiAqIFJ1bnMgYSBjb250ZXh0IGNoZWNrIG9uIHRoZSBjdXJyZW50IGNvbnRleHRcbiAqIEBwYXJhbSB7Y29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjdXJyZW50IGNvbnRleHQgcGFyYW1zXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucnVuQ29udGV4dENoZWNrID0gZnVuY3Rpb24oY29udGV4dFBhcmFtcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGluZGV4ID0gY29udGV4dFBhcmFtcy5pbmRleDtcbiAgICB0aGlzLmNvbnRleHRDaGVja2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZXh0Q2hlY2tlcikge1xuICAgICAgICB2YXIgY29udGV4dE5hbWUgPSBjb250ZXh0Q2hlY2tlci5jb250ZXh0TmFtZTtcbiAgICAgICAgdmFyIG9wZW5SYW5nZSA9IHRoaXMkMS5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2U7XG4gICAgICAgIGlmICghb3BlblJhbmdlICYmIGNvbnRleHRDaGVja2VyLmNoZWNrU3RhcnQoY29udGV4dFBhcmFtcykpIHtcbiAgICAgICAgICAgIG9wZW5SYW5nZSA9IG5ldyBDb250ZXh0UmFuZ2UoaW5kZXgsIG51bGwsIGNvbnRleHROYW1lKTtcbiAgICAgICAgICAgIHRoaXMkMS5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2UgPSBvcGVuUmFuZ2U7XG4gICAgICAgICAgICB0aGlzJDEuZGlzcGF0Y2goJ2NvbnRleHRTdGFydCcsIFtjb250ZXh0TmFtZSwgaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISFvcGVuUmFuZ2UgJiYgY29udGV4dENoZWNrZXIuY2hlY2tFbmQoY29udGV4dFBhcmFtcykpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoaW5kZXggLSBvcGVuUmFuZ2Uuc3RhcnRJbmRleCkgKyAxO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcyQxLnNldEVuZE9mZnNldChvZmZzZXQsIGNvbnRleHROYW1lKTtcbiAgICAgICAgICAgIHRoaXMkMS5kaXNwYXRjaCgnY29udGV4dEVuZCcsIFtjb250ZXh0TmFtZSwgcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHRleHQgaW50byBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBhIHRleHQgdG8gdG9rZW5pemVcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnJlc2V0Q29udGV4dHNSYW5nZXMoKTtcbiAgICB2YXIgY2hhcnMgPSBBcnJheS5mcm9tKHRleHQpO1xuICAgIHRoaXMuZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGNoYXJzLCBpKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgnbmV4dCcsIFtjb250ZXh0UGFyYW1zXSk7XG4gICAgICAgIHRoaXMucnVuQ29udGV4dENoZWNrKGNvbnRleHRQYXJhbXMpO1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4oY2hhcik7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKCduZXdUb2tlbicsIFt0b2tlbiwgY29udGV4dFBhcmFtc10pO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoKCdlbmQnLCBbdGhpcy50b2tlbnNdKTtcbiAgICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vLyDila3ilIDilITilITilITilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilITilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDila5cbi8vIOKUiiBDaGFyYWN0ZXIgQ2xhc3MgQXNzZXJ0aW9ucyDilIogQ2hlY2tzIGlmIGEgY2hhciBiZWxvbmdzIHRvIGEgY2VydGFpbiBjbGFzcyDilIpcbi8vIOKVsOKUgOKVvuKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUhOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKVr1xuLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyBBcmFiaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNBcmFiaWNDaGFyKGMpIHtcbiAgICByZXR1cm4gL1tcXHUwNjAwLVxcdTA2NUZcXHUwNjZBLVxcdTA2RDJcXHUwNkZBLVxcdTA2RkZdLy50ZXN0KGMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyBhbiBpc29sYXRlZCBhcmFiaWMgY2hhclxuICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBpc0lzb2xhdGVkQXJhYmljQ2hhcihjaGFyKSB7XG4gICAgcmV0dXJuIC9bXFx1MDYzMFxcdTA2OTBcXHUwNjIxXFx1MDYzMVxcdTA2NjFcXHUwNjcxXFx1MDYyMlxcdTA2MzJcXHUwNjcyXFx1MDY5MlxcdTA2QzJcXHUwNjIzXFx1MDY3M1xcdTA2OTNcXHUwNkMzXFx1MDYyNFxcdTA2OTRcXHUwNkM0XFx1MDYyNVxcdTA2NzVcXHUwNjk1XFx1MDZDNVxcdTA2RTVcXHUwNjc2XFx1MDY5NlxcdTA2QzZcXHUwNjI3XFx1MDY3N1xcdTA2OTdcXHUwNkM3XFx1MDY0OFxcdTA2ODhcXHUwNjk4XFx1MDZDOFxcdTA2ODlcXHUwNjk5XFx1MDZDOVxcdTA2OEFcXHUwNkNBXFx1MDY2QlxcdTA2OEJcXHUwNkNCXFx1MDY4Q1xcdTA2OERcXHUwNkNEXFx1MDZGRFxcdTA2OEVcXHUwNkVFXFx1MDZGRVxcdTA2MkZcXHUwNjhGXFx1MDZDRlxcdTA2RUZdLy50ZXN0KGNoYXIpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyBhbiBBcmFiaWMgVGFzaGtlZWwgY2hhclxuICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihjaGFyKSB7XG4gICAgcmV0dXJuIC9bXFx1MDYwMC1cXHUwNjA1XFx1MDYwQy1cXHUwNjBFXFx1MDYxMC1cXHUwNjFCXFx1MDYxRVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRF0vLnRlc3QoY2hhcik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGlzIExhdGluXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzTGF0aW5DaGFyKGMpIHtcbiAgICByZXR1cm4gL1tBLXpdLy50ZXN0KGMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyB3aGl0ZXNwYWNlIGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGMpIHtcbiAgICByZXR1cm4gL1xccy8udGVzdChjKTtcbn1cblxuLyoqXG4gKiBRdWVyeSBhIGZlYXR1cmUgYnkgc29tZSBvZiBpdCdzIHByb3BlcnRpZXMgdG8gbG9va3VwIGEgZ2x5cGggc3Vic3RpdHV0aW9uLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGZlYXR1cmUgcXVlcnkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Rm9udH0gZm9udCBvcGVudHlwZSBmb250IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEZlYXR1cmVRdWVyeShmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbiAgICB0aGlzLmZlYXR1cmVzID0ge307XG59XG5cbi8qKlxuICogQHR5cGVkZWYgU3Vic3RpdHV0aW9uQWN0aW9uXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBzdWJzdGl0dXRpb24gdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhZyBmZWF0dXJlIHRhZ1xuICogQHByb3BlcnR5IHthbnl9IHN1YnN0aXR1dGlvbiBzdWJzdGl0dXRpb24gdmFsdWUocylcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIHN1YnN0aXR1dGlvbiBhY3Rpb24gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3Vic3RpdHV0aW9uQWN0aW9ufSBhY3Rpb25cbiAqL1xuZnVuY3Rpb24gU3Vic3RpdHV0aW9uQWN0aW9uKGFjdGlvbikge1xuICAgIHRoaXMuaWQgPSBhY3Rpb24uaWQ7XG4gICAgdGhpcy50YWcgPSBhY3Rpb24udGFnO1xuICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gYWN0aW9uLnN1YnN0aXR1dGlvbjtcbn1cblxuLyoqXG4gKiBMb29rdXAgYSBjb3ZlcmFnZSB0YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggZ2x5cGggaW5kZXhcbiAqIEBwYXJhbSB7Q292ZXJhZ2VUYWJsZX0gY292ZXJhZ2UgY292ZXJhZ2UgdGFibGVcbiAqL1xuZnVuY3Rpb24gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgY292ZXJhZ2UpIHtcbiAgICBpZiAoIWdseXBoSW5kZXgpIHsgcmV0dXJuIC0xOyB9XG4gICAgc3dpdGNoIChjb3ZlcmFnZS5mb3JtYXQpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGNvdmVyYWdlLmdseXBocy5pbmRleE9mKGdseXBoSW5kZXgpO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSBjb3ZlcmFnZS5yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCA+PSByYW5nZS5zdGFydCAmJiBnbHlwaEluZGV4IDw9IHJhbmdlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2x5cGhJbmRleCAtIHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gLTE7IC8vIG5vdCBmb3VuZFxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogSGFuZGxlIGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAxXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIGdseXBoSW5kZXggKyBzdWJ0YWJsZS5kZWx0YUdseXBoSWQ7XG59XG5cbi8qKlxuICogSGFuZGxlIGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAyXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIHN1YnRhYmxlLnN1YnN0aXR1dGVbc3Vic3RpdHV0ZUluZGV4XTtcbn1cblxuLyoqXG4gKiBMb29rdXAgYSBsaXN0IG9mIGNvdmVyYWdlIHRhYmxlc1xuICogQHBhcmFtIHthbnl9IGNvdmVyYWdlTGlzdCBhIGxpc3Qgb2YgY292ZXJhZ2UgdGFibGVzXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cENvdmVyYWdlTGlzdChjb3ZlcmFnZUxpc3QsIGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgbG9va3VwTGlzdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJhZ2VMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb3ZlcmFnZSA9IGNvdmVyYWdlTGlzdFtpXTtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgICAgIGdseXBoSW5kZXggPSBBcnJheS5pc0FycmF5KGdseXBoSW5kZXgpID8gZ2x5cGhJbmRleFswXSA6IGdseXBoSW5kZXg7XG4gICAgICAgIHZhciBsb29rdXBJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIGNvdmVyYWdlKTtcbiAgICAgICAgaWYgKGxvb2t1cEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgbG9va3VwTGlzdC5wdXNoKGxvb2t1cEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobG9va3VwTGlzdC5sZW5ndGggIT09IGNvdmVyYWdlTGlzdC5sZW5ndGgpIHsgcmV0dXJuIC0xOyB9XG4gICAgcmV0dXJuIGxvb2t1cExpc3Q7XG59XG5cbi8qKlxuICogSGFuZGxlIGNoYWluaW5nIGNvbnRleHQgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDNcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyB0byBsb29rdXBcbiAqL1xuZnVuY3Rpb24gY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzKGNvbnRleHRQYXJhbXMsIHN1YnRhYmxlKSB7XG4gICAgdmFyIGxvb2t1cHNDb3VudCA9IChcbiAgICAgICAgc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggK1xuICAgICAgICBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZS5sZW5ndGggK1xuICAgICAgICBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGhcbiAgICApO1xuICAgIGlmIChjb250ZXh0UGFyYW1zLmNvbnRleHQubGVuZ3RoIDwgbG9va3Vwc0NvdW50KSB7IHJldHVybiBbXTsgfVxuICAgIC8vIElOUFVUIExPT0tVUCAvL1xuICAgIHZhciBpbnB1dExvb2t1cHMgPSBsb29rdXBDb3ZlcmFnZUxpc3QoXG4gICAgICAgIHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UsIGNvbnRleHRQYXJhbXNcbiAgICApO1xuICAgIGlmIChpbnB1dExvb2t1cHMgPT09IC0xKSB7IHJldHVybiBbXTsgfVxuICAgIC8vIExPT0tBSEVBRCBMT09LVVAgLy9cbiAgICB2YXIgbG9va2FoZWFkT2Zmc2V0ID0gc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggLSAxO1xuICAgIGlmIChjb250ZXh0UGFyYW1zLmxvb2thaGVhZC5sZW5ndGggPCBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZS5sZW5ndGgpIHsgcmV0dXJuIFtdOyB9XG4gICAgdmFyIGxvb2thaGVhZENvbnRleHQgPSBjb250ZXh0UGFyYW1zLmxvb2thaGVhZC5zbGljZShsb29rYWhlYWRPZmZzZXQpO1xuICAgIHdoaWxlIChsb29rYWhlYWRDb250ZXh0Lmxlbmd0aCAmJiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihsb29rYWhlYWRDb250ZXh0WzBdLmNoYXIpKSB7XG4gICAgICAgIGxvb2thaGVhZENvbnRleHQuc2hpZnQoKTtcbiAgICB9XG4gICAgdmFyIGxvb2thaGVhZFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGxvb2thaGVhZENvbnRleHQsIDApO1xuICAgIHZhciBsb29rYWhlYWRMb29rdXBzID0gbG9va3VwQ292ZXJhZ2VMaXN0KFxuICAgICAgICBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZSwgbG9va2FoZWFkUGFyYW1zXG4gICAgKTtcbiAgICAvLyBCQUNLVFJBQ0sgTE9PS1VQIC8vXG4gICAgdmFyIGJhY2t0cmFja0NvbnRleHQgPSBbXS5jb25jYXQoY29udGV4dFBhcmFtcy5iYWNrdHJhY2spO1xuICAgIGJhY2t0cmFja0NvbnRleHQucmV2ZXJzZSgpO1xuICAgIHdoaWxlIChiYWNrdHJhY2tDb250ZXh0Lmxlbmd0aCAmJiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihiYWNrdHJhY2tDb250ZXh0WzBdLmNoYXIpKSB7XG4gICAgICAgIGJhY2t0cmFja0NvbnRleHQuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKGJhY2t0cmFja0NvbnRleHQubGVuZ3RoIDwgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UubGVuZ3RoKSB7IHJldHVybiBbXTsgfVxuICAgIHZhciBiYWNrdHJhY2tQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhiYWNrdHJhY2tDb250ZXh0LCAwKTtcbiAgICB2YXIgYmFja3RyYWNrTG9va3VwcyA9IGxvb2t1cENvdmVyYWdlTGlzdChcbiAgICAgICAgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UsIGJhY2t0cmFja1BhcmFtc1xuICAgICk7XG4gICAgdmFyIGNvbnRleHRSdWxlc01hdGNoID0gKFxuICAgICAgICBpbnB1dExvb2t1cHMubGVuZ3RoID09PSBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmxlbmd0aCAmJlxuICAgICAgICBsb29rYWhlYWRMb29rdXBzLmxlbmd0aCA9PT0gc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RoICYmXG4gICAgICAgIGJhY2t0cmFja0xvb2t1cHMubGVuZ3RoID09PSBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGhcbiAgICApO1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgaWYgKGNvbnRleHRSdWxlc01hdGNoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGUubG9va3VwUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvb2t1cFJlY29yZCA9IHN1YnRhYmxlLmxvb2t1cFJlY29yZHNbaV07XG4gICAgICAgICAgICB2YXIgbG9va3VwTGlzdEluZGV4ID0gbG9va3VwUmVjb3JkLmxvb2t1cExpc3RJbmRleDtcbiAgICAgICAgICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwQnlJbmRleChsb29rdXBMaXN0SW5kZXgpO1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBsb29rdXBUYWJsZS5zdWJ0YWJsZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VidGFibGUkMSA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlc1tzXTtcbiAgICAgICAgICAgICAgICB2YXIgbG9va3VwID0gdGhpcy5nZXRMb29rdXBNZXRob2QobG9va3VwVGFibGUsIHN1YnRhYmxlJDEpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb25UeXBlID0gdGhpcy5nZXRTdWJzdGl0dXRpb25UeXBlKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSQxKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uVHlwZSA9PT0gJzEyJykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGlucHV0TG9va3Vwcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoSW5kZXggPSBjb250ZXh0UGFyYW1zLmdldChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb24gPSBsb29rdXAoZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7IHN1YnN0aXR1dGlvbnMucHVzaChzdWJzdGl0dXRpb24pOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG59XG5cbi8qKlxuICogSGFuZGxlIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAxXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MShjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZSkge1xuICAgIC8vIENPVkVSQUdFIExPT0tVUCAvL1xuICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgIHZhciBsaWdTZXRJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICBpZiAobGlnU2V0SW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgLy8gQ09NUE9ORU5UUyBMT09LVVBcbiAgICAvLyAoISkgbm90ZSwgY29tcG9uZW50cyBhcmUgb3JkZXJlZCBpbiB0aGUgd3JpdHRlbiBkaXJlY3Rpb24uXG4gICAgdmFyIGxpZ2F0dXJlO1xuICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1tsaWdTZXRJbmRleF07XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBsaWdhdHVyZVNldC5sZW5ndGg7IHMrKykge1xuICAgICAgICBsaWdhdHVyZSA9IGxpZ2F0dXJlU2V0W3NdO1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpZ2F0dXJlLmNvbXBvbmVudHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBsb29rYWhlYWRJdGVtID0gY29udGV4dFBhcmFtcy5sb29rYWhlYWRbbF07XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gbGlnYXR1cmUuY29tcG9uZW50c1tsXTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWRJdGVtICE9PSBjb21wb25lbnQpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIGlmIChsID09PSBsaWdhdHVyZS5jb21wb25lbnRzLmxlbmd0aCAtIDEpIHsgcmV0dXJuIGxpZ2F0dXJlOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogSGFuZGxlIGRlY29tcG9zaXRpb24gc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IGdseXBoIGluZGV4XG4gKiBAcGFyYW0ge2FueX0gc3VidGFibGUgc3VidGFibGVcbiAqL1xuZnVuY3Rpb24gZGVjb21wb3NpdGlvblN1YnN0aXR1dGlvbkZvcm1hdDEoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIHN1YnRhYmxlLnNlcXVlbmNlc1tzdWJzdGl0dXRlSW5kZXhdO1xufVxuXG4vKipcbiAqIEdldCBkZWZhdWx0IHNjcmlwdCBmZWF0dXJlcyBpbmRleGVzXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdFNjcmlwdEZlYXR1cmVzSW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NyaXB0cyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5zY3JpcHRzO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc2NyaXB0cy5sZW5ndGg7IHMrKykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tzXTtcbiAgICAgICAgaWYgKHNjcmlwdC50YWcgPT09ICdERkxUJykgeyByZXR1cm4gKFxuICAgICAgICAgICAgc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlc1xuICAgICAgICApOyB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbi8qKlxuICogR2V0IGZlYXR1cmUgaW5kZXhlcyBvZiBhIHNwZWNpZmljIHNjcmlwdFxuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0U2NyaXB0RmVhdHVyZXNJbmRleGVzID0gZnVuY3Rpb24oc2NyaXB0VGFnKSB7XG4gICAgdmFyIHRhYmxlcyA9IHRoaXMuZm9udC50YWJsZXM7XG4gICAgaWYgKCF0YWJsZXMuZ3N1YikgeyByZXR1cm4gW107IH1cbiAgICBpZiAoIXNjcmlwdFRhZykgeyByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzKCk7IH1cbiAgICB2YXIgc2NyaXB0cyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5zY3JpcHRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcbiAgICAgICAgaWYgKHNjcmlwdC50YWcgPT09IHNjcmlwdFRhZyAmJiBzY3JpcHQuc2NyaXB0LmRlZmF1bHRMYW5nU3lzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkcyA9IHNjcmlwdC5sYW5nU3lzUmVjb3JkcztcbiAgICAgICAgICAgIGlmICghIWxhbmdTeXNSZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsYW5nU3lzUmVjb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZCA9IGxhbmdTeXNSZWNvcmRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ1N5c1JlY29yZC50YWcgPT09IHNjcmlwdFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdTeXMgPSBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5cy5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzKCk7XG59O1xuXG4vKipcbiAqIE1hcCBhIGZlYXR1cmUgdGFnIHRvIGEgZ3N1YiBmZWF0dXJlXG4gKiBAcGFyYW0ge2FueX0gZmVhdHVyZXMgZ3N1YiBmZWF0dXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUubWFwVGFnc1RvRmVhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHNjcmlwdFRhZykge1xuICAgIHZhciB0YWdzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGFnID0gZmVhdHVyZXNbaV0udGFnO1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldLmZlYXR1cmU7XG4gICAgICAgIHRhZ3NbdGFnXSA9IGZlYXR1cmU7XG4gICAgfVxuICAgIHRoaXMuZmVhdHVyZXNbc2NyaXB0VGFnXS50YWdzID0gdGFncztcbn07XG5cbi8qKlxuICogR2V0IGZlYXR1cmVzIG9mIGEgc3BlY2lmaWMgc2NyaXB0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0VGFnIHNjcmlwdCB0YWdcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRTY3JpcHRGZWF0dXJlcyA9IGZ1bmN0aW9uIChzY3JpcHRUYWcpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzW3NjcmlwdFRhZ107XG4gICAgaWYgKHRoaXMuZmVhdHVyZXMuaGFzT3duUHJvcGVydHkoc2NyaXB0VGFnKSkgeyByZXR1cm4gZmVhdHVyZXM7IH1cbiAgICB2YXIgZmVhdHVyZXNJbmRleGVzID0gdGhpcy5nZXRTY3JpcHRGZWF0dXJlc0luZGV4ZXMoc2NyaXB0VGFnKTtcbiAgICBpZiAoIWZlYXR1cmVzSW5kZXhlcykgeyByZXR1cm4gbnVsbDsgfVxuICAgIHZhciBnc3ViID0gdGhpcy5mb250LnRhYmxlcy5nc3ViO1xuICAgIGZlYXR1cmVzID0gZmVhdHVyZXNJbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGdzdWIuZmVhdHVyZXNbaW5kZXhdOyB9KTtcbiAgICB0aGlzLmZlYXR1cmVzW3NjcmlwdFRhZ10gPSBmZWF0dXJlcztcbiAgICB0aGlzLm1hcFRhZ3NUb0ZlYXR1cmVzKGZlYXR1cmVzLCBzY3JpcHRUYWcpO1xuICAgIHJldHVybiBmZWF0dXJlcztcbn07XG5cbi8qKlxuICogR2V0IHN1YnN0aXR1dGlvbiB0eXBlXG4gKiBAcGFyYW0ge2FueX0gbG9va3VwVGFibGUgbG9va3VwIHRhYmxlXG4gKiBAcGFyYW0ge2FueX0gc3VidGFibGUgc3VidGFibGVcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRTdWJzdGl0dXRpb25UeXBlID0gZnVuY3Rpb24obG9va3VwVGFibGUsIHN1YnRhYmxlKSB7XG4gICAgdmFyIGxvb2t1cFR5cGUgPSBsb29rdXBUYWJsZS5sb29rdXBUeXBlLnRvU3RyaW5nKCk7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gc3VidGFibGUuc3Vic3RGb3JtYXQudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gbG9va3VwVHlwZSArIHN1YnN0Rm9ybWF0O1xufTtcblxuLyoqXG4gKiBHZXQgbG9va3VwIG1ldGhvZFxuICogQHBhcmFtIHthbnl9IGxvb2t1cFRhYmxlIGxvb2t1cCB0YWJsZVxuICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0TG9va3VwTWV0aG9kID0gZnVuY3Rpb24obG9va3VwVGFibGUsIHN1YnRhYmxlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3Vic3RpdHV0aW9uVHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUpO1xuICAgIHN3aXRjaCAoc3Vic3RpdHV0aW9uVHlwZSkge1xuICAgICAgICBjYXNlICcxMSc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdseXBoSW5kZXgpIHsgcmV0dXJuIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBjYXNlICcxMic6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdseXBoSW5kZXgpIHsgcmV0dXJuIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBjYXNlICc2Myc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHRQYXJhbXMpIHsgcmV0dXJuIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0My5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzJDEsIFtjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICk7IH07XG4gICAgICAgIGNhc2UgJzQxJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dFBhcmFtcykgeyByZXR1cm4gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMkMSwgW2NvbnRleHRQYXJhbXMsIHN1YnRhYmxlXVxuICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgY2FzZSAnMjEnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbHlwaEluZGV4KSB7IHJldHVybiBkZWNvbXBvc2l0aW9uU3Vic3RpdHV0aW9uRm9ybWF0MS5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzJDEsIFtnbHlwaEluZGV4LCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICk7IH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJsb29rdXBUeXBlOiBcIiArIChsb29rdXBUYWJsZS5sb29rdXBUeXBlKSArIFwiIC0gXCIgK1xuICAgICAgICAgICAgICAgIFwic3Vic3RGb3JtYXQ6IFwiICsgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0KSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICBcImlzIG5vdCB5ZXQgc3VwcG9ydGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBbIExPT0tVUCBUWVBFUyBdXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTaW5nbGUgICAgICAgICAgICAgICAgICAgICAgICAxO1xuICogTXVsdGlwbGUgICAgICAgICAgICAgICAgICAgICAgMjtcbiAqIEFsdGVybmF0ZSAgICAgICAgICAgICAgICAgICAgIDM7XG4gKiBMaWdhdHVyZSAgICAgICAgICAgICAgICAgICAgICA0O1xuICogQ29udGV4dCAgICAgICAgICAgICAgICAgICAgICAgNTtcbiAqIENoYWluaW5nQ29udGV4dCAgICAgICAgICAgICAgIDY7XG4gKiBFeHRlbnNpb25TdWJzdGl0dXRpb24gICAgICAgICA3O1xuICogUmV2ZXJzZUNoYWluaW5nQ29udGV4dCAgICAgICAgODtcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBGUXVlcnlcbiAqIEB0eXBlIE9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBmZWF0dXJlIHRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdCBmZWF0dXJlIHNjcmlwdFxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBMb29rdXAgYSBmZWF0dXJlIHVzaW5nIGEgcXVlcnkgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGUXVlcnl9IHF1ZXJ5IGZlYXR1cmUgcXVlcnlcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5sb29rdXBGZWF0dXJlID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgdmFyIGNvbnRleHRQYXJhbXMgPSBxdWVyeS5jb250ZXh0UGFyYW1zO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBjb250ZXh0UGFyYW1zLmluZGV4O1xuICAgIHZhciBmZWF0dXJlID0gdGhpcy5nZXRGZWF0dXJlKHtcbiAgICAgICAgdGFnOiBxdWVyeS50YWcsIHNjcmlwdDogcXVlcnkuc2NyaXB0XG4gICAgfSk7XG4gICAgaWYgKCFmZWF0dXJlKSB7IHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIFwiZm9udCAnXCIgKyAodGhpcy5mb250Lm5hbWVzLmZ1bGxOYW1lLmVuKSArIFwiJyBcIiArXG4gICAgICAgIFwiZG9lc24ndCBzdXBwb3J0IGZlYXR1cmUgJ1wiICsgKHF1ZXJ5LnRhZykgKyBcIicgXCIgK1xuICAgICAgICBcImZvciBzY3JpcHQgJ1wiICsgKHF1ZXJ5LnNjcmlwdCkgKyBcIicuXCJcbiAgICApOyB9XG4gICAgdmFyIGxvb2t1cHMgPSB0aGlzLmdldEZlYXR1cmVMb29rdXBzKGZlYXR1cmUpO1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW10uY29uY2F0KGNvbnRleHRQYXJhbXMuY29udGV4dCk7XG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsb29rdXBzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBsb29rdXBUYWJsZSA9IGxvb2t1cHNbbF07XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSB0aGlzLmdldExvb2t1cFN1YnRhYmxlcyhsb29rdXBUYWJsZSk7XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3VidGFibGVzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbc107XG4gICAgICAgICAgICB2YXIgc3Vic3RUeXBlID0gdGhpcy5nZXRTdWJzdGl0dXRpb25UeXBlKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSk7XG4gICAgICAgICAgICB2YXIgbG9va3VwID0gdGhpcy5nZXRMb29rdXBNZXRob2QobG9va3VwVGFibGUsIHN1YnRhYmxlKTtcbiAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb24gPSAodm9pZCAwKTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3Vic3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnMTEnOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogMTEsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzEyJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDEyLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc2Myc6XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic3RpdHV0aW9uKSAmJiBzdWJzdGl0dXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA2MywgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnNDEnOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDQxLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcyMSc6XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAyMSwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoc3Vic3RpdHV0aW9ucywgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnN0aXR1dGlvbikgJiYgIXN1YnN0aXR1dGlvbi5sZW5ndGgpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnMubGVuZ3RoID8gc3Vic3RpdHV0aW9ucyA6IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGZvbnQgc3VwcG9ydHMgYSBzcGVjaWZpYyBmZWF0dXJlc1xuICogQHBhcmFtIHtGUXVlcnl9IHF1ZXJ5IGZlYXR1cmUgcXVlcnkgb2JqZWN0XG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5LnNjcmlwdCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB0aGlzLmdldFNjcmlwdEZlYXR1cmVzKHF1ZXJ5LnNjcmlwdCk7XG4gICAgdmFyIHN1cHBvcnRlZFNjcmlwdCA9IHRoaXMuZmVhdHVyZXMuaGFzT3duUHJvcGVydHkocXVlcnkuc2NyaXB0KTtcbiAgICBpZiAoIXF1ZXJ5LnRhZykgeyByZXR1cm4gc3VwcG9ydGVkU2NyaXB0OyB9XG4gICAgdmFyIHN1cHBvcnRlZEZlYXR1cmUgPSAoXG4gICAgICAgIHRoaXMuZmVhdHVyZXNbcXVlcnkuc2NyaXB0XS5zb21lKGZ1bmN0aW9uIChmZWF0dXJlKSB7IHJldHVybiBmZWF0dXJlLnRhZyA9PT0gcXVlcnkudGFnOyB9KVxuICAgICk7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFNjcmlwdCAmJiBzdXBwb3J0ZWRGZWF0dXJlO1xufTtcblxuLyoqXG4gKiBHZXQgbG9va3VwIHRhYmxlIHN1YnRhYmxlc1xuICogQHBhcmFtIHthbnl9IGxvb2t1cFRhYmxlIGxvb2t1cCB0YWJsZVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cFN1YnRhYmxlcyA9IGZ1bmN0aW9uIChsb29rdXBUYWJsZSkge1xuICAgIHJldHVybiBsb29rdXBUYWJsZS5zdWJ0YWJsZXMgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCB0YWJsZSBieSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxvb2t1cCB0YWJsZSBpbmRleFxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgbG9va3VwcyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5sb29rdXBzO1xuICAgIHJldHVybiBsb29rdXBzW2luZGV4XSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgbG9va3VwIHRhYmxlcyBmb3IgYSBmZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldEZlYXR1cmVMb29rdXBzID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAvLyBUT0RPOiBtZW1vaXplXG4gICAgcmV0dXJuIGZlYXR1cmUubG9va3VwTGlzdEluZGV4ZXMubWFwKHRoaXMuZ2V0TG9va3VwQnlJbmRleC5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogUXVlcnkgYSBmZWF0dXJlIGJ5IGl0J3MgcHJvcGVydGllc1xuICogQHBhcmFtIHthbnl9IHF1ZXJ5IGFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiBhIHF1ZXJ5XG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0RmVhdHVyZSA9IGZ1bmN0aW9uIGdldEZlYXR1cmUocXVlcnkpIHtcbiAgICBpZiAoIXRoaXMuZm9udCkgeyByZXR1cm4geyBGQUlMOiBcIk5vIGZvbnQgd2FzIGZvdW5kXCJ9OyB9XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLmhhc093blByb3BlcnR5KHF1ZXJ5LnNjcmlwdCkpIHtcbiAgICAgICAgdGhpcy5nZXRTY3JpcHRGZWF0dXJlcyhxdWVyeS5zY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgc2NyaXB0RmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzW3F1ZXJ5LnNjcmlwdF07XG4gICAgaWYgKCFzY3JpcHRGZWF0dXJlcykgeyByZXR1cm4gKFxuICAgICAgICB7IEZBSUw6IChcIk5vIGZlYXR1cmUgZm9yIHNjcmlwdCBcIiArIChxdWVyeS5zY3JpcHQpKX1cbiAgICApOyB9XG4gICAgaWYgKCFzY3JpcHRGZWF0dXJlcy50YWdzW3F1ZXJ5LnRhZ10pIHsgcmV0dXJuIG51bGw7IH1cbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1txdWVyeS5zY3JpcHRdLnRhZ3NbcXVlcnkudGFnXTtcbn07XG5cbi8qKlxuICogQXJhYmljIHdvcmQgY29udGV4dCBjaGVja2Vyc1xuICovXG5cbmZ1bmN0aW9uIGFyYWJpY1dvcmRTdGFydENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgY2hhciA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICB2YXIgcHJldkNoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgtMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gPyBhcmFiaWMgZmlyc3QgY2hhclxuICAgICAgICAocHJldkNoYXIgPT09IG51bGwgJiYgaXNBcmFiaWNDaGFyKGNoYXIpKSB8fFxuICAgICAgICAvLyA/IGFyYWJpYyBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gYXJhYmljIGNoYXJcbiAgICAgICAgKCFpc0FyYWJpY0NoYXIocHJldkNoYXIpICYmIGlzQXJhYmljQ2hhcihjaGFyKSlcbiAgICApO1xufVxuXG5mdW5jdGlvbiBhcmFiaWNXb3JkRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBuZXh0Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KDEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gbGFzdCBhcmFiaWMgY2hhclxuICAgICAgICAobmV4dENoYXIgPT09IG51bGwpIHx8XG4gICAgICAgIC8vID8gbmV4dCBjaGFyIGlzIG5vdCBhcmFiaWNcbiAgICAgICAgKCFpc0FyYWJpY0NoYXIobmV4dENoYXIpKVxuICAgICk7XG59XG5cbnZhciBhcmFiaWNXb3JkQ2hlY2sgPSB7XG4gICAgc3RhcnRDaGVjazogYXJhYmljV29yZFN0YXJ0Q2hlY2ssXG4gICAgZW5kQ2hlY2s6IGFyYWJpY1dvcmRFbmRDaGVja1xufTtcblxuLyoqXG4gKiBBcmFiaWMgc2VudGVuY2UgY29udGV4dCBjaGVja2Vyc1xuICovXG5cbmZ1bmN0aW9uIGFyYWJpY1NlbnRlbmNlU3RhcnRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGNoYXIgPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoLTEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gYW4gYXJhYmljIGNoYXIgcHJlY2VkZWQgd2l0aCBhIG5vbiBhcmFiaWMgY2hhclxuICAgICAgICAoaXNBcmFiaWNDaGFyKGNoYXIpIHx8IGlzVGFzaGtlZWxBcmFiaWNDaGFyKGNoYXIpKSAmJlxuICAgICAgICAhaXNBcmFiaWNDaGFyKHByZXZDaGFyKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGFyYWJpY1NlbnRlbmNlRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBuZXh0Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KDEpO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIG5leHRDaGFyID09PSBudWxsOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgKCFpc0FyYWJpY0NoYXIobmV4dENoYXIpICYmICFpc1Rhc2hrZWVsQXJhYmljQ2hhcihuZXh0Q2hhcikpOlxuICAgICAgICAgICAgdmFyIG5leHRJc1doaXRlc3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuICAgICAgICAgICAgaWYgKCFuZXh0SXNXaGl0ZXNwYWNlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICBpZiAobmV4dElzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmFiaWNDaGFyQWhlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcmFiaWNDaGFyQWhlYWQgPSAoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRQYXJhbXMubG9va2FoZWFkLnNvbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYykgeyByZXR1cm4gaXNBcmFiaWNDaGFyKGMpIHx8IGlzVGFzaGtlZWxBcmFiaWNDaGFyKGMpOyB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghYXJhYmljQ2hhckFoZWFkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbnZhciBhcmFiaWNTZW50ZW5jZUNoZWNrID0ge1xuICAgIHN0YXJ0Q2hlY2s6IGFyYWJpY1NlbnRlbmNlU3RhcnRDaGVjayxcbiAgICBlbmRDaGVjazogYXJhYmljU2VudGVuY2VFbmRDaGVja1xufTtcblxuLyoqXG4gKiBBcHBseSBzaW5nbGUgc3Vic3RpdHV0aW9uIGZvcm1hdCAxXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEkMShhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICB0b2tlbnNbaW5kZXhdLnNldFN0YXRlKGFjdGlvbi50YWcsIGFjdGlvbi5zdWJzdGl0dXRpb24pO1xufVxuXG4vKipcbiAqIEFwcGx5IHNpbmdsZSBzdWJzdGl0dXRpb24gZm9ybWF0IDJcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MiQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgIHRva2Vuc1tpbmRleF0uc2V0U3RhdGUoYWN0aW9uLnRhZywgYWN0aW9uLnN1YnN0aXR1dGlvbik7XG59XG5cbi8qKlxuICogQXBwbHkgY2hhaW5pbmcgY29udGV4dCBzdWJzdGl0dXRpb24gZm9ybWF0IDNcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgYWN0aW9uLnN1YnN0aXR1dGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzdCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpbmRleCArIG9mZnNldF07XG4gICAgICAgIHRva2VuLnNldFN0YXRlKGFjdGlvbi50YWcsIHN1YnN0KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSBsaWdhdHVyZSBzdWJzdGl0dXRpb24gZm9ybWF0IDFcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2luZGV4XTtcbiAgICB0b2tlbi5zZXRTdGF0ZShhY3Rpb24udGFnLCBhY3Rpb24uc3Vic3RpdHV0aW9uLmxpZ0dseXBoKTtcbiAgICB2YXIgY29tcHNDb3VudCA9IGFjdGlvbi5zdWJzdGl0dXRpb24uY29tcG9uZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wc0NvdW50OyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaW5kZXggKyBpICsgMV07XG4gICAgICAgIHRva2VuLnNldFN0YXRlKCdkZWxldGVkJywgdHJ1ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFN1cHBvcnRlZCBzdWJzdGl0dXRpb25zXG4gKi9cbnZhciBTVUJTVElUVVRJT05TID0ge1xuICAgIDExOiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxJDEsXG4gICAgMTI6IHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIkMSxcbiAgICA2MzogY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEsXG4gICAgNDE6IGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MSQxXG59O1xuXG4vKipcbiAqIEFwcGx5IHN1YnN0aXR1dGlvbnMgdG8gYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5mdW5jdGlvbiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgU3Vic3RpdHV0aW9uQWN0aW9uICYmIFNVQlNUSVRVVElPTlNbYWN0aW9uLmlkXSkge1xuICAgICAgICBTVUJTVElUVVRJT05TW2FjdGlvbi5pZF0oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTtcbiAgICB9XG59XG5cbi8qKlxuICogQXBwbHkgQXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyB0byBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGNhbiBiZSBjb25uZWN0ZWQgdG8gaXQncyBwcmVjZWRpbmcgY2hhclxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjaGFyQ29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyBvZiBhIGNoYXJcbiAqL1xuZnVuY3Rpb24gd2lsbENvbm5lY3RQcmV2KGNoYXJDb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGJhY2t0cmFjayA9IFtdLmNvbmNhdChjaGFyQ29udGV4dFBhcmFtcy5iYWNrdHJhY2spO1xuICAgIGZvciAodmFyIGkgPSBiYWNrdHJhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHByZXZDaGFyID0gYmFja3RyYWNrW2ldO1xuICAgICAgICB2YXIgaXNvbGF0ZWQgPSBpc0lzb2xhdGVkQXJhYmljQ2hhcihwcmV2Q2hhcik7XG4gICAgICAgIHZhciB0YXNoa2VlbCA9IGlzVGFzaGtlZWxBcmFiaWNDaGFyKHByZXZDaGFyKTtcbiAgICAgICAgaWYgKCFpc29sYXRlZCAmJiAhdGFzaGtlZWwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgaWYgKGlzb2xhdGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGNhbiBiZSBjb25uZWN0ZWQgdG8gaXQncyBwcm9jZWVkaW5nIGNoYXJcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY2hhckNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgb2YgYSBjaGFyXG4gKi9cbmZ1bmN0aW9uIHdpbGxDb25uZWN0TmV4dChjaGFyQ29udGV4dFBhcmFtcykge1xuICAgIGlmIChpc0lzb2xhdGVkQXJhYmljQ2hhcihjaGFyQ29udGV4dFBhcmFtcy5jdXJyZW50KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb250ZXh0UGFyYW1zLmxvb2thaGVhZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV4dENoYXIgPSBjaGFyQ29udGV4dFBhcmFtcy5sb29rYWhlYWRbaV07XG4gICAgICAgIHZhciB0YXNoa2VlbCA9IGlzVGFzaGtlZWxBcmFiaWNDaGFyKG5leHRDaGFyKTtcbiAgICAgICAgaWYgKCF0YXNoa2VlbCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQXBwbHkgYXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyB0byBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge0NvbnRleHRSYW5nZX0gcmFuZ2UgYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gYXJhYmljUHJlc2VudGF0aW9uRm9ybXMocmFuZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhcbiAgICAgICAgdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmdldFN0YXRlKCdnbHlwaEluZGV4Jyk7IH1cbiAgICApLCAwKTtcbiAgICB2YXIgY2hhckNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhcbiAgICAgICAgdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH1cbiAgICApLCAwKTtcbiAgICB0b2tlbnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4sIGluZGV4KSB7XG4gICAgICAgIGlmIChpc1Rhc2hrZWVsQXJhYmljQ2hhcih0b2tlbi5jaGFyKSkgeyByZXR1cm47IH1cbiAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICBjaGFyQ29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgQ09OTkVDVCA9IDA7IC8vIDIgYml0cyAwMCAoMTA6IGNhbiBjb25uZWN0IG5leHQpICgwMTogY2FuIGNvbm5lY3QgcHJldilcbiAgICAgICAgaWYgKHdpbGxDb25uZWN0UHJldihjaGFyQ29udGV4dFBhcmFtcykpIHsgQ09OTkVDVCB8PSAxOyB9XG4gICAgICAgIGlmICh3aWxsQ29ubmVjdE5leHQoY2hhckNvbnRleHRQYXJhbXMpKSB7IENPTk5FQ1QgfD0gMjsgfVxuICAgICAgICB2YXIgdGFnO1xuICAgICAgICBzd2l0Y2ggKENPTk5FQ1QpIHtcbiAgICAgICAgICAgIGNhc2UgMTogKHRhZyA9ICdmaW5hJyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOiAodGFnID0gJ2luaXQnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6ICh0YWcgPSAnbWVkaScpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFncy5pbmRleE9mKHRhZykgPT09IC0xKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcbiAgICAgICAgICAgIHRhZzogdGFnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMgaW5zdGFuY2VvZiBFcnJvcikgeyByZXR1cm4gY29uc29sZS5pbmZvKHN1YnN0aXR1dGlvbnMubWVzc2FnZSk7IH1cbiAgICAgICAgc3Vic3RpdHV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgU3Vic3RpdHV0aW9uQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0UGFyYW1zLmNvbnRleHRbaW5kZXhdID0gYWN0aW9uLnN1YnN0aXR1dGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgQXJhYmljIHJlcXVpcmVkIGxpZ2F0dXJlcyBmZWF0dXJlIHRvIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cblxuLyoqXG4gKiBVcGRhdGUgY29udGV4dCBwYXJhbXNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0UGFyYW1zKHRva2VucywgaW5kZXgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5hY3RpdmVTdGF0ZS52YWx1ZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0UGFyYW1zKGNvbnRleHQsIGluZGV4IHx8IDApO1xufVxuXG4vKipcbiAqIEFwcGx5IEFyYWJpYyByZXF1aXJlZCBsaWdhdHVyZXMgdG8gYSBjb250ZXh0IHJhbmdlXG4gKiBAcGFyYW0ge0NvbnRleHRSYW5nZX0gcmFuZ2UgYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gYXJhYmljUmVxdWlyZWRMaWdhdHVyZXMocmFuZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcbiAgICB2YXIgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXModG9rZW5zKTtcbiAgICBjb250ZXh0UGFyYW1zLmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGhJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcbiAgICAgICAgICAgIHRhZzogJ3JsaWcnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTsgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBMYXRpbiB3b3JkIGNvbnRleHQgY2hlY2tlcnNcbiAqL1xuXG5mdW5jdGlvbiBsYXRpbldvcmRTdGFydENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgY2hhciA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICB2YXIgcHJldkNoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgtMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gPyBsYXRpbiBmaXJzdCBjaGFyXG4gICAgICAgIChwcmV2Q2hhciA9PT0gbnVsbCAmJiBpc0xhdGluQ2hhcihjaGFyKSkgfHxcbiAgICAgICAgLy8gPyBsYXRpbiBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gbGF0aW4gY2hhclxuICAgICAgICAoIWlzTGF0aW5DaGFyKHByZXZDaGFyKSAmJiBpc0xhdGluQ2hhcihjaGFyKSlcbiAgICApO1xufVxuXG5mdW5jdGlvbiBsYXRpbldvcmRFbmRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIG5leHRDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gPyBsYXN0IGxhdGluIGNoYXJcbiAgICAgICAgKG5leHRDaGFyID09PSBudWxsKSB8fFxuICAgICAgICAvLyA/IG5leHQgY2hhciBpcyBub3QgbGF0aW5cbiAgICAgICAgKCFpc0xhdGluQ2hhcihuZXh0Q2hhcikpXG4gICAgKTtcbn1cblxudmFyIGxhdGluV29yZENoZWNrID0ge1xuICAgIHN0YXJ0Q2hlY2s6IGxhdGluV29yZFN0YXJ0Q2hlY2ssXG4gICAgZW5kQ2hlY2s6IGxhdGluV29yZEVuZENoZWNrXG59O1xuXG4vKipcbiAqIEFwcGx5IExhdGluIGxpZ2F0dXJlIGZlYXR1cmUgdG8gYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuXG4vKipcbiAqIFVwZGF0ZSBjb250ZXh0IHBhcmFtc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggY3VycmVudCBpdGVtIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMsIGluZGV4KSB7XG4gICAgdmFyIGNvbnRleHQgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uYWN0aXZlU3RhdGUudmFsdWU7IH0pO1xuICAgIHJldHVybiBuZXcgQ29udGV4dFBhcmFtcyhjb250ZXh0LCBpbmRleCB8fCAwKTtcbn1cblxuLyoqXG4gKiBBcHBseSBBcmFiaWMgcmVxdWlyZWQgbGlnYXR1cmVzIHRvIGEgY29udGV4dCByYW5nZVxuICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGxhdGluTGlnYXR1cmUocmFuZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnbGF0bic7XG4gICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcbiAgICB2YXIgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMpO1xuICAgIGNvbnRleHRQYXJhbXMuY29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uIChnbHlwaEluZGV4LCBpbmRleCkge1xuICAgICAgICBjb250ZXh0UGFyYW1zLnNldEN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gdGhpcyQxLnF1ZXJ5Lmxvb2t1cEZlYXR1cmUoe1xuICAgICAgICAgICAgdGFnOiAnbGlnYScsIHNjcmlwdDogc2NyaXB0LCBjb250ZXh0UGFyYW1zOiBjb250ZXh0UGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3Vic3RpdHV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogSW5mZXIgYmlkaXJlY3Rpb25hbCBwcm9wZXJ0aWVzIGZvciBhIGdpdmVuIHRleHQgYW5kIGFwcGx5XG4gKiB0aGUgY29ycmVzcG9uZGluZyBsYXlvdXQgcnVsZXMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgQmlkaS4gZmVhdHVyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlRGlyIHRleHQgYmFzZSBkaXJlY3Rpb24uIHZhbHVlIGVpdGhlciAnbHRyJyBvciAncnRsJ1xuICovXG5mdW5jdGlvbiBCaWRpKGJhc2VEaXIpIHtcbiAgICB0aGlzLmJhc2VEaXIgPSBiYXNlRGlyIHx8ICdsdHInO1xuICAgIHRoaXMudG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xuICAgIHRoaXMuZmVhdHVyZXNUYWdzID0ge307XG59XG5cbi8qKlxuICogU2V0cyBCaWRpIHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGEgdGV4dCBpbnB1dFxuICovXG5CaWRpLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBTdG9yZSBlc3NlbnRpYWwgY29udGV4dCBjaGVja3M6XG4gKiBhcmFiaWMgd29yZCBjaGVjayBmb3IgYXBwbHlpbmcgZ3N1YiBmZWF0dXJlc1xuICogYXJhYmljIHNlbnRlbmNlIGNoZWNrIGZvciBhZGp1c3RpbmcgYXJhYmljIGxheW91dFxuICovXG5CaWRpLnByb3RvdHlwZS5jb250ZXh0Q2hlY2tzID0gKHtcbiAgICBsYXRpbldvcmRDaGVjazogbGF0aW5Xb3JkQ2hlY2ssXG4gICAgYXJhYmljV29yZENoZWNrOiBhcmFiaWNXb3JkQ2hlY2ssXG4gICAgYXJhYmljU2VudGVuY2VDaGVjazogYXJhYmljU2VudGVuY2VDaGVja1xufSk7XG5cbi8qKlxuICogUmVnaXN0ZXIgYXJhYmljIHdvcmQgY2hlY2tcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb250ZXh0Q2hlY2tlcihjaGVja0lkKSB7XG4gICAgdmFyIGNoZWNrID0gdGhpcy5jb250ZXh0Q2hlY2tzWyhjaGVja0lkICsgXCJDaGVja1wiKV07XG4gICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyQ29udGV4dENoZWNrZXIoXG4gICAgICAgIGNoZWNrSWQsIGNoZWNrLnN0YXJ0Q2hlY2ssIGNoZWNrLmVuZENoZWNrXG4gICAgKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIHByZSB0b2tlbml6YXRpb24gcHJvY2VkdXJlIHRoZW5cbiAqIHRva2VuaXplIHRleHQgaW5wdXRcbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVUZXh0KCkge1xuICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnbGF0aW5Xb3JkJyk7XG4gICAgcmVnaXN0ZXJDb250ZXh0Q2hlY2tlci5jYWxsKHRoaXMsICdhcmFiaWNXb3JkJyk7XG4gICAgcmVnaXN0ZXJDb250ZXh0Q2hlY2tlci5jYWxsKHRoaXMsICdhcmFiaWNTZW50ZW5jZScpO1xuICAgIHJldHVybiB0aGlzLnRva2VuaXplci50b2tlbml6ZSh0aGlzLnRleHQpO1xufVxuXG4vKipcbiAqIFJldmVyc2UgYXJhYmljIHNlbnRlbmNlIGxheW91dFxuICogVE9ETzogY2hlY2sgYmFzZSBkaXIgYmVmb3JlIGFwcGx5aW5nIGFkanVzdG1lbnRzIC0gcHJpb3JpdHkgbG93XG4gKi9cbmZ1bmN0aW9uIHJldmVyc2VBcmFiaWNTZW50ZW5jZXMoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnYXJhYmljU2VudGVuY2UnKTtcbiAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHJhbmdlVG9rZW5zID0gdGhpcyQxLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgICAgIHRoaXMkMS50b2tlbml6ZXIucmVwbGFjZVJhbmdlKFxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRJbmRleCxcbiAgICAgICAgICAgIHJhbmdlLmVuZE9mZnNldCxcbiAgICAgICAgICAgIHJhbmdlVG9rZW5zLnJldmVyc2UoKVxuICAgICAgICApO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHN1cHBvcnRlZCBmZWF0dXJlcyB0YWdzXG4gKiBAcGFyYW0ge3NjcmlwdH0gc2NyaXB0IHNjcmlwdCB0YWdcbiAqIEBwYXJhbSB7QXJyYXl9IHRhZ3MgZmVhdHVyZXMgdGFncyBsaXN0XG4gKi9cbkJpZGkucHJvdG90eXBlLnJlZ2lzdGVyRmVhdHVyZXMgPSBmdW5jdGlvbiAoc2NyaXB0LCB0YWdzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3VwcG9ydGVkVGFncyA9IHRhZ3MuZmlsdGVyKFxuICAgICAgICBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0aGlzJDEucXVlcnkuc3VwcG9ydHMoe3NjcmlwdDogc2NyaXB0LCB0YWc6IHRhZ30pOyB9XG4gICAgKTtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XSA9IHN1cHBvcnRlZFRhZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XSA9XG4gICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF0uY29uY2F0KHN1cHBvcnRlZFRhZ3MpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgR1NVQiBmZWF0dXJlc1xuICogQHBhcmFtIHtBcnJheX0gdGFnc0xpc3QgYSBsaXN0IG9mIGZlYXR1cmVzIHRhZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgYSBzY3JpcHQgdGFnXG4gKiBAcGFyYW0ge0ZvbnR9IGZvbnQgb3BlbnR5cGUgZm9udCBpbnN0YW5jZVxuICovXG5CaWRpLnByb3RvdHlwZS5hcHBseUZlYXR1cmVzID0gZnVuY3Rpb24gKGZvbnQsIGZlYXR1cmVzKSB7XG4gICAgaWYgKCFmb250KSB7IHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ05vIHZhbGlkIGZvbnQgd2FzIHByb3ZpZGVkIHRvIGFwcGx5IGZlYXR1cmVzJ1xuICAgICk7IH1cbiAgICBpZiAoIXRoaXMucXVlcnkpIHsgdGhpcy5xdWVyeSA9IG5ldyBGZWF0dXJlUXVlcnkoZm9udCk7IH1cbiAgICBmb3IgKHZhciBmID0gMDsgZiA8IGZlYXR1cmVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbZl07XG4gICAgICAgIGlmICghdGhpcy5xdWVyeS5zdXBwb3J0cyh7c2NyaXB0OiBmZWF0dXJlLnNjcmlwdH0pKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlcyhmZWF0dXJlLnNjcmlwdCwgZmVhdHVyZS50YWdzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc3RhdGUgbW9kaWZpZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RpZmllcklkIHN0YXRlIG1vZGlmaWVyIGlkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vZGlmaWVyIGEgbW9kaWZpZXIgZnVuY3Rpb24gdG8gc2V0IHRva2VuIHN0YXRlXG4gKi9cbkJpZGkucHJvdG90eXBlLnJlZ2lzdGVyTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcikge1xuICAgIHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyTW9kaWZpZXIobW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmICdnbHlwaEluZGV4JyBpcyByZWdpc3RlcmVkXG4gKi9cbmZ1bmN0aW9uIGNoZWNrR2x5cGhJbmRleFN0YXR1cygpIHtcbiAgICBpZiAodGhpcy50b2tlbml6ZXIucmVnaXN0ZXJlZE1vZGlmaWVycy5pbmRleE9mKCdnbHlwaEluZGV4JykgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdnbHlwaEluZGV4IG1vZGlmaWVyIGlzIHJlcXVpcmVkIHRvIGFwcGx5ICcgK1xuICAgICAgICAgICAgJ2FyYWJpYyBwcmVzZW50YXRpb24gZmVhdHVyZXMuJ1xuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcHBseSBhcmFiaWMgcHJlc2VudGF0aW9uIGZvcm1zIGZlYXR1cmVzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QXJhYmljUHJlc2VudGF0aW9uRm9ybXMoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2FyYWInO1xuICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cbiAgICBjaGVja0dseXBoSW5kZXhTdGF0dXMuY2FsbCh0aGlzKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnYXJhYmljV29yZCcpO1xuICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBhcmFiaWNQcmVzZW50YXRpb25Gb3Jtcy5jYWxsKHRoaXMkMSwgcmFuZ2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IHJlcXVpcmVkIGFyYWJpYyBsaWdhdHVyZXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBcmFiaWNSZXF1aXJlTGlnYXR1cmVzKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuICAgIGlmICh0YWdzLmluZGV4T2YoJ3JsaWcnKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgY2hlY2tHbHlwaEluZGV4U3RhdHVzLmNhbGwodGhpcyk7XG4gICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1dvcmQnKTtcbiAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgYXJhYmljUmVxdWlyZWRMaWdhdHVyZXMuY2FsbCh0aGlzJDEsIHJhbmdlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSByZXF1aXJlZCBhcmFiaWMgbGlnYXR1cmVzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TGF0aW5MaWdhdHVyZXMoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2xhdG4nO1xuICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cbiAgICB2YXIgdGFncyA9IHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF07XG4gICAgaWYgKHRhZ3MuaW5kZXhPZignbGlnYScpID09PSAtMSkgeyByZXR1cm47IH1cbiAgICBjaGVja0dseXBoSW5kZXhTdGF0dXMuY2FsbCh0aGlzKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnbGF0aW5Xb3JkJyk7XG4gICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIGxhdGluTGlnYXR1cmUuY2FsbCh0aGlzJDEsIHJhbmdlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbnRleHQgaXMgcmVnaXN0ZXJlZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCBjb250ZXh0IGlkXG4gKi9cbkJpZGkucHJvdG90eXBlLmNoZWNrQ29udGV4dFJlYWR5ID0gZnVuY3Rpb24gKGNvbnRleHRJZCkge1xuICAgIHJldHVybiAhIXRoaXMudG9rZW5pemVyLmdldENvbnRleHQoY29udGV4dElkKTtcbn07XG5cbi8qKlxuICogQXBwbHkgZmVhdHVyZXMgdG8gcmVnaXN0ZXJlZCBjb250ZXh0c1xuICovXG5CaWRpLnByb3RvdHlwZS5hcHBseUZlYXR1cmVzVG9Db250ZXh0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHRSZWFkeSgnYXJhYmljV29yZCcpKSB7XG4gICAgICAgIGFwcGx5QXJhYmljUHJlc2VudGF0aW9uRm9ybXMuY2FsbCh0aGlzKTtcbiAgICAgICAgYXBwbHlBcmFiaWNSZXF1aXJlTGlnYXR1cmVzLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dFJlYWR5KCdsYXRpbldvcmQnKSkge1xuICAgICAgICBhcHBseUxhdGluTGlnYXR1cmVzLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dFJlYWR5KCdhcmFiaWNTZW50ZW5jZScpKSB7XG4gICAgICAgIHJldmVyc2VBcmFiaWNTZW50ZW5jZXMuY2FsbCh0aGlzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHByb2Nlc3MgdGV4dCBpbnB1dFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgYW4gaW5wdXQgdGV4dFxuICovXG5CaWRpLnByb3RvdHlwZS5wcm9jZXNzVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICBpZiAoIXRoaXMudGV4dCB8fCB0aGlzLnRleHQgIT09IHRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0KHRleHQpO1xuICAgICAgICB0b2tlbml6ZVRleHQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcHBseUZlYXR1cmVzVG9Db250ZXh0cygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJvY2VzcyBhIHN0cmluZyBvZiB0ZXh0IHRvIGlkZW50aWZ5IGFuZCBhZGp1c3RcbiAqIGJpZGlyZWN0aW9uYWwgdGV4dCBlbnRpdGllcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGlucHV0IHRleHRcbiAqL1xuQmlkaS5wcm90b3R5cGUuZ2V0QmlkaVRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHRoaXMucHJvY2Vzc1RleHQodGV4dCk7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLmdldFRleHQoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHN0YXRlIGluZGV4IG9mIGVhY2ggdG9rZW5cbiAqIEBwYXJhbSB7dGV4dH0gdGV4dCBhbiBpbnB1dCB0ZXh0XG4gKi9cbkJpZGkucHJvdG90eXBlLmdldFRleHRHbHlwaHMgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHRoaXMucHJvY2Vzc1RleHQodGV4dCk7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG9rZW5pemVyLnRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuaXplci50b2tlbnNbaV07XG4gICAgICAgIGlmICh0b2tlbi5zdGF0ZS5kZWxldGVkKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIHZhciBpbmRleCA9IHRva2VuLmFjdGl2ZVN0YXRlLnZhbHVlO1xuICAgICAgICBpbmRleGVzLnB1c2goQXJyYXkuaXNBcnJheShpbmRleCkgPyBpbmRleFswXSA6IGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4ZXM7XG59O1xuXG4vLyBUaGUgRm9udCBvYmplY3RcblxuLyoqXG4gKiBAdHlwZWRlZiBGb250T3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGVtcHR5IC0gd2hldGhlciB0byBjcmVhdGUgYSBuZXcgZW1wdHkgZm9udFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseU5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZU5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZnVsbE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gcG9zdFNjcmlwdE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyXG4gKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclVSTFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2VVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNjcmlwdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBjb3B5cmlnaHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdHJhZGVtYXJrXG4gKiBAcHJvcGVydHkge051bWJlcn0gdW5pdHNQZXJFbVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGFzY2VuZGVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVzY2VuZGVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gY3JlYXRlZFRpbWVzdGFtcFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSB3ZWlnaHRDbGFzc1xuICogQHByb3BlcnR5IHtzdHJpbmc9fSB3aWR0aENsYXNzXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGZzU2VsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIEZvbnQgcmVwcmVzZW50cyBhIGxvYWRlZCBPcGVuVHlwZSBmb250IGZpbGUuXG4gKiBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuICogb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Gb250XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Rm9udE9wdGlvbnN9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRm9udChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy50YWJsZXMgPSBvcHRpb25zLnRhYmxlcyB8fCB7fTtcblxuICAgIGlmICghb3B0aW9ucy5lbXB0eSkge1xuICAgICAgICAvLyBDaGVjayB0aGF0IHdlJ3ZlIHByb3ZpZGVkIHRoZSBtaW5pbXVtIHNldCBvZiBuYW1lcy5cbiAgICAgICAgY2hlY2tBcmd1bWVudChcbiAgICAgICAgICAgIG9wdGlvbnMuZmFtaWx5TmFtZSxcbiAgICAgICAgICAgICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBmYW1pbHlOYW1lIGlzIHJlcXVpcmVkLidcbiAgICAgICAgKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVOYW1lLFxuICAgICAgICAgICAgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHN0eWxlTmFtZSBpcyByZXF1aXJlZC4nXG4gICAgICAgICk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQoXG4gICAgICAgICAgICBvcHRpb25zLnVuaXRzUGVyRW0sXG4gICAgICAgICAgICAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgdW5pdHNQZXJFbSBpcyByZXF1aXJlZC4nXG4gICAgICAgICk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQoXG4gICAgICAgICAgICBvcHRpb25zLmFzY2VuZGVyLFxuICAgICAgICAgICAgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGFzY2VuZGVyIGlzIHJlcXVpcmVkLidcbiAgICAgICAgKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChcbiAgICAgICAgICAgIG9wdGlvbnMuZGVzY2VuZGVyIDw9IDAsXG4gICAgICAgICAgICAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgbmVnYXRpdmUgZGVzY2VuZGVyIHZhbHVlIGlzIHJlcXVpcmVkLidcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnVuaXRzUGVyRW0gPSBvcHRpb25zLnVuaXRzUGVyRW0gfHwgMTAwMDtcbiAgICAgICAgdGhpcy5hc2NlbmRlciA9IG9wdGlvbnMuYXNjZW5kZXI7XG4gICAgICAgIHRoaXMuZGVzY2VuZGVyID0gb3B0aW9ucy5kZXNjZW5kZXI7XG4gICAgICAgIHRoaXMuY3JlYXRlZFRpbWVzdGFtcCA9IG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy50YWJsZXMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMudGFibGVzLCB7XG4gICAgICAgICAgICBvczI6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB1c1dlaWdodENsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy53ZWlnaHRDbGFzcyB8fCB0aGlzLnVzV2VpZ2h0Q2xhc3Nlcy5NRURJVU0sXG4gICAgICAgICAgICAgICAgICAgIHVzV2lkdGhDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2lkdGhDbGFzcyB8fCB0aGlzLnVzV2lkdGhDbGFzc2VzLk1FRElVTSxcbiAgICAgICAgICAgICAgICAgICAgZnNTZWxlY3Rpb246XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZzU2VsZWN0aW9uIHx8IHRoaXMuZnNTZWxlY3Rpb25WYWx1ZXMuUkVHVUxBUixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMudGFibGVzLm9zMlxuICAgICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdXBwb3J0ZWQgPSB0cnVlOyAvLyBEZXByZWNhdGVkOiBwYXJzZUJ1ZmZlciB3aWxsIHRocm93IGFuIGVycm9yIGlmIGZvbnQgaXMgbm90IHN1cHBvcnRlZC5cbiAgICB0aGlzLmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldCh0aGlzLCBvcHRpb25zLmdseXBocyB8fCBbXSk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG5ldyBEZWZhdWx0RW5jb2RpbmcodGhpcyk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBQb3NpdGlvbih0aGlzKTtcbiAgICB0aGlzLnN1YnN0aXR1dGlvbiA9IG5ldyBTdWJzdGl0dXRpb24odGhpcyk7XG4gICAgdGhpcy50YWJsZXMgPSB0aGlzLnRhYmxlcyB8fCB7fTtcblxuICAgIC8vIG5lZWRlZCBmb3IgbG93IG1lbW9yeSBtb2RlIG9ubHkuXG4gICAgdGhpcy5fcHVzaCA9IG51bGw7XG4gICAgdGhpcy5faG10eFRhYmxlRGF0YSA9IHt9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoaW50aW5nJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oaW50aW5nKSB7IHJldHVybiB0aGlzLl9oaW50aW5nOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lc0Zvcm1hdCA9PT0gJ3RydWV0eXBlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5faGludGluZyA9IG5ldyBIaW50aW5nKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZm9udCBoYXMgYSBnbHlwaCBmb3IgdGhlIGdpdmVuIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkZvbnQucHJvdG90eXBlLmhhc0NoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBnbHlwaCBpbmRleC5cbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KHMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgR2x5cGggb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbiAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGggPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBnbHlwaEluZGV4ID0gdGhpcy5jaGFyVG9HbHlwaEluZGV4KGMpO1xuICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIC8vIC5ub3RkZWZcbiAgICAgICAgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZmVhdHVyZXNcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zIGZlYXR1cmVzIG9wdGlvbnNcbiAqL1xuRm9udC5wcm90b3R5cGUudXBkYXRlRmVhdHVyZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIFRPRE86IHVwZGF0ZSBhbGwgZmVhdHVyZXMgb3B0aW9ucyBub3Qgb25seSAnbGF0bicuXG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnMuZmVhdHVyZXMubWFwKGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlLnNjcmlwdCA9PT0gJ2xhdG4nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjcmlwdDogJ2xhdG4nLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncy5maWx0ZXIoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gb3B0aW9uc1t0YWddOyB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiB0ZXh0IHRvIGEgbGlzdCBvZiBHbHlwaCBvYmplY3RzLlxuICogTm90ZSB0aGF0IHRoZXJlIGlzIG5vIHN0cmljdCBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlbiBjaGFyYWN0ZXJzIGFuZFxuICogZ2x5cGhzLCBzbyB0aGUgbGlzdCBvZiByZXR1cm5lZCBnbHlwaHMgY2FuIGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gdGhlXG4gKiBsZW5ndGggb2YgdGhlIGdpdmVuIHN0cmluZy5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaFtdfVxuICovXG5Gb250LnByb3RvdHlwZS5zdHJpbmdUb0dseXBocyA9IGZ1bmN0aW9uIChzLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYmlkaSA9IG5ldyBCaWRpKCk7XG5cbiAgICAvLyBDcmVhdGUgYW5kIHJlZ2lzdGVyICdnbHlwaEluZGV4JyBzdGF0ZSBtb2RpZmllclxuICAgIHZhciBjaGFyVG9HbHlwaEluZGV4TW9kID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0aGlzJDEuY2hhclRvR2x5cGhJbmRleCh0b2tlbi5jaGFyKTsgfTtcbiAgICBiaWRpLnJlZ2lzdGVyTW9kaWZpZXIoJ2dseXBoSW5kZXgnLCBudWxsLCBjaGFyVG9HbHlwaEluZGV4TW9kKTtcblxuICAgIC8vIHJvbGwtYmFjayB0byBkZWZhdWx0IGZlYXR1cmVzXG4gICAgdmFyIGZlYXR1cmVzID0gb3B0aW9uc1xuICAgICAgICA/IHRoaXMudXBkYXRlRmVhdHVyZXMob3B0aW9ucy5mZWF0dXJlcylcbiAgICAgICAgOiB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zLmZlYXR1cmVzO1xuXG4gICAgYmlkaS5hcHBseUZlYXR1cmVzKHRoaXMsIGZlYXR1cmVzKTtcblxuICAgIHZhciBpbmRleGVzID0gYmlkaS5nZXRUZXh0R2x5cGhzKHMpO1xuXG4gICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoO1xuXG4gICAgLy8gY29udmVydCBnbHlwaCBpbmRleGVzIHRvIGdseXBoIG9iamVjdHNcbiAgICB2YXIgZ2x5cGhzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgdmFyIG5vdGRlZiA9IHRoaXMuZ2x5cGhzLmdldCgwKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoc1tpXSA9IHRoaXMuZ2x5cGhzLmdldChpbmRleGVzW2ldKSB8fCBub3RkZWY7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUga2VybmluZyBwYWlyIGJldHdlZW4gdGhlIGxlZnQgZ2x5cGggKG9yIGl0cyBpbmRleClcbiAqIGFuZCB0aGUgcmlnaHQgZ2x5cGggKG9yIGl0cyBpbmRleCkuIElmIG5vIGtlcm5pbmcgcGFpciBpcyBmb3VuZCwgcmV0dXJuIDAuXG4gKiBUaGUga2VybmluZyB2YWx1ZSBnZXRzIGFkZGVkIHRvIHRoZSBhZHZhbmNlIHdpZHRoIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHNwYWNpbmdcbiAqIGJldHdlZW4gZ2x5cGhzLlxuICogRm9yIEdQT1Mga2VybmluZywgdGhpcyBtZXRob2QgdXNlcyB0aGUgZGVmYXVsdCBzY3JpcHQgYW5kIGxhbmd1YWdlLCB3aGljaCBjb3ZlcnNcbiAqIG1vc3QgdXNlIGNhc2VzLiBUbyBoYXZlIGdyZWF0ZXIgY29udHJvbCwgdXNlIGZvbnQucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlIC5cbiAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSBsZWZ0R2x5cGhcbiAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSByaWdodEdseXBoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uIChsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICBsZWZ0R2x5cGggPSBsZWZ0R2x5cGguaW5kZXggfHwgbGVmdEdseXBoO1xuICAgIHJpZ2h0R2x5cGggPSByaWdodEdseXBoLmluZGV4IHx8IHJpZ2h0R2x5cGg7XG4gICAgdmFyIGdwb3NLZXJuaW5nID0gdGhpcy5wb3NpdGlvbi5kZWZhdWx0S2VybmluZ1RhYmxlcztcbiAgICBpZiAoZ3Bvc0tlcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlKFxuICAgICAgICAgICAgZ3Bvc0tlcm5pbmcsXG4gICAgICAgICAgICBsZWZ0R2x5cGgsXG4gICAgICAgICAgICByaWdodEdseXBoXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vIFwia2VyblwiIHRhYmxlXG4gICAgcmV0dXJuIHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDA7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIEdseXBoUmVuZGVyT3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NjcmlwdF0gLSBzY3JpcHQgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuIEJ5IGRlZmF1bHQsICdERkxUJyBvciAnbGF0bicgaXMgdXNlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL3NjcmlwdHRhZ3MuaHRtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J10gLSBsYW5ndWFnZSBzeXN0ZW0gdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L2RldmVsb3BlcnMvb3BlbnR5cGUvbGFuZ3VhZ2V0YWdzLmFzcHhcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlcm5pbmc9dHJ1ZV0gLSB3aGV0aGVyIHRvIGluY2x1ZGUga2VybmluZyB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZmVhdHVyZXNdIC0gT3BlblR5cGUgTGF5b3V0IGZlYXR1cmUgdGFncy4gVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZmVhdHVyZXMgb2YgdGhlIGdpdmVuIHNjcmlwdC9sYW5ndWFnZSBzeXN0ZW0uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2ZlYXR1cmV0YWdzLmh0bVxuICovXG5Gb250LnByb3RvdHlwZS5kZWZhdWx0UmVuZGVyT3B0aW9ucyA9IHtcbiAgICBrZXJuaW5nOiB0cnVlLFxuICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVzZSA0IGZlYXR1cmVzIGFyZSByZXF1aXJlZCB0byByZW5kZXIgQXJhYmljIHRleHQgcHJvcGVybHlcbiAgICAgICAgICogYW5kIHNob3VsZG4ndCBiZSB0dXJuZWQgb2ZmIHdoZW4gcmVuZGVyaW5nIGFyYWJpYyB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgeyBzY3JpcHQ6ICdhcmFiJywgdGFnczogWydpbml0JywgJ21lZGknLCAnZmluYScsICdybGlnJ10gfSxcbiAgICAgICAgeyBzY3JpcHQ6ICdsYXRuJywgdGFnczogWydsaWdhJywgJ3JsaWcnXSB9IF0sXG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIGdseXBoIGluIHRoZSBnaXZlbiB0ZXh0LlxuICogVGhlIGNhbGxiYWNrIGdldHMgYChnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpYC4qIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBhcHBseS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkZvbnQucHJvdG90eXBlLmZvckVhY2hHbHlwaCA9IGZ1bmN0aW9uIChcbiAgICB0ZXh0LFxuICAgIHgsXG4gICAgeSxcbiAgICBmb250U2l6ZSxcbiAgICBvcHRpb25zLFxuICAgIGNhbGxiYWNrXG4pIHtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHZhciBmb250U2NhbGUgPSAoMSAvIHRoaXMudW5pdHNQZXJFbSkgKiBmb250U2l6ZTtcbiAgICB2YXIgZ2x5cGhzID0gdGhpcy5zdHJpbmdUb0dseXBocyh0ZXh0LCBvcHRpb25zKTtcbiAgICB2YXIga2VybmluZ0xvb2t1cHM7XG4gICAgaWYgKG9wdGlvbnMua2VybmluZykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gb3B0aW9ucy5zY3JpcHQgfHwgdGhpcy5wb3NpdGlvbi5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgICAgICBrZXJuaW5nTG9va3VwcyA9IHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1RhYmxlcyhcbiAgICAgICAgICAgIHNjcmlwdCxcbiAgICAgICAgICAgIG9wdGlvbnMubGFuZ3VhZ2VcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChnbHlwaC5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZVdpZHRoICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMua2VybmluZyAmJiBpIDwgZ2x5cGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhcHBseSBwb3NpdGlvbiBhZGp1c3RtZW50IGxvb2t1cHMgaW4gYSBtb3JlIGdlbmVyaWMgd2F5LlxuICAgICAgICAgICAgLy8gSGVyZSB3ZSBvbmx5IHVzZSB0aGUgeEFkdmFuY2UgdmFsdWUuXG4gICAgICAgICAgICB2YXIga2VybmluZ1ZhbHVlID0ga2VybmluZ0xvb2t1cHNcbiAgICAgICAgICAgICAgICA/IHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgIGtlcm5pbmdMb29rdXBzLFxuICAgICAgICAgICAgICAgICAgICAgIGdseXBoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIGdseXBoc1tpICsgMV0uaW5kZXhcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgeCArPSBvcHRpb25zLmxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRyYWNraW5nKSB7XG4gICAgICAgICAgICB4ICs9IChvcHRpb25zLnRyYWNraW5nIC8gMTAwMCkgKiBmb250U2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGZ1bGxQYXRoID0gbmV3IFBhdGgoKTtcbiAgICB0aGlzLmZvckVhY2hHbHlwaChcbiAgICAgICAgdGV4dCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uIChnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgICAgIGZ1bGxQYXRoLmV4dGVuZChnbHlwaFBhdGgpO1xuICAgICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBQYXRoIG9iamVjdHMgdGhhdCByZXByZXNlbnQgdGhlIGdseXBocyBvZiBhIGdpdmVuIHRleHQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0UGF0aHMgPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZ2x5cGhQYXRocyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKFxuICAgICAgICB0ZXh0LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnVuY3Rpb24gKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICAgICAgdmFyIGdseXBoUGF0aCA9IGdseXBoLmdldFBhdGgoZ1gsIGdZLCBnRm9udFNpemUsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICAgICAgZ2x5cGhQYXRocy5wdXNoKGdseXBoUGF0aCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIGdseXBoUGF0aHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFkdmFuY2Ugd2lkdGggb2YgYSB0ZXh0LlxuICpcbiAqIFRoaXMgaXMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIFBhdGguZ2V0Qm91bmRpbmdCb3goKSBhcyBmb3IgZXhhbXBsZSBhXG4gKiBzdWZmaXhlZCB3aGl0ZXNwYWNlIGluY3JlYXNlcyB0aGUgYWR2YW5jZVdpZHRoIGJ1dCBub3QgdGhlIGJvdW5kaW5nIGJveFxuICogb3IgYW4gb3ZlcmhhbmdpbmcgbGV0dGVyIGxpa2UgYSBjYWxsaWdyYXBoaWMgJ2YnIG1pZ2h0IGhhdmUgYSBxdWl0ZSBsYXJnZXJcbiAqIGJvdW5kaW5nIGJveCB0aGFuIGl0cyBhZHZhbmNlIHdpZHRoLlxuICpcbiAqIFRoaXMgY29ycmVzcG9uZHMgdG8gY2FudmFzMmRDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4gYWR2YW5jZSB3aWR0aFxuICovXG5Gb250LnByb3RvdHlwZS5nZXRBZHZhbmNlV2lkdGggPSBmdW5jdGlvbiAodGV4dCwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgMCwgMCwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uICgpIHt9KTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUuZnNTZWxlY3Rpb25WYWx1ZXMgPSB7XG4gICAgSVRBTElDOiAweDAwMSwgLy8xXG4gICAgVU5ERVJTQ09SRTogMHgwMDIsIC8vMlxuICAgIE5FR0FUSVZFOiAweDAwNCwgLy80XG4gICAgT1VUTElORUQ6IDB4MDA4LCAvLzhcbiAgICBTVFJJS0VPVVQ6IDB4MDEwLCAvLzE2XG4gICAgQk9MRDogMHgwMjAsIC8vMzJcbiAgICBSRUdVTEFSOiAweDA0MCwgLy82NFxuICAgIFVTRVJfVFlQT19NRVRSSUNTOiAweDA4MCwgLy8xMjhcbiAgICBXV1M6IDB4MTAwLCAvLzI1NlxuICAgIE9CTElRVUU6IDB4MjAwLCAvLzUxMlxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS51c1dpZHRoQ2xhc3NlcyA9IHtcbiAgICBVTFRSQV9DT05ERU5TRUQ6IDEsXG4gICAgRVhUUkFfQ09OREVOU0VEOiAyLFxuICAgIENPTkRFTlNFRDogMyxcbiAgICBTRU1JX0NPTkRFTlNFRDogNCxcbiAgICBNRURJVU06IDUsXG4gICAgU0VNSV9FWFBBTkRFRDogNixcbiAgICBFWFBBTkRFRDogNyxcbiAgICBFWFRSQV9FWFBBTkRFRDogOCxcbiAgICBVTFRSQV9FWFBBTkRFRDogOSxcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUudXNXZWlnaHRDbGFzc2VzID0ge1xuICAgIFRISU46IDEwMCxcbiAgICBFWFRSQV9MSUdIVDogMjAwLFxuICAgIExJR0hUOiAzMDAsXG4gICAgTk9STUFMOiA0MDAsXG4gICAgTUVESVVNOiA1MDAsXG4gICAgU0VNSV9CT0xEOiA2MDAsXG4gICAgQk9MRDogNzAwLFxuICAgIEVYVFJBX0JPTEQ6IDgwMCxcbiAgICBCTEFDSzogOTAwLFxufTtcblxuLy8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCkge1xuICAgIC8vU2tpcCByZXNlcnZlZC5cbiAgICBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG4gICAgY21hcC5sZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICB2YXIgZ3JvdXBDb3VudDtcbiAgICBjbWFwLmdyb3VwQ291bnQgPSBncm91cENvdW50ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY21hcC5nbHlwaEluZGV4TWFwID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3RhcnRDaGFyQ29kZSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgZW5kQ2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIHN0YXJ0R2x5cGhJZCA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSBzdGFydENoYXJDb2RlOyBjIDw9IGVuZENoYXJDb2RlOyBjICs9IDEpIHtcbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IHN0YXJ0R2x5cGhJZDtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhJZCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCkge1xuICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cbiAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cbiAgICB2YXIgc2VnQ291bnQ7XG4gICAgY21hcC5zZWdDb3VudCA9IHNlZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpID4+IDE7XG5cbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cbiAgICAvLyBUaGUgXCJ1bnJvbGxlZFwiIG1hcHBpbmcgZnJvbSBjaGFyYWN0ZXIgY29kZXMgdG8gZ2x5cGggaW5kaWNlcy5cbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgZW5kQ291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTQpO1xuICAgIHZhciBzdGFydENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogMlxuICAgICk7XG4gICAgdmFyIGlkRGVsdGFQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKFxuICAgICAgICBkYXRhLFxuICAgICAgICBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA0XG4gICAgKTtcbiAgICB2YXIgaWRSYW5nZU9mZnNldFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDZcbiAgICApO1xuICAgIHZhciBnbHlwaEluZGV4T2Zmc2V0ID0gc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogODtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ0NvdW50IC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICAgIHZhciBlbmRDb3VudCA9IGVuZENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBzdGFydENvdW50ID0gc3RhcnRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgaWREZWx0YSA9IGlkRGVsdGFQYXJzZXIucGFyc2VTaG9ydCgpO1xuICAgICAgICB2YXIgaWRSYW5nZU9mZnNldCA9IGlkUmFuZ2VPZmZzZXRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZm9yICh2YXIgYyA9IHN0YXJ0Q291bnQ7IGMgPD0gZW5kQ291bnQ7IGMgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGlkUmFuZ2VPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgaWRSYW5nZU9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ID1cbiAgICAgICAgICAgICAgICAgICAgaWRSYW5nZU9mZnNldFBhcnNlci5vZmZzZXQgK1xuICAgICAgICAgICAgICAgICAgICBpZFJhbmdlT2Zmc2V0UGFyc2VyLnJlbGF0aXZlT2Zmc2V0IC1cbiAgICAgICAgICAgICAgICAgICAgMjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgb2YgdGhlIGlkUmFuZ2VPZmZzZXQsIHdoaWNoIHdpbGwgbW92ZSB1cyBpbnRvIHRoZSBnbHlwaEluZGV4IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gaWRSYW5nZU9mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIHRoZSBjaGFyYWN0ZXIgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2VnbWVudCwgbXVsdGlwbGllZCBieSAyIGZvciBVU0hPUlRzLlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gKGMgLSBzdGFydENvdW50KSAqIDI7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBnbHlwaEluZGV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGdseXBoSW5kZXggKyBpZERlbHRhKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoYyArIGlkRGVsdGEpICYgMHhmZmZmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbWFwLmdseXBoSW5kZXhNYXBbY10gPSBnbHlwaEluZGV4O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBQYXJzZSB0aGUgYGNtYXBgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbi8vIFRoZXJlIGFyZSBtYW55IGF2YWlsYWJsZSBmb3JtYXRzLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBXaW5kb3dzIGZvcm1hdCA0IGFuZCAxMi5cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGBDbWFwRW5jb2RpbmdgIG9iamVjdCBvciBudWxsIGlmIG5vIHN1cHBvcnRlZCBmb3JtYXQgY291bGQgYmUgZm91bmQuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBjbWFwID0ge307XG4gICAgY21hcC52ZXJzaW9uID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0KTtcbiAgICBjaGVjay5hcmd1bWVudChjbWFwLnZlcnNpb24gPT09IDAsICdjbWFwIHRhYmxlIHZlcnNpb24gc2hvdWxkIGJlIDAuJyk7XG5cbiAgICAvLyBUaGUgY21hcCB0YWJsZSBjYW4gY29udGFpbiBtYW55IHN1Yi10YWJsZXMsIGVhY2ggd2l0aCB0aGVpciBvd24gZm9ybWF0LlxuICAgIC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBhIFwicGxhdGZvcm0gMFwiIChVbmljb2RlIGZvcm1hdCkgYW5kIFwicGxhdGZvcm0gM1wiIChXaW5kb3dzIGZvcm1hdCkgdGFibGUuXG4gICAgY21hcC5udW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICB2YXIgb2Zmc2V0ID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IGNtYXAubnVtVGFibGVzIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgdmFyIHBsYXRmb3JtSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgaSAqIDgpO1xuICAgICAgICB2YXIgZW5jb2RpbmdJZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyBpICogOCArIDIpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAocGxhdGZvcm1JZCA9PT0gMyAmJlxuICAgICAgICAgICAgICAgIChlbmNvZGluZ0lkID09PSAwIHx8IGVuY29kaW5nSWQgPT09IDEgfHwgZW5jb2RpbmdJZCA9PT0gMTApKSB8fFxuICAgICAgICAgICAgKHBsYXRmb3JtSWQgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAoZW5jb2RpbmdJZCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZ0lkID09PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nSWQgPT09IDIgfHxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmdJZCA9PT0gMyB8fFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZ0lkID09PSA0KSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBzdGFydCArIDQgKyBpICogOCArIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBjbWFwIHRhYmxlIGluIHRoZSBmb250IHRoYXQgd2Ugc3VwcG9ydC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBjbWFwIHN1Yi10YWJsZXMgZm91bmQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICBjbWFwLmZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcblxuICAgIGlmIChjbWFwLmZvcm1hdCA9PT0gMTIpIHtcbiAgICAgICAgcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKTtcbiAgICB9IGVsc2UgaWYgKGNtYXAuZm9ybWF0ID09PSA0KSB7XG4gICAgICAgIHBhcnNlQ21hcFRhYmxlRm9ybWF0NChjbWFwLCBwLCBkYXRhLCBzdGFydCwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnT25seSBmb3JtYXQgNCBhbmQgMTIgY21hcCB0YWJsZXMgYXJlIHN1cHBvcnRlZCAoZm91bmQgZm9ybWF0ICcgK1xuICAgICAgICAgICAgICAgIGNtYXAuZm9ybWF0ICtcbiAgICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtYXA7XG59XG5cbnZhciBjbWFwID0geyBwYXJzZTogcGFyc2VDbWFwVGFibGUgfTtcblxuLy8gVGhlIGBDRkZgIHRhYmxlIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cblxuLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbi8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgdmFyIGJpYXM7XG4gICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgYmlhcyA9IDEwNztcbiAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgIGJpYXMgPSAxMTMxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICB9XG5cbiAgICByZXR1cm4gYmlhcztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cbi8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgb2JqZWN0T2Zmc2V0O1xuICAgIHZhciBlbmRPZmZzZXQ7XG4gICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArIChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSArIDI7XG4gICAgICAgIHZhciBwb3MgPSBzdGFydCArIDM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBpbmRleCBhcnJheSBpcyA0IGhlYWRlciBieXRlcyArIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBvZmZzZXQuXG4gICAgICAgIGVuZE9mZnNldCA9IG9iamVjdE9mZnNldCArIG9mZnNldHNbY291bnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0ICsgMjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSQxXSxcbiAgICAgICAgICAgIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSQxICsgMV1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBvYmplY3RzOiBvYmplY3RzLCBzdGFydE9mZnNldDogc3RhcnQsIGVuZE9mZnNldDogZW5kT2Zmc2V0IH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ0ZGSW5kZXhMb3dNZW1vcnkoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG4gICAgdmFyIG9iamVjdE9mZnNldDtcbiAgICB2YXIgZW5kT2Zmc2V0O1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoY291bnQgKyAxKSAqIG9mZnNldFNpemUgKyAyO1xuICAgICAgICB2YXIgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSArPSAxKSB7XG4gICAgICAgICAgICBvZmZzZXRzLnB1c2gocGFyc2UuZ2V0T2Zmc2V0KGRhdGEsIHBvcywgb2Zmc2V0U2l6ZSkpO1xuICAgICAgICAgICAgcG9zICs9IG9mZnNldFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgb2Zmc2V0czogb2Zmc2V0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldCB9O1xufVxuZnVuY3Rpb24gZ2V0Q2ZmSW5kZXhPYmplY3QoaSwgb2Zmc2V0cywgZGF0YSwgc3RhcnQsIGNvbnZlcnNpb25Gbikge1xuICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG4gICAgdmFyIG9iamVjdE9mZnNldCA9IDA7XG4gICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArIChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSArIDI7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gcGFyc2UuZ2V0Qnl0ZXMoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9iamVjdE9mZnNldCArIG9mZnNldHNbaV0sXG4gICAgICAgIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSArIDFdXG4gICAgKTtcbiAgICBpZiAoY29udmVyc2lvbkZuKSB7XG4gICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1QgcmVhbCB2YWx1ZS5cbmZ1bmN0aW9uIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcikge1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIGVvZiA9IDE1O1xuICAgIHZhciBsb29rdXAgPSBbXG4gICAgICAgICcwJyxcbiAgICAgICAgJzEnLFxuICAgICAgICAnMicsXG4gICAgICAgICczJyxcbiAgICAgICAgJzQnLFxuICAgICAgICAnNScsXG4gICAgICAgICc2JyxcbiAgICAgICAgJzcnLFxuICAgICAgICAnOCcsXG4gICAgICAgICc5JyxcbiAgICAgICAgJy4nLFxuICAgICAgICAnRScsXG4gICAgICAgICdFLScsXG4gICAgICAgIG51bGwsXG4gICAgICAgICctJyBdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBiID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICB2YXIgbjEgPSBiID4+IDQ7XG4gICAgICAgIHZhciBuMiA9IGIgJiAxNTtcblxuICAgICAgICBpZiAobjEgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IGxvb2t1cFtuMV07XG5cbiAgICAgICAgaWYgKG4yID09PSBlb2YpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcyArPSBsb29rdXBbbjJdO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cbmZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG4gICAgdmFyIGIxO1xuICAgIHZhciBiMjtcbiAgICB2YXIgYjM7XG4gICAgdmFyIGI0O1xuICAgIGlmIChiMCA9PT0gMjgpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIxIDw8IDgpIHwgYjI7XG4gICAgfVxuXG4gICAgaWYgKGIwID09PSAyOSkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIzID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiNCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpIHwgKGIzIDw8IDgpIHwgYjQ7XG4gICAgfVxuXG4gICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMzIgJiYgYjAgPD0gMjQ2KSB7XG4gICAgICAgIHJldHVybiBiMCAtIDEzOTtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMjQ3ICYmIGIwIDw9IDI1MCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIChiMCAtIDI0NykgKiAyNTYgKyBiMSArIDEwODtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGIwICcgKyBiMCk7XG59XG5cbi8vIENvbnZlcnQgdGhlIGVudHJpZXMgcmV0dXJuZWQgYnkgYHBhcnNlRGljdGAgdG8gYSBwcm9wZXIgZGljdGlvbmFyeS5cbi8vIElmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIG9uZSwgaXQgaXMgdW5wYWNrZWQuXG5mdW5jdGlvbiBlbnRyaWVzVG9PYmplY3QoZW50cmllcykge1xuICAgIHZhciBvID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2ldWzBdO1xuICAgICAgICB2YXIgdmFsdWVzID0gZW50cmllc1tpXVsxXTtcbiAgICAgICAgdmFyIHZhbHVlID0gKHZvaWQgMCk7XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhaXNOYU4ob1trZXldKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgJyArIG8gKyAnIGFscmVhZHkgaGFzIGtleSAnICsga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb2JqZWN0LlxuLy8gQSBkaWN0aW9uYXJ5IGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBpbiBhIGNvbXBhY3QgdG9rZW5pemVkIGZvcm1hdC5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRGljdChkYXRhLCBzdGFydCwgc2l6ZSkge1xuICAgIHN0YXJ0ID0gc3RhcnQgIT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogMDtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICB2YXIgb3BlcmFuZHMgPSBbXTtcbiAgICBzaXplID0gc2l6ZSAhPT0gdW5kZWZpbmVkID8gc2l6ZSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgd2hpbGUgKHBhcnNlci5yZWxhdGl2ZU9mZnNldCA8IHNpemUpIHtcbiAgICAgICAgdmFyIG9wID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCBieXRlIGZvciBlYWNoIGRpY3QgaXRlbSBkaXN0aW5ndWlzaGVzIGJldHdlZW4gb3BlcmF0b3IgKGtleSkgYW5kIG9wZXJhbmQgKHZhbHVlKS5cbiAgICAgICAgLy8gVmFsdWVzIDw9IDIxIGFyZSBvcGVyYXRvcnMuXG4gICAgICAgIGlmIChvcCA8PSAyMSkge1xuICAgICAgICAgICAgLy8gVHdvLWJ5dGUgb3BlcmF0b3JzIGhhdmUgYW4gaW5pdGlhbCBlc2NhcGUgYnl0ZSBvZiAxMi5cbiAgICAgICAgICAgIGlmIChvcCA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBvcCA9IDEyMDAgKyBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVudHJpZXMucHVzaChbb3AsIG9wZXJhbmRzXSk7XG4gICAgICAgICAgICBvcGVyYW5kcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIG9wZXJhbmRzICh2YWx1ZXMpIGNvbWUgYmVmb3JlIHRoZSBvcGVyYXRvcnMgKGtleXMpLCB3ZSBzdG9yZSBhbGwgb3BlcmFuZHMgaW4gYSBsaXN0XG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSBlbmNvdW50ZXIgYW4gb3BlcmF0b3IuXG4gICAgICAgICAgICBvcGVyYW5kcy5wdXNoKHBhcnNlT3BlcmFuZChwYXJzZXIsIG9wKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpO1xufVxuXG4vLyBHaXZlbiBhIFN0cmluZyBJbmRleCAoU0lEKSwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgc3RyaW5nLlxuLy8gU3RyaW5ncyBiZWxvdyBpbmRleCAzOTIgYXJlIHN0YW5kYXJkIENGRiBzdHJpbmdzIGFuZCBhcmUgbm90IGVuY29kZWQgaW4gdGhlIGZvbnQuXG5mdW5jdGlvbiBnZXRDRkZTdHJpbmcoc3RyaW5ncywgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPD0gMzkwKSB7XG4gICAgICAgIGluZGV4ID0gY2ZmU3RhbmRhcmRTdHJpbmdzW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IHN0cmluZ3NbaW5kZXggLSAzOTFdO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbn1cblxuLy8gSW50ZXJwcmV0IGEgZGljdGlvbmFyeSBhbmQgcmV0dXJuIGEgbmV3IGRpY3Rpb25hcnkgd2l0aCByZWFkYWJsZSBrZXlzIGFuZCB2YWx1ZXMgZm9yIG1pc3NpbmcgZW50cmllcy5cbi8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYG1ldGFgIHdoaWNoIGlzIGEgbGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYG9wZXJhbmRgLCBgbmFtZWAgYW5kIGBkZWZhdWx0YC5cbmZ1bmN0aW9uIGludGVycHJldERpY3QoZGljdCwgbWV0YSwgc3RyaW5ncykge1xuICAgIHZhciBuZXdEaWN0ID0ge307XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhbHNvIHdhbnQgdG8gaW5jbHVkZSBtaXNzaW5nIHZhbHVlcywgd2Ugc3RhcnQgb3V0IGZyb20gdGhlIG1ldGEgbGlzdFxuICAgIC8vIGFuZCBsb29rdXAgdmFsdWVzIGluIHRoZSBkaWN0LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbSA9IG1ldGFbaV07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobS50eXBlKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdmFsdWVzLmxlbmd0aCA9IG0udHlwZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG0udHlwZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGljdFttLm9wXSAhPT0gdW5kZWZpbmVkID8gZGljdFttLm9wXVtqXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgbS52YWx1ZVtqXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtLnZhbHVlW2pdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobS50eXBlW2pdID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldENGRlN0cmluZyhzdHJpbmdzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlc1tqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCA/IG0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RpY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZGVyID0ge307XG4gICAgaGVhZGVyLmZvcm1hdE1ham9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG4gICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuICAgIGhlYWRlci5vZmZzZXRTaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAzKTtcbiAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcbiAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgIHJldHVybiBoZWFkZXI7XG59XG5cbnZhciBUT1BfRElDVF9NRVRBID0gW1xuICAgIHsgbmFtZTogJ3ZlcnNpb24nLCBvcDogMCwgdHlwZTogJ1NJRCcgfSxcbiAgICB7IG5hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCcgfSxcbiAgICB7IG5hbWU6ICdjb3B5cmlnaHQnLCBvcDogMTIwMCwgdHlwZTogJ1NJRCcgfSxcbiAgICB7IG5hbWU6ICdmdWxsTmFtZScsIG9wOiAyLCB0eXBlOiAnU0lEJyB9LFxuICAgIHsgbmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCcgfSxcbiAgICB7IG5hbWU6ICd3ZWlnaHQnLCBvcDogNCwgdHlwZTogJ1NJRCcgfSxcbiAgICB7IG5hbWU6ICdpc0ZpeGVkUGl0Y2gnLCBvcDogMTIwMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAndW5kZXJsaW5lUG9zaXRpb24nLCBvcDogMTIwMywgdHlwZTogJ251bWJlcicsIHZhbHVlOiAtMTAwIH0sXG4gICAgeyBuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgb3A6IDEyMDQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogNTAgfSxcbiAgICB7IG5hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnY2hhcnN0cmluZ1R5cGUnLCBvcDogMTIwNiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAyIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnZm9udE1hdHJpeCcsXG4gICAgICAgIG9wOiAxMjA3LFxuICAgICAgICB0eXBlOiBbJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJ10sXG4gICAgICAgIHZhbHVlOiBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXSxcbiAgICB9LFxuICAgIHsgbmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2ZvbnRCQm94JyxcbiAgICAgICAgb3A6IDUsXG4gICAgICAgIHR5cGU6IFsnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJ10sXG4gICAgICAgIHZhbHVlOiBbMCwgMCwgMCwgMF0sXG4gICAgfSxcbiAgICB7IG5hbWU6ICdzdHJva2VXaWR0aCcsIG9wOiAxMjA4LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGwgfSxcbiAgICB7IG5hbWU6ICdjaGFyc2V0Jywgb3A6IDE1LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdlbmNvZGluZycsIG9wOiAxNiwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ3ByaXZhdGUnLCBvcDogMTgsIHR5cGU6IFsnbnVtYmVyJywgJ29mZnNldCddLCB2YWx1ZTogWzAsIDBdIH0sXG4gICAgeyBuYW1lOiAncm9zJywgb3A6IDEyMzAsIHR5cGU6IFsnU0lEJywgJ1NJRCcsICdudW1iZXInXSB9LFxuICAgIHsgbmFtZTogJ2NpZEZvbnRWZXJzaW9uJywgb3A6IDEyMzEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ2NpZEZvbnRSZXZpc2lvbicsIG9wOiAxMjMyLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdjaWRGb250VHlwZScsIG9wOiAxMjMzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdjaWRDb3VudCcsIG9wOiAxMjM0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDg3MjAgfSxcbiAgICB7IG5hbWU6ICd1aWRCYXNlJywgb3A6IDEyMzUsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBuYW1lOiAnZmRBcnJheScsIG9wOiAxMjM2LCB0eXBlOiAnb2Zmc2V0JyB9LFxuICAgIHsgbmFtZTogJ2ZkU2VsZWN0Jywgb3A6IDEyMzcsIHR5cGU6ICdvZmZzZXQnIH0sXG4gICAgeyBuYW1lOiAnZm9udE5hbWUnLCBvcDogMTIzOCwgdHlwZTogJ1NJRCcgfSBdO1xuXG52YXIgUFJJVkFURV9ESUNUX01FVEEgPSBbXG4gICAgeyBuYW1lOiAnc3VicnMnLCBvcDogMTksIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ2RlZmF1bHRXaWR0aFgnLCBvcDogMjAsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9IF07XG5cbi8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG5mdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0ID0gcGFyc2VDRkZEaWN0KGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgVE9QX0RJQ1RfTUVUQSwgc3RyaW5ncyk7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgcHJpdmF0ZSBkaWN0aW9uYXJ5LiBXZSBkb24ndCBmdWxseSBwYXJzZSBvdXQgYWxsIHRoZSB2YWx1ZXMsIG9ubHkgdGhlIG9uZXMgd2UgbmVlZC5cbmZ1bmN0aW9uIHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgc3RhcnQsIHNpemUsIHN0cmluZ3MpIHtcbiAgICB2YXIgZGljdCA9IHBhcnNlQ0ZGRGljdChkYXRhLCBzdGFydCwgc2l6ZSk7XG4gICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgUFJJVkFURV9ESUNUX01FVEEsIHN0cmluZ3MpO1xufVxuXG4vLyBSZXR1cm5zIGEgbGlzdCBvZiBcIlRvcCBESUNUXCJzIGZvdW5kIHVzaW5nIGFuIElOREVYIGxpc3QuXG4vLyBVc2VkIHRvIHJlYWQgYm90aCB0aGUgdXN1YWwgaGlnaC1sZXZlbCBUb3AgRElDVHMgYW5kIGFsc28gdGhlIEZEQXJyYXlcbi8vIGRpc2NvdmVyZWQgaW5zaWRlIENJRC1rZXllZCBmb250cy4gIFdoZW4gYSBUb3AgRElDVCBoYXMgYSByZWZlcmVuY2UgdG9cbi8vIGEgUHJpdmF0ZSBESUNUIHRoYXQgaXMgcmVhZCBhbmQgc2F2ZWQgaW50byB0aGUgVG9wIERJQ1QuXG4vL1xuLy8gSW4gYWRkaXRpb24gdG8gdGhlIGV4cGVjdGVkL29wdGlvbmFsIHZhbHVlcyBhcyBvdXRsaW5lZCBpbiBUT1BfRElDVF9NRVRBXG4vLyB0aGUgZm9sbG93aW5nIHZhbHVlcyBtaWdodCBiZSBzYXZlZCBpbnRvIHRoZSBUb3AgRElDVC5cbi8vXG4vLyAgICBfc3VicnMgW10gICAgICAgIGFycmF5IG9mIGxvY2FsIENGRiBzdWJyb3V0aW5lcyBmcm9tIFByaXZhdGUgRElDVFxuLy8gICAgX3N1YnJzQmlhcyAgICAgICBiaWFzIHZhbHVlIGNvbXB1dGVkIGZyb20gbnVtYmVyIG9mIHN1YnJvdXRpbmVzXG4vLyAgICAgICAgICAgICAgICAgICAgICAoc2VlIGNhbGNDRkZTdWJyb3V0aW5lQmlhcygpIGFuZCBwYXJzZUNGRkNoYXJzdHJpbmcoKSlcbi8vICAgIF9kZWZhdWx0V2lkdGhYICAgZGVmYXVsdCB3aWR0aHMgZm9yIENGRiBjaGFyYWN0ZXJzXG4vLyAgICBfbm9taW5hbFdpZHRoWCAgIGJpYXMgYWRkZWQgdG8gd2lkdGggZW1iZWRkZWQgd2l0aGluIGdseXBoIGRlc2NyaXB0aW9uXG4vL1xuLy8gICAgX3ByaXZhdGVEaWN0ICAgICBzYXZlZCBjb3B5IG9mIHBhcnNlZCBQcml2YXRlIERJQ1QgZnJvbSBUb3AgRElDVFxuZnVuY3Rpb24gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIGNmZkluZGV4LCBzdHJpbmdzKSB7XG4gICAgdmFyIHRvcERpY3RBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGlUb3BEaWN0ID0gMDsgaVRvcERpY3QgPCBjZmZJbmRleC5sZW5ndGg7IGlUb3BEaWN0ICs9IDEpIHtcbiAgICAgICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KFxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoY2ZmSW5kZXhbaVRvcERpY3RdKS5idWZmZXJcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ3MpO1xuICAgICAgICB0b3BEaWN0Ll9zdWJycyA9IFtdO1xuICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSAwO1xuICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gMDtcbiAgICAgICAgdG9wRGljdC5fbm9taW5hbFdpZHRoWCA9IDA7XG4gICAgICAgIHZhciBwcml2YXRlU2l6ZSA9IHRvcERpY3QucHJpdmF0ZVswXTtcbiAgICAgICAgdmFyIHByaXZhdGVPZmZzZXQgPSB0b3BEaWN0LnByaXZhdGVbMV07XG4gICAgICAgIGlmIChwcml2YXRlU2l6ZSAhPT0gMCAmJiBwcml2YXRlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZU9mZnNldCArIHN0YXJ0LFxuICAgICAgICAgICAgICAgIHByaXZhdGVTaXplLFxuICAgICAgICAgICAgICAgIHN0cmluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgICAgIHRvcERpY3QuX25vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnJPZmZzZXQgPSBwcml2YXRlT2Zmc2V0ICsgcHJpdmF0ZURpY3Quc3VicnM7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3Vick9mZnNldCArIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0b3BEaWN0Ll9zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICAgICAgICAgIHRvcERpY3QuX3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyh0b3BEaWN0Ll9zdWJycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3BEaWN0Ll9wcml2YXRlRGljdCA9IHByaXZhdGVEaWN0O1xuICAgICAgICB9XG4gICAgICAgIHRvcERpY3RBcnJheS5wdXNoKHRvcERpY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9wRGljdEFycmF5O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGNoYXJzZXQgdGFibGUsIHdoaWNoIGNvbnRhaW5zIGludGVybmFsIG5hbWVzIGZvciBhbGwgdGhlIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBsaXN0IG9mIGdseXBoIG5hbWVzLlxuLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTMsIFwiQ2hhcnNldHNcIi5cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnNldChkYXRhLCBzdGFydCwgbkdseXBocywgc3RyaW5ncykge1xuICAgIHZhciBzaWQ7XG4gICAgdmFyIGNvdW50O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblxuICAgIC8vIFRoZSAubm90ZGVmIGdseXBoIGlzIG5vdCBpbmNsdWRlZCwgc28gc3VidHJhY3QgMS5cbiAgICBuR2x5cGhzIC09IDE7XG4gICAgdmFyIGNoYXJzZXQgPSBbJy5ub3RkZWYnXTtcblxuICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8PSBjb3VudDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8PSBjb3VudDsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYXJzZXQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyc2V0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGVuY29kaW5nIGRhdGEuIE9ubHkgb25lIGVuY29kaW5nIGNhbiBiZSBzcGVjaWZpZWQgcGVyIGZvbnQuXG4vLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMiwgXCJFbmNvZGluZ3NcIi5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQsIGNoYXJzZXQpIHtcbiAgICB2YXIgY29kZTtcbiAgICB2YXIgZW5jID0ge307XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgdmFyIG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkNvZGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvZGUgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZW5jW2NvZGVdID0gaTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgY29kZSA9IDE7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG5SYW5nZXM7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgdmFyIG5MZWZ0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDZmZFbmNvZGluZyhlbmMsIGNoYXJzZXQpO1xufVxuXG4vLyBUYWtlIGluIGNoYXJzdHJpbmcgY29kZSBhbmQgcmV0dXJuIGEgR2x5cGggb2JqZWN0LlxuLy8gVGhlIGVuY29kaW5nIGlzIGRlc2NyaWJlZCBpbiB0aGUgVHlwZSAyIENoYXJzdHJpbmcgRm9ybWF0XG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXJzdHIyLmh0bVxuZnVuY3Rpb24gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjb2RlKSB7XG4gICAgdmFyIGMxeDtcbiAgICB2YXIgYzF5O1xuICAgIHZhciBjMng7XG4gICAgdmFyIGMyeTtcbiAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIG5TdGVtcyA9IDA7XG4gICAgdmFyIGhhdmVXaWR0aCA9IGZhbHNlO1xuICAgIHZhciBvcGVuID0gZmFsc2U7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgc3VicnM7XG4gICAgdmFyIHN1YnJzQmlhcztcbiAgICB2YXIgZGVmYXVsdFdpZHRoWDtcbiAgICB2YXIgbm9taW5hbFdpZHRoWDtcbiAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgdmFyIGZkSW5kZXggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRTZWxlY3RbZ2x5cGguaW5kZXhdO1xuICAgICAgICB2YXIgZmREaWN0ID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2ZkQXJyYXlbZmRJbmRleF07XG4gICAgICAgIHN1YnJzID0gZmREaWN0Ll9zdWJycztcbiAgICAgICAgc3VicnNCaWFzID0gZmREaWN0Ll9zdWJyc0JpYXM7XG4gICAgICAgIGRlZmF1bHRXaWR0aFggPSBmZERpY3QuX2RlZmF1bHRXaWR0aFg7XG4gICAgICAgIG5vbWluYWxXaWR0aFggPSBmZERpY3QuX25vbWluYWxXaWR0aFg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3VicnMgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnM7XG4gICAgICAgIHN1YnJzQmlhcyA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9zdWJyc0JpYXM7XG4gICAgICAgIGRlZmF1bHRXaWR0aFggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgbm9taW5hbFdpZHRoWCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9ub21pbmFsV2lkdGhYO1xuICAgIH1cbiAgICB2YXIgd2lkdGggPSBkZWZhdWx0V2lkdGhYO1xuXG4gICAgZnVuY3Rpb24gbmV3Q29udG91cih4LCB5KSB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIG9wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgIHZhciBoYXNXaWR0aEFyZztcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHN0ZW0gb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBpcyBhbHdheXMgZXZlbi5cbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIHVuZXZlbiwgdGhhdCBtZWFucyBhIHdpZHRoIGlzIHNwZWNpZmllZC5cbiAgICAgICAgaGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuICAgICAgICBpZiAoaGFzV2lkdGhBcmcgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5TdGVtcyArPSBzdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZShjb2RlKSB7XG4gICAgICAgIHZhciBiMTtcbiAgICAgICAgdmFyIGIyO1xuICAgICAgICB2YXIgYjM7XG4gICAgICAgIHZhciBiNDtcbiAgICAgICAgdmFyIGNvZGVJbmRleDtcbiAgICAgICAgdmFyIHN1YnJDb2RlO1xuICAgICAgICB2YXIganB4O1xuICAgICAgICB2YXIganB5O1xuICAgICAgICB2YXIgYzN4O1xuICAgICAgICB2YXIgYzN5O1xuICAgICAgICB2YXIgYzR4O1xuICAgICAgICB2YXIgYzR5O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBjb2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHYgPSBjb2RlW2ldO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBoc3RlbVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gdnN0ZW1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IC8vIHZtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHJsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OiAvLyBobGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6IC8vIHZsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODogLy8gcnJjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiAvLyBjYWxsc3ViclxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIHN1YnJzQmlhcztcbiAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBzdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlKHN1YnJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6IC8vIHJldHVyblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogLy8gZmxleCBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM1OiAvLyBmbGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeTMgZHg0IGR5NCBkeDUgZHk1IGR4NiBkeTYgZmQgZmxleCAoMTIgMzUpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7IC8vIGZsZXggZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0OiAvLyBoZmxleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR4NiBoZmxleCAoMTIgMzQpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7IC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSB5OyAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNjogLy8gaGZsZXgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR5NSBkeDYgaGZsZXgxICgxMiAzNikgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzogLy8gZmxleDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZDYgZmxleDEgKDEyIDM3KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGM0eCAtIHgpID4gTWF0aC5hYnMoYzR5IC0geSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0dseXBoICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGguaW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogdW5rbm93biBvcGVyYXRvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyMDAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OiAvLyBlbmRjaGFyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE4OiAvLyBoc3RlbWhtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOTogLy8gaGludG1hc2tcbiAgICAgICAgICAgICAgICBjYXNlIDIwOiAvLyBjbnRybWFza1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gKG5TdGVtcyArIDcpID4+IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6IC8vIHJtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDIgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzogLy8gdnN0ZW1obVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ6IC8vIHJjdXJ2ZWxpbmVcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTogLy8gcmxpbmVjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjY6IC8vIHZ2Y3VydmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBoaGN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyODogLy8gc2hvcnRpbnRcbiAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBiMiA9IGNvZGVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSkgPj4gMTYpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjk6IC8vIGNhbGxnc3ViclxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIGZvbnQuZ3N1YnJzQmlhcztcbiAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBmb250LmdzdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlKHN1YnJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzA6IC8vIHZoY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMTogLy8gaHZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAodiA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnR2x5cGggJyArIGdseXBoLmluZGV4ICsgJzogdW5rbm93biBvcGVyYXRvciAnICsgdlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjQ3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHYgLSAxMzkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goLSh2IC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiMyA9IGNvZGVbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpIHwgKGIzIDw8IDgpIHwgYjQpIC8gNjU1MzZcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlKGNvZGUpO1xuXG4gICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRkRTZWxlY3QoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIGZkQXJyYXlDb3VudCkge1xuICAgIHZhciBmZFNlbGVjdCA9IFtdO1xuICAgIHZhciBmZEluZGV4O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIC8vIFNpbXBsZSBsaXN0IG9mIG5HbHlwaHMgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaUdpZCA9IDA7IGlHaWQgPCBuR2x5cGhzOyBpR2lkKyspIHtcbiAgICAgICAgICAgIGZkSW5kZXggPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgaWYgKGZkSW5kZXggPj0gZmRBcnJheUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBmZEluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKEZEIGNvdW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZmRBcnJheUNvdW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDMpIHtcbiAgICAgICAgLy8gUmFuZ2VzXG4gICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgIHZhciBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICBpZiAoZmlyc3QgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgaW5pdGlhbCBHSUQgJyArXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICBmb3IgKHZhciBpUmFuZ2UgPSAwOyBpUmFuZ2UgPCBuUmFuZ2VzOyBpUmFuZ2UrKykge1xuICAgICAgICAgICAgZmRJbmRleCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBuZXh0ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBpZiAoZmRJbmRleCA+PSBmZEFycmF5Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdDRkYgdGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgaGFzIGJhZCBGRCBpbmRleCB2YWx1ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZkSW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAoRkQgY291bnQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBmZEFycmF5Q291bnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID4gbkdseXBocykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIEdJRCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IGZpcnN0IDwgbmV4dDsgZmlyc3QrKykge1xuICAgICAgICAgICAgICAgIGZkU2VsZWN0LnB1c2goZmRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQgIT09IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgZmluYWwgR0lEICcgK1xuICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCB0YWJsZSBoYXMgdW5zdXBwb3J0ZWQgZm9ybWF0ICcgKyBmb3JtYXRcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZkU2VsZWN0O1xufVxuXG4vLyBQYXJzZSB0aGUgYENGRmAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cbmZ1bmN0aW9uIHBhcnNlQ0ZGVGFibGUoZGF0YSwgc3RhcnQsIGZvbnQsIG9wdCkge1xuICAgIGZvbnQudGFibGVzLmNmZiA9IHt9O1xuICAgIHZhciBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIG5hbWVJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGhlYWRlci5lbmRPZmZzZXQsXG4gICAgICAgIHBhcnNlLmJ5dGVzVG9TdHJpbmdcbiAgICApO1xuICAgIHZhciB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgIHZhciBzdHJpbmdJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHRvcERpY3RJbmRleC5lbmRPZmZzZXQsXG4gICAgICAgIHBhcnNlLmJ5dGVzVG9TdHJpbmdcbiAgICApO1xuICAgIHZhciBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG4gICAgZm9udC5nc3VicnMgPSBnbG9iYWxTdWJySW5kZXgub2JqZWN0cztcbiAgICBmb250LmdzdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5nc3VicnMpO1xuXG4gICAgdmFyIHRvcERpY3RBcnJheSA9IGdhdGhlckNGRlRvcERpY3RzKFxuICAgICAgICBkYXRhLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgdG9wRGljdEluZGV4Lm9iamVjdHMsXG4gICAgICAgIHN0cmluZ0luZGV4Lm9iamVjdHNcbiAgICApO1xuICAgIGlmICh0b3BEaWN0QXJyYXkubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQ0ZGIHRhYmxlIGhhcyB0b28gbWFueSBmb250cyBpbiAnRm9udFNldCcgLSBjb3VudCBvZiBmb250cyBOYW1lSW5kZXgubGVuZ3RoID0gXCIgK1xuICAgICAgICAgICAgICAgIHRvcERpY3RBcnJheS5sZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgdG9wRGljdCA9IHRvcERpY3RBcnJheVswXTtcbiAgICBmb250LnRhYmxlcy5jZmYudG9wRGljdCA9IHRvcERpY3Q7XG5cbiAgICBpZiAodG9wRGljdC5fcHJpdmF0ZURpY3QpIHtcbiAgICAgICAgZm9udC5kZWZhdWx0V2lkdGhYID0gdG9wRGljdC5fcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgZm9udC5ub21pbmFsV2lkdGhYID0gdG9wRGljdC5fcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcbiAgICB9XG5cbiAgICBpZiAodG9wRGljdC5yb3NbMF0gIT09IHVuZGVmaW5lZCAmJiB0b3BEaWN0LnJvc1sxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvbnQuaXNDSURGb250ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgdmFyIGZkQXJyYXlPZmZzZXQgPSB0b3BEaWN0LmZkQXJyYXk7XG4gICAgICAgIHZhciBmZFNlbGVjdE9mZnNldCA9IHRvcERpY3QuZmRTZWxlY3Q7XG4gICAgICAgIGlmIChmZEFycmF5T2Zmc2V0ID09PSAwIHx8IGZkU2VsZWN0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0ZvbnQgaXMgbWFya2VkIGFzIGEgQ0lEIGZvbnQsIGJ1dCBGREFycmF5IGFuZC9vciBGRFNlbGVjdCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmZEFycmF5T2Zmc2V0ICs9IHN0YXJ0O1xuICAgICAgICB2YXIgZmRBcnJheUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBmZEFycmF5T2Zmc2V0KTtcbiAgICAgICAgdmFyIGZkQXJyYXkgPSBnYXRoZXJDRkZUb3BEaWN0cyhcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGZkQXJyYXlJbmRleC5vYmplY3RzLFxuICAgICAgICAgICAgc3RyaW5nSW5kZXgub2JqZWN0c1xuICAgICAgICApO1xuICAgICAgICB0b3BEaWN0Ll9mZEFycmF5ID0gZmRBcnJheTtcbiAgICAgICAgZmRTZWxlY3RPZmZzZXQgKz0gc3RhcnQ7XG4gICAgICAgIHRvcERpY3QuX2ZkU2VsZWN0ID0gcGFyc2VDRkZGRFNlbGVjdChcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBmZFNlbGVjdE9mZnNldCxcbiAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzLFxuICAgICAgICAgICAgZmRBcnJheS5sZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJpdmF0ZURpY3RPZmZzZXQgPSBzdGFydCArIHRvcERpY3QucHJpdmF0ZVsxXTtcbiAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcml2YXRlRGljdE9mZnNldCxcbiAgICAgICAgdG9wRGljdC5wcml2YXRlWzBdLFxuICAgICAgICBzdHJpbmdJbmRleC5vYmplY3RzXG4gICAgKTtcbiAgICBmb250LmRlZmF1bHRXaWR0aFggPSBwcml2YXRlRGljdC5kZWZhdWx0V2lkdGhYO1xuICAgIGZvbnQubm9taW5hbFdpZHRoWCA9IHByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG5cbiAgICBpZiAocHJpdmF0ZURpY3Quc3VicnMgIT09IDApIHtcbiAgICAgICAgdmFyIHN1YnJPZmZzZXQgPSBwcml2YXRlRGljdE9mZnNldCArIHByaXZhdGVEaWN0LnN1YnJzO1xuICAgICAgICB2YXIgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcbiAgICAgICAgZm9udC5zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LnN1YnJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LnN1YnJzID0gW107XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gMDtcbiAgICB9XG5cbiAgICAvLyBPZmZzZXRzIGluIHRoZSB0b3AgZGljdCBhcmUgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQ0ZGIGRhdGEsIHNvIGFkZCB0aGUgQ0ZGIHN0YXJ0IG9mZnNldC5cbiAgICB2YXIgY2hhclN0cmluZ3NJbmRleDtcbiAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuICAgICAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleExvd01lbW9yeShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3NcbiAgICAgICAgKTtcbiAgICAgICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vZmZzZXRzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgICAgICBmb250Lm5HbHlwaHMgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHMubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KFxuICAgICAgICBkYXRhLFxuICAgICAgICBzdGFydCArIHRvcERpY3QuY2hhcnNldCxcbiAgICAgICAgZm9udC5uR2x5cGhzLFxuICAgICAgICBzdHJpbmdJbmRleC5vYmplY3RzXG4gICAgKTtcbiAgICBpZiAodG9wRGljdC5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAvLyBTdGFuZGFyZCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IENmZkVuY29kaW5nKGNmZlN0YW5kYXJkRW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH0gZWxzZSBpZiAodG9wRGljdC5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAvLyBFeHBlcnQgZW5jb2RpbmdcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBDZmZFbmNvZGluZyhjZmZFeHBlcnRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IHBhcnNlQ0ZGRW5jb2RpbmcoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc3RhcnQgKyB0b3BEaWN0LmVuY29kaW5nLFxuICAgICAgICAgICAgY2hhcnNldFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFByZWZlciB0aGUgQ01BUCBlbmNvZGluZyB0byB0aGUgQ0ZGIGVuY29kaW5nLlxuICAgIGZvbnQuZW5jb2RpbmcgPSBmb250LmVuY29kaW5nIHx8IGZvbnQuY2ZmRW5jb2Rpbmc7XG5cbiAgICBmb250LmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcbiAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuICAgICAgICBmb250Ll9wdXNoID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3RyaW5nID0gZ2V0Q2ZmSW5kZXhPYmplY3QoXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBjaGFyU3RyaW5nc0luZGV4Lm9mZnNldHMsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb250LmdseXBocy5wdXNoKFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgZ2x5cGhzZXQuY2ZmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyU3RyaW5nKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQubkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hhclN0cmluZyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0c1tpXTtcbiAgICAgICAgICAgIGZvbnQuZ2x5cGhzLnB1c2goXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBnbHlwaHNldC5jZmZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJTdHJpbmcpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgY2ZmID0geyBwYXJzZTogcGFyc2VDRkZUYWJsZSB9O1xuXG4vLyBUaGUgYGZ2YXJgIHRhYmxlIHN0b3JlcyBmb250IHZhcmlhdGlvbiBheGVzIGFuZCBpbnN0YW5jZXMuXG5cbmZ1bmN0aW9uIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG4gICAgdmFyIGF4aXMgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGF4aXMudGFnID0gcC5wYXJzZVRhZygpO1xuICAgIGF4aXMubWluVmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBheGlzLmRlZmF1bHRWYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIGF4aXMubWF4VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAvLyByZXNlcnZlZCBmb3IgZmxhZ3M7IG5vIHZhbHVlcyBkZWZpbmVkXG4gICAgYXhpcy5uYW1lID0gbmFtZXNbcC5wYXJzZVVTaG9ydCgpXSB8fCB7fTtcbiAgICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gcGFyc2VGdmFySW5zdGFuY2UoZGF0YSwgc3RhcnQsIGF4ZXMsIG5hbWVzKSB7XG4gICAgdmFyIGluc3QgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGluc3QubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTsgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuXG4gICAgaW5zdC5jb29yZGluYXRlcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnN0LmNvb3JkaW5hdGVzW2F4ZXNbaV0udGFnXSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ2YXJUYWJsZShkYXRhLCBzdGFydCwgbmFtZXMpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgdGFibGVWZXJzaW9uID09PSAweDAwMDEwMDAwLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgZnZhciB0YWJsZSB2ZXJzaW9uLidcbiAgICApO1xuICAgIHZhciBvZmZzZXRUb0RhdGEgPSBwLnBhcnNlT2Zmc2V0MTYoKTtcbiAgICAvLyBTa2lwIGNvdW50U2l6ZVBhaXJzLlxuICAgIHAuc2tpcCgndVNob3J0JywgMSk7XG4gICAgdmFyIGF4aXNDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgYXhpc1NpemUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGluc3RhbmNlQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGluc3RhbmNlU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcblxuICAgIHZhciBheGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGlzQ291bnQ7IGkrKykge1xuICAgICAgICBheGVzLnB1c2goXG4gICAgICAgICAgICBwYXJzZUZ2YXJBeGlzKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0VG9EYXRhICsgaSAqIGF4aXNTaXplLCBuYW1lcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2VzID0gW107XG4gICAgdmFyIGluc3RhbmNlU3RhcnQgPSBzdGFydCArIG9mZnNldFRvRGF0YSArIGF4aXNDb3VudCAqIGF4aXNTaXplO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5zdGFuY2VDb3VudDsgaisrKSB7XG4gICAgICAgIGluc3RhbmNlcy5wdXNoKFxuICAgICAgICAgICAgcGFyc2VGdmFySW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ICsgaiAqIGluc3RhbmNlU2l6ZSxcbiAgICAgICAgICAgICAgICBheGVzLFxuICAgICAgICAgICAgICAgIG5hbWVzXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgYXhlczogYXhlcywgaW5zdGFuY2VzOiBpbnN0YW5jZXMgfTtcbn1cblxudmFyIGZ2YXIgPSB7IHBhcnNlOiBwYXJzZUZ2YXJUYWJsZSB9O1xuXG4vLyBUaGUgYEdERUZgIHRhYmxlIGNvbnRhaW5zIHZhcmlvdXMgZ2x5cGggcHJvcGVydGllc1xuXG52YXIgYXR0YWNoTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBhdHRhY2hQb2ludHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci51U2hvcnRMaXN0KSlcbiAgICB9O1xufTtcblxudmFyIGNhcmV0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGZvcm1hdCA9PT0gMSB8fCBmb3JtYXQgPT09IDIgfHwgZm9ybWF0ID09PSAzLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgQ2FyZXRWYWx1ZSB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgY29vcmRpbmF0ZTogdGhpcy5wYXJzZVNob3J0KCkgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4geyBwb2ludGluZGV4OiB0aGlzLnBhcnNlU2hvcnQoKSB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7XG4gICAgICAgIC8vIERldmljZSAvIFZhcmlhdGlvbiBJbmRleCB0YWJsZXMgdW5zdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuIHsgY29vcmRpbmF0ZTogdGhpcy5wYXJzZVNob3J0KCkgfTtcbiAgICB9XG59O1xuXG52YXIgbGlnR2x5cGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoY2FyZXRWYWx1ZSkpO1xufTtcblxudmFyIGxpZ0NhcmV0TGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBsaWdHbHlwaHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGxpZ0dseXBoKSlcbiAgICB9O1xufTtcblxudmFyIG1hcmtHbHlwaFNldHMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBhcnNlVVNob3J0KCk7IC8vIFZlcnNpb25cbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUdERUZUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigxKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjIgfHwgdGFibGVWZXJzaW9uID09PSAxLjMsXG4gICAgICAgICdVbnN1cHBvcnRlZCBHREVGIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgdmFyIGdkZWYgPSB7XG4gICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgY2xhc3NEZWY6IHAucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgIGF0dGFjaExpc3Q6IHAucGFyc2VQb2ludGVyKGF0dGFjaExpc3QpLFxuICAgICAgICBsaWdDYXJldExpc3Q6IHAucGFyc2VQb2ludGVyKGxpZ0NhcmV0TGlzdCksXG4gICAgICAgIG1hcmtBdHRhY2hDbGFzc0RlZjogcC5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKVxuICAgIH07XG4gICAgaWYgKHRhYmxlVmVyc2lvbiA+PSAxLjIpIHtcbiAgICAgICAgZ2RlZi5tYXJrR2x5cGhTZXRzID0gcC5wYXJzZVBvaW50ZXIobWFya0dseXBoU2V0cyk7XG4gICAgfVxuICAgIHJldHVybiBnZGVmO1xufVxudmFyIGdkZWYgPSB7IHBhcnNlOiBwYXJzZUdERUZUYWJsZSB9O1xuXG4vLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cblxudmFyIHN1YnRhYmxlUGFyc2VycyA9IG5ldyBBcnJheSgxMCk7IC8vIHN1YnRhYmxlUGFyc2Vyc1swXSBpcyB1bnVzZWRcblxuLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjbG9va3VwLXR5cGUtMS1zaW5nbGUtYWRqdXN0bWVudC1wb3NpdGlvbmluZy1zdWJ0YWJsZVxuLy8gdGhpcyA9IFBhcnNlciBpbnN0YW5jZVxuc3VidGFibGVQYXJzZXJzWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgcG9zZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChwb3Nmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCgpLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAocG9zZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy5wYXJzZVZhbHVlUmVjb3JkTGlzdCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnMHgnICtcbiAgICAgICAgICAgIHN0YXJ0LnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAnOiBHUE9TIGxvb2t1cCB0eXBlIDEgZm9ybWF0IG11c3QgYmUgMSBvciAyLidcbiAgICApO1xufTtcblxuLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjbG9va3VwLXR5cGUtMi1wYWlyLWFkanVzdG1lbnQtcG9zaXRpb25pbmctc3VidGFibGVcbnN1YnRhYmxlUGFyc2Vyc1syXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHBvc0Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIHBvc0Zvcm1hdCA9PT0gMSB8fCBwb3NGb3JtYXQgPT09IDIsXG4gICAgICAgICcweCcgK1xuICAgICAgICAgICAgc3RhcnQudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICc6IEdQT1MgbG9va3VwIHR5cGUgMiBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJ1xuICAgICk7XG4gICAgdmFyIGNvdmVyYWdlID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKTtcbiAgICB2YXIgdmFsdWVGb3JtYXQxID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZUZvcm1hdDIgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHBvc0Zvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBBZGp1c3RtZW50cyBmb3IgR2x5cGggUGFpcnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQxOiB2YWx1ZUZvcm1hdDEsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0MixcbiAgICAgICAgICAgIHBhaXJTZXRzOiB0aGlzLnBhcnNlTGlzdChcbiAgICAgICAgICAgICAgICBQYXJzZXIucG9pbnRlcihcbiAgICAgICAgICAgICAgICAgICAgUGFyc2VyLmxpc3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWlyVmFsdWVSZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHBvc0Zvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgY2xhc3NEZWYxID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKTtcbiAgICAgICAgdmFyIGNsYXNzRGVmMiA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZik7XG4gICAgICAgIHZhciBjbGFzczFDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGNsYXNzMkNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gQ2xhc3MgUGFpciBBZGp1c3RtZW50XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IHBvc0Zvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0MTogdmFsdWVGb3JtYXQxLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQyOiB2YWx1ZUZvcm1hdDIsXG4gICAgICAgICAgICBjbGFzc0RlZjE6IGNsYXNzRGVmMSxcbiAgICAgICAgICAgIGNsYXNzRGVmMjogY2xhc3NEZWYyLFxuICAgICAgICAgICAgY2xhc3MxQ291bnQ6IGNsYXNzMUNvdW50LFxuICAgICAgICAgICAgY2xhc3MyQ291bnQ6IGNsYXNzMkNvdW50LFxuICAgICAgICAgICAgY2xhc3NSZWNvcmRzOiB0aGlzLnBhcnNlTGlzdChcbiAgICAgICAgICAgICAgICBjbGFzczFDb3VudCxcbiAgICAgICAgICAgICAgICBQYXJzZXIubGlzdChjbGFzczJDb3VudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUxOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMjogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MiksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuc3VidGFibGVQYXJzZXJzWzNdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAzKCkge1xuICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgMyBub3Qgc3VwcG9ydGVkJyB9O1xufTtcbnN1YnRhYmxlUGFyc2Vyc1s0XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNCgpIHtcbiAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDQgbm90IHN1cHBvcnRlZCcgfTtcbn07XG5zdWJ0YWJsZVBhcnNlcnNbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA1IG5vdCBzdXBwb3J0ZWQnIH07XG59O1xuc3VidGFibGVQYXJzZXJzWzZdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA2KCkge1xuICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNiBub3Qgc3VwcG9ydGVkJyB9O1xufTtcbnN1YnRhYmxlUGFyc2Vyc1s3XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNygpIHtcbiAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDcgbm90IHN1cHBvcnRlZCcgfTtcbn07XG5zdWJ0YWJsZVBhcnNlcnNbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA4IG5vdCBzdXBwb3J0ZWQnIH07XG59O1xuc3VidGFibGVQYXJzZXJzWzldID0gZnVuY3Rpb24gcGFyc2VMb29rdXA5KCkge1xuICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOSBub3Qgc3VwcG9ydGVkJyB9O1xufTtcblxuLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3NcbmZ1bmN0aW9uIHBhcnNlR3Bvc1RhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKDEpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICB0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjEsXG4gICAgICAgICdVbnN1cHBvcnRlZCBHUE9TIHRhYmxlIHZlcnNpb24gJyArIHRhYmxlVmVyc2lvblxuICAgICk7XG5cbiAgICBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzKSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyksXG4gICAgICAgICAgICB2YXJpYXRpb25zOiBwLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0KCksXG4gICAgICAgIH07XG4gICAgfVxufVxuXG52YXIgZ3BvcyA9IHsgcGFyc2U6IHBhcnNlR3Bvc1RhYmxlIH07XG5cbi8vIFRoZSBgR1NVQmAgdGFibGUgY29udGFpbnMgbGlnYXR1cmVzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cbnZhciBzdWJ0YWJsZVBhcnNlcnMkMSA9IG5ldyBBcnJheSg5KTsgLy8gc3VidGFibGVQYXJzZXJzWzBdIGlzIHVudXNlZFxuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI1NTXG5zdWJ0YWJsZVBhcnNlcnMkMVsxXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGRlbHRhR2x5cGhJZDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBzdWJzdGl0dXRlOiB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSAxIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nXG4gICAgKTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jTVNcbnN1YnRhYmxlUGFyc2VycyQxWzJdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAyKCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgc3Vic3RGb3JtYXQgPT09IDEsXG4gICAgICAgICdHU1VCIE11bHRpcGxlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBzZXF1ZW5jZXM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpLFxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0FTXG5zdWJ0YWJsZVBhcnNlcnMkMVszXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMygpIHtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIHN1YnN0Rm9ybWF0ID09PSAxLFxuICAgICAgICAnR1NVQiBBbHRlcm5hdGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMSdcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGFsdGVybmF0ZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpLFxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0xTXG5zdWJ0YWJsZVBhcnNlcnMkMVs0XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNCgpIHtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIHN1YnN0Rm9ybWF0ID09PSAxLFxuICAgICAgICAnR1NVQiBsaWdhdHVyZSB0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBsaWdhdHVyZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxpZ0dseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVVTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICB9O1xufTtcblxudmFyIGxvb2t1cFJlY29yZERlc2MgPSB7XG4gICAgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQsXG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0NTRlxuc3VidGFibGVQYXJzZXJzJDFbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblxuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBydWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmREZXNjXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgY2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICBjbGFzc1NldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmREZXNjXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDMpIHtcbiAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2VzOiB0aGlzLnBhcnNlTGlzdChcbiAgICAgICAgICAgICAgICBnbHlwaENvdW50LFxuICAgICAgICAgICAgICAgIFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDUgZm9ybWF0IG11c3QgYmUgMSwgMiBvciAzLidcbiAgICApO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNDQ1xuc3VidGFibGVQYXJzZXJzJDFbNl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDYoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBjaGFpblJ1bGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBiYWNrdHJhY2tDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGlucHV0Q2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICBsb29rYWhlYWRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGNoYWluQ2xhc3NTZXQ6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja3RyYWNrOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVNob3J0KCkgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDMsXG4gICAgICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBpbnB1dENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJ1xuICAgICk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0VTXG5zdWJ0YWJsZVBhcnNlcnMkMVs3XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNygpIHtcbiAgICAvLyBFeHRlbnNpb24gU3Vic3RpdHV0aW9uIHN1YnRhYmxlXG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICBzdWJzdEZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ0dTVUIgRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnXG4gICAgKTtcbiAgICB2YXIgZXh0ZW5zaW9uTG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgZXh0ZW5zaW9uUGFyc2VyID0gbmV3IFBhcnNlcihcbiAgICAgICAgdGhpcy5kYXRhLFxuICAgICAgICB0aGlzLm9mZnNldCArIHRoaXMucGFyc2VVTG9uZygpXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgbG9va3VwVHlwZTogZXh0ZW5zaW9uTG9va3VwVHlwZSxcbiAgICAgICAgZXh0ZW5zaW9uOiBzdWJ0YWJsZVBhcnNlcnMkMVtleHRlbnNpb25Mb29rdXBUeXBlXS5jYWxsKGV4dGVuc2lvblBhcnNlciksXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jUkNDU1xuc3VidGFibGVQYXJzZXJzJDFbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICBzdWJzdEZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ0dTVUIgUmV2ZXJzZSBDaGFpbmluZyBDb250ZXh0dWFsIFNpbmdsZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJ1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgYmFja3RyYWNrQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICBsb29rYWhlYWRDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgIHN1YnN0aXR1dGVzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2dzdWIuaHRtXG5mdW5jdGlvbiBwYXJzZUdzdWJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigxKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgdGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSB2ZXJzaW9uLidcbiAgICApO1xuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMkMSksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMkMSksXG4gICAgICAgICAgICB2YXJpYXRpb25zOiBwLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0KCksXG4gICAgICAgIH07XG4gICAgfVxufVxuXG52YXIgZ3N1YiA9IHsgcGFyc2U6IHBhcnNlR3N1YlRhYmxlIH07XG5cbi8vIFRoZSBgaGVhZGAgdGFibGUgY29udGFpbnMgZ2xvYmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb250LlxuXG4vLyBQYXJzZSB0aGUgaGVhZGVyIGBoZWFkYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VIZWFkVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaGVhZC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBoZWFkLmZvbnRSZXZpc2lvbiA9IE1hdGgucm91bmQocC5wYXJzZUZpeGVkKCkgKiAxMDAwKSAvIDEwMDA7XG4gICAgaGVhZC5jaGVja1N1bUFkanVzdG1lbnQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBoZWFkLm1hZ2ljTnVtYmVyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIGhlYWQubWFnaWNOdW1iZXIgPT09IDB4NWYwZjNjZjUsXG4gICAgICAgICdGb250IGhlYWRlciBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyLidcbiAgICApO1xuICAgIGhlYWQuZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC51bml0c1BlckVtID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQuY3JlYXRlZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLm1vZGlmaWVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuICAgIGhlYWQueE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueE1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQubWFjU3R5bGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5sb3dlc3RSZWNQUEVNID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQuZm9udERpcmVjdGlvbkhpbnQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLmluZGV4VG9Mb2NGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLmdseXBoRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHJldHVybiBoZWFkO1xufVxuXG52YXIgaGVhZCA9IHsgcGFyc2U6IHBhcnNlSGVhZFRhYmxlIH07XG5cbi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuXG4vLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoaGVhID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHJldHVybiBoaGVhO1xufVxuXG52YXIgaGhlYSA9IHsgcGFyc2U6IHBhcnNlSGhlYVRhYmxlIH07XG5cbi8vIFRoZSBgaG10eGAgdGFibGUgY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cblxuZnVuY3Rpb24gcGFyc2VIbXR4VGFibGVBbGwoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKSB7XG4gICAgdmFyIGFkdmFuY2VXaWR0aDtcbiAgICB2YXIgbGVmdFNpZGVCZWFyaW5nO1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgZm9udCBpcyBtb25vc3BhY2VkLCBvbmx5IG9uZSBlbnRyeSBpcyBuZWVkZWQuIFRoaXMgbGFzdCBlbnRyeSBhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IGdseXBocy5cbiAgICAgICAgaWYgKGkgPCBudW1NZXRyaWNzKSB7XG4gICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcbiAgICAgICAgZ2x5cGgubGVmdFNpZGVCZWFyaW5nID0gbGVmdFNpZGVCZWFyaW5nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VIbXR4VGFibGVPbkxvd01lbW9yeShmb250LCBkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzKSB7XG4gICAgZm9udC5faG10eFRhYmxlRGF0YSA9IHt9O1xuXG4gICAgdmFyIGFkdmFuY2VXaWR0aDtcbiAgICB2YXIgbGVmdFNpZGVCZWFyaW5nO1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgZm9udCBpcyBtb25vc3BhY2VkLCBvbmx5IG9uZSBlbnRyeSBpcyBuZWVkZWQuIFRoaXMgbGFzdCBlbnRyeSBhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IGdseXBocy5cbiAgICAgICAgaWYgKGkgPCBudW1NZXRyaWNzKSB7XG4gICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvbnQuX2htdHhUYWJsZURhdGFbaV0gPSB7XG4gICAgICAgICAgICBhZHZhbmNlV2lkdGg6IGFkdmFuY2VXaWR0aCxcbiAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZzogbGVmdFNpZGVCZWFyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gUGFyc2UgdGhlIGBobXR4YCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShmb250LCBkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMsIG9wdCkge1xuICAgIGlmIChvcHQubG93TWVtb3J5KVxuICAgICAgICB7IHBhcnNlSG10eFRhYmxlT25Mb3dNZW1vcnkoZm9udCwgZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocyk7IH1cbiAgICBlbHNlIHsgcGFyc2VIbXR4VGFibGVBbGwoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKTsgfVxufVxuXG52YXIgaG10eCA9IHsgcGFyc2U6IHBhcnNlSG10eFRhYmxlIH07XG5cbi8vIFRoZSBga2VybmAgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycy5cblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApIHtcbiAgICB2YXIgcGFpcnMgPSB7fTtcbiAgICAvLyBTa2lwIG5UYWJsZXMuXG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICB2YXIgc3VidGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBzdWJ0YWJsZUxlbmd0aCwgc3VidGFibGVDb3ZlcmFnZVxuICAgIHAuc2tpcCgndVNob3J0JywgMik7XG4gICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuZnVuY3Rpb24gcGFyc2VNYWNLZXJuVGFibGUocCkge1xuICAgIHZhciBwYWlycyA9IHt9O1xuICAgIC8vIFRoZSBNYWMga2VybiB0YWJsZSBzdG9yZXMgdGhlIHZlcnNpb24gYXMgYSBmaXhlZCAoMzIgYml0cykgYnV0IHdlIG9ubHkgbG9hZGVkIHRoZSBmaXJzdCAxNiBiaXRzLlxuICAgIC8vIFNraXAgdGhlIHJlc3QuXG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICB2YXIgblRhYmxlcyA9IHAucGFyc2VVTG9uZygpO1xuICAgIC8vY2hlY2suYXJndW1lbnQoblRhYmxlcyA9PT0gMSwgJ09ubHkgMSBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQgKGdvdCAnICsgblRhYmxlcyArICcpLicpO1xuICAgIGlmIChuVGFibGVzID4gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ09ubHkgdGhlIGZpcnN0IGtlcm4gc3VidGFibGUgaXMgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBwLnNraXAoJ3VMb25nJyk7XG4gICAgdmFyIGNvdmVyYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBjb3ZlcmFnZSAmIDB4RkY7XG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICBpZiAoc3VidGFibGVWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHZhciBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5cbi8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlV2luZG93c0tlcm5UYWJsZShwKTtcbiAgICB9IGVsc2UgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VNYWNLZXJuVGFibGUocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24gKCcgKyB0YWJsZVZlcnNpb24gKyAnKS4nKTtcbiAgICB9XG59XG5cbnZhciBrZXJuID0geyBwYXJzZTogcGFyc2VLZXJuVGFibGUgfTtcblxuLy8gVGhlIGBsdGFnYCB0YWJsZSBzdG9yZXMgSUVURiBCQ1AtNDcgbGFuZ3VhZ2UgdGFncy4gSXQgYWxsb3dzIHN1cHBvcnRpbmdcblxuZnVuY3Rpb24gcGFyc2VMdGFnVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBsdGFnIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gVGhlICdsdGFnJyBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGRlZmluZSBhbnkgZmxhZ3M7IHNraXAgdGhlIGZpZWxkLlxuICAgIHAuc2tpcCgndUxvbmcnLCAxKTtcbiAgICB2YXIgbnVtVGFncyA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhZ3M7IGkrKykge1xuICAgICAgICB2YXIgdGFnID0gJyc7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCArIHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IG9mZnNldCArIGxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhLmdldEludDgoaikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbnZhciBsdGFnID0geyBwYXJzZTogcGFyc2VMdGFnVGFibGUgfTtcblxuLy8gVGhlIGBsb2NhYCB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LlxuXG4vLyBQYXJzZSB0aGUgYGxvY2FgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQsXG4vLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG4vLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuLy8gVGhlIGxvY2EgdGFibGUgaGFzIHR3byB2ZXJzaW9uczogYSBzaG9ydCB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1U2hvcnRzLCBhbmQgYSBsb25nXG4vLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG4vLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG5mdW5jdGlvbiBwYXJzZUxvY2FUYWJsZShkYXRhLCBzdGFydCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBwYXJzZUZuID0gc2hvcnRWZXJzaW9uID8gcC5wYXJzZVVTaG9ydCA6IHAucGFyc2VVTG9uZztcbiAgICAvLyBUaGVyZSBpcyBhbiBleHRyYSBlbnRyeSBhZnRlciB0aGUgbGFzdCBpbmRleCBlbGVtZW50IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgbGFzdCBnbHlwaC5cbiAgICAvLyBUaGF0J3Mgd2h5IHdlIHVzZSBudW1HbHlwaHMgKyAxLlxuICAgIHZhciBnbHlwaE9mZnNldHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBocyArIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhPZmZzZXQgPSBwYXJzZUZuLmNhbGwocCk7XG4gICAgICAgIGlmIChzaG9ydFZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIFRoZSBzaG9ydCB0YWJsZSB2ZXJzaW9uIHN0b3JlcyB0aGUgYWN0dWFsIG9mZnNldCBkaXZpZGVkIGJ5IDIuXG4gICAgICAgICAgICBnbHlwaE9mZnNldCAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGhPZmZzZXRzLnB1c2goZ2x5cGhPZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG59XG5cbnZhciBsb2NhID0geyBwYXJzZTogcGFyc2VMb2NhVGFibGUgfTtcblxuLy8gVGhlIGBtYXhwYCB0YWJsZSBlc3RhYmxpc2hlcyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgdGhlIGZvbnQuXG5cbi8vIFBhcnNlIHRoZSBtYXhpbXVtIHByb2ZpbGUgYG1heHBgIHRhYmxlLlxuZnVuY3Rpb24gcGFyc2VNYXhwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgbWF4cCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgbWF4cC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBtYXhwLm51bUdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAobWF4cC52ZXJzaW9uID09PSAxLjApIHtcbiAgICAgICAgbWF4cC5tYXhQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlUG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvc2l0ZUNvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFpvbmVzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFR3aWxpZ2h0UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0b3JhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4RnVuY3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heEluc3RydWN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTdGFja0VsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFNpemVPZkluc3RydWN0aW9ucyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb25lbnRFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb25lbnREZXB0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4cDtcbn1cblxudmFyIG1heHAgPSB7IHBhcnNlOiBwYXJzZU1heHBUYWJsZSB9O1xuXG4vLyBUaGUgYE9TLzJgIHRhYmxlIGNvbnRhaW5zIG1ldHJpY3MgcmVxdWlyZWQgaW4gT3BlblR5cGUgZm9udHMuXG5cbi8vIFBhcnNlIHRoZSBPUy8yIGFuZCBXaW5kb3dzIG1ldHJpY3MgYE9TLzJgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZU9TMlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIG9zMiA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgb3MyLnZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnhBdmdDaGFyV2lkdGggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIudXNXZWlnaHRDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaWR0aENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5mc1R5cGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WVNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WVNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdHJpa2VvdXRTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdHJpa2VvdXRQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5zRmFtaWx5Q2xhc3MgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIucGFub3NlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIG9zMi5wYW5vc2VbaV0gPSBwLnBhcnNlQnl0ZSgpO1xuICAgIH1cblxuICAgIG9zMi51bFVuaWNvZGVSYW5nZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMyA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIuYWNoVmVuZElEID0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgcC5wYXJzZUJ5dGUoKSxcbiAgICAgICAgcC5wYXJzZUJ5dGUoKSxcbiAgICAgICAgcC5wYXJzZUJ5dGUoKSxcbiAgICAgICAgcC5wYXJzZUJ5dGUoKVxuICAgICk7XG4gICAgb3MyLmZzU2VsZWN0aW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c0ZpcnN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c0xhc3RDaGFySW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnNUeXBvQXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc1R5cG9EZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc1R5cG9MaW5lR2FwID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2luQXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpbkRlc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKG9zMi52ZXJzaW9uID49IDEpIHtcbiAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICB9XG5cbiAgICBpZiAob3MyLnZlcnNpb24gPj0gMikge1xuICAgICAgICBvczIuc3hIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgb3MyLnNDYXBIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzRGVmYXVsdENoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c0JyZWFrQ2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzTWF4Q29udGVudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3MyO1xufVxuXG52YXIgb3MyID0geyBwYXJzZTogcGFyc2VPUzJUYWJsZSB9O1xuXG4vLyBUaGUgYHBvc3RgIHRhYmxlIHN0b3JlcyBhZGRpdGlvbmFsIFBvc3RTY3JpcHQgaW5mb3JtYXRpb24sIHN1Y2ggYXMgZ2x5cGggbmFtZXMuXG5cbi8vIFBhcnNlIHRoZSBQb3N0U2NyaXB0IGBwb3N0YCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VQb3N0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcG9zdCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgcG9zdC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBwb3N0Lml0YWxpY0FuZ2xlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcG9zdC51bmRlcmxpbmVQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QudW5kZXJsaW5lVGhpY2tuZXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC5pc0ZpeGVkUGl0Y2ggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm5hbWVzID0gW107XG4gICAgc3dpdGNoIChwb3N0LnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMi41OlxuICAgICAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHBvc3Qub2Zmc2V0ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBwb3N0Lm9mZnNldFtpJDFdID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcG9zdDtcbn1cblxudmFyIHBvc3QgPSB7IHBhcnNlOiBwYXJzZVBvc3RUYWJsZSB9O1xuXG4vLyBEYXRhIHR5cGVzIHVzZWQgaW4gdGhlIE9wZW5UeXBlIGZvbnQgZmlsZS5cblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5kZWNvZGVcbiAqIEBjbGFzc1xuICovXG52YXIgZGVjb2RlID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGOCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcbiAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDEpIHtcbiAgICAgICAgY29kZVBvaW50c1tqXSA9IGRhdGEuZ2V0VWludDgob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGMTYgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bUJ5dGVzKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICB2YXIgbnVtQ2hhcnMgPSBudW1CeXRlcyAvIDI7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMikge1xuICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbn07XG5cbi8vIERhdGEgZm9yIGNvbnZlcnRpbmcgb2xkIGVpZ2h0LWJpdCBNYWNpbnRvc2ggZW5jb2RpbmdzIHRvIFVuaWNvZGUuXG4vLyBUaGlzIHJlcHJlc2VudGF0aW9uIGlzIG9wdGltaXplZCBmb3IgZGVjb2Rpbmc7IGVuY29kaW5nIGlzIHNsb3dlclxuLy8gYW5kIG5lZWRzIG1vcmUgbWVtb3J5LiBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IGFsbCBvcGVudHlwZS5qcyB1c2Vyc1xuLy8gd2FudCB0byBvcGVuIGZvbnRzLCBidXQgc2F2aW5nIGEgZm9udCB3aWxsIGJlIGNvbXBhcmF0aXZlbHkgcmFyZVxuLy8gc28gaXQgY2FuIGJlIG1vcmUgZXhwZW5zaXZlLiBLZXllZCBieSBJQU5BIGNoYXJhY3RlciBzZXQgbmFtZS5cbi8vXG4vLyBQeXRob24gc2NyaXB0IGZvciBnZW5lcmF0aW5nIHRoZXNlIHN0cmluZ3M6XG4vL1xuLy8gICAgIHMgPSB1Jycuam9pbihbY2hyKGMpLmRlY29kZSgnbWFjX2dyZWVrJykgZm9yIGMgaW4gcmFuZ2UoMTI4LCAyNTYpXSlcbi8vICAgICBwcmludChzLmVuY29kZSgndXRmLTgnKSlcbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGVpZ2h0Qml0TWFjRW5jb2RpbmdzID0ge1xuICAgICd4LW1hYy1jcm9hdGlhbic6ICAvLyBQeXRob246ICdtYWNfY3JvYXRpYW4nXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsWg4oSiwrTCqOKJoMW9w5jiiJ7CseKJpOKJpeKIhsK14oiC4oiR4oiPxaHiiKvCqsK6zqnFvsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omIxIbCq8SM4oCmwqDDgMODw5XFksWTxJDigJTigJzigJ3igJjigJnDt+KXiu+jv8Kp4oGE4oKs4oC54oC6w4bCu+KAk8K34oCa4oCe4oCww4LEh8OBxI3DiMONw47Dj8OMw5PDlMSRw5LDmsObw5nEscuGy5zCr8+Aw4vLmsK4w4rDpsuHJyxcbiAgICAneC1tYWMtY3lyaWxsaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2N5cmlsbGljJ1xuICAgICfQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv4oCgwrDSkMKjwqfigKLCttCGwq7CqeKEotCC0ZLiiaDQg9GT4oiewrHiiaTiiaXRlsK10pHQiNCE0ZTQh9GX0InRmdCK0ZonICtcbiAgICAn0ZjQhcKs4oiaxpLiiYjiiIbCq8K74oCmwqDQi9Gb0IzRnNGV4oCT4oCU4oCc4oCd4oCY4oCZw7figJ7QjtGe0I/Rn+KEltCB0ZHRj9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGOJyxcbiAgICAneC1tYWMtZ2FlbGljJzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0dBRUxJQy5UWFRcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOG4gsKx4omk4oml4biDxIrEi+G4iuG4i+G4nuG4n8SgxKHhuYDDpsO4JyArXG4gICAgJ+G5geG5luG5l8m8xpLFv+G5oMKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnhuaHhupvDv8W44bmq4oKs4oC54oC6xbbFt+G5q8K34buy4buz4oGKw4LDisOBw4vDiMONw47Dj8OMw5PDlOKZo8OSw5rDm8OZxLHDncO9xbTFteG6hOG6heG6gOG6geG6guG6gycsXG4gICAgJ3gtbWFjLWdyZWVrJzogIC8vIFB5dGhvbjogJ21hY19ncmVlaydcbiAgICAnw4TCucKyw4nCs8OWw5zOhcOgw6LDpM6EwqjDp8Opw6jDqsOrwqPihKLDrsOv4oCiwr3igLDDtMO2wqbigqzDucO7w7zigKDOk86UzpjOm86ezqDDn8KuwqnOo86qwqfiiaDCsMK3zpHCseKJpOKJpcKlzpLOlc6WzpfOmc6azpzOps6rzqjOqScgK1xuICAgICfOrM6dwqzOn86h4omIzqTCq8K74oCmwqDOpc6nzobOiMWT4oCT4oCV4oCc4oCd4oCY4oCZw7fOic6KzozOjs6tzq7Or8+Mzo/Pjc6xzrLPiM60zrXPhs6zzrfOuc6+zrrOu868zr3Ov8+Az47Pgc+Dz4TOuM+Jz4LPh8+FzrbPis+LzpDOsFxcdTAwQUQnLFxuICAgICd4LW1hYy1pY2VsYW5kaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2ljZWxhbmQnXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zDncKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzDkMOww57DvsO9wrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtaW51aXQnOiAvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvSU5VSVQuVFhUXG4gICAgJ+GQg+GQhOGQheGQhuGQiuGQi+GQseGQsuGQs+GQtOGQuOGQueGRieGRjuGRj+GRkOGRkeGRleGRluGRpuGRreGRruGRr+GRsOGRsuGRs+GSg+GSi+GSjOGSjeGSjuGSkOGSkcKw4ZKh4ZKl4ZKm4oCiwrbhkqfCrsKp4oSi4ZKo4ZKq4ZKr4ZK74ZOC4ZOD4ZOE4ZOF4ZOH4ZOI4ZOQ4ZOv4ZOw4ZOx4ZOy4ZO04ZO14ZSF4ZOV4ZOW4ZOXJyArXG4gICAgJ+GTmOGTmuGTm+GTquGUqOGUqeGUquGUq+GUreKApsKg4ZSu4ZS+4ZWV4ZWW4ZWX4oCT4oCU4oCc4oCd4oCY4oCZ4ZWY4ZWZ4ZWa4ZWd4ZWG4ZWH4ZWI4ZWJ4ZWL4ZWM4ZWQ4ZW/4ZaA4ZaB4ZaC4ZaD4ZaE4ZaF4ZaP4ZaQ4ZaR4ZaS4ZaT4ZaU4ZaV4Zmx4Zmy4Zmz4Zm04Zm14Zm24ZaW4Zag4Zah4Zai4Zaj4Zak4Zal4Zam4ZW8xYHFgicsXG4gICAgJ3gtbWFjLWNlJzogIC8vIFB5dGhvbjogJ21hY19sYXRpbjInXG4gICAgJ8OExIDEgcOJxITDlsOcw6HEhcSMw6TEjcSGxIfDqcW5xbrEjsOtxI/EksSTxJbDs8SXw7TDtsO1w7rEmsSbw7zigKDCsMSYwqPCp+KAosK2w5/CrsKp4oSixJnCqOKJoMSjxK7Er8Sq4omk4omlxKvEtuKIguKIkcWCxLvEvMS9xL7EucS6xYUnICtcbiAgICAnxYbFg8Ks4oiaxYTFh+KIhsKrwrvigKbCoMWIxZDDlcWRxYzigJPigJTigJzigJ3igJjigJnDt+KXisWNxZTFlcWY4oC54oC6xZnFlsWXxaDigJrigJ7FocWaxZvDgcWkxaXDjcW9xb7FqsOTw5TFq8Wuw5rFr8WwxbHFssWzw53DvcS3xbvFgcW8xKLLhycsXG4gICAgbWFjaW50b3NoOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAuu+sge+sguKAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLXJvbWFuaWFuJzogIC8vIFB5dGhvbjogJ21hY19yb21hbmlhbidcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgxILImOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pxIPImScgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzigLnigLrImsib4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtdHVya2lzaCc6ICAvLyBQeXRob246ICdtYWNfdHVya2lzaCdcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjEnsSfxLDEscWexZ/igKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDme+ioMuGy5zCr8uYy5nLmsK4y53Lm8uHJ1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIG9sZC1zdHlsZSBNYWNpbnRvc2ggc3RyaW5nLiBSZXR1cm5zIGVpdGhlciBhIFVuaWNvZGUgSmF2YVNjcmlwdFxuICogc3RyaW5nLCBvciAndW5kZWZpbmVkJyBpZiB0aGUgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQuIEZvciBleGFtcGxlLCB3ZSBkb1xuICogbm90IHN1cHBvcnQgQ2hpbmVzZSwgSmFwYW5lc2Ugb3IgS29yZWFuIGJlY2F1c2UgdGhlc2Ugd291bGQgbmVlZCBsYXJnZVxuICogbWFwcGluZyB0YWJsZXMuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGFMZW5ndGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLk1BQ1NUUklORyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQsIGRhdGFMZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgdmFyIHRhYmxlID0gZWlnaHRCaXRNYWNFbmNvZGluZ3NbZW5jb2RpbmddO1xuICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgICAgIC8vIEluIGFsbCBlaWdodC1iaXQgTWFjIGVuY29kaW5ncywgdGhlIGNoYXJhY3RlcnMgMHgwMC4uMHg3RiBhcmVcbiAgICAgICAgLy8gbWFwcGVkIHRvIFUrMDAwMC4uVSswMDdGOyB3ZSBvbmx5IG5lZWQgdG8gbG9vayB1cCB0aGUgb3RoZXJzLlxuICAgICAgICBpZiAoYyA8PSAweDdGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0YWJsZVtjICYgMHg3Rl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gVGhlIGBHUE9TYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cbi8vIFBhcnNlIHRoZSBtZXRhZGF0YSBgbWV0YWAgdGFibGUuXG4vLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2bWV0YS5odG1sXG5mdW5jdGlvbiBwYXJzZU1ldGFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIE1FVEEgdGFibGUgdmVyc2lvbi4nKTtcbiAgICBwLnBhcnNlVUxvbmcoKTsgLy8gZmxhZ3MgLSBjdXJyZW50bHkgdW51c2VkIGFuZCBzZXQgdG8gMFxuICAgIHAucGFyc2VVTG9uZygpOyAvLyB0YWJsZU9mZnNldFxuICAgIHZhciBudW1EYXRhTWFwcyA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIHRhZ3MgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFNYXBzOyBpKyspIHtcbiAgICAgICAgdmFyIHRhZyA9IHAucGFyc2VUYWcoKTtcbiAgICAgICAgdmFyIGRhdGFPZmZzZXQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIHRleHQgPSBkZWNvZGUuVVRGOChkYXRhLCBzdGFydCArIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xuXG4gICAgICAgIHRhZ3NbdGFnXSA9IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG52YXIgbWV0YSA9IHsgcGFyc2U6IHBhcnNlTWV0YVRhYmxlIH07XG5cbi8vIG9wZW50eXBlLmpzXG5cbi8qKlxuICogVGhlIG9wZW50eXBlIGxpYnJhcnkuXG4gKiBAbmFtZXNwYWNlIG9wZW50eXBlXG4gKi9cblxuLy8gVGFibGUgRGlyZWN0b3J5IEVudHJpZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBQYXJzZXMgT3BlblR5cGUgdGFibGUgZW50cmllcy5cbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7T2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKSB7XG4gICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgIHZhciBwID0gMTI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFnID0gcGFyc2UuZ2V0VGFnKGRhdGEsIHApO1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgNCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgMTIpO1xuICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgIGNoZWNrc3VtOiBjaGVja3N1bSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBwICs9IDE2O1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG59XG5cbi8qKlxuICogUGFyc2VzIFdPRkYgdGFibGUgZW50cmllcy5cbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7T2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpIHtcbiAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG4gICAgdmFyIHAgPSA0NDsgLy8gb2Zmc2V0IHRvIHRoZSBmaXJzdCB0YWJsZSBkaXJlY3RvcnkgZW50cnkuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFnID0gcGFyc2UuZ2V0VGFnKGRhdGEsIHApO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuICAgICAgICB2YXIgY29tcExlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcbiAgICAgICAgdmFyIG9yaWdMZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgMTIpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKGNvbXBMZW5ndGggPCBvcmlnTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wcmVzc2lvbiA9ICdXT0ZGJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgY29tcHJlc3Npb246IGNvbXByZXNzaW9uLFxuICAgICAgICAgICAgY29tcHJlc3NlZExlbmd0aDogY29tcExlbmd0aCxcbiAgICAgICAgICAgIGxlbmd0aDogb3JpZ0xlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIHAgKz0gMjA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlRW50cmllcztcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBUYWJsZURhdGFcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtEYXRhVmlld30gZGF0YSAtIFRoZSBEYXRhVmlld1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCAtIFRoZSBkYXRhIG9mZnNldC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7T2JqZWN0fVxuICogQHJldHVybiB7VGFibGVEYXRhfVxuICovXG5mdW5jdGlvbiB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSkge1xuICAgIGlmICh0YWJsZUVudHJ5LmNvbXByZXNzaW9uID09PSAnV09GRicpIHtcbiAgICAgICAgdmFyIGluQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICAgIHRhYmxlRW50cnkub2Zmc2V0ICsgMixcbiAgICAgICAgICAgIHRhYmxlRW50cnkuY29tcHJlc3NlZExlbmd0aCAtIDJcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgaW5mbGF0ZVN5bmMoaW5CdWZmZXIsIG91dEJ1ZmZlcik7XG4gICAgICAgIGlmIChvdXRCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gdGFibGVFbnRyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnRGVjb21wcmVzc2lvbiBlcnJvcjogJyArXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlRW50cnkudGFnICtcbiAgICAgICAgICAgICAgICAgICAgXCIgZGVjb21wcmVzc2VkIGxlbmd0aCBkb2Vzbid0IG1hdGNoIHJlY29yZGVkIGxlbmd0aFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlciwgMCk7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHZpZXcsIG9mZnNldDogMCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIG9mZnNldDogdGFibGVFbnRyeS5vZmZzZXQgfTtcbiAgICB9XG59XG5cbi8vIFB1YmxpYyBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBQYXJzZSB0aGUgT3BlblR5cGUgZmlsZSBkYXRhIChhcyBhbiBBcnJheUJ1ZmZlcikgYW5kIHJldHVybiBhIEZvbnQgb2JqZWN0LlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBmb250IGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn1cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0IC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICogQHJldHVybiB7b3BlbnR5cGUuRm9udH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgPT09IHVuZGVmaW5lZCB8fCBvcHQgPT09IG51bGwgPyB7fSA6IG9wdDtcblxuICAgIHZhciBpbmRleFRvTG9jRm9ybWF0O1xuXG4gICAgLy8gU2luY2UgdGhlIGNvbnN0cnVjdG9yIGNhbiBhbHNvIGJlIGNhbGxlZCB0byBjcmVhdGUgbmV3IGZvbnRzIGZyb20gc2NyYXRjaCwgd2UgaW5kaWNhdGUgdGhpc1xuICAgIC8vIHNob3VsZCBiZSBhbiBlbXB0eSBmb250IHRoYXQgd2UnbGwgZmlsbCB3aXRoIG91ciBvd24gZGF0YS5cbiAgICB2YXIgZm9udCA9IG5ldyBGb250KHsgZW1wdHk6IHRydWUgfSk7XG5cbiAgICAvLyBPcGVuVHlwZSBmb250cyB1c2UgYmlnIGVuZGlhbiBieXRlIG9yZGVyaW5nLlxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdHlwZWQgYXJyYXkgdmlldyB0eXBlcywgYmVjYXVzZSB0aGV5IG9wZXJhdGUgd2l0aCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaG9zdCBjb21wdXRlci5cbiAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cbiAgICB2YXIgZGF0YSA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDApO1xuICAgIHZhciBudW1UYWJsZXM7XG4gICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgIHZhciBzaWduYXR1cmUgPSBwYXJzZS5nZXRUYWcoZGF0YSwgMCk7XG4gICAgaWYgKFxuICAgICAgICBzaWduYXR1cmUgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkgfHxcbiAgICAgICAgc2lnbmF0dXJlID09PSAndHJ1ZScgfHxcbiAgICAgICAgc2lnbmF0dXJlID09PSAndHlwMSdcbiAgICApIHtcbiAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICd0cnVldHlwZSc7XG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCA0KTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSAnT1RUTycpIHtcbiAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICdjZmYnO1xuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gJ3dPRkYnKSB7XG4gICAgICAgIHZhciBmbGF2b3IgPSBwYXJzZS5nZXRUYWcoZGF0YSwgNCk7XG4gICAgICAgIGlmIChmbGF2b3IgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYXZvciA9PT0gJ09UVE8nKSB7XG4gICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ2NmZic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIGZsYXZvciAnICsgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCAxMik7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgc2lnbmF0dXJlICcgKyBzaWduYXR1cmUpO1xuICAgIH1cblxuICAgIHZhciBjZmZUYWJsZUVudHJ5O1xuICAgIHZhciBmdmFyVGFibGVFbnRyeTtcbiAgICB2YXIgZ2x5ZlRhYmxlRW50cnk7XG4gICAgdmFyIGdkZWZUYWJsZUVudHJ5O1xuICAgIHZhciBncG9zVGFibGVFbnRyeTtcbiAgICB2YXIgZ3N1YlRhYmxlRW50cnk7XG4gICAgdmFyIGhtdHhUYWJsZUVudHJ5O1xuICAgIHZhciBrZXJuVGFibGVFbnRyeTtcbiAgICB2YXIgbG9jYVRhYmxlRW50cnk7XG4gICAgdmFyIG1ldGFUYWJsZUVudHJ5O1xuICAgIHZhciBwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFibGVFbnRyeSA9IHRhYmxlRW50cmllc1tpXTtcbiAgICAgICAgdmFyIHRhYmxlID0gKHZvaWQgMCk7XG4gICAgICAgIHN3aXRjaCAodGFibGVFbnRyeS50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NtYXAnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmNtYXAgPSBjbWFwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5lbmNvZGluZyA9IG5ldyBDbWFwRW5jb2RpbmcoZm9udC50YWJsZXMuY21hcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjdnQgJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmN2dCA9IHAucGFyc2VTaG9ydExpc3QodGFibGVFbnRyeS5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Z2YXInOlxuICAgICAgICAgICAgICAgIGZ2YXJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZwZ20nOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuZnBnbSA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5oZWFkID0gaGVhZC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudW5pdHNQZXJFbSA9IGZvbnQudGFibGVzLmhlYWQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICBpbmRleFRvTG9jRm9ybWF0ID0gZm9udC50YWJsZXMuaGVhZC5pbmRleFRvTG9jRm9ybWF0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGhlYSc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuaGhlYSA9IGhoZWEucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LmFzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5hc2NlbmRlcjtcbiAgICAgICAgICAgICAgICBmb250LmRlc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuZGVzY2VuZGVyO1xuICAgICAgICAgICAgICAgIGZvbnQubnVtYmVyT2ZITWV0cmljcyA9IGZvbnQudGFibGVzLmhoZWEubnVtYmVyT2ZITWV0cmljcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2htdHgnOlxuICAgICAgICAgICAgICAgIGhtdHhUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2x0YWcnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGx0YWdUYWJsZSA9IGx0YWcucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21heHAnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLm1heHAgPSBtYXhwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5udW1HbHlwaHMgPSBmb250LnRhYmxlcy5tYXhwLm51bUdseXBocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ09TLzInOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLm9zMiA9IG9zMi5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncG9zdCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMucG9zdCA9IHBvc3QucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ByZXAnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMucHJlcCA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnbHlmJzpcbiAgICAgICAgICAgICAgICBnbHlmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb2NhJzpcbiAgICAgICAgICAgICAgICBsb2NhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDRkYgJzpcbiAgICAgICAgICAgICAgICBjZmZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tlcm4nOlxuICAgICAgICAgICAgICAgIGtlcm5UYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dERUYnOlxuICAgICAgICAgICAgICAgIGdkZWZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dQT1MnOlxuICAgICAgICAgICAgICAgIGdwb3NUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dTVUInOlxuICAgICAgICAgICAgICAgIGdzdWJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICAgICAgICAgIG1ldGFUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnbHlmVGFibGVFbnRyeSAmJiBsb2NhVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgc2hvcnRWZXJzaW9uID0gaW5kZXhUb0xvY0Zvcm1hdCA9PT0gMDtcbiAgICAgICAgdmFyIGxvY2FUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBsb2NhVGFibGVFbnRyeSk7XG4gICAgICAgIHZhciBsb2NhT2Zmc2V0cyA9IGxvY2EucGFyc2UoXG4gICAgICAgICAgICBsb2NhVGFibGUuZGF0YSxcbiAgICAgICAgICAgIGxvY2FUYWJsZS5vZmZzZXQsXG4gICAgICAgICAgICBmb250Lm51bUdseXBocyxcbiAgICAgICAgICAgIHNob3J0VmVyc2lvblxuICAgICAgICApO1xuICAgICAgICB2YXIgZ2x5ZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdseWZUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5nbHlwaHMgPSBnbHlmLnBhcnNlKFxuICAgICAgICAgICAgZ2x5ZlRhYmxlLmRhdGEsXG4gICAgICAgICAgICBnbHlmVGFibGUub2Zmc2V0LFxuICAgICAgICAgICAgbG9jYU9mZnNldHMsXG4gICAgICAgICAgICBmb250LFxuICAgICAgICAgICAgb3B0XG4gICAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjZmZUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBjZmZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBjZmZUYWJsZUVudHJ5KTtcbiAgICAgICAgY2ZmLnBhcnNlKGNmZlRhYmxlLmRhdGEsIGNmZlRhYmxlLm9mZnNldCwgZm9udCwgb3B0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGRvZXNuJ3QgY29udGFpbiBUcnVlVHlwZSBvciBDRkYgb3V0bGluZXMuXCIpO1xuICAgIH1cblxuICAgIHZhciBobXR4VGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgaG10eFRhYmxlRW50cnkpO1xuICAgIGhtdHgucGFyc2UoXG4gICAgICAgIGZvbnQsXG4gICAgICAgIGhtdHhUYWJsZS5kYXRhLFxuICAgICAgICBobXR4VGFibGUub2Zmc2V0LFxuICAgICAgICBmb250Lm51bWJlck9mSE1ldHJpY3MsXG4gICAgICAgIGZvbnQubnVtR2x5cGhzLFxuICAgICAgICBmb250LmdseXBocyxcbiAgICAgICAgb3B0XG4gICAgKTtcbiAgICBhZGRHbHlwaE5hbWVzKGZvbnQsIG9wdCk7XG5cbiAgICBpZiAoa2VyblRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGtlcm5UYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBrZXJuVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ga2Vybi5wYXJzZShrZXJuVGFibGUuZGF0YSwga2VyblRhYmxlLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoZ2RlZlRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGdkZWZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnZGVmVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmdkZWYgPSBnZGVmLnBhcnNlKGdkZWZUYWJsZS5kYXRhLCBnZGVmVGFibGUub2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZ3Bvc1RhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGdwb3NUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBncG9zVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmdwb3MgPSBncG9zLnBhcnNlKGdwb3NUYWJsZS5kYXRhLCBncG9zVGFibGUub2Zmc2V0KTtcbiAgICAgICAgZm9udC5wb3NpdGlvbi5pbml0KCk7XG4gICAgfVxuXG4gICAgaWYgKGdzdWJUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBnc3ViVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3N1YlRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5nc3ViID0gZ3N1Yi5wYXJzZShnc3ViVGFibGUuZGF0YSwgZ3N1YlRhYmxlLm9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKGZ2YXJUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBmdmFyVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZnZhclRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5mdmFyID0gZnZhci5wYXJzZShcbiAgICAgICAgICAgIGZ2YXJUYWJsZS5kYXRhLFxuICAgICAgICAgICAgZnZhclRhYmxlLm9mZnNldCxcbiAgICAgICAgICAgIGZvbnQubmFtZXNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAobWV0YVRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIG1ldGFUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBtZXRhVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLm1ldGEgPSBtZXRhLnBhcnNlKG1ldGFUYWJsZS5kYXRhLCBtZXRhVGFibGUub2Zmc2V0KTtcbiAgICAgICAgZm9udC5tZXRhcyA9IGZvbnQudGFibGVzLm1ldGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnQ7XG59XG5cbmZ1bmN0aW9uIGxvYWQoKSB7fVxuZnVuY3Rpb24gbG9hZFN5bmMoKSB7fVxuXG52YXIgb3BlbnR5cGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICBfX3Byb3RvX186IG51bGwsXG4gICBGb250OiBGb250LFxuICAgR2x5cGg6IEdseXBoLFxuICAgUGF0aDogUGF0aCxcbiAgIF9wYXJzZTogcGFyc2UsXG4gICBwYXJzZTogcGFyc2VCdWZmZXIsXG4gICBsb2FkOiBsb2FkLFxuICAgbG9hZFN5bmM6IGxvYWRTeW5jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgb3BlbnR5cGU7XG5leHBvcnQgeyBGb250LCBHbHlwaCwgUGF0aCwgcGFyc2UgYXMgX3BhcnNlLCBsb2FkLCBsb2FkU3luYywgcGFyc2VCdWZmZXIgYXMgcGFyc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW50eXBlLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/@shuding/opentype.js/dist/opentype.module.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/camelize/index.js":
/*!****************************************!*\
  !*** ./node_modules/camelize/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (obj) {\n\tif (typeof obj === 'string') { return camelCase(obj); }\n\treturn walk(obj);\n};\n\nfunction walk(obj) {\n\tif (!obj || typeof obj !== 'object') { return obj; }\n\tif (isDate(obj) || isRegex(obj)) { return obj; }\n\tif (isArray(obj)) { return map(obj, walk); }\n\treturn reduce(objectKeys(obj), function (acc, key) {\n\t\tvar camel = camelCase(key);\n\t\tacc[camel] = walk(obj[key]);\n\t\treturn acc;\n\t}, {});\n}\n\nfunction camelCase(str) {\n\treturn str.replace(/[_.-](\\w|$)/g, function (_, x) {\n\t\treturn x.toUpperCase();\n\t});\n}\n\nvar isArray = Array.isArray || function (obj) {\n\treturn Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nvar isDate = function (obj) {\n\treturn Object.prototype.toString.call(obj) === '[object Date]';\n};\n\nvar isRegex = function (obj) {\n\treturn Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar has = Object.prototype.hasOwnProperty;\nvar objectKeys = Object.keys || function (obj) {\n\tvar keys = [];\n\tfor (var key in obj) {\n\t\tif (has.call(obj, key)) { keys.push(key); }\n\t}\n\treturn keys;\n};\n\nfunction map(xs, f) {\n\tif (xs.map) { return xs.map(f); }\n\tvar res = [];\n\tfor (var i = 0; i < xs.length; i++) {\n\t\tres.push(f(xs[i], i));\n\t}\n\treturn res;\n}\n\nfunction reduce(xs, f, acc) {\n\tif (xs.reduce) { return xs.reduce(f, acc); }\n\tfor (var i = 0; i < xs.length; i++) {\n\t\tacc = f(acc, xs[i], i);\n\t}\n\treturn acc;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL2NhbWVsaXplL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEMsb0NBQW9DO0FBQ3BDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY2FtZWxpemUvaW5kZXguanM/N2NlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGNhbWVsQ2FzZShvYmopOyB9XG5cdHJldHVybiB3YWxrKG9iaik7XG59O1xuXG5mdW5jdGlvbiB3YWxrKG9iaikge1xuXHRpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgeyByZXR1cm4gb2JqOyB9XG5cdGlmIChpc0RhdGUob2JqKSB8fCBpc1JlZ2V4KG9iaikpIHsgcmV0dXJuIG9iajsgfVxuXHRpZiAoaXNBcnJheShvYmopKSB7IHJldHVybiBtYXAob2JqLCB3YWxrKTsgfVxuXHRyZXR1cm4gcmVkdWNlKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24gKGFjYywga2V5KSB7XG5cdFx0dmFyIGNhbWVsID0gY2FtZWxDYXNlKGtleSk7XG5cdFx0YWNjW2NhbWVsXSA9IHdhbGsob2JqW2tleV0pO1xuXHRcdHJldHVybiBhY2M7XG5cdH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY2FtZWxDYXNlKHN0cikge1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tfLi1dKFxcd3wkKS9nLCBmdW5jdGlvbiAoXywgeCkge1xuXHRcdHJldHVybiB4LnRvVXBwZXJDYXNlKCk7XG5cdH0pO1xufVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaXNEYXRlID0gZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnZhciBpc1JlZ2V4ID0gZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcblx0dmFyIGtleXMgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGlmIChoYXMuY2FsbChvYmosIGtleSkpIHsga2V5cy5wdXNoKGtleSk7IH1cblx0fVxuXHRyZXR1cm4ga2V5cztcbn07XG5cbmZ1bmN0aW9uIG1hcCh4cywgZikge1xuXHRpZiAoeHMubWFwKSB7IHJldHVybiB4cy5tYXAoZik7IH1cblx0dmFyIHJlcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG5cdFx0cmVzLnB1c2goZih4c1tpXSwgaSkpO1xuXHR9XG5cdHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZSh4cywgZiwgYWNjKSB7XG5cdGlmICh4cy5yZWR1Y2UpIHsgcmV0dXJuIHhzLnJlZHVjZShmLCBhY2MpOyB9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcblx0XHRhY2MgPSBmKGFjYywgeHNbaV0sIGkpO1xuXHR9XG5cdHJldHVybiBhY2M7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/camelize/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/css-background-parser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-background-parser/index.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("/*!\n * https://github.com/gilmoreorless/css-background-parser\n * Copyright © 2015 Gilmore Davidson under the MIT license: http://gilmoreorless.mit-license.org/\n */\n(function (exports) {\n\n    function BackgroundList(backgrounds) {\n        if (!(this instanceof BackgroundList)) {\n            return new BackgroundList();\n        }\n        this.backgrounds = backgrounds || [];\n    }\n\n    BackgroundList.prototype.toString = function () {\n        return this.backgrounds.join(', ');\n    };\n\n\n    function Background(props) {\n        if (!(this instanceof Background)) {\n            return new Background(props);\n        }\n        props = props || {};\n        var bg = this;\n\n        function defprop(name, defaultValue) {\n            bg[name] = (name in props) ? props[name] : defaultValue;\n        }\n\n        // http://www.w3.org/TR/css3-background/#backgrounds\n        defprop('color', '');\n        defprop('image', 'none');\n        defprop('attachment', 'scroll');\n        defprop('clip', 'border-box');\n        defprop('origin', 'padding-box');\n        defprop('position', '0% 0%');\n        defprop('repeat', 'repeat');\n        defprop('size', 'auto');\n    }\n\n    Background.prototype.toString = function () {\n        var list = [\n            this.image,\n            this.repeat,\n            this.attachment,\n            this.position + ' / ' + this.size,\n            this.origin,\n            this.clip\n        ];\n        if (this.color) {\n            list.unshift(this.color);\n        }\n        return list.join(' ');\n    };\n\n    exports.BackgroundList = BackgroundList;\n    exports.Background = Background;\n\n\n    function parseImages(cssText) {\n        var images = [];\n        var tokens = /[,\\(\\)]/;\n        var parens = 0;\n        var buffer = '';\n\n        if (cssText == null) {\n            return images;\n        }\n\n        while (cssText.length) {\n            var match = tokens.exec(cssText);\n            if (!match) {\n                break;\n            }\n            var char = match[0];\n            var ignoreChar = false;\n            switch (char) {\n                case ',':\n                    if (!parens) {\n                        images.push(buffer.trim());\n                        buffer = '';\n                        ignoreChar = true;\n                    }\n                    break;\n                case '(':\n                    parens++;\n                    break;\n                case ')':\n                    parens--;\n                    break;\n            }\n\n            var index = match.index + 1;\n            buffer += cssText.slice(0, ignoreChar ? index - 1 : index);\n            cssText = cssText.slice(index);\n        }\n\n        if (buffer.length || cssText.length) {\n            images.push((buffer + cssText).trim());\n        }\n\n        return images;\n    }\n\n    // Helper for .map()\n    function trim(str) {\n        return str.trim();\n    }\n\n    function parseSimpleList(cssText) {\n        return (cssText || '').split(',').map(trim);\n    }\n\n    exports.parseElementStyle = function (styleObject) {\n        var list = new BackgroundList();\n        if (styleObject == null) {\n            return list;\n        }\n\n        var bgImage = parseImages(styleObject.backgroundImage);\n        var bgColor = styleObject.backgroundColor;\n        var bgAttachment = parseSimpleList(styleObject.backgroundAttachment);\n        var bgClip       = parseSimpleList(styleObject.backgroundClip);\n        var bgOrigin     = parseSimpleList(styleObject.backgroundOrigin);\n        var bgPosition   = parseSimpleList(styleObject.backgroundPosition);\n        var bgRepeat     = parseSimpleList(styleObject.backgroundRepeat);\n        var bgSize       = parseSimpleList(styleObject.backgroundSize);\n        var background;\n\n        for (var i = 0, ii = bgImage.length; i < ii; i++) {\n            background = new Background({\n                image:      bgImage[i],\n                attachment: bgAttachment[i % bgAttachment.length],\n                clip:       bgClip[i % bgClip.length],\n                origin:     bgOrigin[i % bgOrigin.length],\n                position:   bgPosition[i % bgPosition.length],\n                repeat:     bgRepeat[i % bgRepeat.length],\n                size:       bgSize[i % bgSize.length]\n            });\n            if (i === ii - 1) {\n                background.color = bgColor;\n            }\n            list.backgrounds.push(background);\n        }\n\n        return list;\n    };\n\n    // exports.parseCssString = function (cssString) {\n    //     return new Background();\n    // };\n\n    // exports.parseBackgroundValue = function (cssString) {\n    //     return new Background();\n    // };\n\n})((function (root) {\n    // CommonJS\n    if ( true && module.exports !== undefined) return module.exports;\n    // Global `cssBgParser`\n    return (root.cssBgParser = {});\n})(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL2Nzcy1iYWNrZ3JvdW5kLXBhcnNlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxRQUFRLEtBQTZCO0FBQ3JDO0FBQ0EsaUNBQWlDO0FBQ2pDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Nzcy1iYWNrZ3JvdW5kLXBhcnNlci9pbmRleC5qcz8wODExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL2dpbG1vcmVvcmxlc3MvY3NzLWJhY2tncm91bmQtcGFyc2VyXG4gKiBDb3B5cmlnaHQgwqkgMjAxNSBHaWxtb3JlIERhdmlkc29uIHVuZGVyIHRoZSBNSVQgbGljZW5zZTogaHR0cDovL2dpbG1vcmVvcmxlc3MubWl0LWxpY2Vuc2Uub3JnL1xuICovXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAgIGZ1bmN0aW9uIEJhY2tncm91bmRMaXN0KGJhY2tncm91bmRzKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCYWNrZ3JvdW5kTGlzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmFja2dyb3VuZExpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhY2tncm91bmRzID0gYmFja2dyb3VuZHMgfHwgW107XG4gICAgfVxuXG4gICAgQmFja2dyb3VuZExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kcy5qb2luKCcsICcpO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIEJhY2tncm91bmQocHJvcHMpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJhY2tncm91bmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJhY2tncm91bmQocHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgICAgIHZhciBiZyA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gZGVmcHJvcChuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGJnW25hbWVdID0gKG5hbWUgaW4gcHJvcHMpID8gcHJvcHNbbmFtZV0gOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWJhY2tncm91bmQvI2JhY2tncm91bmRzXG4gICAgICAgIGRlZnByb3AoJ2NvbG9yJywgJycpO1xuICAgICAgICBkZWZwcm9wKCdpbWFnZScsICdub25lJyk7XG4gICAgICAgIGRlZnByb3AoJ2F0dGFjaG1lbnQnLCAnc2Nyb2xsJyk7XG4gICAgICAgIGRlZnByb3AoJ2NsaXAnLCAnYm9yZGVyLWJveCcpO1xuICAgICAgICBkZWZwcm9wKCdvcmlnaW4nLCAncGFkZGluZy1ib3gnKTtcbiAgICAgICAgZGVmcHJvcCgncG9zaXRpb24nLCAnMCUgMCUnKTtcbiAgICAgICAgZGVmcHJvcCgncmVwZWF0JywgJ3JlcGVhdCcpO1xuICAgICAgICBkZWZwcm9wKCdzaXplJywgJ2F1dG8nKTtcbiAgICB9XG5cbiAgICBCYWNrZ3JvdW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXG4gICAgICAgICAgICB0aGlzLmltYWdlLFxuICAgICAgICAgICAgdGhpcy5yZXBlYXQsXG4gICAgICAgICAgICB0aGlzLmF0dGFjaG1lbnQsXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICsgJyAvICcgKyB0aGlzLnNpemUsXG4gICAgICAgICAgICB0aGlzLm9yaWdpbixcbiAgICAgICAgICAgIHRoaXMuY2xpcFxuICAgICAgICBdO1xuICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgbGlzdC51bnNoaWZ0KHRoaXMuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0LmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5CYWNrZ3JvdW5kTGlzdCA9IEJhY2tncm91bmRMaXN0O1xuICAgIGV4cG9ydHMuQmFja2dyb3VuZCA9IEJhY2tncm91bmQ7XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW1hZ2VzKGNzc1RleHQpIHtcbiAgICAgICAgdmFyIGltYWdlcyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW5zID0gL1ssXFwoXFwpXS87XG4gICAgICAgIHZhciBwYXJlbnMgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgICAgICAgaWYgKGNzc1RleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChjc3NUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdG9rZW5zLmV4ZWMoY3NzVGV4dCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhciA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgdmFyIGlnbm9yZUNoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goYnVmZmVyLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZUNoYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnMrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgICAgIHBhcmVucy0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gbWF0Y2guaW5kZXggKyAxO1xuICAgICAgICAgICAgYnVmZmVyICs9IGNzc1RleHQuc2xpY2UoMCwgaWdub3JlQ2hhciA/IGluZGV4IC0gMSA6IGluZGV4KTtcbiAgICAgICAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnNsaWNlKGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoIHx8IGNzc1RleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbWFnZXMucHVzaCgoYnVmZmVyICsgY3NzVGV4dCkudHJpbSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbWFnZXM7XG4gICAgfVxuXG4gICAgLy8gSGVscGVyIGZvciAubWFwKClcbiAgICBmdW5jdGlvbiB0cmltKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNpbXBsZUxpc3QoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gKGNzc1RleHQgfHwgJycpLnNwbGl0KCcsJykubWFwKHRyaW0pO1xuICAgIH1cblxuICAgIGV4cG9ydHMucGFyc2VFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGVPYmplY3QpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBuZXcgQmFja2dyb3VuZExpc3QoKTtcbiAgICAgICAgaWYgKHN0eWxlT2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJnSW1hZ2UgPSBwYXJzZUltYWdlcyhzdHlsZU9iamVjdC5iYWNrZ3JvdW5kSW1hZ2UpO1xuICAgICAgICB2YXIgYmdDb2xvciA9IHN0eWxlT2JqZWN0LmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgdmFyIGJnQXR0YWNobWVudCA9IHBhcnNlU2ltcGxlTGlzdChzdHlsZU9iamVjdC5iYWNrZ3JvdW5kQXR0YWNobWVudCk7XG4gICAgICAgIHZhciBiZ0NsaXAgICAgICAgPSBwYXJzZVNpbXBsZUxpc3Qoc3R5bGVPYmplY3QuYmFja2dyb3VuZENsaXApO1xuICAgICAgICB2YXIgYmdPcmlnaW4gICAgID0gcGFyc2VTaW1wbGVMaXN0KHN0eWxlT2JqZWN0LmJhY2tncm91bmRPcmlnaW4pO1xuICAgICAgICB2YXIgYmdQb3NpdGlvbiAgID0gcGFyc2VTaW1wbGVMaXN0KHN0eWxlT2JqZWN0LmJhY2tncm91bmRQb3NpdGlvbik7XG4gICAgICAgIHZhciBiZ1JlcGVhdCAgICAgPSBwYXJzZVNpbXBsZUxpc3Qoc3R5bGVPYmplY3QuYmFja2dyb3VuZFJlcGVhdCk7XG4gICAgICAgIHZhciBiZ1NpemUgICAgICAgPSBwYXJzZVNpbXBsZUxpc3Qoc3R5bGVPYmplY3QuYmFja2dyb3VuZFNpemUpO1xuICAgICAgICB2YXIgYmFja2dyb3VuZDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBiZ0ltYWdlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQgPSBuZXcgQmFja2dyb3VuZCh7XG4gICAgICAgICAgICAgICAgaW1hZ2U6ICAgICAgYmdJbWFnZVtpXSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50OiBiZ0F0dGFjaG1lbnRbaSAlIGJnQXR0YWNobWVudC5sZW5ndGhdLFxuICAgICAgICAgICAgICAgIGNsaXA6ICAgICAgIGJnQ2xpcFtpICUgYmdDbGlwLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgb3JpZ2luOiAgICAgYmdPcmlnaW5baSAlIGJnT3JpZ2luLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICAgYmdQb3NpdGlvbltpICUgYmdQb3NpdGlvbi5sZW5ndGhdLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogICAgIGJnUmVwZWF0W2kgJSBiZ1JlcGVhdC5sZW5ndGhdLFxuICAgICAgICAgICAgICAgIHNpemU6ICAgICAgIGJnU2l6ZVtpICUgYmdTaXplLmxlbmd0aF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGkgPT09IGlpIC0gMSkge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQuY29sb3IgPSBiZ0NvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5iYWNrZ3JvdW5kcy5wdXNoKGJhY2tncm91bmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIC8vIGV4cG9ydHMucGFyc2VDc3NTdHJpbmcgPSBmdW5jdGlvbiAoY3NzU3RyaW5nKSB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgQmFja2dyb3VuZCgpO1xuICAgIC8vIH07XG5cbiAgICAvLyBleHBvcnRzLnBhcnNlQmFja2dyb3VuZFZhbHVlID0gZnVuY3Rpb24gKGNzc1N0cmluZykge1xuICAgIC8vICAgICByZXR1cm4gbmV3IEJhY2tncm91bmQoKTtcbiAgICAvLyB9O1xuXG59KSgoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAvLyBDb21tb25KU1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gICAgLy8gR2xvYmFsIGBjc3NCZ1BhcnNlcmBcbiAgICByZXR1cm4gKHJvb3QuY3NzQmdQYXJzZXIgPSB7fSk7XG59KSh0aGlzKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/css-background-parser/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/css-box-shadow/index.js":
/*!**********************************************!*\
  !*** ./node_modules/css-box-shadow/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("const VALUES_REG = /,(?![^\\(]*\\))/\nconst PARTS_REG = /\\s(?![^(]*\\))/\nconst LENGTH_REG = /^[0-9]+[a-zA-Z%]+?$/\n\nconst parseValue = str => {\n  const parts = str.split(PARTS_REG)\n  const inset = parts.includes('inset')\n  const last = parts.slice(-1)[0]\n  const color = !isLength(last) ? last : undefined\n\n  const nums = parts\n    .filter(n => n !== 'inset')\n    .filter(n => n !== color)\n    .map(toNum)\n  const [ offsetX, offsetY, blurRadius, spreadRadius ] = nums\n\n  return {\n    inset,\n    offsetX,\n    offsetY,\n    blurRadius,\n    spreadRadius,\n    color\n  }\n}\n\nconst stringifyValue = obj => {\n  const {\n    inset,\n    offsetX = 0,\n    offsetY = 0,\n    blurRadius = 0,\n    spreadRadius,\n    color\n  } = obj || {}\n\n  return [\n    (inset ? 'inset' : null),\n    offsetX,\n    offsetY,\n    blurRadius ,\n    spreadRadius,\n    color\n  ].filter(v => v !== null && v !== undefined)\n    .map(toPx)\n    .map(s => ('' + s).trim())\n    .join(' ')\n}\n\nconst isLength = v => v === '0' || LENGTH_REG.test(v)\nconst toNum = v => {\n  if (!/px$/.test(v) && v !== '0') return v\n  const n = parseFloat(v)\n  return !isNaN(n) ? n : v\n}\nconst toPx = n => typeof n === 'number' && n !== 0 ? (n + 'px') : n\n\nconst parse = str => str.split(VALUES_REG).map(s => s.trim()).map(parseValue)\nconst stringify = arr => arr.map(stringifyValue).join(', ')\n\nmodule.exports = {\n  parse,\n  stringify\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL2Nzcy1ib3gtc2hhZG93L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jc3MtYm94LXNoYWRvdy9pbmRleC5qcz85NjliIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZBTFVFU19SRUcgPSAvLCg/IVteXFwoXSpcXCkpL1xuY29uc3QgUEFSVFNfUkVHID0gL1xccyg/IVteKF0qXFwpKS9cbmNvbnN0IExFTkdUSF9SRUcgPSAvXlswLTldK1thLXpBLVolXSs/JC9cblxuY29uc3QgcGFyc2VWYWx1ZSA9IHN0ciA9PiB7XG4gIGNvbnN0IHBhcnRzID0gc3RyLnNwbGl0KFBBUlRTX1JFRylcbiAgY29uc3QgaW5zZXQgPSBwYXJ0cy5pbmNsdWRlcygnaW5zZXQnKVxuICBjb25zdCBsYXN0ID0gcGFydHMuc2xpY2UoLTEpWzBdXG4gIGNvbnN0IGNvbG9yID0gIWlzTGVuZ3RoKGxhc3QpID8gbGFzdCA6IHVuZGVmaW5lZFxuXG4gIGNvbnN0IG51bXMgPSBwYXJ0c1xuICAgIC5maWx0ZXIobiA9PiBuICE9PSAnaW5zZXQnKVxuICAgIC5maWx0ZXIobiA9PiBuICE9PSBjb2xvcilcbiAgICAubWFwKHRvTnVtKVxuICBjb25zdCBbIG9mZnNldFgsIG9mZnNldFksIGJsdXJSYWRpdXMsIHNwcmVhZFJhZGl1cyBdID0gbnVtc1xuXG4gIHJldHVybiB7XG4gICAgaW5zZXQsXG4gICAgb2Zmc2V0WCxcbiAgICBvZmZzZXRZLFxuICAgIGJsdXJSYWRpdXMsXG4gICAgc3ByZWFkUmFkaXVzLFxuICAgIGNvbG9yXG4gIH1cbn1cblxuY29uc3Qgc3RyaW5naWZ5VmFsdWUgPSBvYmogPT4ge1xuICBjb25zdCB7XG4gICAgaW5zZXQsXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgYmx1clJhZGl1cyA9IDAsXG4gICAgc3ByZWFkUmFkaXVzLFxuICAgIGNvbG9yXG4gIH0gPSBvYmogfHwge31cblxuICByZXR1cm4gW1xuICAgIChpbnNldCA/ICdpbnNldCcgOiBudWxsKSxcbiAgICBvZmZzZXRYLFxuICAgIG9mZnNldFksXG4gICAgYmx1clJhZGl1cyAsXG4gICAgc3ByZWFkUmFkaXVzLFxuICAgIGNvbG9yXG4gIF0uZmlsdGVyKHYgPT4gdiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQpXG4gICAgLm1hcCh0b1B4KVxuICAgIC5tYXAocyA9PiAoJycgKyBzKS50cmltKCkpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCBpc0xlbmd0aCA9IHYgPT4gdiA9PT0gJzAnIHx8IExFTkdUSF9SRUcudGVzdCh2KVxuY29uc3QgdG9OdW0gPSB2ID0+IHtcbiAgaWYgKCEvcHgkLy50ZXN0KHYpICYmIHYgIT09ICcwJykgcmV0dXJuIHZcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodilcbiAgcmV0dXJuICFpc05hTihuKSA/IG4gOiB2XG59XG5jb25zdCB0b1B4ID0gbiA9PiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgbiAhPT0gMCA/IChuICsgJ3B4JykgOiBuXG5cbmNvbnN0IHBhcnNlID0gc3RyID0+IHN0ci5zcGxpdChWQUxVRVNfUkVHKS5tYXAocyA9PiBzLnRyaW0oKSkubWFwKHBhcnNlVmFsdWUpXG5jb25zdCBzdHJpbmdpZnkgPSBhcnIgPT4gYXJyLm1hcChzdHJpbmdpZnlWYWx1ZSkuam9pbignLCAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2UsXG4gIHN0cmluZ2lmeVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/css-box-shadow/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/css-color-keywords/index.js":
/*!**************************************************!*\
  !*** ./node_modules/css-color-keywords/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./colors.json */ \"(middleware)/./node_modules/css-color-keywords/colors.json\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL2Nzcy1jb2xvci1rZXl3b3Jkcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix1SEFBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Nzcy1jb2xvci1rZXl3b3Jkcy9pbmRleC5qcz8xZmMxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29sb3JzLmpzb24nKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/css-color-keywords/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/css-to-react-native/index.js":
/*!***************************************************!*\
  !*** ./node_modules/css-to-react-native/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar parse = __webpack_require__(/*! postcss-value-parser */ \"(middleware)/./node_modules/postcss-value-parser/lib/index.js\");\n\nvar parse__default = _interopDefault(parse);\n\nvar camelizeStyleName = _interopDefault(__webpack_require__(/*! camelize */ \"(middleware)/./node_modules/camelize/index.js\"));\n\nvar cssColorKeywords = _interopDefault(__webpack_require__(/*! css-color-keywords */ \"(middleware)/./node_modules/css-color-keywords/index.js\"));\n\nvar matchString = function matchString(node) {\n  if (node.type !== 'string') return null;\n  return node.value.replace(/\\\\([0-9a-f]{1,6})(?:\\s|$)/gi, function (match, charCode) {\n    return String.fromCharCode(parseInt(charCode, 16));\n  }).replace(/\\\\/g, '');\n};\n\nvar hexColorRe = /^(#(?:[0-9a-f]{3,4}){1,2})$/i;\nvar cssFunctionNameRe = /^(rgba?|hsla?|hwb|lab|lch|gray|color)$/;\n\nvar matchColor = function matchColor(node) {\n  if (node.type === 'word' && (hexColorRe.test(node.value) || node.value in cssColorKeywords || node.value === 'transparent')) {\n    return node.value;\n  } else if (node.type === 'function' && cssFunctionNameRe.test(node.value)) {\n    return parse.stringify(node);\n  }\n\n  return null;\n};\n\nvar noneRe = /^(none)$/i;\nvar autoRe = /^(auto)$/i;\nvar identRe = /(^-?[_a-z][_a-z0-9-]*$)/i; // Note if these are wrong, you'll need to change index.js too\n\nvar numberRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)$/i; // Note lengthRe is sneaky: you can omit units for 0\n\nvar lengthRe = /^(0$|(?:[+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)(?=px$))/i;\nvar unsupportedUnitRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?(ch|em|ex|rem|vh|vw|vmin|vmax|cm|mm|in|pc|pt))$/i;\nvar angleRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?(?:deg|rad))$/i;\nvar percentRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?%)$/i;\n\nvar noopToken = function noopToken(predicate) {\n  return function (node) {\n    return predicate(node) ? '<token>' : null;\n  };\n};\n\nvar valueForTypeToken = function valueForTypeToken(type) {\n  return function (node) {\n    return node.type === type ? node.value : null;\n  };\n};\n\nvar regExpToken = function regExpToken(regExp, transform) {\n  if (transform === void 0) {\n    transform = String;\n  }\n\n  return function (node) {\n    if (node.type !== 'word') return null;\n    var match = node.value.match(regExp);\n    if (match === null) return null;\n    var value = transform(match[1]);\n    return value;\n  };\n};\n\nvar SPACE = noopToken(function (node) {\n  return node.type === 'space';\n});\nvar SLASH = noopToken(function (node) {\n  return node.type === 'div' && node.value === '/';\n});\nvar COMMA = noopToken(function (node) {\n  return node.type === 'div' && node.value === ',';\n});\nvar WORD = valueForTypeToken('word');\nvar NONE = regExpToken(noneRe);\nvar AUTO = regExpToken(autoRe);\nvar NUMBER = regExpToken(numberRe, Number);\nvar LENGTH = regExpToken(lengthRe, Number);\nvar UNSUPPORTED_LENGTH_UNIT = regExpToken(unsupportedUnitRe);\nvar ANGLE = regExpToken(angleRe, function (angle) {\n  return angle.toLowerCase();\n});\nvar PERCENT = regExpToken(percentRe);\nvar IDENT = regExpToken(identRe);\nvar STRING = matchString;\nvar COLOR = matchColor;\nvar LINE = regExpToken(/^(none|underline|line-through)$/i);\nvar BORDER_STYLE = regExpToken(/^(solid|dashed|dotted)$/);\nvar defaultBorderWidth = 1;\nvar defaultBorderColor = 'black';\nvar defaultBorderStyle = 'solid';\n\nvar border = function border(tokenStream) {\n  var borderWidth;\n  var borderColor;\n  var borderStyle;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      borderWidth: 0,\n      borderColor: 'black',\n      borderStyle: 'solid'\n    };\n  }\n\n  var partsParsed = 0;\n\n  while (partsParsed < 3 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (borderWidth === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n      borderWidth = tokenStream.lastValue;\n    } else if (borderColor === undefined && tokenStream.matches(COLOR)) {\n      borderColor = tokenStream.lastValue;\n    } else if (borderStyle === undefined && tokenStream.matches(BORDER_STYLE)) {\n      borderStyle = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (borderWidth === undefined) borderWidth = defaultBorderWidth;\n  if (borderColor === undefined) borderColor = defaultBorderColor;\n  if (borderStyle === undefined) borderStyle = defaultBorderStyle;\n  return {\n    borderWidth: borderWidth,\n    borderColor: borderColor,\n    borderStyle: borderStyle\n  };\n};\n\nvar directionFactory = function directionFactory(_ref) {\n  var _ref$types = _ref.types,\n      types = _ref$types === void 0 ? [LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT] : _ref$types,\n      _ref$directions = _ref.directions,\n      directions = _ref$directions === void 0 ? ['Top', 'Right', 'Bottom', 'Left'] : _ref$directions,\n      _ref$prefix = _ref.prefix,\n      prefix = _ref$prefix === void 0 ? '' : _ref$prefix,\n      _ref$suffix = _ref.suffix,\n      suffix = _ref$suffix === void 0 ? '' : _ref$suffix;\n  return function (tokenStream) {\n    var _ref2;\n\n    var values = []; // borderWidth doesn't currently allow a percent value, but may do in the future\n\n    values.push(tokenStream.expect.apply(tokenStream, types));\n\n    while (values.length < 4 && tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE);\n      values.push(tokenStream.expect.apply(tokenStream, types));\n    }\n\n    tokenStream.expectEmpty();\n    var top = values[0],\n        _values$ = values[1],\n        right = _values$ === void 0 ? top : _values$,\n        _values$2 = values[2],\n        bottom = _values$2 === void 0 ? top : _values$2,\n        _values$3 = values[3],\n        left = _values$3 === void 0 ? right : _values$3;\n\n    var keyFor = function keyFor(n) {\n      return \"\" + prefix + directions[n] + suffix;\n    };\n\n    return _ref2 = {}, _ref2[keyFor(0)] = top, _ref2[keyFor(1)] = right, _ref2[keyFor(2)] = bottom, _ref2[keyFor(3)] = left, _ref2;\n  };\n};\n\nvar parseShadowOffset = function parseShadowOffset(tokenStream) {\n  var width = tokenStream.expect(LENGTH);\n  var height = tokenStream.matches(SPACE) ? tokenStream.expect(LENGTH) : width;\n  tokenStream.expectEmpty();\n  return {\n    width: width,\n    height: height\n  };\n};\n\nvar parseShadow = function parseShadow(tokenStream) {\n  var offsetX;\n  var offsetY;\n  var radius;\n  var color;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      offset: {\n        width: 0,\n        height: 0\n      },\n      radius: 0,\n      color: 'black'\n    };\n  }\n\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n\n    if (offsetX === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n      offsetX = tokenStream.lastValue;\n      tokenStream.expect(SPACE);\n      offsetY = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE) && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n        radius = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (color === undefined && tokenStream.matches(COLOR)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    didParseFirst = true;\n  }\n\n  if (offsetX === undefined) tokenStream[\"throw\"]();\n  return {\n    offset: {\n      width: offsetX,\n      height: offsetY\n    },\n    radius: radius !== undefined ? radius : 0,\n    color: color !== undefined ? color : 'black'\n  };\n};\n\nvar boxShadow = function boxShadow(tokenStream) {\n  var _parseShadow = parseShadow(tokenStream),\n      offset = _parseShadow.offset,\n      radius = _parseShadow.radius,\n      color = _parseShadow.color;\n\n  return {\n    shadowOffset: offset,\n    shadowRadius: radius,\n    shadowColor: color,\n    shadowOpacity: 1\n  };\n};\n\nvar defaultFlexGrow = 1;\nvar defaultFlexShrink = 1;\nvar defaultFlexBasis = 0;\n\nvar flex = function flex(tokenStream) {\n  var flexGrow;\n  var flexShrink;\n  var flexBasis;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      flexGrow: 0,\n      flexShrink: 0,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.saveRewindPoint();\n\n  if (tokenStream.matches(AUTO) && !tokenStream.hasTokens()) {\n    return {\n      flexGrow: 1,\n      flexShrink: 1,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.rewind();\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (flexGrow === undefined && tokenStream.matches(NUMBER)) {\n      flexGrow = tokenStream.lastValue;\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE) && tokenStream.matches(NUMBER)) {\n        flexShrink = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (flexBasis === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT)) {\n      flexBasis = tokenStream.lastValue;\n    } else if (flexBasis === undefined && tokenStream.matches(AUTO)) {\n      flexBasis = 'auto';\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexGrow === undefined) flexGrow = defaultFlexGrow;\n  if (flexShrink === undefined) flexShrink = defaultFlexShrink;\n  if (flexBasis === undefined) flexBasis = defaultFlexBasis;\n  return {\n    flexGrow: flexGrow,\n    flexShrink: flexShrink,\n    flexBasis: flexBasis\n  };\n};\n\nvar FLEX_WRAP = regExpToken(/(nowrap|wrap|wrap-reverse)/);\nvar FLEX_DIRECTION = regExpToken(/(row|row-reverse|column|column-reverse)/);\nvar defaultFlexWrap = 'nowrap';\nvar defaultFlexDirection = 'row';\n\nvar flexFlow = function flexFlow(tokenStream) {\n  var flexWrap;\n  var flexDirection;\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (flexWrap === undefined && tokenStream.matches(FLEX_WRAP)) {\n      flexWrap = tokenStream.lastValue;\n    } else if (flexDirection === undefined && tokenStream.matches(FLEX_DIRECTION)) {\n      flexDirection = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexWrap === undefined) flexWrap = defaultFlexWrap;\n  if (flexDirection === undefined) flexDirection = defaultFlexDirection;\n  return {\n    flexWrap: flexWrap,\n    flexDirection: flexDirection\n  };\n};\n\nvar fontFamily = function fontFamily(tokenStream) {\n  var fontFamily;\n\n  if (tokenStream.matches(STRING)) {\n    fontFamily = tokenStream.lastValue;\n  } else {\n    fontFamily = tokenStream.expect(IDENT);\n\n    while (tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE);\n      var nextIdent = tokenStream.expect(IDENT);\n      fontFamily += \" \" + nextIdent;\n    }\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    fontFamily: fontFamily\n  };\n};\n\nvar NORMAL = regExpToken(/^(normal)$/);\nvar STYLE = regExpToken(/^(italic)$/);\nvar WEIGHT = regExpToken(/^([1-9]00|bold)$/);\nvar VARIANT = regExpToken(/^(small-caps)$/);\nvar defaultFontStyle = 'normal';\nvar defaultFontWeight = 'normal';\nvar defaultFontVariant = [];\n\nvar font = function font(tokenStream) {\n  var fontStyle;\n  var fontWeight;\n  var fontVariant; // let fontSize;\n\n  var lineHeight; // let fontFamily;\n\n  var numStyleWeightVariantMatched = 0;\n\n  while (numStyleWeightVariantMatched < 3 && tokenStream.hasTokens()) {\n    if (tokenStream.matches(NORMAL)) ;else if (fontStyle === undefined && tokenStream.matches(STYLE)) {\n      fontStyle = tokenStream.lastValue;\n    } else if (fontWeight === undefined && tokenStream.matches(WEIGHT)) {\n      fontWeight = tokenStream.lastValue;\n    } else if (fontVariant === undefined && tokenStream.matches(VARIANT)) {\n      fontVariant = [tokenStream.lastValue];\n    } else {\n      break;\n    }\n    tokenStream.expect(SPACE);\n    numStyleWeightVariantMatched += 1;\n  }\n\n  var fontSize = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n\n  if (tokenStream.matches(SLASH)) {\n    lineHeight = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n  }\n\n  tokenStream.expect(SPACE);\n\n  var _fontFamily = fontFamily(tokenStream),\n      fontFamily$1 = _fontFamily.fontFamily;\n\n  if (fontStyle === undefined) fontStyle = defaultFontStyle;\n  if (fontWeight === undefined) fontWeight = defaultFontWeight;\n  if (fontVariant === undefined) fontVariant = defaultFontVariant;\n  var out = {\n    fontStyle: fontStyle,\n    fontWeight: fontWeight,\n    fontVariant: fontVariant,\n    fontSize: fontSize,\n    fontFamily: fontFamily$1\n  };\n  if (lineHeight !== undefined) out.lineHeight = lineHeight;\n  return out;\n};\n\nvar ALIGN_CONTENT = regExpToken(/(flex-(?:start|end)|center|stretch|space-(?:between|around))/);\nvar JUSTIFY_CONTENT = regExpToken(/(flex-(?:start|end)|center|space-(?:between|around|evenly))/);\n\nvar placeContent = function placeContent(tokenStream) {\n  var alignContent = tokenStream.expect(ALIGN_CONTENT);\n  var justifyContent;\n\n  if (tokenStream.hasTokens()) {\n    tokenStream.expect(SPACE);\n    justifyContent = tokenStream.expect(JUSTIFY_CONTENT);\n  } else {\n    justifyContent = 'stretch';\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    alignContent: alignContent,\n    justifyContent: justifyContent\n  };\n};\n\nvar STYLE$1 = regExpToken(/^(solid|double|dotted|dashed)$/);\nvar defaultTextDecorationLine = 'none';\nvar defaultTextDecorationStyle = 'solid';\nvar defaultTextDecorationColor = 'black';\n\nvar textDecoration = function textDecoration(tokenStream) {\n  var line;\n  var style;\n  var color;\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n\n    if (line === undefined && tokenStream.matches(LINE)) {\n      var lines = [tokenStream.lastValue.toLowerCase()];\n      tokenStream.saveRewindPoint();\n\n      if (lines[0] !== 'none' && tokenStream.matches(SPACE) && tokenStream.matches(LINE)) {\n        lines.push(tokenStream.lastValue.toLowerCase()); // Underline comes before line-through\n\n        lines.sort().reverse();\n      } else {\n        tokenStream.rewind();\n      }\n\n      line = lines.join(' ');\n    } else if (style === undefined && tokenStream.matches(STYLE$1)) {\n      style = tokenStream.lastValue;\n    } else if (color === undefined && tokenStream.matches(COLOR)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    didParseFirst = true;\n  }\n\n  return {\n    textDecorationLine: line !== undefined ? line : defaultTextDecorationLine,\n    textDecorationColor: color !== undefined ? color : defaultTextDecorationColor,\n    textDecorationStyle: style !== undefined ? style : defaultTextDecorationStyle\n  };\n};\n\nvar textDecorationLine = function textDecorationLine(tokenStream) {\n  var lines = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n    lines.push(tokenStream.expect(LINE).toLowerCase());\n    didParseFirst = true;\n  }\n\n  lines.sort().reverse();\n  return {\n    textDecorationLine: lines.join(' ')\n  };\n};\n\nvar textShadow = function textShadow(tokenStream) {\n  var _parseShadow2 = parseShadow(tokenStream),\n      offset = _parseShadow2.offset,\n      radius = _parseShadow2.radius,\n      color = _parseShadow2.color;\n\n  return {\n    textShadowOffset: offset,\n    textShadowRadius: radius,\n    textShadowColor: color\n  };\n};\n\nvar oneOfType = function oneOfType(tokenType) {\n  return function (functionStream) {\n    var value = functionStream.expect(tokenType);\n    functionStream.expectEmpty();\n    return value;\n  };\n};\n\nvar singleNumber = oneOfType(NUMBER);\nvar singleLength = oneOfType(LENGTH);\nvar singleAngle = oneOfType(ANGLE);\n\nvar xyTransformFactory = function xyTransformFactory(tokenType) {\n  return function (key, valueIfOmitted) {\n    return function (functionStream) {\n      var _ref3, _ref4;\n\n      var x = functionStream.expect(tokenType);\n      var y;\n\n      if (functionStream.hasTokens()) {\n        functionStream.expect(COMMA);\n        y = functionStream.expect(tokenType);\n      } else if (valueIfOmitted !== undefined) {\n        y = valueIfOmitted;\n      } else {\n        // Assumption, if x === y, then we can omit XY\n        // I.e. scale(5) => [{ scale: 5 }] rather than [{ scaleX: 5 }, { scaleY: 5 }]\n        return x;\n      }\n\n      functionStream.expectEmpty();\n      return [(_ref3 = {}, _ref3[key + \"Y\"] = y, _ref3), (_ref4 = {}, _ref4[key + \"X\"] = x, _ref4)];\n    };\n  };\n};\n\nvar xyNumber = xyTransformFactory(NUMBER);\nvar xyLength = xyTransformFactory(LENGTH);\nvar xyAngle = xyTransformFactory(ANGLE);\nvar partTransforms = {\n  perspective: singleNumber,\n  scale: xyNumber('scale'),\n  scaleX: singleNumber,\n  scaleY: singleNumber,\n  translate: xyLength('translate', 0),\n  translateX: singleLength,\n  translateY: singleLength,\n  rotate: singleAngle,\n  rotateX: singleAngle,\n  rotateY: singleAngle,\n  rotateZ: singleAngle,\n  skewX: singleAngle,\n  skewY: singleAngle,\n  skew: xyAngle('skew', '0deg')\n};\n\nvar transform = function transform(tokenStream) {\n  var transforms = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n    var functionStream = tokenStream.expectFunction();\n    var functionName = functionStream.functionName;\n    var transformedValues = partTransforms[functionName](functionStream);\n\n    if (!Array.isArray(transformedValues)) {\n      var _ref5;\n\n      transformedValues = [(_ref5 = {}, _ref5[functionName] = transformedValues, _ref5)];\n    }\n\n    transforms = transformedValues.concat(transforms);\n    didParseFirst = true;\n  }\n\n  return {\n    transform: transforms\n  };\n};\n\nvar background = function background(tokenStream) {\n  return {\n    backgroundColor: tokenStream.expect(COLOR)\n  };\n};\n\nvar borderColor = directionFactory({\n  types: [COLOR],\n  prefix: 'border',\n  suffix: 'Color'\n});\nvar borderRadius = directionFactory({\n  directions: ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'],\n  prefix: 'border',\n  suffix: 'Radius'\n});\nvar borderWidth = directionFactory({\n  prefix: 'border',\n  suffix: 'Width'\n});\nvar margin = directionFactory({\n  types: [LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT, AUTO],\n  prefix: 'margin'\n});\nvar padding = directionFactory({\n  prefix: 'padding'\n});\n\nvar fontVariant = function fontVariant(tokenStream) {\n  return {\n    fontVariant: [tokenStream.expect(IDENT)]\n  };\n};\n\nvar fontWeight = function fontWeight(tokenStream) {\n  return {\n    fontWeight: tokenStream.expect(WORD) // Also match numbers as strings\n\n  };\n};\n\nvar shadowOffset = function shadowOffset(tokenStream) {\n  return {\n    shadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar textShadowOffset = function textShadowOffset(tokenStream) {\n  return {\n    textShadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar transforms = {\n  background: background,\n  border: border,\n  borderColor: borderColor,\n  borderRadius: borderRadius,\n  borderWidth: borderWidth,\n  boxShadow: boxShadow,\n  flex: flex,\n  flexFlow: flexFlow,\n  font: font,\n  fontFamily: fontFamily,\n  fontVariant: fontVariant,\n  fontWeight: fontWeight,\n  margin: margin,\n  padding: padding,\n  placeContent: placeContent,\n  shadowOffset: shadowOffset,\n  textShadow: textShadow,\n  textShadowOffset: textShadowOffset,\n  textDecoration: textDecoration,\n  textDecorationLine: textDecorationLine,\n  transform: transform\n};\nvar propertiesWithoutUnits;\n\nif (true) {\n  propertiesWithoutUnits = ['aspectRatio', 'elevation', 'flexGrow', 'flexShrink', 'opacity', 'shadowOpacity', 'zIndex'];\n}\n\nvar devPropertiesWithUnitsRegExp = propertiesWithoutUnits != null ? new RegExp(propertiesWithoutUnits.join('|')) : null;\nvar SYMBOL_MATCH = 'SYMBOL_MATCH';\n\nvar TokenStream =\n/*#__PURE__*/\nfunction () {\n  function TokenStream(nodes, parent) {\n    this.index = 0;\n    this.nodes = nodes;\n    this.functionName = parent != null ? parent.value : null;\n    this.lastValue = null;\n    this.rewindIndex = -1;\n  }\n\n  var _proto = TokenStream.prototype;\n\n  _proto.hasTokens = function hasTokens() {\n    return this.index <= this.nodes.length - 1;\n  };\n\n  _proto[SYMBOL_MATCH] = function () {\n    if (!this.hasTokens()) return null;\n    var node = this.nodes[this.index];\n\n    for (var i = 0; i < arguments.length; i += 1) {\n      var tokenDescriptor = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      var value = tokenDescriptor(node);\n\n      if (value !== null) {\n        this.index += 1;\n        this.lastValue = value;\n        return value;\n      }\n    }\n\n    return null;\n  };\n\n  _proto.matches = function matches() {\n    return this[SYMBOL_MATCH].apply(this, arguments) !== null;\n  };\n\n  _proto.expect = function expect() {\n    var value = this[SYMBOL_MATCH].apply(this, arguments);\n    return value !== null ? value : this[\"throw\"]();\n  };\n\n  _proto.matchesFunction = function matchesFunction() {\n    var node = this.nodes[this.index];\n    if (node.type !== 'function') return null;\n    var value = new TokenStream(node.nodes, node);\n    this.index += 1;\n    this.lastValue = null;\n    return value;\n  };\n\n  _proto.expectFunction = function expectFunction() {\n    var value = this.matchesFunction();\n    return value !== null ? value : this[\"throw\"]();\n  };\n\n  _proto.expectEmpty = function expectEmpty() {\n    if (this.hasTokens()) this[\"throw\"]();\n  };\n\n  _proto[\"throw\"] = function _throw() {\n    throw new Error(\"Unexpected token type: \" + this.nodes[this.index].type);\n  };\n\n  _proto.saveRewindPoint = function saveRewindPoint() {\n    this.rewindIndex = this.index;\n  };\n\n  _proto.rewind = function rewind() {\n    if (this.rewindIndex === -1) throw new Error('Internal error');\n    this.index = this.rewindIndex;\n    this.lastValue = null;\n  };\n\n  return TokenStream;\n}();\n/* eslint-disable no-param-reassign */\n// Note if this is wrong, you'll need to change tokenTypes.js too\n\n\nvar numberOrLengthRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)(?:px)?$/i;\nvar numberOnlyRe = /^[+-]?(?:\\d*\\.\\d*|[1-9]\\d*)(?:e[+-]?\\d+)?$/i;\nvar boolRe = /^true|false$/i;\nvar nullRe = /^null$/i;\nvar undefinedRe = /^undefined$/i; // Undocumented export\n\nvar transformRawValue = function transformRawValue(propName, value) {\n  if (true) {\n    var needsUnit = !devPropertiesWithUnitsRegExp.test(propName);\n    var isNumberWithoutUnit = numberOnlyRe.test(value);\n\n    if (needsUnit && isNumberWithoutUnit) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Expected style \\\"\" + propName + \": \" + value + \"\\\" to contain units\");\n    }\n\n    if (!needsUnit && value !== '0' && !isNumberWithoutUnit) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Expected style \\\"\" + propName + \": \" + value + \"\\\" to be unitless\");\n    }\n  }\n\n  var numberMatch = value.match(numberOrLengthRe);\n  if (numberMatch !== null) return Number(numberMatch[1]);\n  var boolMatch = value.match(boolRe);\n  if (boolMatch !== null) return boolMatch[0].toLowerCase() === 'true';\n  var nullMatch = value.match(nullRe);\n  if (nullMatch !== null) return null;\n  var undefinedMatch = value.match(undefinedRe);\n  if (undefinedMatch !== null) return undefined;\n  return value;\n};\n\nvar baseTransformShorthandValue = function baseTransformShorthandValue(propName, value) {\n  var ast = parse__default(value);\n  var tokenStream = new TokenStream(ast.nodes);\n  return transforms[propName](tokenStream);\n};\n\nvar transformShorthandValue =  false ? 0 : function (propName, value) {\n  try {\n    return baseTransformShorthandValue(propName, value);\n  } catch (e) {\n    throw new Error(\"Failed to parse declaration \\\"\" + propName + \": \" + value + \"\\\"\");\n  }\n};\n\nvar getStylesForProperty = function getStylesForProperty(propName, inputValue, allowShorthand) {\n  var _ref6;\n\n  var isRawValue = allowShorthand === false || !(propName in transforms);\n  var value = inputValue.trim();\n  var propValues = isRawValue ? (_ref6 = {}, _ref6[propName] = transformRawValue(propName, value), _ref6) : transformShorthandValue(propName, value);\n  return propValues;\n};\n\nvar getPropertyName = function getPropertyName(propName) {\n  var isCustomProp = /^--\\w+/.test(propName);\n\n  if (isCustomProp) {\n    return propName;\n  }\n\n  return camelizeStyleName(propName);\n};\n\nvar index = function index(rules, shorthandBlacklist) {\n  if (shorthandBlacklist === void 0) {\n    shorthandBlacklist = [];\n  }\n\n  return rules.reduce(function (accum, rule) {\n    var propertyName = getPropertyName(rule[0]);\n    var value = rule[1];\n    var allowShorthand = shorthandBlacklist.indexOf(propertyName) === -1;\n    return Object.assign(accum, getStylesForProperty(propertyName, value, allowShorthand));\n  }, {});\n};\n\nexports[\"default\"] = index;\nexports.getPropertyName = getPropertyName;\nexports.getStylesForProperty = getStylesForProperty;\nexports.transformRawValue = transformRawValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL2Nzcy10by1yZWFjdC1uYXRpdmUvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsMkZBQXNCOztBQUUxQzs7QUFFQSx3Q0FBd0MsbUJBQU8sQ0FBQywrREFBVTs7QUFFMUQsdUNBQXVDLG1CQUFPLENBQUMsbUZBQW9COztBQUVuRTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUNBQWlDLElBQUksRUFBRSxJQUFJO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUMsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQixrQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLCtCQUErQixVQUFVLGlCQUFpQixXQUFXLElBQUksV0FBVztBQUNwRjtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDJDQUEyQztBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixNQUFxQyxHQUFHLENBQTJCO0FBQ2pHO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3NzLXRvLXJlYWN0LW5hdGl2ZS9pbmRleC5qcz81MTJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdChleCkge1xuICByZXR1cm4gZXggJiYgdHlwZW9mIGV4ID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZXggPyBleFsnZGVmYXVsdCddIDogZXg7XG59XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJ3Bvc3Rjc3MtdmFsdWUtcGFyc2VyJyk7XG5cbnZhciBwYXJzZV9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChwYXJzZSk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdjYW1lbGl6ZScpKTtcblxudmFyIGNzc0NvbG9yS2V5d29yZHMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnY3NzLWNvbG9yLWtleXdvcmRzJykpO1xuXG52YXIgbWF0Y2hTdHJpbmcgPSBmdW5jdGlvbiBtYXRjaFN0cmluZyhub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgIT09ICdzdHJpbmcnKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIG5vZGUudmFsdWUucmVwbGFjZSgvXFxcXChbMC05YS1mXXsxLDZ9KSg/Olxcc3wkKS9naSwgZnVuY3Rpb24gKG1hdGNoLCBjaGFyQ29kZSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNoYXJDb2RlLCAxNikpO1xuICB9KS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbn07XG5cbnZhciBoZXhDb2xvclJlID0gL14oIyg/OlswLTlhLWZdezMsNH0pezEsMn0pJC9pO1xudmFyIGNzc0Z1bmN0aW9uTmFtZVJlID0gL14ocmdiYT98aHNsYT98aHdifGxhYnxsY2h8Z3JheXxjb2xvcikkLztcblxudmFyIG1hdGNoQ29sb3IgPSBmdW5jdGlvbiBtYXRjaENvbG9yKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3dvcmQnICYmIChoZXhDb2xvclJlLnRlc3Qobm9kZS52YWx1ZSkgfHwgbm9kZS52YWx1ZSBpbiBjc3NDb2xvcktleXdvcmRzIHx8IG5vZGUudmFsdWUgPT09ICd0cmFuc3BhcmVudCcpKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnZnVuY3Rpb24nICYmIGNzc0Z1bmN0aW9uTmFtZVJlLnRlc3Qobm9kZS52YWx1ZSkpIHtcbiAgICByZXR1cm4gcGFyc2Uuc3RyaW5naWZ5KG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgbm9uZVJlID0gL14obm9uZSkkL2k7XG52YXIgYXV0b1JlID0gL14oYXV0bykkL2k7XG52YXIgaWRlbnRSZSA9IC8oXi0/W19hLXpdW19hLXowLTktXSokKS9pOyAvLyBOb3RlIGlmIHRoZXNlIGFyZSB3cm9uZywgeW91J2xsIG5lZWQgdG8gY2hhbmdlIGluZGV4LmpzIHRvb1xuXG52YXIgbnVtYmVyUmUgPSAvXihbKy1dPyg/OlxcZCpcXC4pP1xcZCsoPzplWystXT9cXGQrKT8pJC9pOyAvLyBOb3RlIGxlbmd0aFJlIGlzIHNuZWFreTogeW91IGNhbiBvbWl0IHVuaXRzIGZvciAwXG5cbnZhciBsZW5ndGhSZSA9IC9eKDAkfCg/OlsrLV0/KD86XFxkKlxcLik/XFxkKyg/OmVbKy1dP1xcZCspPykoPz1weCQpKS9pO1xudmFyIHVuc3VwcG9ydGVkVW5pdFJlID0gL14oWystXT8oPzpcXGQqXFwuKT9cXGQrKD86ZVsrLV0/XFxkKyk/KGNofGVtfGV4fHJlbXx2aHx2d3x2bWlufHZtYXh8Y218bW18aW58cGN8cHQpKSQvaTtcbnZhciBhbmdsZVJlID0gL14oWystXT8oPzpcXGQqXFwuKT9cXGQrKD86ZVsrLV0/XFxkKyk/KD86ZGVnfHJhZCkpJC9pO1xudmFyIHBlcmNlbnRSZSA9IC9eKFsrLV0/KD86XFxkKlxcLik/XFxkKyg/OmVbKy1dP1xcZCspPyUpJC9pO1xuXG52YXIgbm9vcFRva2VuID0gZnVuY3Rpb24gbm9vcFRva2VuKHByZWRpY2F0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlKG5vZGUpID8gJzx0b2tlbj4nIDogbnVsbDtcbiAgfTtcbn07XG5cbnZhciB2YWx1ZUZvclR5cGVUb2tlbiA9IGZ1bmN0aW9uIHZhbHVlRm9yVHlwZVRva2VuKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gdHlwZSA/IG5vZGUudmFsdWUgOiBudWxsO1xuICB9O1xufTtcblxudmFyIHJlZ0V4cFRva2VuID0gZnVuY3Rpb24gcmVnRXhwVG9rZW4ocmVnRXhwLCB0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNmb3JtID0gU3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ3dvcmQnKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgbWF0Y2ggPSBub2RlLnZhbHVlLm1hdGNoKHJlZ0V4cCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm0obWF0Y2hbMV0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG5cbnZhciBTUEFDRSA9IG5vb3BUb2tlbihmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSAnc3BhY2UnO1xufSk7XG52YXIgU0xBU0ggPSBub29wVG9rZW4oZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2RpdicgJiYgbm9kZS52YWx1ZSA9PT0gJy8nO1xufSk7XG52YXIgQ09NTUEgPSBub29wVG9rZW4oZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2RpdicgJiYgbm9kZS52YWx1ZSA9PT0gJywnO1xufSk7XG52YXIgV09SRCA9IHZhbHVlRm9yVHlwZVRva2VuKCd3b3JkJyk7XG52YXIgTk9ORSA9IHJlZ0V4cFRva2VuKG5vbmVSZSk7XG52YXIgQVVUTyA9IHJlZ0V4cFRva2VuKGF1dG9SZSk7XG52YXIgTlVNQkVSID0gcmVnRXhwVG9rZW4obnVtYmVyUmUsIE51bWJlcik7XG52YXIgTEVOR1RIID0gcmVnRXhwVG9rZW4obGVuZ3RoUmUsIE51bWJlcik7XG52YXIgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQgPSByZWdFeHBUb2tlbih1bnN1cHBvcnRlZFVuaXRSZSk7XG52YXIgQU5HTEUgPSByZWdFeHBUb2tlbihhbmdsZVJlLCBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgcmV0dXJuIGFuZ2xlLnRvTG93ZXJDYXNlKCk7XG59KTtcbnZhciBQRVJDRU5UID0gcmVnRXhwVG9rZW4ocGVyY2VudFJlKTtcbnZhciBJREVOVCA9IHJlZ0V4cFRva2VuKGlkZW50UmUpO1xudmFyIFNUUklORyA9IG1hdGNoU3RyaW5nO1xudmFyIENPTE9SID0gbWF0Y2hDb2xvcjtcbnZhciBMSU5FID0gcmVnRXhwVG9rZW4oL14obm9uZXx1bmRlcmxpbmV8bGluZS10aHJvdWdoKSQvaSk7XG52YXIgQk9SREVSX1NUWUxFID0gcmVnRXhwVG9rZW4oL14oc29saWR8ZGFzaGVkfGRvdHRlZCkkLyk7XG52YXIgZGVmYXVsdEJvcmRlcldpZHRoID0gMTtcbnZhciBkZWZhdWx0Qm9yZGVyQ29sb3IgPSAnYmxhY2snO1xudmFyIGRlZmF1bHRCb3JkZXJTdHlsZSA9ICdzb2xpZCc7XG5cbnZhciBib3JkZXIgPSBmdW5jdGlvbiBib3JkZXIodG9rZW5TdHJlYW0pIHtcbiAgdmFyIGJvcmRlcldpZHRoO1xuICB2YXIgYm9yZGVyQ29sb3I7XG4gIHZhciBib3JkZXJTdHlsZTtcblxuICBpZiAodG9rZW5TdHJlYW0ubWF0Y2hlcyhOT05FKSkge1xuICAgIHRva2VuU3RyZWFtLmV4cGVjdEVtcHR5KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgYm9yZGVyQ29sb3I6ICdibGFjaycsXG4gICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJ1xuICAgIH07XG4gIH1cblxuICB2YXIgcGFydHNQYXJzZWQgPSAwO1xuXG4gIHdoaWxlIChwYXJ0c1BhcnNlZCA8IDMgJiYgdG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICBpZiAocGFydHNQYXJzZWQgIT09IDApIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG5cbiAgICBpZiAoYm9yZGVyV2lkdGggPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKExFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQpKSB7XG4gICAgICBib3JkZXJXaWR0aCA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGJvcmRlckNvbG9yID09PSB1bmRlZmluZWQgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhDT0xPUikpIHtcbiAgICAgIGJvcmRlckNvbG9yID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoYm9yZGVyU3R5bGUgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKEJPUkRFUl9TVFlMRSkpIHtcbiAgICAgIGJvcmRlclN0eWxlID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlblN0cmVhbVtcInRocm93XCJdKCk7XG4gICAgfVxuXG4gICAgcGFydHNQYXJzZWQgKz0gMTtcbiAgfVxuXG4gIHRva2VuU3RyZWFtLmV4cGVjdEVtcHR5KCk7XG4gIGlmIChib3JkZXJXaWR0aCA9PT0gdW5kZWZpbmVkKSBib3JkZXJXaWR0aCA9IGRlZmF1bHRCb3JkZXJXaWR0aDtcbiAgaWYgKGJvcmRlckNvbG9yID09PSB1bmRlZmluZWQpIGJvcmRlckNvbG9yID0gZGVmYXVsdEJvcmRlckNvbG9yO1xuICBpZiAoYm9yZGVyU3R5bGUgPT09IHVuZGVmaW5lZCkgYm9yZGVyU3R5bGUgPSBkZWZhdWx0Qm9yZGVyU3R5bGU7XG4gIHJldHVybiB7XG4gICAgYm9yZGVyV2lkdGg6IGJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvcixcbiAgICBib3JkZXJTdHlsZTogYm9yZGVyU3R5bGVcbiAgfTtcbn07XG5cbnZhciBkaXJlY3Rpb25GYWN0b3J5ID0gZnVuY3Rpb24gZGlyZWN0aW9uRmFjdG9yeShfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGVzID0gX3JlZi50eXBlcyxcbiAgICAgIHR5cGVzID0gX3JlZiR0eXBlcyA9PT0gdm9pZCAwID8gW0xFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQsIFBFUkNFTlRdIDogX3JlZiR0eXBlcyxcbiAgICAgIF9yZWYkZGlyZWN0aW9ucyA9IF9yZWYuZGlyZWN0aW9ucyxcbiAgICAgIGRpcmVjdGlvbnMgPSBfcmVmJGRpcmVjdGlvbnMgPT09IHZvaWQgMCA/IFsnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdMZWZ0J10gOiBfcmVmJGRpcmVjdGlvbnMsXG4gICAgICBfcmVmJHByZWZpeCA9IF9yZWYucHJlZml4LFxuICAgICAgcHJlZml4ID0gX3JlZiRwcmVmaXggPT09IHZvaWQgMCA/ICcnIDogX3JlZiRwcmVmaXgsXG4gICAgICBfcmVmJHN1ZmZpeCA9IF9yZWYuc3VmZml4LFxuICAgICAgc3VmZml4ID0gX3JlZiRzdWZmaXggPT09IHZvaWQgMCA/ICcnIDogX3JlZiRzdWZmaXg7XG4gIHJldHVybiBmdW5jdGlvbiAodG9rZW5TdHJlYW0pIHtcbiAgICB2YXIgX3JlZjI7XG5cbiAgICB2YXIgdmFsdWVzID0gW107IC8vIGJvcmRlcldpZHRoIGRvZXNuJ3QgY3VycmVudGx5IGFsbG93IGEgcGVyY2VudCB2YWx1ZSwgYnV0IG1heSBkbyBpbiB0aGUgZnV0dXJlXG5cbiAgICB2YWx1ZXMucHVzaCh0b2tlblN0cmVhbS5leHBlY3QuYXBwbHkodG9rZW5TdHJlYW0sIHR5cGVzKSk7XG5cbiAgICB3aGlsZSAodmFsdWVzLmxlbmd0aCA8IDQgJiYgdG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICAgIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG4gICAgICB2YWx1ZXMucHVzaCh0b2tlblN0cmVhbS5leHBlY3QuYXBwbHkodG9rZW5TdHJlYW0sIHR5cGVzKSk7XG4gICAgfVxuXG4gICAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgICB2YXIgdG9wID0gdmFsdWVzWzBdLFxuICAgICAgICBfdmFsdWVzJCA9IHZhbHVlc1sxXSxcbiAgICAgICAgcmlnaHQgPSBfdmFsdWVzJCA9PT0gdm9pZCAwID8gdG9wIDogX3ZhbHVlcyQsXG4gICAgICAgIF92YWx1ZXMkMiA9IHZhbHVlc1syXSxcbiAgICAgICAgYm90dG9tID0gX3ZhbHVlcyQyID09PSB2b2lkIDAgPyB0b3AgOiBfdmFsdWVzJDIsXG4gICAgICAgIF92YWx1ZXMkMyA9IHZhbHVlc1szXSxcbiAgICAgICAgbGVmdCA9IF92YWx1ZXMkMyA9PT0gdm9pZCAwID8gcmlnaHQgOiBfdmFsdWVzJDM7XG5cbiAgICB2YXIga2V5Rm9yID0gZnVuY3Rpb24ga2V5Rm9yKG4pIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgZGlyZWN0aW9uc1tuXSArIHN1ZmZpeDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW2tleUZvcigwKV0gPSB0b3AsIF9yZWYyW2tleUZvcigxKV0gPSByaWdodCwgX3JlZjJba2V5Rm9yKDIpXSA9IGJvdHRvbSwgX3JlZjJba2V5Rm9yKDMpXSA9IGxlZnQsIF9yZWYyO1xuICB9O1xufTtcblxudmFyIHBhcnNlU2hhZG93T2Zmc2V0ID0gZnVuY3Rpb24gcGFyc2VTaGFkb3dPZmZzZXQodG9rZW5TdHJlYW0pIHtcbiAgdmFyIHdpZHRoID0gdG9rZW5TdHJlYW0uZXhwZWN0KExFTkdUSCk7XG4gIHZhciBoZWlnaHQgPSB0b2tlblN0cmVhbS5tYXRjaGVzKFNQQUNFKSA/IHRva2VuU3RyZWFtLmV4cGVjdChMRU5HVEgpIDogd2lkdGg7XG4gIHRva2VuU3RyZWFtLmV4cGVjdEVtcHR5KCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59O1xuXG52YXIgcGFyc2VTaGFkb3cgPSBmdW5jdGlvbiBwYXJzZVNoYWRvdyh0b2tlblN0cmVhbSkge1xuICB2YXIgb2Zmc2V0WDtcbiAgdmFyIG9mZnNldFk7XG4gIHZhciByYWRpdXM7XG4gIHZhciBjb2xvcjtcblxuICBpZiAodG9rZW5TdHJlYW0ubWF0Y2hlcyhOT05FKSkge1xuICAgIHRva2VuU3RyZWFtLmV4cGVjdEVtcHR5KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LFxuICAgICAgcmFkaXVzOiAwLFxuICAgICAgY29sb3I6ICdibGFjaydcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRpZFBhcnNlRmlyc3QgPSBmYWxzZTtcblxuICB3aGlsZSAodG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICBpZiAoZGlkUGFyc2VGaXJzdCkgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcblxuICAgIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhMRU5HVEgsIFVOU1VQUE9SVEVEX0xFTkdUSF9VTklUKSkge1xuICAgICAgb2Zmc2V0WCA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgICAgIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG4gICAgICBvZmZzZXRZID0gdG9rZW5TdHJlYW0uZXhwZWN0KExFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQpO1xuICAgICAgdG9rZW5TdHJlYW0uc2F2ZVJld2luZFBvaW50KCk7XG5cbiAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaGVzKFNQQUNFKSAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKExFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQpKSB7XG4gICAgICAgIHJhZGl1cyA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuU3RyZWFtLnJld2luZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKENPTE9SKSkge1xuICAgICAgY29sb3IgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuU3RyZWFtW1widGhyb3dcIl0oKTtcbiAgICB9XG5cbiAgICBkaWRQYXJzZUZpcnN0ID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvZmZzZXRYID09PSB1bmRlZmluZWQpIHRva2VuU3RyZWFtW1widGhyb3dcIl0oKTtcbiAgcmV0dXJuIHtcbiAgICBvZmZzZXQ6IHtcbiAgICAgIHdpZHRoOiBvZmZzZXRYLFxuICAgICAgaGVpZ2h0OiBvZmZzZXRZXG4gICAgfSxcbiAgICByYWRpdXM6IHJhZGl1cyAhPT0gdW5kZWZpbmVkID8gcmFkaXVzIDogMCxcbiAgICBjb2xvcjogY29sb3IgIT09IHVuZGVmaW5lZCA/IGNvbG9yIDogJ2JsYWNrJ1xuICB9O1xufTtcblxudmFyIGJveFNoYWRvdyA9IGZ1bmN0aW9uIGJveFNoYWRvdyh0b2tlblN0cmVhbSkge1xuICB2YXIgX3BhcnNlU2hhZG93ID0gcGFyc2VTaGFkb3codG9rZW5TdHJlYW0pLFxuICAgICAgb2Zmc2V0ID0gX3BhcnNlU2hhZG93Lm9mZnNldCxcbiAgICAgIHJhZGl1cyA9IF9wYXJzZVNoYWRvdy5yYWRpdXMsXG4gICAgICBjb2xvciA9IF9wYXJzZVNoYWRvdy5jb2xvcjtcblxuICByZXR1cm4ge1xuICAgIHNoYWRvd09mZnNldDogb2Zmc2V0LFxuICAgIHNoYWRvd1JhZGl1czogcmFkaXVzLFxuICAgIHNoYWRvd0NvbG9yOiBjb2xvcixcbiAgICBzaGFkb3dPcGFjaXR5OiAxXG4gIH07XG59O1xuXG52YXIgZGVmYXVsdEZsZXhHcm93ID0gMTtcbnZhciBkZWZhdWx0RmxleFNocmluayA9IDE7XG52YXIgZGVmYXVsdEZsZXhCYXNpcyA9IDA7XG5cbnZhciBmbGV4ID0gZnVuY3Rpb24gZmxleCh0b2tlblN0cmVhbSkge1xuICB2YXIgZmxleEdyb3c7XG4gIHZhciBmbGV4U2hyaW5rO1xuICB2YXIgZmxleEJhc2lzO1xuXG4gIGlmICh0b2tlblN0cmVhbS5tYXRjaGVzKE5PTkUpKSB7XG4gICAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmxleEdyb3c6IDAsXG4gICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgZmxleEJhc2lzOiAnYXV0bydcbiAgICB9O1xuICB9XG5cbiAgdG9rZW5TdHJlYW0uc2F2ZVJld2luZFBvaW50KCk7XG5cbiAgaWYgKHRva2VuU3RyZWFtLm1hdGNoZXMoQVVUTykgJiYgIXRva2VuU3RyZWFtLmhhc1Rva2VucygpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZsZXhHcm93OiAxLFxuICAgICAgZmxleFNocmluazogMSxcbiAgICAgIGZsZXhCYXNpczogJ2F1dG8nXG4gICAgfTtcbiAgfVxuXG4gIHRva2VuU3RyZWFtLnJld2luZCgpO1xuICB2YXIgcGFydHNQYXJzZWQgPSAwO1xuXG4gIHdoaWxlIChwYXJ0c1BhcnNlZCA8IDIgJiYgdG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICBpZiAocGFydHNQYXJzZWQgIT09IDApIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG5cbiAgICBpZiAoZmxleEdyb3cgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKE5VTUJFUikpIHtcbiAgICAgIGZsZXhHcm93ID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgICAgdG9rZW5TdHJlYW0uc2F2ZVJld2luZFBvaW50KCk7XG5cbiAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaGVzKFNQQUNFKSAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKE5VTUJFUikpIHtcbiAgICAgICAgZmxleFNocmluayA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuU3RyZWFtLnJld2luZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmxleEJhc2lzID09PSB1bmRlZmluZWQgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhMRU5HVEgsIFVOU1VQUE9SVEVEX0xFTkdUSF9VTklULCBQRVJDRU5UKSkge1xuICAgICAgZmxleEJhc2lzID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZmxleEJhc2lzID09PSB1bmRlZmluZWQgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhBVVRPKSkge1xuICAgICAgZmxleEJhc2lzID0gJ2F1dG8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlblN0cmVhbVtcInRocm93XCJdKCk7XG4gICAgfVxuXG4gICAgcGFydHNQYXJzZWQgKz0gMTtcbiAgfVxuXG4gIHRva2VuU3RyZWFtLmV4cGVjdEVtcHR5KCk7XG4gIGlmIChmbGV4R3JvdyA9PT0gdW5kZWZpbmVkKSBmbGV4R3JvdyA9IGRlZmF1bHRGbGV4R3JvdztcbiAgaWYgKGZsZXhTaHJpbmsgPT09IHVuZGVmaW5lZCkgZmxleFNocmluayA9IGRlZmF1bHRGbGV4U2hyaW5rO1xuICBpZiAoZmxleEJhc2lzID09PSB1bmRlZmluZWQpIGZsZXhCYXNpcyA9IGRlZmF1bHRGbGV4QmFzaXM7XG4gIHJldHVybiB7XG4gICAgZmxleEdyb3c6IGZsZXhHcm93LFxuICAgIGZsZXhTaHJpbms6IGZsZXhTaHJpbmssXG4gICAgZmxleEJhc2lzOiBmbGV4QmFzaXNcbiAgfTtcbn07XG5cbnZhciBGTEVYX1dSQVAgPSByZWdFeHBUb2tlbigvKG5vd3JhcHx3cmFwfHdyYXAtcmV2ZXJzZSkvKTtcbnZhciBGTEVYX0RJUkVDVElPTiA9IHJlZ0V4cFRva2VuKC8ocm93fHJvdy1yZXZlcnNlfGNvbHVtbnxjb2x1bW4tcmV2ZXJzZSkvKTtcbnZhciBkZWZhdWx0RmxleFdyYXAgPSAnbm93cmFwJztcbnZhciBkZWZhdWx0RmxleERpcmVjdGlvbiA9ICdyb3cnO1xuXG52YXIgZmxleEZsb3cgPSBmdW5jdGlvbiBmbGV4Rmxvdyh0b2tlblN0cmVhbSkge1xuICB2YXIgZmxleFdyYXA7XG4gIHZhciBmbGV4RGlyZWN0aW9uO1xuICB2YXIgcGFydHNQYXJzZWQgPSAwO1xuXG4gIHdoaWxlIChwYXJ0c1BhcnNlZCA8IDIgJiYgdG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICBpZiAocGFydHNQYXJzZWQgIT09IDApIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG5cbiAgICBpZiAoZmxleFdyYXAgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKEZMRVhfV1JBUCkpIHtcbiAgICAgIGZsZXhXcmFwID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZmxleERpcmVjdGlvbiA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoRkxFWF9ESVJFQ1RJT04pKSB7XG4gICAgICBmbGV4RGlyZWN0aW9uID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlblN0cmVhbVtcInRocm93XCJdKCk7XG4gICAgfVxuXG4gICAgcGFydHNQYXJzZWQgKz0gMTtcbiAgfVxuXG4gIHRva2VuU3RyZWFtLmV4cGVjdEVtcHR5KCk7XG4gIGlmIChmbGV4V3JhcCA9PT0gdW5kZWZpbmVkKSBmbGV4V3JhcCA9IGRlZmF1bHRGbGV4V3JhcDtcbiAgaWYgKGZsZXhEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkgZmxleERpcmVjdGlvbiA9IGRlZmF1bHRGbGV4RGlyZWN0aW9uO1xuICByZXR1cm4ge1xuICAgIGZsZXhXcmFwOiBmbGV4V3JhcCxcbiAgICBmbGV4RGlyZWN0aW9uOiBmbGV4RGlyZWN0aW9uXG4gIH07XG59O1xuXG52YXIgZm9udEZhbWlseSA9IGZ1bmN0aW9uIGZvbnRGYW1pbHkodG9rZW5TdHJlYW0pIHtcbiAgdmFyIGZvbnRGYW1pbHk7XG5cbiAgaWYgKHRva2VuU3RyZWFtLm1hdGNoZXMoU1RSSU5HKSkge1xuICAgIGZvbnRGYW1pbHkgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgZm9udEZhbWlseSA9IHRva2VuU3RyZWFtLmV4cGVjdChJREVOVCk7XG5cbiAgICB3aGlsZSAodG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICAgIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG4gICAgICB2YXIgbmV4dElkZW50ID0gdG9rZW5TdHJlYW0uZXhwZWN0KElERU5UKTtcbiAgICAgIGZvbnRGYW1pbHkgKz0gXCIgXCIgKyBuZXh0SWRlbnQ7XG4gICAgfVxuICB9XG5cbiAgdG9rZW5TdHJlYW0uZXhwZWN0RW1wdHkoKTtcbiAgcmV0dXJuIHtcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5XG4gIH07XG59O1xuXG52YXIgTk9STUFMID0gcmVnRXhwVG9rZW4oL14obm9ybWFsKSQvKTtcbnZhciBTVFlMRSA9IHJlZ0V4cFRva2VuKC9eKGl0YWxpYykkLyk7XG52YXIgV0VJR0hUID0gcmVnRXhwVG9rZW4oL14oWzEtOV0wMHxib2xkKSQvKTtcbnZhciBWQVJJQU5UID0gcmVnRXhwVG9rZW4oL14oc21hbGwtY2FwcykkLyk7XG52YXIgZGVmYXVsdEZvbnRTdHlsZSA9ICdub3JtYWwnO1xudmFyIGRlZmF1bHRGb250V2VpZ2h0ID0gJ25vcm1hbCc7XG52YXIgZGVmYXVsdEZvbnRWYXJpYW50ID0gW107XG5cbnZhciBmb250ID0gZnVuY3Rpb24gZm9udCh0b2tlblN0cmVhbSkge1xuICB2YXIgZm9udFN0eWxlO1xuICB2YXIgZm9udFdlaWdodDtcbiAgdmFyIGZvbnRWYXJpYW50OyAvLyBsZXQgZm9udFNpemU7XG5cbiAgdmFyIGxpbmVIZWlnaHQ7IC8vIGxldCBmb250RmFtaWx5O1xuXG4gIHZhciBudW1TdHlsZVdlaWdodFZhcmlhbnRNYXRjaGVkID0gMDtcblxuICB3aGlsZSAobnVtU3R5bGVXZWlnaHRWYXJpYW50TWF0Y2hlZCA8IDMgJiYgdG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2hlcyhOT1JNQUwpKSA7ZWxzZSBpZiAoZm9udFN0eWxlID09PSB1bmRlZmluZWQgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhTVFlMRSkpIHtcbiAgICAgIGZvbnRTdHlsZSA9IHRva2VuU3RyZWFtLmxhc3RWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGZvbnRXZWlnaHQgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKFdFSUdIVCkpIHtcbiAgICAgIGZvbnRXZWlnaHQgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChmb250VmFyaWFudCA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoVkFSSUFOVCkpIHtcbiAgICAgIGZvbnRWYXJpYW50ID0gW3Rva2VuU3RyZWFtLmxhc3RWYWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0b2tlblN0cmVhbS5leHBlY3QoU1BBQ0UpO1xuICAgIG51bVN0eWxlV2VpZ2h0VmFyaWFudE1hdGNoZWQgKz0gMTtcbiAgfVxuXG4gIHZhciBmb250U2l6ZSA9IHRva2VuU3RyZWFtLmV4cGVjdChMRU5HVEgsIFVOU1VQUE9SVEVEX0xFTkdUSF9VTklUKTtcblxuICBpZiAodG9rZW5TdHJlYW0ubWF0Y2hlcyhTTEFTSCkpIHtcbiAgICBsaW5lSGVpZ2h0ID0gdG9rZW5TdHJlYW0uZXhwZWN0KExFTkdUSCwgVU5TVVBQT1JURURfTEVOR1RIX1VOSVQpO1xuICB9XG5cbiAgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcblxuICB2YXIgX2ZvbnRGYW1pbHkgPSBmb250RmFtaWx5KHRva2VuU3RyZWFtKSxcbiAgICAgIGZvbnRGYW1pbHkkMSA9IF9mb250RmFtaWx5LmZvbnRGYW1pbHk7XG5cbiAgaWYgKGZvbnRTdHlsZSA9PT0gdW5kZWZpbmVkKSBmb250U3R5bGUgPSBkZWZhdWx0Rm9udFN0eWxlO1xuICBpZiAoZm9udFdlaWdodCA9PT0gdW5kZWZpbmVkKSBmb250V2VpZ2h0ID0gZGVmYXVsdEZvbnRXZWlnaHQ7XG4gIGlmIChmb250VmFyaWFudCA9PT0gdW5kZWZpbmVkKSBmb250VmFyaWFudCA9IGRlZmF1bHRGb250VmFyaWFudDtcbiAgdmFyIG91dCA9IHtcbiAgICBmb250U3R5bGU6IGZvbnRTdHlsZSxcbiAgICBmb250V2VpZ2h0OiBmb250V2VpZ2h0LFxuICAgIGZvbnRWYXJpYW50OiBmb250VmFyaWFudCxcbiAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseSQxXG4gIH07XG4gIGlmIChsaW5lSGVpZ2h0ICE9PSB1bmRlZmluZWQpIG91dC5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBBTElHTl9DT05URU5UID0gcmVnRXhwVG9rZW4oLyhmbGV4LSg/OnN0YXJ0fGVuZCl8Y2VudGVyfHN0cmV0Y2h8c3BhY2UtKD86YmV0d2Vlbnxhcm91bmQpKS8pO1xudmFyIEpVU1RJRllfQ09OVEVOVCA9IHJlZ0V4cFRva2VuKC8oZmxleC0oPzpzdGFydHxlbmQpfGNlbnRlcnxzcGFjZS0oPzpiZXR3ZWVufGFyb3VuZHxldmVubHkpKS8pO1xuXG52YXIgcGxhY2VDb250ZW50ID0gZnVuY3Rpb24gcGxhY2VDb250ZW50KHRva2VuU3RyZWFtKSB7XG4gIHZhciBhbGlnbkNvbnRlbnQgPSB0b2tlblN0cmVhbS5leHBlY3QoQUxJR05fQ09OVEVOVCk7XG4gIHZhciBqdXN0aWZ5Q29udGVudDtcblxuICBpZiAodG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICB0b2tlblN0cmVhbS5leHBlY3QoU1BBQ0UpO1xuICAgIGp1c3RpZnlDb250ZW50ID0gdG9rZW5TdHJlYW0uZXhwZWN0KEpVU1RJRllfQ09OVEVOVCk7XG4gIH0gZWxzZSB7XG4gICAganVzdGlmeUNvbnRlbnQgPSAnc3RyZXRjaCc7XG4gIH1cblxuICB0b2tlblN0cmVhbS5leHBlY3RFbXB0eSgpO1xuICByZXR1cm4ge1xuICAgIGFsaWduQ29udGVudDogYWxpZ25Db250ZW50LFxuICAgIGp1c3RpZnlDb250ZW50OiBqdXN0aWZ5Q29udGVudFxuICB9O1xufTtcblxudmFyIFNUWUxFJDEgPSByZWdFeHBUb2tlbigvXihzb2xpZHxkb3VibGV8ZG90dGVkfGRhc2hlZCkkLyk7XG52YXIgZGVmYXVsdFRleHREZWNvcmF0aW9uTGluZSA9ICdub25lJztcbnZhciBkZWZhdWx0VGV4dERlY29yYXRpb25TdHlsZSA9ICdzb2xpZCc7XG52YXIgZGVmYXVsdFRleHREZWNvcmF0aW9uQ29sb3IgPSAnYmxhY2snO1xuXG52YXIgdGV4dERlY29yYXRpb24gPSBmdW5jdGlvbiB0ZXh0RGVjb3JhdGlvbih0b2tlblN0cmVhbSkge1xuICB2YXIgbGluZTtcbiAgdmFyIHN0eWxlO1xuICB2YXIgY29sb3I7XG4gIHZhciBkaWRQYXJzZUZpcnN0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRva2VuU3RyZWFtLmhhc1Rva2VucygpKSB7XG4gICAgaWYgKGRpZFBhcnNlRmlyc3QpIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG5cbiAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoTElORSkpIHtcbiAgICAgIHZhciBsaW5lcyA9IFt0b2tlblN0cmVhbS5sYXN0VmFsdWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB0b2tlblN0cmVhbS5zYXZlUmV3aW5kUG9pbnQoKTtcblxuICAgICAgaWYgKGxpbmVzWzBdICE9PSAnbm9uZScgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhTUEFDRSkgJiYgdG9rZW5TdHJlYW0ubWF0Y2hlcyhMSU5FKSkge1xuICAgICAgICBsaW5lcy5wdXNoKHRva2VuU3RyZWFtLmxhc3RWYWx1ZS50b0xvd2VyQ2FzZSgpKTsgLy8gVW5kZXJsaW5lIGNvbWVzIGJlZm9yZSBsaW5lLXRocm91Z2hcblxuICAgICAgICBsaW5lcy5zb3J0KCkucmV2ZXJzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5TdHJlYW0ucmV3aW5kKCk7XG4gICAgICB9XG5cbiAgICAgIGxpbmUgPSBsaW5lcy5qb2luKCcgJyk7XG4gICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gdW5kZWZpbmVkICYmIHRva2VuU3RyZWFtLm1hdGNoZXMoU1RZTEUkMSkpIHtcbiAgICAgIHN0eWxlID0gdG9rZW5TdHJlYW0ubGFzdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCAmJiB0b2tlblN0cmVhbS5tYXRjaGVzKENPTE9SKSkge1xuICAgICAgY29sb3IgPSB0b2tlblN0cmVhbS5sYXN0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuU3RyZWFtW1widGhyb3dcIl0oKTtcbiAgICB9XG5cbiAgICBkaWRQYXJzZUZpcnN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGV4dERlY29yYXRpb25MaW5lOiBsaW5lICE9PSB1bmRlZmluZWQgPyBsaW5lIDogZGVmYXVsdFRleHREZWNvcmF0aW9uTGluZSxcbiAgICB0ZXh0RGVjb3JhdGlvbkNvbG9yOiBjb2xvciAhPT0gdW5kZWZpbmVkID8gY29sb3IgOiBkZWZhdWx0VGV4dERlY29yYXRpb25Db2xvcixcbiAgICB0ZXh0RGVjb3JhdGlvblN0eWxlOiBzdHlsZSAhPT0gdW5kZWZpbmVkID8gc3R5bGUgOiBkZWZhdWx0VGV4dERlY29yYXRpb25TdHlsZVxuICB9O1xufTtcblxudmFyIHRleHREZWNvcmF0aW9uTGluZSA9IGZ1bmN0aW9uIHRleHREZWNvcmF0aW9uTGluZSh0b2tlblN0cmVhbSkge1xuICB2YXIgbGluZXMgPSBbXTtcbiAgdmFyIGRpZFBhcnNlRmlyc3QgPSBmYWxzZTtcblxuICB3aGlsZSAodG9rZW5TdHJlYW0uaGFzVG9rZW5zKCkpIHtcbiAgICBpZiAoZGlkUGFyc2VGaXJzdCkgdG9rZW5TdHJlYW0uZXhwZWN0KFNQQUNFKTtcbiAgICBsaW5lcy5wdXNoKHRva2VuU3RyZWFtLmV4cGVjdChMSU5FKS50b0xvd2VyQ2FzZSgpKTtcbiAgICBkaWRQYXJzZUZpcnN0ID0gdHJ1ZTtcbiAgfVxuXG4gIGxpbmVzLnNvcnQoKS5yZXZlcnNlKCk7XG4gIHJldHVybiB7XG4gICAgdGV4dERlY29yYXRpb25MaW5lOiBsaW5lcy5qb2luKCcgJylcbiAgfTtcbn07XG5cbnZhciB0ZXh0U2hhZG93ID0gZnVuY3Rpb24gdGV4dFNoYWRvdyh0b2tlblN0cmVhbSkge1xuICB2YXIgX3BhcnNlU2hhZG93MiA9IHBhcnNlU2hhZG93KHRva2VuU3RyZWFtKSxcbiAgICAgIG9mZnNldCA9IF9wYXJzZVNoYWRvdzIub2Zmc2V0LFxuICAgICAgcmFkaXVzID0gX3BhcnNlU2hhZG93Mi5yYWRpdXMsXG4gICAgICBjb2xvciA9IF9wYXJzZVNoYWRvdzIuY29sb3I7XG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0U2hhZG93T2Zmc2V0OiBvZmZzZXQsXG4gICAgdGV4dFNoYWRvd1JhZGl1czogcmFkaXVzLFxuICAgIHRleHRTaGFkb3dDb2xvcjogY29sb3JcbiAgfTtcbn07XG5cbnZhciBvbmVPZlR5cGUgPSBmdW5jdGlvbiBvbmVPZlR5cGUodG9rZW5UeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZnVuY3Rpb25TdHJlYW0pIHtcbiAgICB2YXIgdmFsdWUgPSBmdW5jdGlvblN0cmVhbS5leHBlY3QodG9rZW5UeXBlKTtcbiAgICBmdW5jdGlvblN0cmVhbS5leHBlY3RFbXB0eSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG5cbnZhciBzaW5nbGVOdW1iZXIgPSBvbmVPZlR5cGUoTlVNQkVSKTtcbnZhciBzaW5nbGVMZW5ndGggPSBvbmVPZlR5cGUoTEVOR1RIKTtcbnZhciBzaW5nbGVBbmdsZSA9IG9uZU9mVHlwZShBTkdMRSk7XG5cbnZhciB4eVRyYW5zZm9ybUZhY3RvcnkgPSBmdW5jdGlvbiB4eVRyYW5zZm9ybUZhY3RvcnkodG9rZW5UeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZUlmT21pdHRlZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZnVuY3Rpb25TdHJlYW0pIHtcbiAgICAgIHZhciBfcmVmMywgX3JlZjQ7XG5cbiAgICAgIHZhciB4ID0gZnVuY3Rpb25TdHJlYW0uZXhwZWN0KHRva2VuVHlwZSk7XG4gICAgICB2YXIgeTtcblxuICAgICAgaWYgKGZ1bmN0aW9uU3RyZWFtLmhhc1Rva2VucygpKSB7XG4gICAgICAgIGZ1bmN0aW9uU3RyZWFtLmV4cGVjdChDT01NQSk7XG4gICAgICAgIHkgPSBmdW5jdGlvblN0cmVhbS5leHBlY3QodG9rZW5UeXBlKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWVJZk9taXR0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5ID0gdmFsdWVJZk9taXR0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBc3N1bXB0aW9uLCBpZiB4ID09PSB5LCB0aGVuIHdlIGNhbiBvbWl0IFhZXG4gICAgICAgIC8vIEkuZS4gc2NhbGUoNSkgPT4gW3sgc2NhbGU6IDUgfV0gcmF0aGVyIHRoYW4gW3sgc2NhbGVYOiA1IH0sIHsgc2NhbGVZOiA1IH1dXG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvblN0cmVhbS5leHBlY3RFbXB0eSgpO1xuICAgICAgcmV0dXJuIFsoX3JlZjMgPSB7fSwgX3JlZjNba2V5ICsgXCJZXCJdID0geSwgX3JlZjMpLCAoX3JlZjQgPSB7fSwgX3JlZjRba2V5ICsgXCJYXCJdID0geCwgX3JlZjQpXTtcbiAgICB9O1xuICB9O1xufTtcblxudmFyIHh5TnVtYmVyID0geHlUcmFuc2Zvcm1GYWN0b3J5KE5VTUJFUik7XG52YXIgeHlMZW5ndGggPSB4eVRyYW5zZm9ybUZhY3RvcnkoTEVOR1RIKTtcbnZhciB4eUFuZ2xlID0geHlUcmFuc2Zvcm1GYWN0b3J5KEFOR0xFKTtcbnZhciBwYXJ0VHJhbnNmb3JtcyA9IHtcbiAgcGVyc3BlY3RpdmU6IHNpbmdsZU51bWJlcixcbiAgc2NhbGU6IHh5TnVtYmVyKCdzY2FsZScpLFxuICBzY2FsZVg6IHNpbmdsZU51bWJlcixcbiAgc2NhbGVZOiBzaW5nbGVOdW1iZXIsXG4gIHRyYW5zbGF0ZTogeHlMZW5ndGgoJ3RyYW5zbGF0ZScsIDApLFxuICB0cmFuc2xhdGVYOiBzaW5nbGVMZW5ndGgsXG4gIHRyYW5zbGF0ZVk6IHNpbmdsZUxlbmd0aCxcbiAgcm90YXRlOiBzaW5nbGVBbmdsZSxcbiAgcm90YXRlWDogc2luZ2xlQW5nbGUsXG4gIHJvdGF0ZVk6IHNpbmdsZUFuZ2xlLFxuICByb3RhdGVaOiBzaW5nbGVBbmdsZSxcbiAgc2tld1g6IHNpbmdsZUFuZ2xlLFxuICBza2V3WTogc2luZ2xlQW5nbGUsXG4gIHNrZXc6IHh5QW5nbGUoJ3NrZXcnLCAnMGRlZycpXG59O1xuXG52YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHRva2VuU3RyZWFtKSB7XG4gIHZhciB0cmFuc2Zvcm1zID0gW107XG4gIHZhciBkaWRQYXJzZUZpcnN0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRva2VuU3RyZWFtLmhhc1Rva2VucygpKSB7XG4gICAgaWYgKGRpZFBhcnNlRmlyc3QpIHRva2VuU3RyZWFtLmV4cGVjdChTUEFDRSk7XG4gICAgdmFyIGZ1bmN0aW9uU3RyZWFtID0gdG9rZW5TdHJlYW0uZXhwZWN0RnVuY3Rpb24oKTtcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25TdHJlYW0uZnVuY3Rpb25OYW1lO1xuICAgIHZhciB0cmFuc2Zvcm1lZFZhbHVlcyA9IHBhcnRUcmFuc2Zvcm1zW2Z1bmN0aW9uTmFtZV0oZnVuY3Rpb25TdHJlYW0pO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkVmFsdWVzKSkge1xuICAgICAgdmFyIF9yZWY1O1xuXG4gICAgICB0cmFuc2Zvcm1lZFZhbHVlcyA9IFsoX3JlZjUgPSB7fSwgX3JlZjVbZnVuY3Rpb25OYW1lXSA9IHRyYW5zZm9ybWVkVmFsdWVzLCBfcmVmNSldO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1lZFZhbHVlcy5jb25jYXQodHJhbnNmb3Jtcyk7XG4gICAgZGlkUGFyc2VGaXJzdCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogdHJhbnNmb3Jtc1xuICB9O1xufTtcblxudmFyIGJhY2tncm91bmQgPSBmdW5jdGlvbiBiYWNrZ3JvdW5kKHRva2VuU3RyZWFtKSB7XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiB0b2tlblN0cmVhbS5leHBlY3QoQ09MT1IpXG4gIH07XG59O1xuXG52YXIgYm9yZGVyQ29sb3IgPSBkaXJlY3Rpb25GYWN0b3J5KHtcbiAgdHlwZXM6IFtDT0xPUl0sXG4gIHByZWZpeDogJ2JvcmRlcicsXG4gIHN1ZmZpeDogJ0NvbG9yJ1xufSk7XG52YXIgYm9yZGVyUmFkaXVzID0gZGlyZWN0aW9uRmFjdG9yeSh7XG4gIGRpcmVjdGlvbnM6IFsnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21SaWdodCcsICdCb3R0b21MZWZ0J10sXG4gIHByZWZpeDogJ2JvcmRlcicsXG4gIHN1ZmZpeDogJ1JhZGl1cydcbn0pO1xudmFyIGJvcmRlcldpZHRoID0gZGlyZWN0aW9uRmFjdG9yeSh7XG4gIHByZWZpeDogJ2JvcmRlcicsXG4gIHN1ZmZpeDogJ1dpZHRoJ1xufSk7XG52YXIgbWFyZ2luID0gZGlyZWN0aW9uRmFjdG9yeSh7XG4gIHR5cGVzOiBbTEVOR1RILCBVTlNVUFBPUlRFRF9MRU5HVEhfVU5JVCwgUEVSQ0VOVCwgQVVUT10sXG4gIHByZWZpeDogJ21hcmdpbidcbn0pO1xudmFyIHBhZGRpbmcgPSBkaXJlY3Rpb25GYWN0b3J5KHtcbiAgcHJlZml4OiAncGFkZGluZydcbn0pO1xuXG52YXIgZm9udFZhcmlhbnQgPSBmdW5jdGlvbiBmb250VmFyaWFudCh0b2tlblN0cmVhbSkge1xuICByZXR1cm4ge1xuICAgIGZvbnRWYXJpYW50OiBbdG9rZW5TdHJlYW0uZXhwZWN0KElERU5UKV1cbiAgfTtcbn07XG5cbnZhciBmb250V2VpZ2h0ID0gZnVuY3Rpb24gZm9udFdlaWdodCh0b2tlblN0cmVhbSkge1xuICByZXR1cm4ge1xuICAgIGZvbnRXZWlnaHQ6IHRva2VuU3RyZWFtLmV4cGVjdChXT1JEKSAvLyBBbHNvIG1hdGNoIG51bWJlcnMgYXMgc3RyaW5nc1xuXG4gIH07XG59O1xuXG52YXIgc2hhZG93T2Zmc2V0ID0gZnVuY3Rpb24gc2hhZG93T2Zmc2V0KHRva2VuU3RyZWFtKSB7XG4gIHJldHVybiB7XG4gICAgc2hhZG93T2Zmc2V0OiBwYXJzZVNoYWRvd09mZnNldCh0b2tlblN0cmVhbSlcbiAgfTtcbn07XG5cbnZhciB0ZXh0U2hhZG93T2Zmc2V0ID0gZnVuY3Rpb24gdGV4dFNoYWRvd09mZnNldCh0b2tlblN0cmVhbSkge1xuICByZXR1cm4ge1xuICAgIHRleHRTaGFkb3dPZmZzZXQ6IHBhcnNlU2hhZG93T2Zmc2V0KHRva2VuU3RyZWFtKVxuICB9O1xufTtcblxudmFyIHRyYW5zZm9ybXMgPSB7XG4gIGJhY2tncm91bmQ6IGJhY2tncm91bmQsXG4gIGJvcmRlcjogYm9yZGVyLFxuICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsXG4gIGJvcmRlclJhZGl1czogYm9yZGVyUmFkaXVzLFxuICBib3JkZXJXaWR0aDogYm9yZGVyV2lkdGgsXG4gIGJveFNoYWRvdzogYm94U2hhZG93LFxuICBmbGV4OiBmbGV4LFxuICBmbGV4RmxvdzogZmxleEZsb3csXG4gIGZvbnQ6IGZvbnQsXG4gIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gIGZvbnRWYXJpYW50OiBmb250VmFyaWFudCxcbiAgZm9udFdlaWdodDogZm9udFdlaWdodCxcbiAgbWFyZ2luOiBtYXJnaW4sXG4gIHBhZGRpbmc6IHBhZGRpbmcsXG4gIHBsYWNlQ29udGVudDogcGxhY2VDb250ZW50LFxuICBzaGFkb3dPZmZzZXQ6IHNoYWRvd09mZnNldCxcbiAgdGV4dFNoYWRvdzogdGV4dFNoYWRvdyxcbiAgdGV4dFNoYWRvd09mZnNldDogdGV4dFNoYWRvd09mZnNldCxcbiAgdGV4dERlY29yYXRpb246IHRleHREZWNvcmF0aW9uLFxuICB0ZXh0RGVjb3JhdGlvbkxpbmU6IHRleHREZWNvcmF0aW9uTGluZSxcbiAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbn07XG52YXIgcHJvcGVydGllc1dpdGhvdXRVbml0cztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJvcGVydGllc1dpdGhvdXRVbml0cyA9IFsnYXNwZWN0UmF0aW8nLCAnZWxldmF0aW9uJywgJ2ZsZXhHcm93JywgJ2ZsZXhTaHJpbmsnLCAnb3BhY2l0eScsICdzaGFkb3dPcGFjaXR5JywgJ3pJbmRleCddO1xufVxuXG52YXIgZGV2UHJvcGVydGllc1dpdGhVbml0c1JlZ0V4cCA9IHByb3BlcnRpZXNXaXRob3V0VW5pdHMgIT0gbnVsbCA/IG5ldyBSZWdFeHAocHJvcGVydGllc1dpdGhvdXRVbml0cy5qb2luKCd8JykpIDogbnVsbDtcbnZhciBTWU1CT0xfTUFUQ0ggPSAnU1lNQk9MX01BVENIJztcblxudmFyIFRva2VuU3RyZWFtID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9rZW5TdHJlYW0obm9kZXMsIHBhcmVudCkge1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB0aGlzLmZ1bmN0aW9uTmFtZSA9IHBhcmVudCAhPSBudWxsID8gcGFyZW50LnZhbHVlIDogbnVsbDtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5yZXdpbmRJbmRleCA9IC0xO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRva2VuU3RyZWFtLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFzVG9rZW5zID0gZnVuY3Rpb24gaGFzVG9rZW5zKCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4IDw9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgfTtcblxuICBfcHJvdG9bU1lNQk9MX01BVENIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzVG9rZW5zKCkpIHJldHVybiBudWxsO1xuICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1t0aGlzLmluZGV4XTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgdG9rZW5EZXNjcmlwdG9yID0gaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdG9rZW5EZXNjcmlwdG9yKG5vZGUpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKCkge1xuICAgIHJldHVybiB0aGlzW1NZTUJPTF9NQVRDSF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSAhPT0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uZXhwZWN0ID0gZnVuY3Rpb24gZXhwZWN0KCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXNbU1lNQk9MX01BVENIXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlIDogdGhpc1tcInRocm93XCJdKCk7XG4gIH07XG5cbiAgX3Byb3RvLm1hdGNoZXNGdW5jdGlvbiA9IGZ1bmN0aW9uIG1hdGNoZXNGdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbdGhpcy5pbmRleF07XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG51bGw7XG4gICAgdmFyIHZhbHVlID0gbmV3IFRva2VuU3RyZWFtKG5vZGUubm9kZXMsIG5vZGUpO1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5leHBlY3RGdW5jdGlvbiA9IGZ1bmN0aW9uIGV4cGVjdEZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMubWF0Y2hlc0Z1bmN0aW9uKCk7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsID8gdmFsdWUgOiB0aGlzW1widGhyb3dcIl0oKTtcbiAgfTtcblxuICBfcHJvdG8uZXhwZWN0RW1wdHkgPSBmdW5jdGlvbiBleHBlY3RFbXB0eSgpIHtcbiAgICBpZiAodGhpcy5oYXNUb2tlbnMoKSkgdGhpc1tcInRocm93XCJdKCk7XG4gIH07XG5cbiAgX3Byb3RvW1widGhyb3dcIl0gPSBmdW5jdGlvbiBfdGhyb3coKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiB0eXBlOiBcIiArIHRoaXMubm9kZXNbdGhpcy5pbmRleF0udHlwZSk7XG4gIH07XG5cbiAgX3Byb3RvLnNhdmVSZXdpbmRQb2ludCA9IGZ1bmN0aW9uIHNhdmVSZXdpbmRQb2ludCgpIHtcbiAgICB0aGlzLnJld2luZEluZGV4ID0gdGhpcy5pbmRleDtcbiAgfTtcblxuICBfcHJvdG8ucmV3aW5kID0gZnVuY3Rpb24gcmV3aW5kKCkge1xuICAgIGlmICh0aGlzLnJld2luZEluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvcicpO1xuICAgIHRoaXMuaW5kZXggPSB0aGlzLnJld2luZEluZGV4O1xuICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gVG9rZW5TdHJlYW07XG59KCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuLy8gTm90ZSBpZiB0aGlzIGlzIHdyb25nLCB5b3UnbGwgbmVlZCB0byBjaGFuZ2UgdG9rZW5UeXBlcy5qcyB0b29cblxuXG52YXIgbnVtYmVyT3JMZW5ndGhSZSA9IC9eKFsrLV0/KD86XFxkKlxcLik/XFxkKyg/OmVbKy1dP1xcZCspPykoPzpweCk/JC9pO1xudmFyIG51bWJlck9ubHlSZSA9IC9eWystXT8oPzpcXGQqXFwuXFxkKnxbMS05XVxcZCopKD86ZVsrLV0/XFxkKyk/JC9pO1xudmFyIGJvb2xSZSA9IC9edHJ1ZXxmYWxzZSQvaTtcbnZhciBudWxsUmUgPSAvXm51bGwkL2k7XG52YXIgdW5kZWZpbmVkUmUgPSAvXnVuZGVmaW5lZCQvaTsgLy8gVW5kb2N1bWVudGVkIGV4cG9ydFxuXG52YXIgdHJhbnNmb3JtUmF3VmFsdWUgPSBmdW5jdGlvbiB0cmFuc2Zvcm1SYXdWYWx1ZShwcm9wTmFtZSwgdmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbmVlZHNVbml0ID0gIWRldlByb3BlcnRpZXNXaXRoVW5pdHNSZWdFeHAudGVzdChwcm9wTmFtZSk7XG4gICAgdmFyIGlzTnVtYmVyV2l0aG91dFVuaXQgPSBudW1iZXJPbmx5UmUudGVzdCh2YWx1ZSk7XG5cbiAgICBpZiAobmVlZHNVbml0ICYmIGlzTnVtYmVyV2l0aG91dFVuaXQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXCJFeHBlY3RlZCBzdHlsZSBcXFwiXCIgKyBwcm9wTmFtZSArIFwiOiBcIiArIHZhbHVlICsgXCJcXFwiIHRvIGNvbnRhaW4gdW5pdHNcIik7XG4gICAgfVxuXG4gICAgaWYgKCFuZWVkc1VuaXQgJiYgdmFsdWUgIT09ICcwJyAmJiAhaXNOdW1iZXJXaXRob3V0VW5pdCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIkV4cGVjdGVkIHN0eWxlIFxcXCJcIiArIHByb3BOYW1lICsgXCI6IFwiICsgdmFsdWUgKyBcIlxcXCIgdG8gYmUgdW5pdGxlc3NcIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIG51bWJlck1hdGNoID0gdmFsdWUubWF0Y2gobnVtYmVyT3JMZW5ndGhSZSk7XG4gIGlmIChudW1iZXJNYXRjaCAhPT0gbnVsbCkgcmV0dXJuIE51bWJlcihudW1iZXJNYXRjaFsxXSk7XG4gIHZhciBib29sTWF0Y2ggPSB2YWx1ZS5tYXRjaChib29sUmUpO1xuICBpZiAoYm9vbE1hdGNoICE9PSBudWxsKSByZXR1cm4gYm9vbE1hdGNoWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgdmFyIG51bGxNYXRjaCA9IHZhbHVlLm1hdGNoKG51bGxSZSk7XG4gIGlmIChudWxsTWF0Y2ggIT09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgdW5kZWZpbmVkTWF0Y2ggPSB2YWx1ZS5tYXRjaCh1bmRlZmluZWRSZSk7XG4gIGlmICh1bmRlZmluZWRNYXRjaCAhPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGJhc2VUcmFuc2Zvcm1TaG9ydGhhbmRWYWx1ZSA9IGZ1bmN0aW9uIGJhc2VUcmFuc2Zvcm1TaG9ydGhhbmRWYWx1ZShwcm9wTmFtZSwgdmFsdWUpIHtcbiAgdmFyIGFzdCA9IHBhcnNlX19kZWZhdWx0KHZhbHVlKTtcbiAgdmFyIHRva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGFzdC5ub2Rlcyk7XG4gIHJldHVybiB0cmFuc2Zvcm1zW3Byb3BOYW1lXSh0b2tlblN0cmVhbSk7XG59O1xuXG52YXIgdHJhbnNmb3JtU2hvcnRoYW5kVmFsdWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gYmFzZVRyYW5zZm9ybVNob3J0aGFuZFZhbHVlIDogZnVuY3Rpb24gKHByb3BOYW1lLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBiYXNlVHJhbnNmb3JtU2hvcnRoYW5kVmFsdWUocHJvcE5hbWUsIHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBkZWNsYXJhdGlvbiBcXFwiXCIgKyBwcm9wTmFtZSArIFwiOiBcIiArIHZhbHVlICsgXCJcXFwiXCIpO1xuICB9XG59O1xuXG52YXIgZ2V0U3R5bGVzRm9yUHJvcGVydHkgPSBmdW5jdGlvbiBnZXRTdHlsZXNGb3JQcm9wZXJ0eShwcm9wTmFtZSwgaW5wdXRWYWx1ZSwgYWxsb3dTaG9ydGhhbmQpIHtcbiAgdmFyIF9yZWY2O1xuXG4gIHZhciBpc1Jhd1ZhbHVlID0gYWxsb3dTaG9ydGhhbmQgPT09IGZhbHNlIHx8ICEocHJvcE5hbWUgaW4gdHJhbnNmb3Jtcyk7XG4gIHZhciB2YWx1ZSA9IGlucHV0VmFsdWUudHJpbSgpO1xuICB2YXIgcHJvcFZhbHVlcyA9IGlzUmF3VmFsdWUgPyAoX3JlZjYgPSB7fSwgX3JlZjZbcHJvcE5hbWVdID0gdHJhbnNmb3JtUmF3VmFsdWUocHJvcE5hbWUsIHZhbHVlKSwgX3JlZjYpIDogdHJhbnNmb3JtU2hvcnRoYW5kVmFsdWUocHJvcE5hbWUsIHZhbHVlKTtcbiAgcmV0dXJuIHByb3BWYWx1ZXM7XG59O1xuXG52YXIgZ2V0UHJvcGVydHlOYW1lID0gZnVuY3Rpb24gZ2V0UHJvcGVydHlOYW1lKHByb3BOYW1lKSB7XG4gIHZhciBpc0N1c3RvbVByb3AgPSAvXi0tXFx3Ky8udGVzdChwcm9wTmFtZSk7XG5cbiAgaWYgKGlzQ3VzdG9tUHJvcCkge1xuICAgIHJldHVybiBwcm9wTmFtZTtcbiAgfVxuXG4gIHJldHVybiBjYW1lbGl6ZVN0eWxlTmFtZShwcm9wTmFtZSk7XG59O1xuXG52YXIgaW5kZXggPSBmdW5jdGlvbiBpbmRleChydWxlcywgc2hvcnRoYW5kQmxhY2tsaXN0KSB7XG4gIGlmIChzaG9ydGhhbmRCbGFja2xpc3QgPT09IHZvaWQgMCkge1xuICAgIHNob3J0aGFuZEJsYWNrbGlzdCA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHJ1bGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHJ1bGUpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lID0gZ2V0UHJvcGVydHlOYW1lKHJ1bGVbMF0pO1xuICAgIHZhciB2YWx1ZSA9IHJ1bGVbMV07XG4gICAgdmFyIGFsbG93U2hvcnRoYW5kID0gc2hvcnRoYW5kQmxhY2tsaXN0LmluZGV4T2YocHJvcGVydHlOYW1lKSA9PT0gLTE7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjdW0sIGdldFN0eWxlc0ZvclByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUsIGFsbG93U2hvcnRoYW5kKSk7XG4gIH0sIHt9KTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gaW5kZXg7XG5leHBvcnRzLmdldFByb3BlcnR5TmFtZSA9IGdldFByb3BlcnR5TmFtZTtcbmV4cG9ydHMuZ2V0U3R5bGVzRm9yUHJvcGVydHkgPSBnZXRTdHlsZXNGb3JQcm9wZXJ0eTtcbmV4cG9ydHMudHJhbnNmb3JtUmF3VmFsdWUgPSB0cmFuc2Zvcm1SYXdWYWx1ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/css-to-react-native/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/get-hostname.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-hostname.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getHostname = getHostname;\n\nfunction getHostname(parsed, headers) {\n  var ref;\n  return (ref = !Array.isArray(headers == null ? void 0 : headers.host) && (headers == null ? void 0 : headers.host) || parsed.hostname) == null ? void 0 : ref.split(':')[0].toLowerCase();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2dldC1ob3N0bmFtZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQUQsbUJBQUEsR0FBc0JFLFdBQXRCOztBQUNBLFNBQVNBLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCQyxPQUE3QixFQUFzQztFQUNsQyxJQUFJQyxHQUFKO0VBQ0EsT0FBTyxDQUFDQSxHQUFHLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDQyxPQUFOLENBQWNILE9BQU8sSUFBSSxJQUFYLEdBQWtCLEtBQUssQ0FBdkIsR0FBMkJBLE9BQU8sQ0FBQ0ksSUFBakQsQ0FBRCxLQUE0REosT0FBTyxJQUFJLElBQVgsR0FBa0IsS0FBSyxDQUF2QixHQUEyQkEsT0FBTyxDQUFDSSxJQUEvRixLQUF3R0wsTUFBTSxDQUFDTSxRQUF0SCxLQUFtSSxJQUFuSSxHQUEwSSxLQUFLLENBQS9JLEdBQW1KSixHQUFHLENBQUNLLEtBQUosQ0FBVSxHQUFWLEVBQWUsQ0FBZixFQUFrQkMsV0FBbEIsRUFBMUo7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZ2V0LWhvc3RuYW1lLmpzPzRjZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEhvc3RuYW1lID0gZ2V0SG9zdG5hbWU7XG5mdW5jdGlvbiBnZXRIb3N0bmFtZShwYXJzZWQsIGhlYWRlcnMpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAocmVmID0gIUFycmF5LmlzQXJyYXkoaGVhZGVycyA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVycy5ob3N0KSAmJiAoaGVhZGVycyA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVycy5ob3N0KSB8fCBwYXJzZWQuaG9zdG5hbWUpID09IG51bGwgPyB2b2lkIDAgOiByZWYuc3BsaXQoJzonKVswXS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtaG9zdG5hbWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0SG9zdG5hbWUiLCJwYXJzZWQiLCJoZWFkZXJzIiwicmVmIiwiQXJyYXkiLCJpc0FycmF5IiwiaG9zdCIsImhvc3RuYW1lIiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/get-hostname.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.detectDomainLocale = detectDomainLocale;\n\nfunction detectDomainLocale(domainItems, hostname, detectedLocale) {\n  let domainItem;\n\n  if (domainItems) {\n    if (detectedLocale) {\n      detectedLocale = detectedLocale.toLowerCase();\n    }\n\n    for (const item of domainItems) {\n      var ref, ref1; // remove port if present\n\n      const domainHostname = (ref = item.domain) == null ? void 0 : ref.split(':')[0].toLowerCase();\n\n      if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((ref1 = item.locales) == null ? void 0 : ref1.some(locale => locale.toLowerCase() === detectedLocale))) {\n        domainItem = item;\n        break;\n      }\n    }\n  }\n\n  return domainItem;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELDBCQUFBLEdBQTZCRSxrQkFBN0I7O0FBQ0EsU0FBU0Esa0JBQVQsQ0FBNEJDLFdBQTVCLEVBQXlDQyxRQUF6QyxFQUFtREMsY0FBbkQsRUFBbUU7RUFDL0QsSUFBSUMsVUFBSjs7RUFDQSxJQUFJSCxXQUFKLEVBQWlCO0lBQ2IsSUFBSUUsY0FBSixFQUFvQjtNQUNoQkEsY0FBYyxHQUFHQSxjQUFjLENBQUNFLFdBQWYsRUFBakI7SUFDSDs7SUFDRCxLQUFLLE1BQU1DLElBQVgsSUFBbUJMLFdBQW5CLEVBQStCO01BQzNCLElBQUlNLEdBQUosRUFBU0MsSUFBVCxDQUQyQixDQUUzQjs7TUFDQSxNQUFNQyxjQUFjLEdBQUcsQ0FBQ0YsR0FBRyxHQUFHRCxJQUFJLENBQUNJLE1BQVosS0FBdUIsSUFBdkIsR0FBOEIsS0FBSyxDQUFuQyxHQUF1Q0gsR0FBRyxDQUFDSSxLQUFKLENBQVUsR0FBVixFQUFlLENBQWYsRUFBa0JOLFdBQWxCLEVBQTlEOztNQUNBLElBQUlILFFBQVEsS0FBS08sY0FBYixJQUErQk4sY0FBYyxLQUFLRyxJQUFJLENBQUNNLGFBQUwsQ0FBbUJQLFdBQW5CLEVBQWxELEtBQXVGLENBQUNHLElBQUksR0FBR0YsSUFBSSxDQUFDTyxPQUFiLEtBQXlCLElBQXpCLEdBQWdDLEtBQUssQ0FBckMsR0FBeUNMLElBQUksQ0FBQ00sSUFBTCxDQUFXQyxNQUFELElBQVVBLE1BQU0sQ0FBQ1YsV0FBUCxPQUF5QkYsY0FBN0MsQ0FBaEksQ0FBSixFQUFtTTtRQUMvTEMsVUFBVSxHQUFHRSxJQUFiO1FBQ0E7TUFDSDtJQUNKO0VBQ0o7O0VBQ0QsT0FBT0YsVUFBUDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlLmpzPzc4ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRldGVjdERvbWFpbkxvY2FsZSA9IGRldGVjdERvbWFpbkxvY2FsZTtcbmZ1bmN0aW9uIGRldGVjdERvbWFpbkxvY2FsZShkb21haW5JdGVtcywgaG9zdG5hbWUsIGRldGVjdGVkTG9jYWxlKSB7XG4gICAgbGV0IGRvbWFpbkl0ZW07XG4gICAgaWYgKGRvbWFpbkl0ZW1zKSB7XG4gICAgICAgIGlmIChkZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgZGV0ZWN0ZWRMb2NhbGUgPSBkZXRlY3RlZExvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBkb21haW5JdGVtcyl7XG4gICAgICAgICAgICB2YXIgcmVmLCByZWYxO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHBvcnQgaWYgcHJlc2VudFxuICAgICAgICAgICAgY29uc3QgZG9tYWluSG9zdG5hbWUgPSAocmVmID0gaXRlbS5kb21haW4pID09IG51bGwgPyB2b2lkIDAgOiByZWYuc3BsaXQoJzonKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGhvc3RuYW1lID09PSBkb21haW5Ib3N0bmFtZSB8fCBkZXRlY3RlZExvY2FsZSA9PT0gaXRlbS5kZWZhdWx0TG9jYWxlLnRvTG93ZXJDYXNlKCkgfHwgKChyZWYxID0gaXRlbS5sb2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMS5zb21lKChsb2NhbGUpPT5sb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gZGV0ZWN0ZWRMb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbkl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb21haW5JdGVtO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3QtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJkb21haW5JdGVtcyIsImhvc3RuYW1lIiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW5JdGVtIiwidG9Mb3dlckNhc2UiLCJpdGVtIiwicmVmIiwicmVmMSIsImRvbWFpbkhvc3RuYW1lIiwiZG9tYWluIiwic3BsaXQiLCJkZWZhdWx0TG9jYWxlIiwibG9jYWxlcyIsInNvbWUiLCJsb2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.normalizeLocalePath = normalizeLocalePath;\n\nfunction normalizeLocalePath(pathname, locales) {\n  let detectedLocale; // first item will be empty string from splitting at first char\n\n  const pathnameParts = pathname.split('/');\n  (locales || []).some(locale => {\n    if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {\n      detectedLocale = locale;\n      pathnameParts.splice(1, 1);\n      pathname = pathnameParts.join('/') || '/';\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    pathname,\n    detectedLocale\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCwyQkFBQSxHQUE4QkUsbUJBQTlCOztBQUNBLFNBQVNBLG1CQUFULENBQTZCQyxRQUE3QixFQUF1Q0MsT0FBdkMsRUFBZ0Q7RUFDNUMsSUFBSUMsY0FBSixDQUQ0QyxDQUU1Qzs7RUFDQSxNQUFNQyxhQUFhLEdBQUdILFFBQVEsQ0FBQ0ksS0FBVCxDQUFlLEdBQWYsQ0FBdEI7RUFDQSxDQUFDSCxPQUFPLElBQUksRUFBWixFQUFnQkksSUFBaEIsQ0FBc0JDLE1BQUQsSUFBVTtJQUMzQixJQUFJSCxhQUFhLENBQUMsQ0FBRCxDQUFiLElBQW9CQSxhQUFhLENBQUMsQ0FBRCxDQUFiLENBQWlCSSxXQUFqQixPQUFtQ0QsTUFBTSxDQUFDQyxXQUFQLEVBQTNELEVBQWlGO01BQzdFTCxjQUFjLEdBQUdJLE1BQWpCO01BQ0FILGFBQWEsQ0FBQ0ssTUFBZCxDQUFxQixDQUFyQixFQUF3QixDQUF4QjtNQUNBUixRQUFRLEdBQUdHLGFBQWEsQ0FBQ00sSUFBZCxDQUFtQixHQUFuQixLQUEyQixHQUF0QztNQUNBLE9BQU8sSUFBUDtJQUNIOztJQUNELE9BQU8sS0FBUDtFQUNILENBUkQ7RUFTQSxPQUFPO0lBQ0hULFFBREc7SUFFSEU7RUFGRyxDQUFQO0FBSUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoLmpzPzA0M2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vcm1hbGl6ZUxvY2FsZVBhdGggPSBub3JtYWxpemVMb2NhbGVQYXRoO1xuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlUGF0aChwYXRobmFtZSwgbG9jYWxlcykge1xuICAgIGxldCBkZXRlY3RlZExvY2FsZTtcbiAgICAvLyBmaXJzdCBpdGVtIHdpbGwgYmUgZW1wdHkgc3RyaW5nIGZyb20gc3BsaXR0aW5nIGF0IGZpcnN0IGNoYXJcbiAgICBjb25zdCBwYXRobmFtZVBhcnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAobG9jYWxlcyB8fCBbXSkuc29tZSgobG9jYWxlKT0+e1xuICAgICAgICBpZiAocGF0aG5hbWVQYXJ0c1sxXSAmJiBwYXRobmFtZVBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgPT09IGxvY2FsZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIHBhdGhuYW1lUGFydHMuc3BsaWNlKDEsIDEpO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZVBhcnRzLmpvaW4oJy8nKSB8fCAnLyc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIGRldGVjdGVkTG9jYWxlXG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLWxvY2FsZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJwYXRobmFtZSIsImxvY2FsZXMiLCJkZXRlY3RlZExvY2FsZSIsInBhdGhuYW1lUGFydHMiLCJzcGxpdCIsInNvbWUiLCJsb2NhbGUiLCJ0b0xvd2VyQ2FzZSIsInNwbGljZSIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-locale.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-locale.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addLocale = addLocale;\n\nvar _addPathPrefix = __webpack_require__(/*! ./add-path-prefix */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\n\nvar _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\n\nfunction addLocale(path, locale, defaultLocale, ignorePrefix) {\n  if (locale && locale !== defaultLocale && (ignorePrefix || !(0, _pathHasPrefix).pathHasPrefix(path.toLowerCase(), `/${locale.toLowerCase()}`) && !(0, _pathHasPrefix).pathHasPrefix(path.toLowerCase(), '/api'))) {\n    return (0, _addPathPrefix).addPathPrefix(path, `/${locale}`);\n  }\n\n  return path;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxpQkFBQSxHQUFvQkUsU0FBcEI7O0FBQ0EsSUFBSUMsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLDJHQUFELENBQTVCOztBQUNBLElBQUlDLGNBQWMsR0FBR0QsbUJBQU8sQ0FBQywyR0FBRCxDQUE1Qjs7QUFDQSxTQUFTRixTQUFULENBQW1CSSxJQUFuQixFQUF5QkMsTUFBekIsRUFBaUNDLGFBQWpDLEVBQWdEQyxZQUFoRCxFQUE4RDtFQUMxRCxJQUFJRixNQUFNLElBQUlBLE1BQU0sS0FBS0MsYUFBckIsS0FBdUNDLFlBQVksSUFBSSxDQUFDLENBQUMsR0FBR0osY0FBSixFQUFvQkssYUFBcEIsQ0FBa0NKLElBQUksQ0FBQ0ssV0FBTCxFQUFsQyxFQUF1RCxJQUFHSixNQUFNLENBQUNJLFdBQVAsRUFBcUIsRUFBL0UsQ0FBRCxJQUFzRixDQUFDLENBQUMsR0FBR04sY0FBSixFQUFvQkssYUFBcEIsQ0FBa0NKLElBQUksQ0FBQ0ssV0FBTCxFQUFsQyxFQUFzRCxNQUF0RCxDQUE5SSxDQUFKLEVBQWtOO0lBQzlNLE9BQU8sQ0FBQyxHQUFHUixjQUFKLEVBQW9CUyxhQUFwQixDQUFrQ04sSUFBbEMsRUFBeUMsSUFBR0MsTUFBTyxFQUFuRCxDQUFQO0VBQ0g7O0VBQ0QsT0FBT0QsSUFBUDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLWxvY2FsZS5qcz8wMjMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRMb2NhbGUgPSBhZGRMb2NhbGU7XG52YXIgX2FkZFBhdGhQcmVmaXggPSByZXF1aXJlKFwiLi9hZGQtcGF0aC1wcmVmaXhcIik7XG52YXIgX3BhdGhIYXNQcmVmaXggPSByZXF1aXJlKFwiLi9wYXRoLWhhcy1wcmVmaXhcIik7XG5mdW5jdGlvbiBhZGRMb2NhbGUocGF0aCwgbG9jYWxlLCBkZWZhdWx0TG9jYWxlLCBpZ25vcmVQcmVmaXgpIHtcbiAgICBpZiAobG9jYWxlICYmIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJiAoaWdub3JlUHJlZml4IHx8ICEoMCwgX3BhdGhIYXNQcmVmaXgpLnBhdGhIYXNQcmVmaXgocGF0aC50b0xvd2VyQ2FzZSgpLCBgLyR7bG9jYWxlLnRvTG93ZXJDYXNlKCl9YCkgJiYgISgwLCBfcGF0aEhhc1ByZWZpeCkucGF0aEhhc1ByZWZpeChwYXRoLnRvTG93ZXJDYXNlKCksICcvYXBpJykpKSB7XG4gICAgICAgIHJldHVybiAoMCwgX2FkZFBhdGhQcmVmaXgpLmFkZFBhdGhQcmVmaXgocGF0aCwgYC8ke2xvY2FsZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC1sb2NhbGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkTG9jYWxlIiwiX2FkZFBhdGhQcmVmaXgiLCJyZXF1aXJlIiwiX3BhdGhIYXNQcmVmaXgiLCJwYXRoIiwibG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImlnbm9yZVByZWZpeCIsInBhdGhIYXNQcmVmaXgiLCJ0b0xvd2VyQ2FzZSIsImFkZFBhdGhQcmVmaXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-locale.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addPathPrefix = addPathPrefix;\n\nvar _parsePath = __webpack_require__(/*! ./parse-path */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nfunction addPathPrefix(path, prefix) {\n  if (!path.startsWith('/') || !prefix) {\n    return path;\n  }\n\n  const {\n    pathname,\n    query,\n    hash\n  } = (0, _parsePath).parsePath(path);\n  return `${prefix}${pathname}${query}${hash}`;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1wcmVmaXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELHFCQUFBLEdBQXdCRSxhQUF4Qjs7QUFDQSxJQUFJQyxVQUFVLEdBQUdDLG1CQUFPLENBQUMsaUdBQUQsQ0FBeEI7O0FBQ0EsU0FBU0YsYUFBVCxDQUF1QkcsSUFBdkIsRUFBNkJDLE1BQTdCLEVBQXFDO0VBQ2pDLElBQUksQ0FBQ0QsSUFBSSxDQUFDRSxVQUFMLENBQWdCLEdBQWhCLENBQUQsSUFBeUIsQ0FBQ0QsTUFBOUIsRUFBc0M7SUFDbEMsT0FBT0QsSUFBUDtFQUNIOztFQUNELE1BQU07SUFBRUcsUUFBRjtJQUFhQyxLQUFiO0lBQXFCQztFQUFyQixJQUErQixDQUFDLEdBQUdQLFVBQUosRUFBZ0JRLFNBQWhCLENBQTBCTixJQUExQixDQUFyQztFQUNBLE9BQVEsR0FBRUMsTUFBTyxHQUFFRSxRQUFTLEdBQUVDLEtBQU0sR0FBRUMsSUFBSyxFQUEzQztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtcHJlZml4LmpzP2MxMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZFBhdGhQcmVmaXggPSBhZGRQYXRoUHJlZml4O1xudmFyIF9wYXJzZVBhdGggPSByZXF1aXJlKFwiLi9wYXJzZS1wYXRoXCIpO1xuZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoLCBwcmVmaXgpIHtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAsIGhhc2ggIH0gPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBgJHtwcmVmaXh9JHtwYXRobmFtZX0ke3F1ZXJ5fSR7aGFzaH1gO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtcGF0aC1wcmVmaXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkUGF0aFByZWZpeCIsIl9wYXJzZVBhdGgiLCJyZXF1aXJlIiwicGF0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCIsInBhcnNlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addPathSuffix = addPathSuffix;\n\nvar _parsePath = __webpack_require__(/*! ./parse-path */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nfunction addPathSuffix(path, suffix) {\n  if (!path.startsWith('/') || !suffix) {\n    return path;\n  }\n\n  const {\n    pathname,\n    query,\n    hash\n  } = (0, _parsePath).parsePath(path);\n  return `${pathname}${suffix}${query}${hash}`;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1zdWZmaXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELHFCQUFBLEdBQXdCRSxhQUF4Qjs7QUFDQSxJQUFJQyxVQUFVLEdBQUdDLG1CQUFPLENBQUMsaUdBQUQsQ0FBeEI7O0FBQ0EsU0FBU0YsYUFBVCxDQUF1QkcsSUFBdkIsRUFBNkJDLE1BQTdCLEVBQXFDO0VBQ2pDLElBQUksQ0FBQ0QsSUFBSSxDQUFDRSxVQUFMLENBQWdCLEdBQWhCLENBQUQsSUFBeUIsQ0FBQ0QsTUFBOUIsRUFBc0M7SUFDbEMsT0FBT0QsSUFBUDtFQUNIOztFQUNELE1BQU07SUFBRUcsUUFBRjtJQUFhQyxLQUFiO0lBQXFCQztFQUFyQixJQUErQixDQUFDLEdBQUdQLFVBQUosRUFBZ0JRLFNBQWhCLENBQTBCTixJQUExQixDQUFyQztFQUNBLE9BQVEsR0FBRUcsUUFBUyxHQUFFRixNQUFPLEdBQUVHLEtBQU0sR0FBRUMsSUFBSyxFQUEzQztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtc3VmZml4LmpzPzdiMzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZFBhdGhTdWZmaXggPSBhZGRQYXRoU3VmZml4O1xudmFyIF9wYXJzZVBhdGggPSByZXF1aXJlKFwiLi9wYXJzZS1wYXRoXCIpO1xuZnVuY3Rpb24gYWRkUGF0aFN1ZmZpeChwYXRoLCBzdWZmaXgpIHtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAsIGhhc2ggIH0gPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBgJHtwYXRobmFtZX0ke3N1ZmZpeH0ke3F1ZXJ5fSR7aGFzaH1gO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtcGF0aC1zdWZmaXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkUGF0aFN1ZmZpeCIsIl9wYXJzZVBhdGgiLCJyZXF1aXJlIiwicGF0aCIsInN1ZmZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCIsInBhcnNlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.formatNextPathnameInfo = formatNextPathnameInfo;\n\nvar _removeTrailingSlash = __webpack_require__(/*! ./remove-trailing-slash */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n\nvar _addPathPrefix = __webpack_require__(/*! ./add-path-prefix */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\n\nvar _addPathSuffix = __webpack_require__(/*! ./add-path-suffix */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js\");\n\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/add-locale.js\");\n\nfunction formatNextPathnameInfo(info) {\n  let pathname = (0, _addLocale).addLocale(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);\n\n  if (info.buildId) {\n    pathname = (0, _addPathSuffix).addPathSuffix((0, _addPathPrefix).addPathPrefix(pathname, `/_next/data/${info.buildId}`), info.pathname === '/' ? 'index.json' : '.json');\n  }\n\n  pathname = (0, _addPathPrefix).addPathPrefix(pathname, info.basePath);\n  return info.trailingSlash ? !info.buildId && !pathname.endsWith('/') ? (0, _addPathSuffix).addPathSuffix(pathname, '/') : pathname : (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCw4QkFBQSxHQUFpQ0Usc0JBQWpDOztBQUNBLElBQUlDLG9CQUFvQixHQUFHQyxtQkFBTyxDQUFDLHVIQUFELENBQWxDOztBQUNBLElBQUlDLGNBQWMsR0FBR0QsbUJBQU8sQ0FBQywyR0FBRCxDQUE1Qjs7QUFDQSxJQUFJRSxjQUFjLEdBQUdGLG1CQUFPLENBQUMsMkdBQUQsQ0FBNUI7O0FBQ0EsSUFBSUcsVUFBVSxHQUFHSCxtQkFBTyxDQUFDLGlHQUFELENBQXhCOztBQUNBLFNBQVNGLHNCQUFULENBQWdDTSxJQUFoQyxFQUFzQztFQUNsQyxJQUFJQyxRQUFRLEdBQUcsQ0FBQyxHQUFHRixVQUFKLEVBQWdCRyxTQUFoQixDQUEwQkYsSUFBSSxDQUFDQyxRQUEvQixFQUF5Q0QsSUFBSSxDQUFDRyxNQUE5QyxFQUFzREgsSUFBSSxDQUFDSSxPQUFMLEdBQWVDLFNBQWYsR0FBMkJMLElBQUksQ0FBQ00sYUFBdEYsRUFBcUdOLElBQUksQ0FBQ08sWUFBMUcsQ0FBZjs7RUFDQSxJQUFJUCxJQUFJLENBQUNJLE9BQVQsRUFBa0I7SUFDZEgsUUFBUSxHQUFHLENBQUMsR0FBR0gsY0FBSixFQUFvQlUsYUFBcEIsQ0FBa0MsQ0FBQyxHQUFHWCxjQUFKLEVBQW9CWSxhQUFwQixDQUFrQ1IsUUFBbEMsRUFBNkMsZUFBY0QsSUFBSSxDQUFDSSxPQUFRLEVBQXhFLENBQWxDLEVBQThHSixJQUFJLENBQUNDLFFBQUwsS0FBa0IsR0FBbEIsR0FBd0IsWUFBeEIsR0FBdUMsT0FBckosQ0FBWDtFQUNIOztFQUNEQSxRQUFRLEdBQUcsQ0FBQyxHQUFHSixjQUFKLEVBQW9CWSxhQUFwQixDQUFrQ1IsUUFBbEMsRUFBNENELElBQUksQ0FBQ1UsUUFBakQsQ0FBWDtFQUNBLE9BQU9WLElBQUksQ0FBQ1csYUFBTCxHQUFxQixDQUFDWCxJQUFJLENBQUNJLE9BQU4sSUFBaUIsQ0FBQ0gsUUFBUSxDQUFDVyxRQUFULENBQWtCLEdBQWxCLENBQWxCLEdBQTJDLENBQUMsR0FBR2QsY0FBSixFQUFvQlUsYUFBcEIsQ0FBa0NQLFFBQWxDLEVBQTRDLEdBQTVDLENBQTNDLEdBQThGQSxRQUFuSCxHQUE4SCxDQUFDLEdBQUdOLG9CQUFKLEVBQTBCa0IsbUJBQTFCLENBQThDWixRQUE5QyxDQUFySTtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mby5qcz9iMTQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mb3JtYXROZXh0UGF0aG5hbWVJbmZvID0gZm9ybWF0TmV4dFBhdGhuYW1lSW5mbztcbnZhciBfcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuL3JlbW92ZS10cmFpbGluZy1zbGFzaFwiKTtcbnZhciBfYWRkUGF0aFByZWZpeCA9IHJlcXVpcmUoXCIuL2FkZC1wYXRoLXByZWZpeFwiKTtcbnZhciBfYWRkUGF0aFN1ZmZpeCA9IHJlcXVpcmUoXCIuL2FkZC1wYXRoLXN1ZmZpeFwiKTtcbnZhciBfYWRkTG9jYWxlID0gcmVxdWlyZShcIi4vYWRkLWxvY2FsZVwiKTtcbmZ1bmN0aW9uIGZvcm1hdE5leHRQYXRobmFtZUluZm8oaW5mbykge1xuICAgIGxldCBwYXRobmFtZSA9ICgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoaW5mby5wYXRobmFtZSwgaW5mby5sb2NhbGUsIGluZm8uYnVpbGRJZCA/IHVuZGVmaW5lZCA6IGluZm8uZGVmYXVsdExvY2FsZSwgaW5mby5pZ25vcmVQcmVmaXgpO1xuICAgIGlmIChpbmZvLmJ1aWxkSWQpIHtcbiAgICAgICAgcGF0aG5hbWUgPSAoMCwgX2FkZFBhdGhTdWZmaXgpLmFkZFBhdGhTdWZmaXgoKDAsIF9hZGRQYXRoUHJlZml4KS5hZGRQYXRoUHJlZml4KHBhdGhuYW1lLCBgL19uZXh0L2RhdGEvJHtpbmZvLmJ1aWxkSWR9YCksIGluZm8ucGF0aG5hbWUgPT09ICcvJyA/ICdpbmRleC5qc29uJyA6ICcuanNvbicpO1xuICAgIH1cbiAgICBwYXRobmFtZSA9ICgwLCBfYWRkUGF0aFByZWZpeCkuYWRkUGF0aFByZWZpeChwYXRobmFtZSwgaW5mby5iYXNlUGF0aCk7XG4gICAgcmV0dXJuIGluZm8udHJhaWxpbmdTbGFzaCA/ICFpbmZvLmJ1aWxkSWQgJiYgIXBhdGhuYW1lLmVuZHNXaXRoKCcvJykgPyAoMCwgX2FkZFBhdGhTdWZmaXgpLmFkZFBhdGhTdWZmaXgocGF0aG5hbWUsICcvJykgOiBwYXRobmFtZSA6ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm8uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsIl9yZW1vdmVUcmFpbGluZ1NsYXNoIiwicmVxdWlyZSIsIl9hZGRQYXRoUHJlZml4IiwiX2FkZFBhdGhTdWZmaXgiLCJfYWRkTG9jYWxlIiwiaW5mbyIsInBhdGhuYW1lIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwiYnVpbGRJZCIsInVuZGVmaW5lZCIsImRlZmF1bHRMb2NhbGUiLCJpZ25vcmVQcmVmaXgiLCJhZGRQYXRoU3VmZml4IiwiYWRkUGF0aFByZWZpeCIsImJhc2VQYXRoIiwidHJhaWxpbmdTbGFzaCIsImVuZHNXaXRoIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getNextPathnameInfo = getNextPathnameInfo;\n\nvar _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ \"(middleware)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _removePathPrefix = __webpack_require__(/*! ./remove-path-prefix */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js\");\n\nvar _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\n\nfunction getNextPathnameInfo(pathname, options) {\n  var _nextConfig;\n\n  const {\n    basePath,\n    i18n,\n    trailingSlash\n  } = (_nextConfig = options.nextConfig) != null ? _nextConfig : {};\n  const info = {\n    pathname: pathname,\n    trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash\n  };\n\n  if (basePath && (0, _pathHasPrefix).pathHasPrefix(info.pathname, basePath)) {\n    info.pathname = (0, _removePathPrefix).removePathPrefix(info.pathname, basePath);\n    info.basePath = basePath;\n  }\n\n  if (options.parseData === true && info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {\n    const paths = info.pathname.replace(/^\\/_next\\/data\\//, '').replace(/\\.json$/, '').split('/');\n    const buildId = paths[0];\n    info.pathname = paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/';\n    info.buildId = buildId;\n  }\n\n  if (i18n) {\n    const pathLocale = (0, _normalizeLocalePath).normalizeLocalePath(info.pathname, i18n.locales);\n    info.locale = pathLocale == null ? void 0 : pathLocale.detectedLocale;\n    info.pathname = (pathLocale == null ? void 0 : pathLocale.pathname) || info.pathname;\n  }\n\n  return info;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCwyQkFBQSxHQUE4QkUsbUJBQTlCOztBQUNBLElBQUlDLG9CQUFvQixHQUFHQyxtQkFBTyxDQUFDLHdIQUFELENBQWxDOztBQUNBLElBQUlDLGlCQUFpQixHQUFHRCxtQkFBTyxDQUFDLGlIQUFELENBQS9COztBQUNBLElBQUlFLGNBQWMsR0FBR0YsbUJBQU8sQ0FBQywyR0FBRCxDQUE1Qjs7QUFDQSxTQUFTRixtQkFBVCxDQUE2QkssUUFBN0IsRUFBdUNDLE9BQXZDLEVBQWdEO0VBQzVDLElBQUlDLFdBQUo7O0VBQ0EsTUFBTTtJQUFFQyxRQUFGO0lBQWFDLElBQWI7SUFBb0JDO0VBQXBCLElBQXVDLENBQUNILFdBQVcsR0FBR0QsT0FBTyxDQUFDSyxVQUF2QixLQUFzQyxJQUF0QyxHQUE2Q0osV0FBN0MsR0FBMkQsRUFBeEc7RUFDQSxNQUFNSyxJQUFJLEdBQUc7SUFDVFAsUUFBUSxFQUFFQSxRQUREO0lBRVRLLGFBQWEsRUFBRUwsUUFBUSxLQUFLLEdBQWIsR0FBbUJBLFFBQVEsQ0FBQ1EsUUFBVCxDQUFrQixHQUFsQixDQUFuQixHQUE0Q0g7RUFGbEQsQ0FBYjs7RUFJQSxJQUFJRixRQUFRLElBQUksQ0FBQyxHQUFHSixjQUFKLEVBQW9CVSxhQUFwQixDQUFrQ0YsSUFBSSxDQUFDUCxRQUF2QyxFQUFpREcsUUFBakQsQ0FBaEIsRUFBNEU7SUFDeEVJLElBQUksQ0FBQ1AsUUFBTCxHQUFnQixDQUFDLEdBQUdGLGlCQUFKLEVBQXVCWSxnQkFBdkIsQ0FBd0NILElBQUksQ0FBQ1AsUUFBN0MsRUFBdURHLFFBQXZELENBQWhCO0lBQ0FJLElBQUksQ0FBQ0osUUFBTCxHQUFnQkEsUUFBaEI7RUFDSDs7RUFDRCxJQUFJRixPQUFPLENBQUNVLFNBQVIsS0FBc0IsSUFBdEIsSUFBOEJKLElBQUksQ0FBQ1AsUUFBTCxDQUFjWSxVQUFkLENBQXlCLGNBQXpCLENBQTlCLElBQTBFTCxJQUFJLENBQUNQLFFBQUwsQ0FBY1EsUUFBZCxDQUF1QixPQUF2QixDQUE5RSxFQUErRztJQUMzRyxNQUFNSyxLQUFLLEdBQUdOLElBQUksQ0FBQ1AsUUFBTCxDQUFjYyxPQUFkLENBQXNCLGtCQUF0QixFQUEwQyxFQUExQyxFQUE4Q0EsT0FBOUMsQ0FBc0QsU0FBdEQsRUFBaUUsRUFBakUsRUFBcUVDLEtBQXJFLENBQTJFLEdBQTNFLENBQWQ7SUFDQSxNQUFNQyxPQUFPLEdBQUdILEtBQUssQ0FBQyxDQUFELENBQXJCO0lBQ0FOLElBQUksQ0FBQ1AsUUFBTCxHQUFnQmEsS0FBSyxDQUFDLENBQUQsQ0FBTCxLQUFhLE9BQWIsR0FBd0IsSUFBR0EsS0FBSyxDQUFDSSxLQUFOLENBQVksQ0FBWixFQUFlQyxJQUFmLENBQW9CLEdBQXBCLENBQXlCLEVBQXBELEdBQXdELEdBQXhFO0lBQ0FYLElBQUksQ0FBQ1MsT0FBTCxHQUFlQSxPQUFmO0VBQ0g7O0VBQ0QsSUFBSVosSUFBSixFQUFVO0lBQ04sTUFBTWUsVUFBVSxHQUFHLENBQUMsR0FBR3ZCLG9CQUFKLEVBQTBCd0IsbUJBQTFCLENBQThDYixJQUFJLENBQUNQLFFBQW5ELEVBQTZESSxJQUFJLENBQUNpQixPQUFsRSxDQUFuQjtJQUNBZCxJQUFJLENBQUNlLE1BQUwsR0FBY0gsVUFBVSxJQUFJLElBQWQsR0FBcUIsS0FBSyxDQUExQixHQUE4QkEsVUFBVSxDQUFDSSxjQUF2RDtJQUNBaEIsSUFBSSxDQUFDUCxRQUFMLEdBQWdCLENBQUNtQixVQUFVLElBQUksSUFBZCxHQUFxQixLQUFLLENBQTFCLEdBQThCQSxVQUFVLENBQUNuQixRQUExQyxLQUF1RE8sSUFBSSxDQUFDUCxRQUE1RTtFQUNIOztFQUNELE9BQU9PLElBQVA7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm8uanM/MGQyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0TmV4dFBhdGhuYW1lSW5mbyA9IGdldE5leHRQYXRobmFtZUluZm87XG52YXIgX25vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi4vLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG52YXIgX3JlbW92ZVBhdGhQcmVmaXggPSByZXF1aXJlKFwiLi9yZW1vdmUtcGF0aC1wcmVmaXhcIik7XG52YXIgX3BhdGhIYXNQcmVmaXggPSByZXF1aXJlKFwiLi9wYXRoLWhhcy1wcmVmaXhcIik7XG5mdW5jdGlvbiBnZXROZXh0UGF0aG5hbWVJbmZvKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9uZXh0Q29uZmlnO1xuICAgIGNvbnN0IHsgYmFzZVBhdGggLCBpMThuICwgdHJhaWxpbmdTbGFzaCAgfSA9IChfbmV4dENvbmZpZyA9IG9wdGlvbnMubmV4dENvbmZpZykgIT0gbnVsbCA/IF9uZXh0Q29uZmlnIDoge307XG4gICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgICB0cmFpbGluZ1NsYXNoOiBwYXRobmFtZSAhPT0gJy8nID8gcGF0aG5hbWUuZW5kc1dpdGgoJy8nKSA6IHRyYWlsaW5nU2xhc2hcbiAgICB9O1xuICAgIGlmIChiYXNlUGF0aCAmJiAoMCwgX3BhdGhIYXNQcmVmaXgpLnBhdGhIYXNQcmVmaXgoaW5mby5wYXRobmFtZSwgYmFzZVBhdGgpKSB7XG4gICAgICAgIGluZm8ucGF0aG5hbWUgPSAoMCwgX3JlbW92ZVBhdGhQcmVmaXgpLnJlbW92ZVBhdGhQcmVmaXgoaW5mby5wYXRobmFtZSwgYmFzZVBhdGgpO1xuICAgICAgICBpbmZvLmJhc2VQYXRoID0gYmFzZVBhdGg7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhcnNlRGF0YSA9PT0gdHJ1ZSAmJiBpbmZvLnBhdGhuYW1lLnN0YXJ0c1dpdGgoJy9fbmV4dC9kYXRhLycpICYmIGluZm8ucGF0aG5hbWUuZW5kc1dpdGgoJy5qc29uJykpIHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBpbmZvLnBhdGhuYW1lLnJlcGxhY2UoL15cXC9fbmV4dFxcL2RhdGFcXC8vLCAnJykucmVwbGFjZSgvXFwuanNvbiQvLCAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3QgYnVpbGRJZCA9IHBhdGhzWzBdO1xuICAgICAgICBpbmZvLnBhdGhuYW1lID0gcGF0aHNbMV0gIT09ICdpbmRleCcgPyBgLyR7cGF0aHMuc2xpY2UoMSkuam9pbignLycpfWAgOiAnLyc7XG4gICAgICAgIGluZm8uYnVpbGRJZCA9IGJ1aWxkSWQ7XG4gICAgfVxuICAgIGlmIChpMThuKSB7XG4gICAgICAgIGNvbnN0IHBhdGhMb2NhbGUgPSAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoaW5mby5wYXRobmFtZSwgaTE4bi5sb2NhbGVzKTtcbiAgICAgICAgaW5mby5sb2NhbGUgPSBwYXRoTG9jYWxlID09IG51bGwgPyB2b2lkIDAgOiBwYXRoTG9jYWxlLmRldGVjdGVkTG9jYWxlO1xuICAgICAgICBpbmZvLnBhdGhuYW1lID0gKHBhdGhMb2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBhdGhMb2NhbGUucGF0aG5hbWUpIHx8IGluZm8ucGF0aG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldE5leHRQYXRobmFtZUluZm8iLCJfbm9ybWFsaXplTG9jYWxlUGF0aCIsInJlcXVpcmUiLCJfcmVtb3ZlUGF0aFByZWZpeCIsIl9wYXRoSGFzUHJlZml4IiwicGF0aG5hbWUiLCJvcHRpb25zIiwiX25leHRDb25maWciLCJiYXNlUGF0aCIsImkxOG4iLCJ0cmFpbGluZ1NsYXNoIiwibmV4dENvbmZpZyIsImluZm8iLCJlbmRzV2l0aCIsInBhdGhIYXNQcmVmaXgiLCJyZW1vdmVQYXRoUHJlZml4IiwicGFyc2VEYXRhIiwic3RhcnRzV2l0aCIsInBhdGhzIiwicmVwbGFjZSIsInNwbGl0IiwiYnVpbGRJZCIsInNsaWNlIiwiam9pbiIsInBhdGhMb2NhbGUiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwibG9jYWxlcyIsImxvY2FsZSIsImRldGVjdGVkTG9jYWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/parse-path.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.parsePath = parsePath;\n\nfunction parsePath(path) {\n  const hashIndex = path.indexOf('#');\n  const queryIndex = path.indexOf('?');\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : ''\n    };\n  }\n\n  return {\n    pathname: path,\n    query: '',\n    hash: ''\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxpQkFBQSxHQUFvQkUsU0FBcEI7O0FBQ0EsU0FBU0EsU0FBVCxDQUFtQkMsSUFBbkIsRUFBeUI7RUFDckIsTUFBTUMsU0FBUyxHQUFHRCxJQUFJLENBQUNFLE9BQUwsQ0FBYSxHQUFiLENBQWxCO0VBQ0EsTUFBTUMsVUFBVSxHQUFHSCxJQUFJLENBQUNFLE9BQUwsQ0FBYSxHQUFiLENBQW5CO0VBQ0EsTUFBTUUsUUFBUSxHQUFHRCxVQUFVLEdBQUcsQ0FBQyxDQUFkLEtBQW9CRixTQUFTLEdBQUcsQ0FBWixJQUFpQkUsVUFBVSxHQUFHRixTQUFsRCxDQUFqQjs7RUFDQSxJQUFJRyxRQUFRLElBQUlILFNBQVMsR0FBRyxDQUFDLENBQTdCLEVBQWdDO0lBQzVCLE9BQU87TUFDSEksUUFBUSxFQUFFTCxJQUFJLENBQUNNLFNBQUwsQ0FBZSxDQUFmLEVBQWtCRixRQUFRLEdBQUdELFVBQUgsR0FBZ0JGLFNBQTFDLENBRFA7TUFFSE0sS0FBSyxFQUFFSCxRQUFRLEdBQUdKLElBQUksQ0FBQ00sU0FBTCxDQUFlSCxVQUFmLEVBQTJCRixTQUFTLEdBQUcsQ0FBQyxDQUFiLEdBQWlCQSxTQUFqQixHQUE2Qk8sU0FBeEQsQ0FBSCxHQUF3RSxFQUZwRjtNQUdIQyxJQUFJLEVBQUVSLFNBQVMsR0FBRyxDQUFDLENBQWIsR0FBaUJELElBQUksQ0FBQ1UsS0FBTCxDQUFXVCxTQUFYLENBQWpCLEdBQXlDO0lBSDVDLENBQVA7RUFLSDs7RUFDRCxPQUFPO0lBQ0hJLFFBQVEsRUFBRUwsSUFEUDtJQUVITyxLQUFLLEVBQUUsRUFGSjtJQUdIRSxJQUFJLEVBQUU7RUFISCxDQUFQO0FBS0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoLmpzP2U1MmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlUGF0aCA9IHBhcnNlUGF0aDtcbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gICAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICAgIGNvbnN0IGhhc1F1ZXJ5ID0gcXVlcnlJbmRleCA+IC0xICYmIChoYXNoSW5kZXggPCAwIHx8IHF1ZXJ5SW5kZXggPCBoYXNoSW5kZXgpO1xuICAgIGlmIChoYXNRdWVyeSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aG5hbWU6IHBhdGguc3Vic3RyaW5nKDAsIGhhc1F1ZXJ5ID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCksXG4gICAgICAgICAgICBxdWVyeTogaGFzUXVlcnkgPyBwYXRoLnN1YnN0cmluZyhxdWVyeUluZGV4LCBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHVuZGVmaW5lZCkgOiAnJyxcbiAgICAgICAgICAgIGhhc2g6IGhhc2hJbmRleCA+IC0xID8gcGF0aC5zbGljZShoYXNoSW5kZXgpIDogJydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgIHF1ZXJ5OiAnJyxcbiAgICAgICAgaGFzaDogJydcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlUGF0aCIsInBhdGgiLCJoYXNoSW5kZXgiLCJpbmRleE9mIiwicXVlcnlJbmRleCIsImhhc1F1ZXJ5IiwicGF0aG5hbWUiLCJzdWJzdHJpbmciLCJxdWVyeSIsInVuZGVmaW5lZCIsImhhc2giLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.pathHasPrefix = pathHasPrefix;\n\nvar _parsePath = __webpack_require__(/*! ./parse-path */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nfunction pathHasPrefix(path, prefix) {\n  if (typeof path !== 'string') {\n    return false;\n  }\n\n  const {\n    pathname\n  } = (0, _parsePath).parsePath(path);\n  return pathname === prefix || pathname.startsWith(prefix + '/');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXRoLWhhcy1wcmVmaXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELHFCQUFBLEdBQXdCRSxhQUF4Qjs7QUFDQSxJQUFJQyxVQUFVLEdBQUdDLG1CQUFPLENBQUMsaUdBQUQsQ0FBeEI7O0FBQ0EsU0FBU0YsYUFBVCxDQUF1QkcsSUFBdkIsRUFBNkJDLE1BQTdCLEVBQXFDO0VBQ2pDLElBQUksT0FBT0QsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtJQUMxQixPQUFPLEtBQVA7RUFDSDs7RUFDRCxNQUFNO0lBQUVFO0VBQUYsSUFBZ0IsQ0FBQyxHQUFHSixVQUFKLEVBQWdCSyxTQUFoQixDQUEwQkgsSUFBMUIsQ0FBdEI7RUFDQSxPQUFPRSxRQUFRLEtBQUtELE1BQWIsSUFBdUJDLFFBQVEsQ0FBQ0UsVUFBVCxDQUFvQkgsTUFBTSxHQUFHLEdBQTdCLENBQTlCO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXRoLWhhcy1wcmVmaXguanM/YjUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGF0aEhhc1ByZWZpeCA9IHBhdGhIYXNQcmVmaXg7XG52YXIgX3BhcnNlUGF0aCA9IHJlcXVpcmUoXCIuL3BhcnNlLXBhdGhcIik7XG5mdW5jdGlvbiBwYXRoSGFzUHJlZml4KHBhdGgsIHByZWZpeCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChwYXRoKTtcbiAgICByZXR1cm4gcGF0aG5hbWUgPT09IHByZWZpeCB8fCBwYXRobmFtZS5zdGFydHNXaXRoKHByZWZpeCArICcvJyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgtaGFzLXByZWZpeC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXRoSGFzUHJlZml4IiwiX3BhcnNlUGF0aCIsInJlcXVpcmUiLCJwYXRoIiwicHJlZml4IiwicGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJzdGFydHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/relativize-url.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/relativize-url.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.relativizeURL = relativizeURL;\n\nfunction relativizeURL(url, base) {\n  const baseURL = typeof base === 'string' ? new URL(base) : base;\n  const relative = new URL(url, base);\n  const origin = `${baseURL.protocol}//${baseURL.host}`;\n  return `${relative.protocol}//${relative.host}` === origin ? relative.toString().replace(origin, '') : relative.toString();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZWxhdGl2aXplLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQUQscUJBQUEsR0FBd0JFLGFBQXhCOztBQUNBLFNBQVNBLGFBQVQsQ0FBdUJDLEdBQXZCLEVBQTRCQyxJQUE1QixFQUFrQztFQUM5QixNQUFNQyxPQUFPLEdBQUcsT0FBT0QsSUFBUCxLQUFnQixRQUFoQixHQUEyQixJQUFJRSxHQUFKLENBQVFGLElBQVIsQ0FBM0IsR0FBMkNBLElBQTNEO0VBQ0EsTUFBTUcsUUFBUSxHQUFHLElBQUlELEdBQUosQ0FBUUgsR0FBUixFQUFhQyxJQUFiLENBQWpCO0VBQ0EsTUFBTUksTUFBTSxHQUFJLEdBQUVILE9BQU8sQ0FBQ0ksUUFBUyxLQUFJSixPQUFPLENBQUNLLElBQUssRUFBcEQ7RUFDQSxPQUFRLEdBQUVILFFBQVEsQ0FBQ0UsUUFBUyxLQUFJRixRQUFRLENBQUNHLElBQUssRUFBdkMsS0FBNkNGLE1BQTdDLEdBQXNERCxRQUFRLENBQUNJLFFBQVQsR0FBb0JDLE9BQXBCLENBQTRCSixNQUE1QixFQUFvQyxFQUFwQyxDQUF0RCxHQUFnR0QsUUFBUSxDQUFDSSxRQUFULEVBQXZHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZWxhdGl2aXplLXVybC5qcz8xZmI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWxhdGl2aXplVVJMID0gcmVsYXRpdml6ZVVSTDtcbmZ1bmN0aW9uIHJlbGF0aXZpemVVUkwodXJsLCBiYXNlKSB7XG4gICAgY29uc3QgYmFzZVVSTCA9IHR5cGVvZiBiYXNlID09PSAnc3RyaW5nJyA/IG5ldyBVUkwoYmFzZSkgOiBiYXNlO1xuICAgIGNvbnN0IHJlbGF0aXZlID0gbmV3IFVSTCh1cmwsIGJhc2UpO1xuICAgIGNvbnN0IG9yaWdpbiA9IGAke2Jhc2VVUkwucHJvdG9jb2x9Ly8ke2Jhc2VVUkwuaG9zdH1gO1xuICAgIHJldHVybiBgJHtyZWxhdGl2ZS5wcm90b2NvbH0vLyR7cmVsYXRpdmUuaG9zdH1gID09PSBvcmlnaW4gPyByZWxhdGl2ZS50b1N0cmluZygpLnJlcGxhY2Uob3JpZ2luLCAnJykgOiByZWxhdGl2ZS50b1N0cmluZygpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWxhdGl2aXplLXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZWxhdGl2aXplVVJMIiwidXJsIiwiYmFzZSIsImJhc2VVUkwiLCJVUkwiLCJyZWxhdGl2ZSIsIm9yaWdpbiIsInByb3RvY29sIiwiaG9zdCIsInRvU3RyaW5nIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/relativize-url.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.removePathPrefix = removePathPrefix;\n\nvar _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\n\nfunction removePathPrefix(path, prefix) {\n  if ((0, _pathHasPrefix).pathHasPrefix(path, prefix)) {\n    const withoutPrefix = path.slice(prefix.length);\n    return withoutPrefix.startsWith('/') ? withoutPrefix : `/${withoutPrefix}`;\n  }\n\n  return path;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtcGF0aC1wcmVmaXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELHdCQUFBLEdBQTJCRSxnQkFBM0I7O0FBQ0EsSUFBSUMsY0FBYyxHQUFHQyxtQkFBTyxDQUFDLDJHQUFELENBQTVCOztBQUNBLFNBQVNGLGdCQUFULENBQTBCRyxJQUExQixFQUFnQ0MsTUFBaEMsRUFBd0M7RUFDcEMsSUFBSSxDQUFDLEdBQUdILGNBQUosRUFBb0JJLGFBQXBCLENBQWtDRixJQUFsQyxFQUF3Q0MsTUFBeEMsQ0FBSixFQUFxRDtJQUNqRCxNQUFNRSxhQUFhLEdBQUdILElBQUksQ0FBQ0ksS0FBTCxDQUFXSCxNQUFNLENBQUNJLE1BQWxCLENBQXRCO0lBQ0EsT0FBT0YsYUFBYSxDQUFDRyxVQUFkLENBQXlCLEdBQXpCLElBQWdDSCxhQUFoQyxHQUFpRCxJQUFHQSxhQUFjLEVBQXpFO0VBQ0g7O0VBQ0QsT0FBT0gsSUFBUDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVtb3ZlLXBhdGgtcHJlZml4LmpzPzYxNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlbW92ZVBhdGhQcmVmaXggPSByZW1vdmVQYXRoUHJlZml4O1xudmFyIF9wYXRoSGFzUHJlZml4ID0gcmVxdWlyZShcIi4vcGF0aC1oYXMtcHJlZml4XCIpO1xuZnVuY3Rpb24gcmVtb3ZlUGF0aFByZWZpeChwYXRoLCBwcmVmaXgpIHtcbiAgICBpZiAoKDAsIF9wYXRoSGFzUHJlZml4KS5wYXRoSGFzUHJlZml4KHBhdGgsIHByZWZpeCkpIHtcbiAgICAgICAgY29uc3Qgd2l0aG91dFByZWZpeCA9IHBhdGguc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB3aXRob3V0UHJlZml4LnN0YXJ0c1dpdGgoJy8nKSA/IHdpdGhvdXRQcmVmaXggOiBgLyR7d2l0aG91dFByZWZpeH1gO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLXBhdGgtcHJlZml4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlbW92ZVBhdGhQcmVmaXgiLCJfcGF0aEhhc1ByZWZpeCIsInJlcXVpcmUiLCJwYXRoIiwicHJlZml4IiwicGF0aEhhc1ByZWZpeCIsIndpdGhvdXRQcmVmaXgiLCJzbGljZSIsImxlbmd0aCIsInN0YXJ0c1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.removeTrailingSlash = removeTrailingSlash;\n\nfunction removeTrailingSlash(route) {\n  return route.replace(/\\/$/, '') || '/';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELDJCQUFBLEdBQThCRSxtQkFBOUI7O0FBQ0EsU0FBU0EsbUJBQVQsQ0FBNkJDLEtBQTdCLEVBQW9DO0VBQ2hDLE9BQU9BLEtBQUssQ0FBQ0MsT0FBTixDQUFjLEtBQWQsRUFBcUIsRUFBckIsS0FBNEIsR0FBbkM7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaC5qcz9lYzA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZW1vdmVUcmFpbGluZ1NsYXNoID0gcmVtb3ZlVHJhaWxpbmdTbGFzaDtcbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2gocm91dGUpIHtcbiAgICByZXR1cm4gcm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLyc7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZS10cmFpbGluZy1zbGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwicm91dGUiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\n");

/***/ }),

/***/ "(middleware)/./pages/api/createImage.js":
/*!**********************************!*\
  !*** ./pages/api/createImage.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"config\": () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _vercel_og__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vercel/og */ \"(middleware)/./node_modules/@vercel/og/dist/index.js\");\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ \"(middleware)/./node_modules/node-fetch/browser.js\");\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(middleware)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__);\nvar _jsxFileName = \"D:\\\\Programmation\\\\JavaScript\\\\react\\\\svg-generator\\\\pages\\\\api\\\\createImage.js\";\n\n\n\n\nconst config = {\n  runtime: 'experimental-edge'\n};\n/* harmony default export */ async function __WEBPACK_DEFAULT_EXPORT__(req, res) {\n  const {\n    searchParams\n  } = new URL(req.url); // make a searchParam object\n\n  const text = decodeURI(searchParams.get(\"text\"));\n  const hasZoom = !searchParams.get(\"zoom\") ? false : true;\n  const zoomProprety = hasZoom ? \"cover\" : \"contain\";\n  let image = searchParams.get(\"image\");\n  let isImage = false;\n\n  try {\n    const resp = await node_fetch__WEBPACK_IMPORTED_MODULE_1___default()(image);\n    isImage = resp.headers.get(\"Content-Type\").includes(\"image\");\n  } catch (err) {\n    console.log(err);\n  } // ?? -> if first is null or undefined\n  // || -> if first is any falsy value\n\n\n  if (!isImage) image = \"\";\n\n  if (!text || !image) {\n    let reason = \"\";\n\n    if (!text && image) {\n      reason = \"No text !\";\n    } else if (!image && text) {\n      reason = \"No image\";\n    } else {\n      reason = \"No text and image\";\n    }\n\n    const left = reason === \"No text and image\" ? \"0\" : \"170px\";\n    return new _vercel_og__WEBPACK_IMPORTED_MODULE_0__.ImageResponse( /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"div\", {\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#333\",\n          width: \"200%\",\n          height: \"100%\"\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 45,\n        columnNumber: 11\n      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"div\", {\n        style: {\n          display: \"flex\",\n          alignItems: \"center\",\n          backgroundColor: \"#333\",\n          position: \"relative\",\n          left: left,\n          top: \"130px\"\n        },\n        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"img\", {\n          src: \"https://www.freeiconspng.com/thumbs/warning-icon-png/sign-warning-icon-png-7.png\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 54,\n          columnNumber: 13\n        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"span\", {\n          style: {\n            color: \"red\",\n            fontFamily: \"system-ui\",\n            fontSize: \"100px\"\n          },\n          children: reason\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 55,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 46,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true));\n  } else {\n    return new _vercel_og__WEBPACK_IMPORTED_MODULE_0__.ImageResponse( /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"head\", {\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#333\",\n          height: \"630px\"\n        },\n        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"img\", {\n          onError: () => {\n            console.log(\"holy shit !\");\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#333\",\n            objectFit: zoomProprety,\n            height: \"480px\",\n            width: \"1200px\"\n          },\n          src: image\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 67,\n          columnNumber: 13\n        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"div\", {\n          style: {\n            borderRadius: \"10px\",\n            display: \"flex\",\n            width: \"1200px\",\n            backgroundColor: \"#333\",\n            height: \"150px\",\n            position: \"relative\",\n            top: \"480px\"\n          },\n          children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"span\", {\n            style: {\n              color: \"#bebebe\",\n              fontWeight: \"900\",\n              fontSize: \"100px\",\n              marginLeft: \"auto\",\n              marginRight: \"auto\"\n            },\n            children: text\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 69,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 68,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 66,\n        columnNumber: 11\n      }, this)\n    }, void 0, false));\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vcGFnZXMvYXBpL2NyZWF0ZUltYWdlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBSU8sTUFBTUUsTUFBTSxHQUFHO0VBQ3BCQyxPQUFPLEVBQUU7QUFEVyxDQUFmO0FBSVAsNkJBQWUsMENBQWdCQyxHQUFoQixFQUFxQkMsR0FBckIsRUFBMEI7RUFDdkMsTUFBTTtJQUFFQztFQUFGLElBQW1CLElBQUlDLEdBQUosQ0FBUUgsR0FBRyxDQUFDSSxHQUFaLENBQXpCLENBRHVDLENBQ0c7O0VBQzFDLE1BQU1DLElBQUksR0FBR0MsU0FBUyxDQUFDSixZQUFZLENBQUNLLEdBQWIsQ0FBaUIsTUFBakIsQ0FBRCxDQUF0QjtFQUNBLE1BQU1DLE9BQU8sR0FBRyxDQUFDTixZQUFZLENBQUNLLEdBQWIsQ0FBaUIsTUFBakIsQ0FBRCxHQUE0QixLQUE1QixHQUFvQyxJQUFwRDtFQUNBLE1BQU1FLFlBQVksR0FBR0QsT0FBTyxHQUFHLE9BQUgsR0FBYSxTQUF6QztFQUNBLElBQUlFLEtBQUssR0FBR1IsWUFBWSxDQUFDSyxHQUFiLENBQWlCLE9BQWpCLENBQVo7RUFDQSxJQUFJSSxPQUFPLEdBQUcsS0FBZDs7RUFJRSxJQUFJO0lBQ0YsTUFBTUMsSUFBSSxHQUFHLE1BQU1mLGlEQUFLLENBQUNhLEtBQUQsQ0FBeEI7SUFDQUMsT0FBTyxHQUFHQyxJQUFJLENBQUNDLE9BQUwsQ0FBYU4sR0FBYixDQUFpQixjQUFqQixFQUFpQ08sUUFBakMsQ0FBMEMsT0FBMUMsQ0FBVjtFQUNELENBSEQsQ0FHRSxPQUFPQyxHQUFQLEVBQVk7SUFDWkMsT0FBTyxDQUFDQyxHQUFSLENBQVlGLEdBQVo7RUFDRCxDQWZvQyxDQWtCckM7RUFDQTs7O0VBQ0EsSUFBSSxDQUFDSixPQUFMLEVBQWNELEtBQUssR0FBRyxFQUFSOztFQUNkLElBQUksQ0FBQ0wsSUFBRCxJQUFTLENBQUNLLEtBQWQsRUFBcUI7SUFDbkIsSUFBSVEsTUFBTSxHQUFHLEVBQWI7O0lBQ0EsSUFBSSxDQUFDYixJQUFELElBQVNLLEtBQWIsRUFBb0I7TUFDbEJRLE1BQU0sR0FBRyxXQUFUO0lBQ0QsQ0FGRCxNQUVNLElBQUksQ0FBQ1IsS0FBRCxJQUFVTCxJQUFkLEVBQW1CO01BQ3ZCYSxNQUFNLEdBQUcsVUFBVDtJQUNELENBRkssTUFFQTtNQUNKQSxNQUFNLEdBQUcsbUJBQVQ7SUFDRDs7SUFDRCxNQUFNQyxJQUFJLEdBQUdELE1BQU0sS0FBSyxtQkFBWCxHQUFpQyxHQUFqQyxHQUF1QyxPQUFwRDtJQUNBLE9BQU8sSUFBSXRCLHFEQUFKLGVBR0w7TUFBQSx3QkFDRTtRQUFLLEtBQUssRUFBRTtVQUFDd0IsUUFBUSxFQUFHLFVBQVo7VUFBeUJDLGVBQWUsRUFBRyxNQUEzQztVQUFvREMsS0FBSyxFQUFHLE1BQTVEO1VBQXFFQyxNQUFNLEVBQUc7UUFBOUU7TUFBWjtRQUFBO1FBQUE7UUFBQTtNQUFBLFFBREYsZUFFRTtRQUFLLEtBQUssRUFBRTtVQUNWQyxPQUFPLEVBQUUsTUFEQztVQUVWQyxVQUFVLEVBQUcsUUFGSDtVQUdWSixlQUFlLEVBQUcsTUFIUjtVQUlWRCxRQUFRLEVBQUcsVUFKRDtVQUtWRCxJQUFJLEVBQUdBLElBTEc7VUFNVk8sR0FBRyxFQUFHO1FBTkksQ0FBWjtRQUFBLHdCQVFFO1VBQUssR0FBRyxFQUFDO1FBQVQ7VUFBQTtVQUFBO1VBQUE7UUFBQSxRQVJGLGVBU0U7VUFBTSxLQUFLLEVBQUU7WUFBQ0MsS0FBSyxFQUFHLEtBQVQ7WUFBaUJDLFVBQVUsRUFBRSxXQUE3QjtZQUEyQ0MsUUFBUSxFQUFHO1VBQXRELENBQWI7VUFBQSxVQUE4RVg7UUFBOUU7VUFBQTtVQUFBO1VBQUE7UUFBQSxRQVRGO01BQUE7UUFBQTtRQUFBO1FBQUE7TUFBQSxRQUZGO0lBQUEsZ0JBSEssQ0FBUDtFQW1CRCxDQTdCRCxNQTZCTTtJQUVKLE9BQU8sSUFBSXRCLHFEQUFKLGVBRUg7TUFBQSx1QkFFQTtRQUFNLEtBQUssRUFBRTtVQUFDd0IsUUFBUSxFQUFHLFVBQVo7VUFBdUJDLGVBQWUsRUFBRyxNQUF6QztVQUFrREUsTUFBTSxFQUFHO1FBQTNELENBQWI7UUFBQSx3QkFDRTtVQUFLLE9BQU8sRUFBRSxNQUFNO1lBQUNQLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLGFBQVo7VUFBMkIsQ0FBaEQ7VUFBa0QsS0FBSyxFQUFFO1lBQUNHLFFBQVEsRUFBRyxVQUFaO1lBQXlCQyxlQUFlLEVBQUcsTUFBM0M7WUFBb0RTLFNBQVMsRUFBR3JCLFlBQWhFO1lBQStFYyxNQUFNLEVBQUcsT0FBeEY7WUFBa0dELEtBQUssRUFBRztVQUExRyxDQUF6RDtVQUE4SyxHQUFHLEVBQUVaO1FBQW5MO1VBQUE7VUFBQTtVQUFBO1FBQUEsUUFERixlQUVFO1VBQUssS0FBSyxFQUFFO1lBQUVxQixZQUFZLEVBQUcsTUFBakI7WUFBeUJQLE9BQU8sRUFBRyxNQUFuQztZQUEwQ0YsS0FBSyxFQUFHLFFBQWxEO1lBQTRERCxlQUFlLEVBQUcsTUFBOUU7WUFBc0ZFLE1BQU0sRUFBRyxPQUEvRjtZQUF3R0gsUUFBUSxFQUFHLFVBQW5IO1lBQWdJTSxHQUFHLEVBQUc7VUFBdEksQ0FBWjtVQUFBLHVCQUNFO1lBQU0sS0FBSyxFQUFFO2NBQUNDLEtBQUssRUFBRyxTQUFUO2NBQW9CSyxVQUFVLEVBQUcsS0FBakM7Y0FBd0NILFFBQVEsRUFBRyxPQUFuRDtjQUE2REksVUFBVSxFQUFHLE1BQTFFO2NBQW1GQyxXQUFXLEVBQUc7WUFBakcsQ0FBYjtZQUFBLFVBQXdIN0I7VUFBeEg7WUFBQTtZQUFBO1lBQUE7VUFBQTtRQURGO1VBQUE7VUFBQTtVQUFBO1FBQUEsUUFGRjtNQUFBO1FBQUE7UUFBQTtRQUFBO01BQUE7SUFGQSxpQkFGRyxDQUFQO0VBYUM7QUFFRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9hcGkvY3JlYXRlSW1hZ2UuanM/YzU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbWFnZVJlc3BvbnNlIH0gZnJvbSBcIkB2ZXJjZWwvb2dcIlxuaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCJcblxuXG5cbmV4cG9ydCBjb25zdCBjb25maWcgPSB7XG4gIHJ1bnRpbWU6ICdleHBlcmltZW50YWwtZWRnZScsXG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChyZXEudXJsKSAvLyBtYWtlIGEgc2VhcmNoUGFyYW0gb2JqZWN0XG4gIGNvbnN0IHRleHQgPSBkZWNvZGVVUkkoc2VhcmNoUGFyYW1zLmdldChcInRleHRcIikpXG4gIGNvbnN0IGhhc1pvb20gPSAhc2VhcmNoUGFyYW1zLmdldChcInpvb21cIikgPyBmYWxzZSA6IHRydWVcbiAgY29uc3Qgem9vbVByb3ByZXR5ID0gaGFzWm9vbSA/IFwiY292ZXJcIiA6IFwiY29udGFpblwiXG4gIGxldCBpbWFnZSA9IHNlYXJjaFBhcmFtcy5nZXQoXCJpbWFnZVwiKVxuICBsZXQgaXNJbWFnZSA9IGZhbHNlXG5cblxuICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGltYWdlKTtcbiAgICAgIGlzSW1hZ2UgPSByZXNwLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpLmluY2x1ZGVzKFwiaW1hZ2VcIilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycilcbiAgICB9XG4gIFxuICBcbiAgICAvLyA/PyAtPiBpZiBmaXJzdCBpcyBudWxsIG9yIHVuZGVmaW5lZFxuICAgIC8vIHx8IC0+IGlmIGZpcnN0IGlzIGFueSBmYWxzeSB2YWx1ZVxuICAgIGlmICghaXNJbWFnZSkgaW1hZ2UgPSBcIlwiIFxuICAgIGlmICghdGV4dCB8fCAhaW1hZ2UpIHsgXG4gICAgICBsZXQgcmVhc29uID0gXCJcIlxuICAgICAgaWYgKCF0ZXh0ICYmIGltYWdlKSB7XG4gICAgICAgIHJlYXNvbiA9IFwiTm8gdGV4dCAhXCJcbiAgICAgIH1lbHNlIGlmICghaW1hZ2UgJiYgdGV4dCl7XG4gICAgICAgIHJlYXNvbiA9IFwiTm8gaW1hZ2VcIlxuICAgICAgfWVsc2Uge1xuICAgICAgICByZWFzb24gPSBcIk5vIHRleHQgYW5kIGltYWdlXCJcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlZnQgPSByZWFzb24gPT09IFwiTm8gdGV4dCBhbmQgaW1hZ2VcIiA/IFwiMFwiIDogXCIxNzBweFwiXG4gICAgICByZXR1cm4gbmV3IEltYWdlUmVzcG9uc2UoXG4gICAgICAgIChcbiAgICBcbiAgICAgICAgPD5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7cG9zaXRpb24gOiBcImFic29sdXRlXCIgLCBiYWNrZ3JvdW5kQ29sb3IgOiBcIiMzMzNcIiAsIHdpZHRoIDogXCIyMDAlXCIgLCBoZWlnaHQgOiBcIjEwMCVcIix9fT48L2Rpdj5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7XG4gICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgIGFsaWduSXRlbXMgOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yIDogXCIjMzMzXCIsXG4gICAgICAgICAgICBwb3NpdGlvbiA6IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgIGxlZnQgOiBsZWZ0LFxuICAgICAgICAgICAgdG9wIDogXCIxMzBweFwiLFxuICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vd3d3LmZyZWVpY29uc3BuZy5jb20vdGh1bWJzL3dhcm5pbmctaWNvbi1wbmcvc2lnbi13YXJuaW5nLWljb24tcG5nLTcucG5nXCIgLz5cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7Y29sb3IgOiBcInJlZFwiICwgZm9udEZhbWlseTogXCJzeXN0ZW0tdWlcIiAsIGZvbnRTaXplIDogXCIxMDBweFwifX0+e3JlYXNvbn08L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgICAgICApXG4gICAgICApXG4gICAgfWVsc2Uge1xuICBcbiAgICAgIHJldHVybiBuZXcgSW1hZ2VSZXNwb25zZShcbiAgICAgICAgICAoXG4gICAgICAgICAgPD5cbiAgICBcbiAgICAgICAgICA8aGVhZCBzdHlsZT17e3Bvc2l0aW9uIDogXCJhYnNvbHV0ZVwiLGJhY2tncm91bmRDb2xvciA6IFwiIzMzM1wiICwgaGVpZ2h0IDogXCI2MzBweFwifX0+XG4gICAgICAgICAgICA8aW1nIG9uRXJyb3I9eygpID0+IHtjb25zb2xlLmxvZyhcImhvbHkgc2hpdCAhXCIpfX0gc3R5bGU9e3twb3NpdGlvbiA6IFwiYWJzb2x1dGVcIiAsIGJhY2tncm91bmRDb2xvciA6IFwiIzMzM1wiICwgb2JqZWN0Rml0IDogem9vbVByb3ByZXR5ICwgaGVpZ2h0IDogXCI0ODBweFwiICwgd2lkdGggOiBcIjEyMDBweFwifX0gc3JjPXtpbWFnZX0+PC9pbWc+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGJvcmRlclJhZGl1cyA6IFwiMTBweFwiLCBkaXNwbGF5IDogXCJmbGV4XCIsd2lkdGggOiBcIjEyMDBweFwiLCBiYWNrZ3JvdW5kQ29sb3IgOiBcIiMzMzNcIiwgaGVpZ2h0IDogXCIxNTBweFwiLCBwb3NpdGlvbiA6IFwicmVsYXRpdmVcIiAsIHRvcCA6IFwiNDgwcHhcIn19PlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17e2NvbG9yIDogXCIjYmViZWJlXCIgLGZvbnRXZWlnaHQgOiBcIjkwMFwiLCBmb250U2l6ZSA6IFwiMTAwcHhcIiAsIG1hcmdpbkxlZnQgOiBcImF1dG9cIiAsIG1hcmdpblJpZ2h0IDogXCJhdXRvXCJ9fT57dGV4dH08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2hlYWQ+XG4gICAgICAgICAgPC8+XG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9XG4gIFxuICAgIH1cblxuXG4iXSwibmFtZXMiOlsiSW1hZ2VSZXNwb25zZSIsImZldGNoIiwiY29uZmlnIiwicnVudGltZSIsInJlcSIsInJlcyIsInNlYXJjaFBhcmFtcyIsIlVSTCIsInVybCIsInRleHQiLCJkZWNvZGVVUkkiLCJnZXQiLCJoYXNab29tIiwiem9vbVByb3ByZXR5IiwiaW1hZ2UiLCJpc0ltYWdlIiwicmVzcCIsImhlYWRlcnMiLCJpbmNsdWRlcyIsImVyciIsImNvbnNvbGUiLCJsb2ciLCJyZWFzb24iLCJsZWZ0IiwicG9zaXRpb24iLCJiYWNrZ3JvdW5kQ29sb3IiLCJ3aWR0aCIsImhlaWdodCIsImRpc3BsYXkiLCJhbGlnbkl0ZW1zIiwidG9wIiwiY29sb3IiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJvYmplY3RGaXQiLCJib3JkZXJSYWRpdXMiLCJmb250V2VpZ2h0IiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./pages/api/createImage.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/build/webpack/loaders/next-edge-function-loader.js?absolutePagePath=D%3A%5CProgrammation%5CJavaScript%5Creact%5Csvg-generator%5Cpages%5Capi%5CcreateImage.js&page=%2Fapi%2FcreateImage&rootDir=D%3A%5CProgrammation%5CJavaScript%5Creact%5Csvg-generator!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-edge-function-loader.js?absolutePagePath=D%3A%5CProgrammation%5CJavaScript%5Creact%5Csvg-generator%5Cpages%5Capi%5CcreateImage.js&page=%2Fapi%2FcreateImage&rootDir=D%3A%5CProgrammation%5CJavaScript%5Creact%5Csvg-generator! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_web_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/web/adapter */ \"(middleware)/./node_modules/next/dist/server/web/adapter.js\");\n\n        \n\n        (0,next_dist_server_web_adapter__WEBPACK_IMPORTED_MODULE_0__.enhanceGlobals)()\n\n        var mod = __webpack_require__(/*! ./pages/api/createImage.js */ \"(middleware)/./pages/api/createImage.js\")\n        var handler = mod.middleware || mod.default;\n\n        if (typeof handler !== 'function') {\n          throw new Error('The Edge Function \"pages/api/createImage\" must export a `default` function');\n        }\n\n        /* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(opts) {\n          return (0,next_dist_server_web_adapter__WEBPACK_IMPORTED_MODULE_0__.adapter)({\n              ...opts,\n              page: \"/api/createImage\",\n              handler,\n          })\n        }\n    //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1lZGdlLWZ1bmN0aW9uLWxvYWRlci5qcz9hYnNvbHV0ZVBhZ2VQYXRoPUQlM0ElNUNQcm9ncmFtbWF0aW9uJTVDSmF2YVNjcmlwdCU1Q3JlYWN0JTVDc3ZnLWdlbmVyYXRvciU1Q3BhZ2VzJTVDYXBpJTVDY3JlYXRlSW1hZ2UuanMmcGFnZT0lMkZhcGklMkZjcmVhdGVJbWFnZSZyb290RGlyPUQlM0ElNUNQcm9ncmFtbWF0aW9uJTVDSmF2YVNjcmlwdCU1Q3JlYWN0JTVDc3ZnLWdlbmVyYXRvciEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsUUFBOEU7O0FBRTlFLFFBQVEsNEVBQWM7O0FBRXRCLGtCQUFrQixtQkFBTyxDQUFDLDJFQUE0QjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw2QkFBZSxvQ0FBVTtBQUNqQyxpQkFBaUIscUVBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz83NjkzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgICBpbXBvcnQgeyBhZGFwdGVyLCBlbmhhbmNlR2xvYmFscyB9IGZyb20gJ25leHQvZGlzdC9zZXJ2ZXIvd2ViL2FkYXB0ZXInXG5cbiAgICAgICAgZW5oYW5jZUdsb2JhbHMoKVxuXG4gICAgICAgIHZhciBtb2QgPSByZXF1aXJlKFwiLi9wYWdlcy9hcGkvY3JlYXRlSW1hZ2UuanNcIilcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBtb2QubWlkZGxld2FyZSB8fCBtb2QuZGVmYXVsdDtcblxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBFZGdlIEZ1bmN0aW9uIFwicGFnZXMvYXBpL2NyZWF0ZUltYWdlXCIgbXVzdCBleHBvcnQgYSBgZGVmYXVsdGAgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgcmV0dXJuIGFkYXB0ZXIoe1xuICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgICBwYWdlOiBcIi9hcGkvY3JlYXRlSW1hZ2VcIixcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/build/webpack/loaders/next-edge-function-loader.js?absolutePagePath=D%3A%5CProgrammation%5CJavaScript%5Creact%5Csvg-generator%5Cpages%5Capi%5CcreateImage.js&page=%2Fapi%2FcreateImage&rootDir=D%3A%5CProgrammation%5CJavaScript%5Creact%5Csvg-generator!\n");

/***/ }),

/***/ "(edge-asset)/./node_modules/@vercel/og/vendor/noto-sans-v27-latin-regular.ttf":
/*!************************************************************************!*\
  !*** ./node_modules/@vercel/og/vendor/noto-sans-v27-latin-regular.ttf ***!
  \************************************************************************/
/***/ ((module) => {

eval("module.exports = \"blob:noto-sans-v27-latin-regular.5dda3fca77107598.ttf\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGVkZ2UtYXNzZXQpLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvb2cvdmVuZG9yL25vdG8tc2Fucy12MjctbGF0aW4tcmVndWxhci50dGYuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvb2cvdmVuZG9yL25vdG8tc2Fucy12MjctbGF0aW4tcmVndWxhci50dGY/ZTk0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiYmxvYjpub3RvLXNhbnMtdjI3LWxhdGluLXJlZ3VsYXIuNWRkYTNmY2E3NzEwNzU5OC50dGZcIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(edge-asset)/./node_modules/@vercel/og/vendor/noto-sans-v27-latin-regular.ttf\n");

/***/ }),

/***/ "(middleware)/./node_modules/@vercel/og/vendor/resvg.simd.wasm?module":
/*!***************************************************************!*\
  !*** ./node_modules/@vercel/og/vendor/resvg.simd.wasm?module ***!
  \***************************************************************/
/***/ ((module) => {

eval("module.exports = wasm_53adb396180a95eb122a0218c93e3d6474b1a27e;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvb2cvdmVuZG9yL3Jlc3ZnLnNpbWQud2FzbT9tb2R1bGUuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvb2cvdmVuZG9yL3Jlc3ZnLnNpbWQud2FzbT80ZmYxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gd2FzbV81M2FkYjM5NjE4MGE5NWViMTIyYTAyMThjOTNlM2Q2NDc0YjFhMjdlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/@vercel/og/vendor/resvg.simd.wasm?module\n");

/***/ }),

/***/ "(middleware)/./node_modules/@vercel/og/vendor/yoga.wasm?module":
/*!*********************************************************!*\
  !*** ./node_modules/@vercel/og/vendor/yoga.wasm?module ***!
  \*********************************************************/
/***/ ((module) => {

eval("module.exports = wasm_5b50c798761dc0131e9ebe945031077e8a02633b;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvb2cvdmVuZG9yL3lvZ2Eud2FzbT9tb2R1bGUuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvb2cvdmVuZG9yL3lvZ2Eud2FzbT83NGExIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gd2FzbV81YjUwYzc5ODc2MWRjMDEzMWU5ZWJlOTQ1MDMxMDc3ZThhMDI2MzNiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/@vercel/og/vendor/yoga.wasm?module\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/compiled/cookie/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/cookie/index.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("var __dirname = \"/\";\n(()=>{\"use strict\";if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var e={};(()=>{var r=e;\n/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */r.parse=parse;r.serialize=serialize;var i=decodeURIComponent;var t=encodeURIComponent;var a=/; */;var n=/^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;function parse(e,r){if(typeof e!==\"string\"){throw new TypeError(\"argument str must be a string\")}var t={};var n=r||{};var o=e.split(a);var s=n.decode||i;for(var p=0;p<o.length;p++){var f=o[p];var u=f.indexOf(\"=\");if(u<0){continue}var v=f.substr(0,u).trim();var c=f.substr(++u,f.length).trim();if('\"'==c[0]){c=c.slice(1,-1)}if(undefined==t[v]){t[v]=tryDecode(c,s)}}return t}function serialize(e,r,i){var a=i||{};var o=a.encode||t;if(typeof o!==\"function\"){throw new TypeError(\"option encode is invalid\")}if(!n.test(e)){throw new TypeError(\"argument name is invalid\")}var s=o(r);if(s&&!n.test(s)){throw new TypeError(\"argument val is invalid\")}var p=e+\"=\"+s;if(null!=a.maxAge){var f=a.maxAge-0;if(isNaN(f)||!isFinite(f)){throw new TypeError(\"option maxAge is invalid\")}p+=\"; Max-Age=\"+Math.floor(f)}if(a.domain){if(!n.test(a.domain)){throw new TypeError(\"option domain is invalid\")}p+=\"; Domain=\"+a.domain}if(a.path){if(!n.test(a.path)){throw new TypeError(\"option path is invalid\")}p+=\"; Path=\"+a.path}if(a.expires){if(typeof a.expires.toUTCString!==\"function\"){throw new TypeError(\"option expires is invalid\")}p+=\"; Expires=\"+a.expires.toUTCString()}if(a.httpOnly){p+=\"; HttpOnly\"}if(a.secure){p+=\"; Secure\"}if(a.sameSite){var u=typeof a.sameSite===\"string\"?a.sameSite.toLowerCase():a.sameSite;switch(u){case true:p+=\"; SameSite=Strict\";break;case\"lax\":p+=\"; SameSite=Lax\";break;case\"strict\":p+=\"; SameSite=Strict\";break;case\"none\":p+=\"; SameSite=None\";break;default:throw new TypeError(\"option sameSite is invalid\")}}return p}function tryDecode(e,r){try{return r(e)}catch(r){return e}}})();module.exports=e})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jb29raWUvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU0sYUFBYSxtRUFBbUUsU0FBUyxLQUFLLFNBQVMsTUFBTTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQix5QkFBeUIseUJBQXlCLFNBQVMsR0FBRyw4Q0FBOEMsb0JBQW9CLHdCQUF3QixxREFBcUQsU0FBUyxZQUFZLGlCQUFpQixrQkFBa0IsWUFBWSxXQUFXLEtBQUssV0FBVyxxQkFBcUIsUUFBUSxTQUFTLDJCQUEyQixvQ0FBb0MsY0FBYyxnQkFBZ0Isb0JBQW9CLHFCQUFxQixTQUFTLDBCQUEwQixZQUFZLGtCQUFrQiwwQkFBMEIsZ0RBQWdELGVBQWUsZ0RBQWdELFdBQVcsa0JBQWtCLCtDQUErQyxjQUFjLG1CQUFtQixpQkFBaUIsMkJBQTJCLGdEQUFnRCxNQUFNLHdCQUF3QixhQUFhLHNCQUFzQixnREFBZ0QsTUFBTSxrQkFBa0IsV0FBVyxvQkFBb0IsOENBQThDLE1BQU0sY0FBYyxjQUFjLDhDQUE4QyxpREFBaUQsTUFBTSxrQ0FBa0MsZUFBZSxNQUFNLFVBQVUsYUFBYSxNQUFNLFFBQVEsZUFBZSx1RUFBdUUsVUFBVSxnQkFBZ0IsaUJBQWlCLE1BQU0sZ0JBQWdCLGNBQWMsTUFBTSxtQkFBbUIsaUJBQWlCLE1BQU0saUJBQWlCLGVBQWUsTUFBTSwyREFBMkQsU0FBUyx3QkFBd0IsSUFBSSxZQUFZLFNBQVMsV0FBVyxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nvb2tpZS9pbmRleC5qcz8xNGIyIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO2lmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgZT17fTsoKCk9Pnt2YXIgcj1lO1xuLyohXG4gKiBjb29raWVcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgUm9tYW4gU2h0eWxtYW5cbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL3IucGFyc2U9cGFyc2U7ci5zZXJpYWxpemU9c2VyaWFsaXplO3ZhciBpPWRlY29kZVVSSUNvbXBvbmVudDt2YXIgdD1lbmNvZGVVUklDb21wb25lbnQ7dmFyIGE9LzsgKi87dmFyIG49L15bXFx1MDAwOVxcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1MDBmZl0rJC87ZnVuY3Rpb24gcGFyc2UoZSxyKXtpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzdHIgbXVzdCBiZSBhIHN0cmluZ1wiKX12YXIgdD17fTt2YXIgbj1yfHx7fTt2YXIgbz1lLnNwbGl0KGEpO3ZhciBzPW4uZGVjb2RlfHxpO2Zvcih2YXIgcD0wO3A8by5sZW5ndGg7cCsrKXt2YXIgZj1vW3BdO3ZhciB1PWYuaW5kZXhPZihcIj1cIik7aWYodTwwKXtjb250aW51ZX12YXIgdj1mLnN1YnN0cigwLHUpLnRyaW0oKTt2YXIgYz1mLnN1YnN0cigrK3UsZi5sZW5ndGgpLnRyaW0oKTtpZignXCInPT1jWzBdKXtjPWMuc2xpY2UoMSwtMSl9aWYodW5kZWZpbmVkPT10W3ZdKXt0W3ZdPXRyeURlY29kZShjLHMpfX1yZXR1cm4gdH1mdW5jdGlvbiBzZXJpYWxpemUoZSxyLGkpe3ZhciBhPWl8fHt9O3ZhciBvPWEuZW5jb2RlfHx0O2lmKHR5cGVvZiBvIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0aW9uIGVuY29kZSBpcyBpbnZhbGlkXCIpfWlmKCFuLnRlc3QoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBuYW1lIGlzIGludmFsaWRcIil9dmFyIHM9byhyKTtpZihzJiYhbi50ZXN0KHMpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgdmFsIGlzIGludmFsaWRcIil9dmFyIHA9ZStcIj1cIitzO2lmKG51bGwhPWEubWF4QWdlKXt2YXIgZj1hLm1heEFnZS0wO2lmKGlzTmFOKGYpfHwhaXNGaW5pdGUoZikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gbWF4QWdlIGlzIGludmFsaWRcIil9cCs9XCI7IE1heC1BZ2U9XCIrTWF0aC5mbG9vcihmKX1pZihhLmRvbWFpbil7aWYoIW4udGVzdChhLmRvbWFpbikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gZG9tYWluIGlzIGludmFsaWRcIil9cCs9XCI7IERvbWFpbj1cIithLmRvbWFpbn1pZihhLnBhdGgpe2lmKCFuLnRlc3QoYS5wYXRoKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbiBwYXRoIGlzIGludmFsaWRcIil9cCs9XCI7IFBhdGg9XCIrYS5wYXRofWlmKGEuZXhwaXJlcyl7aWYodHlwZW9mIGEuZXhwaXJlcy50b1VUQ1N0cmluZyE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbiBleHBpcmVzIGlzIGludmFsaWRcIil9cCs9XCI7IEV4cGlyZXM9XCIrYS5leHBpcmVzLnRvVVRDU3RyaW5nKCl9aWYoYS5odHRwT25seSl7cCs9XCI7IEh0dHBPbmx5XCJ9aWYoYS5zZWN1cmUpe3ArPVwiOyBTZWN1cmVcIn1pZihhLnNhbWVTaXRlKXt2YXIgdT10eXBlb2YgYS5zYW1lU2l0ZT09PVwic3RyaW5nXCI/YS5zYW1lU2l0ZS50b0xvd2VyQ2FzZSgpOmEuc2FtZVNpdGU7c3dpdGNoKHUpe2Nhc2UgdHJ1ZTpwKz1cIjsgU2FtZVNpdGU9U3RyaWN0XCI7YnJlYWs7Y2FzZVwibGF4XCI6cCs9XCI7IFNhbWVTaXRlPUxheFwiO2JyZWFrO2Nhc2VcInN0cmljdFwiOnArPVwiOyBTYW1lU2l0ZT1TdHJpY3RcIjticmVhaztjYXNlXCJub25lXCI6cCs9XCI7IFNhbWVTaXRlPU5vbmVcIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gc2FtZVNpdGUgaXMgaW52YWxpZFwiKX19cmV0dXJuIHB9ZnVuY3Rpb24gdHJ5RGVjb2RlKGUscil7dHJ5e3JldHVybiByKGUpfWNhdGNoKHIpe3JldHVybiBlfX19KSgpO21vZHVsZS5leHBvcnRzPWV9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/compiled/cookie/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/internal-utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/server/internal-utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.stripInternalQueries = stripInternalQueries;\nexports.stripInternalSearchParams = stripInternalSearchParams;\nconst INTERNAL_QUERY_NAMES = [\n    \"__nextFallback\",\n    \"__nextLocale\",\n    \"__nextDefaultLocale\",\n    \"__nextIsNotFound\",\n    // RSC\n    \"__flight__\",\n    // Routing\n    \"__flight_router_state_tree__\",\n    \"__flight_prefetch__\", \n];\nconst EXTENDED_INTERNAL_QUERY_NAMES = [\n    \"__nextDataReq\"\n];\nfunction stripInternalQueries(query) {\n    for (const name of INTERNAL_QUERY_NAMES){\n        delete query[name];\n    }\n}\nfunction stripInternalSearchParams(searchParams, extended) {\n    for (const name of INTERNAL_QUERY_NAMES){\n        searchParams.delete(name);\n    }\n    if (extended) {\n        for (const name of EXTENDED_INTERNAL_QUERY_NAMES){\n            searchParams.delete(name);\n        }\n    }\n    return searchParams;\n}\n\n//# sourceMappingURL=internal-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvaW50ZXJuYWwtdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiw0QkFBNEI7QUFDNUIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9pbnRlcm5hbC11dGlscy5qcz8wN2M5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zdHJpcEludGVybmFsUXVlcmllcyA9IHN0cmlwSW50ZXJuYWxRdWVyaWVzO1xuZXhwb3J0cy5zdHJpcEludGVybmFsU2VhcmNoUGFyYW1zID0gc3RyaXBJbnRlcm5hbFNlYXJjaFBhcmFtcztcbmNvbnN0IElOVEVSTkFMX1FVRVJZX05BTUVTID0gW1xuICAgIFwiX19uZXh0RmFsbGJhY2tcIixcbiAgICBcIl9fbmV4dExvY2FsZVwiLFxuICAgIFwiX19uZXh0RGVmYXVsdExvY2FsZVwiLFxuICAgIFwiX19uZXh0SXNOb3RGb3VuZFwiLFxuICAgIC8vIFJTQ1xuICAgIFwiX19mbGlnaHRfX1wiLFxuICAgIC8vIFJvdXRpbmdcbiAgICBcIl9fZmxpZ2h0X3JvdXRlcl9zdGF0ZV90cmVlX19cIixcbiAgICBcIl9fZmxpZ2h0X3ByZWZldGNoX19cIiwgXG5dO1xuY29uc3QgRVhURU5ERURfSU5URVJOQUxfUVVFUllfTkFNRVMgPSBbXG4gICAgXCJfX25leHREYXRhUmVxXCJcbl07XG5mdW5jdGlvbiBzdHJpcEludGVybmFsUXVlcmllcyhxdWVyeSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBJTlRFUk5BTF9RVUVSWV9OQU1FUyl7XG4gICAgICAgIGRlbGV0ZSBxdWVyeVtuYW1lXTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpcEludGVybmFsU2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcywgZXh0ZW5kZWQpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgSU5URVJOQUxfUVVFUllfTkFNRVMpe1xuICAgICAgICBzZWFyY2hQYXJhbXMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIEVYVEVOREVEX0lOVEVSTkFMX1FVRVJZX05BTUVTKXtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5kZWxldGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwtdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/internal-utils.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/web/adapter.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/server/web/adapter.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.adapter = adapter;\nexports.blockUnallowedResponse = blockUnallowedResponse;\nexports.enhanceGlobals = enhanceGlobals;\nvar _error = __webpack_require__(/*! ./error */ \"(middleware)/./node_modules/next/dist/server/web/error.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(middleware)/./node_modules/next/dist/server/web/utils.js\");\nvar _fetchEvent = __webpack_require__(/*! ./spec-extension/fetch-event */ \"(middleware)/./node_modules/next/dist/server/web/spec-extension/fetch-event.js\");\nvar _request = __webpack_require__(/*! ./spec-extension/request */ \"(middleware)/./node_modules/next/dist/server/web/spec-extension/request.js\");\nvar _response = __webpack_require__(/*! ./spec-extension/response */ \"(middleware)/./node_modules/next/dist/server/web/spec-extension/response.js\");\nvar _relativizeUrl = __webpack_require__(/*! ../../shared/lib/router/utils/relativize-url */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/relativize-url.js\");\nvar _nextUrl = __webpack_require__(/*! ./next-url */ \"(middleware)/./node_modules/next/dist/server/web/next-url.js\");\nvar _internalUtils = __webpack_require__(/*! ../internal-utils */ \"(middleware)/./node_modules/next/dist/server/internal-utils.js\");\nclass NextRequestHint extends _request.NextRequest {\n    constructor(params){\n        super(params.input, params.init);\n        this.sourcePage = params.page;\n    }\n    get request() {\n        throw new _error.PageSignatureError({\n            page: this.sourcePage\n        });\n    }\n    respondWith() {\n        throw new _error.PageSignatureError({\n            page: this.sourcePage\n        });\n    }\n    waitUntil() {\n        throw new _error.PageSignatureError({\n            page: this.sourcePage\n        });\n    }\n}\nasync function adapter(params) {\n    // TODO-APP: use explicit marker for this\n    const isEdgeRendering = typeof self.__BUILD_MANIFEST !== \"undefined\";\n    const requestUrl = new _nextUrl.NextURL(params.request.url, {\n        headers: params.request.headers,\n        nextConfig: params.request.nextConfig\n    });\n    // Ensure users only see page requests, never data requests.\n    const buildId = requestUrl.buildId;\n    requestUrl.buildId = \"\";\n    const isDataReq = params.request.headers[\"x-nextjs-data\"];\n    if (isDataReq && requestUrl.pathname === \"/index\") {\n        requestUrl.pathname = \"/\";\n    }\n    // Preserve flight data.\n    const flightSearchParameters = requestUrl.flightSearchParameters;\n    // Parameters should only be stripped for middleware\n    if (!isEdgeRendering) {\n        requestUrl.flightSearchParameters = undefined;\n    }\n    // Strip internal query parameters off the request.\n    (0, _internalUtils).stripInternalSearchParams(requestUrl.searchParams, true);\n    const request = new NextRequestHint({\n        page: params.page,\n        input: String(requestUrl),\n        init: {\n            body: params.request.body,\n            geo: params.request.geo,\n            headers: (0, _utils).fromNodeHeaders(params.request.headers),\n            ip: params.request.ip,\n            method: params.request.method,\n            nextConfig: params.request.nextConfig\n        }\n    });\n    /**\n   * This allows to identify the request as a data request. The user doesn't\n   * need to know about this property neither use it. We add it for testing\n   * purposes.\n   */ if (isDataReq) {\n        Object.defineProperty(request, \"__isData\", {\n            enumerable: false,\n            value: true\n        });\n    }\n    const event = new _fetchEvent.NextFetchEvent({\n        request,\n        page: params.page\n    });\n    let response = await params.handler(request, event);\n    /**\n   * For rewrites we must always include the locale in the final pathname\n   * so we re-create the NextURL forcing it to include it when the it is\n   * an internal rewrite. Also we make sure the outgoing rewrite URL is\n   * a data URL if the request was a data request.\n   */ const rewrite = response == null ? void 0 : response.headers.get(\"x-middleware-rewrite\");\n    if (response && rewrite) {\n        const rewriteUrl = new _nextUrl.NextURL(rewrite, {\n            forceLocale: true,\n            headers: params.request.headers,\n            nextConfig: params.request.nextConfig\n        });\n        if (rewriteUrl.host === request.nextUrl.host) {\n            rewriteUrl.buildId = buildId || rewriteUrl.buildId;\n            rewriteUrl.flightSearchParameters = flightSearchParameters || rewriteUrl.flightSearchParameters;\n            response.headers.set(\"x-middleware-rewrite\", String(rewriteUrl));\n        }\n        /**\n     * When the request is a data request we must show if there was a rewrite\n     * with an internal header so the client knows which component to load\n     * from the data request.\n     */ if (isDataReq) {\n            response.headers.set(\"x-nextjs-rewrite\", (0, _relativizeUrl).relativizeURL(String(rewriteUrl), String(requestUrl)));\n        }\n    }\n    /**\n   * For redirects we will not include the locale in case when it is the\n   * default and we must also make sure the outgoing URL is a data one if\n   * the incoming request was a data request.\n   */ const redirect = response == null ? void 0 : response.headers.get(\"Location\");\n    if (response && redirect) {\n        const redirectURL = new _nextUrl.NextURL(redirect, {\n            forceLocale: false,\n            headers: params.request.headers,\n            nextConfig: params.request.nextConfig\n        });\n        /**\n     * Responses created from redirects have immutable headers so we have\n     * to clone the response to be able to modify it.\n     */ response = new Response(response.body, response);\n        if (redirectURL.host === request.nextUrl.host) {\n            redirectURL.buildId = buildId || redirectURL.buildId;\n            redirectURL.flightSearchParameters = flightSearchParameters || redirectURL.flightSearchParameters;\n            response.headers.set(\"Location\", String(redirectURL));\n        }\n        /**\n     * When the request is a data request we can't use the location header as\n     * it may end up with CORS error. Instead we map to an internal header so\n     * the client knows the destination.\n     */ if (isDataReq) {\n            response.headers.delete(\"Location\");\n            response.headers.set(\"x-nextjs-redirect\", (0, _relativizeUrl).relativizeURL(String(redirectURL), String(requestUrl)));\n        }\n    }\n    return {\n        response: response || _response.NextResponse.next(),\n        waitUntil: Promise.all(event[_fetchEvent.waitUntilSymbol])\n    };\n}\nfunction blockUnallowedResponse(promise) {\n    return promise.then((result)=>{\n        var ref;\n        if ((ref = result.response) == null ? void 0 : ref.body) {\n            console.error(new Error(`A middleware can not alter response's body. Learn more: https://nextjs.org/docs/messages/returning-response-body-in-middleware`));\n            return {\n                ...result,\n                response: new Response(\"Internal Server Error\", {\n                    status: 500,\n                    statusText: \"Internal Server Error\"\n                })\n            };\n        }\n        return result;\n    });\n}\nfunction getUnsupportedModuleErrorMessage(module) {\n    // warning: if you change these messages, you must adjust how react-dev-overlay's middleware detects modules not found\n    return `The edge runtime does not support Node.js '${module}' module.\nLearn More: https://nextjs.org/docs/messages/node-module-in-edge-runtime`;\n}\nfunction __import_unsupported(moduleName) {\n    const proxy = new Proxy(function() {}, {\n        get (_obj, prop) {\n            if (prop === \"then\") {\n                return {};\n            }\n            throw new Error(getUnsupportedModuleErrorMessage(moduleName));\n        },\n        construct () {\n            throw new Error(getUnsupportedModuleErrorMessage(moduleName));\n        },\n        apply (_target, _this, args) {\n            if (typeof args[0] === \"function\") {\n                return args[0](proxy);\n            }\n            throw new Error(getUnsupportedModuleErrorMessage(moduleName));\n        }\n    });\n    return new Proxy({}, {\n        get: ()=>proxy\n    });\n}\nfunction enhanceGlobals() {\n    // The condition is true when the \"process\" module is provided\n    if (process !== __webpack_require__.g.process) {\n        // prefer local process but global.process has correct \"env\"\n        process.env = __webpack_require__.g.process.env;\n        __webpack_require__.g.process = process;\n    }\n    // to allow building code that import but does not use node.js modules,\n    // webpack will expect this function to exist in global scope\n    Object.defineProperty(globalThis, \"__import_unsupported\", {\n        value: __import_unsupported,\n        enumerable: false,\n        configurable: false\n    });\n}\n\n//# sourceMappingURL=adapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL2FkYXB0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixlQUFlO0FBQ2YsOEJBQThCO0FBQzlCLHNCQUFzQjtBQUN0QixhQUFhLG1CQUFPLENBQUMsMEVBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDBFQUFTO0FBQzlCLGtCQUFrQixtQkFBTyxDQUFDLG9IQUE4QjtBQUN4RCxlQUFlLG1CQUFPLENBQUMsNEdBQTBCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDhHQUEyQjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyxxSUFBOEM7QUFDM0UsZUFBZSxtQkFBTyxDQUFDLGdGQUFZO0FBQ25DLHFCQUFxQixtQkFBTyxDQUFDLHlGQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBTTtBQUMxQjtBQUNBLHNCQUFzQixxQkFBTTtBQUM1QixRQUFRLHFCQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL2FkYXB0ZXIuanM/NGZlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRhcHRlciA9IGFkYXB0ZXI7XG5leHBvcnRzLmJsb2NrVW5hbGxvd2VkUmVzcG9uc2UgPSBibG9ja1VuYWxsb3dlZFJlc3BvbnNlO1xuZXhwb3J0cy5lbmhhbmNlR2xvYmFscyA9IGVuaGFuY2VHbG9iYWxzO1xudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIF9mZXRjaEV2ZW50ID0gcmVxdWlyZShcIi4vc3BlYy1leHRlbnNpb24vZmV0Y2gtZXZlbnRcIik7XG52YXIgX3JlcXVlc3QgPSByZXF1aXJlKFwiLi9zcGVjLWV4dGVuc2lvbi9yZXF1ZXN0XCIpO1xudmFyIF9yZXNwb25zZSA9IHJlcXVpcmUoXCIuL3NwZWMtZXh0ZW5zaW9uL3Jlc3BvbnNlXCIpO1xudmFyIF9yZWxhdGl2aXplVXJsID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbGF0aXZpemUtdXJsXCIpO1xudmFyIF9uZXh0VXJsID0gcmVxdWlyZShcIi4vbmV4dC11cmxcIik7XG52YXIgX2ludGVybmFsVXRpbHMgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwtdXRpbHNcIik7XG5jbGFzcyBOZXh0UmVxdWVzdEhpbnQgZXh0ZW5kcyBfcmVxdWVzdC5OZXh0UmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKXtcbiAgICAgICAgc3VwZXIocGFyYW1zLmlucHV0LCBwYXJhbXMuaW5pdCk7XG4gICAgICAgIHRoaXMuc291cmNlUGFnZSA9IHBhcmFtcy5wYWdlO1xuICAgIH1cbiAgICBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9lcnJvci5QYWdlU2lnbmF0dXJlRXJyb3Ioe1xuICAgICAgICAgICAgcGFnZTogdGhpcy5zb3VyY2VQYWdlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNwb25kV2l0aCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9lcnJvci5QYWdlU2lnbmF0dXJlRXJyb3Ioe1xuICAgICAgICAgICAgcGFnZTogdGhpcy5zb3VyY2VQYWdlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YWl0VW50aWwoKSB7XG4gICAgICAgIHRocm93IG5ldyBfZXJyb3IuUGFnZVNpZ25hdHVyZUVycm9yKHtcbiAgICAgICAgICAgIHBhZ2U6IHRoaXMuc291cmNlUGFnZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhZGFwdGVyKHBhcmFtcykge1xuICAgIC8vIFRPRE8tQVBQOiB1c2UgZXhwbGljaXQgbWFya2VyIGZvciB0aGlzXG4gICAgY29uc3QgaXNFZGdlUmVuZGVyaW5nID0gdHlwZW9mIHNlbGYuX19CVUlMRF9NQU5JRkVTVCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICBjb25zdCByZXF1ZXN0VXJsID0gbmV3IF9uZXh0VXJsLk5leHRVUkwocGFyYW1zLnJlcXVlc3QudXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHBhcmFtcy5yZXF1ZXN0LmhlYWRlcnMsXG4gICAgICAgIG5leHRDb25maWc6IHBhcmFtcy5yZXF1ZXN0Lm5leHRDb25maWdcbiAgICB9KTtcbiAgICAvLyBFbnN1cmUgdXNlcnMgb25seSBzZWUgcGFnZSByZXF1ZXN0cywgbmV2ZXIgZGF0YSByZXF1ZXN0cy5cbiAgICBjb25zdCBidWlsZElkID0gcmVxdWVzdFVybC5idWlsZElkO1xuICAgIHJlcXVlc3RVcmwuYnVpbGRJZCA9IFwiXCI7XG4gICAgY29uc3QgaXNEYXRhUmVxID0gcGFyYW1zLnJlcXVlc3QuaGVhZGVyc1tcIngtbmV4dGpzLWRhdGFcIl07XG4gICAgaWYgKGlzRGF0YVJlcSAmJiByZXF1ZXN0VXJsLnBhdGhuYW1lID09PSBcIi9pbmRleFwiKSB7XG4gICAgICAgIHJlcXVlc3RVcmwucGF0aG5hbWUgPSBcIi9cIjtcbiAgICB9XG4gICAgLy8gUHJlc2VydmUgZmxpZ2h0IGRhdGEuXG4gICAgY29uc3QgZmxpZ2h0U2VhcmNoUGFyYW1ldGVycyA9IHJlcXVlc3RVcmwuZmxpZ2h0U2VhcmNoUGFyYW1ldGVycztcbiAgICAvLyBQYXJhbWV0ZXJzIHNob3VsZCBvbmx5IGJlIHN0cmlwcGVkIGZvciBtaWRkbGV3YXJlXG4gICAgaWYgKCFpc0VkZ2VSZW5kZXJpbmcpIHtcbiAgICAgICAgcmVxdWVzdFVybC5mbGlnaHRTZWFyY2hQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBTdHJpcCBpbnRlcm5hbCBxdWVyeSBwYXJhbWV0ZXJzIG9mZiB0aGUgcmVxdWVzdC5cbiAgICAoMCwgX2ludGVybmFsVXRpbHMpLnN0cmlwSW50ZXJuYWxTZWFyY2hQYXJhbXMocmVxdWVzdFVybC5zZWFyY2hQYXJhbXMsIHRydWUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3RIaW50KHtcbiAgICAgICAgcGFnZTogcGFyYW1zLnBhZ2UsXG4gICAgICAgIGlucHV0OiBTdHJpbmcocmVxdWVzdFVybCksXG4gICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgIGJvZHk6IHBhcmFtcy5yZXF1ZXN0LmJvZHksXG4gICAgICAgICAgICBnZW86IHBhcmFtcy5yZXF1ZXN0LmdlbyxcbiAgICAgICAgICAgIGhlYWRlcnM6ICgwLCBfdXRpbHMpLmZyb21Ob2RlSGVhZGVycyhwYXJhbXMucmVxdWVzdC5oZWFkZXJzKSxcbiAgICAgICAgICAgIGlwOiBwYXJhbXMucmVxdWVzdC5pcCxcbiAgICAgICAgICAgIG1ldGhvZDogcGFyYW1zLnJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgbmV4dENvbmZpZzogcGFyYW1zLnJlcXVlc3QubmV4dENvbmZpZ1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAqIFRoaXMgYWxsb3dzIHRvIGlkZW50aWZ5IHRoZSByZXF1ZXN0IGFzIGEgZGF0YSByZXF1ZXN0LiBUaGUgdXNlciBkb2Vzbid0XG4gICAqIG5lZWQgdG8ga25vdyBhYm91dCB0aGlzIHByb3BlcnR5IG5laXRoZXIgdXNlIGl0LiBXZSBhZGQgaXQgZm9yIHRlc3RpbmdcbiAgICogcHVycG9zZXMuXG4gICAqLyBpZiAoaXNEYXRhUmVxKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1ZXN0LCBcIl9faXNEYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IF9mZXRjaEV2ZW50Lk5leHRGZXRjaEV2ZW50KHtcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcGFnZTogcGFyYW1zLnBhZ2VcbiAgICB9KTtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBwYXJhbXMuaGFuZGxlcihyZXF1ZXN0LCBldmVudCk7XG4gICAgLyoqXG4gICAqIEZvciByZXdyaXRlcyB3ZSBtdXN0IGFsd2F5cyBpbmNsdWRlIHRoZSBsb2NhbGUgaW4gdGhlIGZpbmFsIHBhdGhuYW1lXG4gICAqIHNvIHdlIHJlLWNyZWF0ZSB0aGUgTmV4dFVSTCBmb3JjaW5nIGl0IHRvIGluY2x1ZGUgaXQgd2hlbiB0aGUgaXQgaXNcbiAgICogYW4gaW50ZXJuYWwgcmV3cml0ZS4gQWxzbyB3ZSBtYWtlIHN1cmUgdGhlIG91dGdvaW5nIHJld3JpdGUgVVJMIGlzXG4gICAqIGEgZGF0YSBVUkwgaWYgdGhlIHJlcXVlc3Qgd2FzIGEgZGF0YSByZXF1ZXN0LlxuICAgKi8gY29uc3QgcmV3cml0ZSA9IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWlkZGxld2FyZS1yZXdyaXRlXCIpO1xuICAgIGlmIChyZXNwb25zZSAmJiByZXdyaXRlKSB7XG4gICAgICAgIGNvbnN0IHJld3JpdGVVcmwgPSBuZXcgX25leHRVcmwuTmV4dFVSTChyZXdyaXRlLCB7XG4gICAgICAgICAgICBmb3JjZUxvY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHBhcmFtcy5yZXF1ZXN0LmhlYWRlcnMsXG4gICAgICAgICAgICBuZXh0Q29uZmlnOiBwYXJhbXMucmVxdWVzdC5uZXh0Q29uZmlnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmV3cml0ZVVybC5ob3N0ID09PSByZXF1ZXN0Lm5leHRVcmwuaG9zdCkge1xuICAgICAgICAgICAgcmV3cml0ZVVybC5idWlsZElkID0gYnVpbGRJZCB8fCByZXdyaXRlVXJsLmJ1aWxkSWQ7XG4gICAgICAgICAgICByZXdyaXRlVXJsLmZsaWdodFNlYXJjaFBhcmFtZXRlcnMgPSBmbGlnaHRTZWFyY2hQYXJhbWV0ZXJzIHx8IHJld3JpdGVVcmwuZmxpZ2h0U2VhcmNoUGFyYW1ldGVycztcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwieC1taWRkbGV3YXJlLXJld3JpdGVcIiwgU3RyaW5nKHJld3JpdGVVcmwpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgKiBXaGVuIHRoZSByZXF1ZXN0IGlzIGEgZGF0YSByZXF1ZXN0IHdlIG11c3Qgc2hvdyBpZiB0aGVyZSB3YXMgYSByZXdyaXRlXG4gICAgICogd2l0aCBhbiBpbnRlcm5hbCBoZWFkZXIgc28gdGhlIGNsaWVudCBrbm93cyB3aGljaCBjb21wb25lbnQgdG8gbG9hZFxuICAgICAqIGZyb20gdGhlIGRhdGEgcmVxdWVzdC5cbiAgICAgKi8gaWYgKGlzRGF0YVJlcSkge1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJ4LW5leHRqcy1yZXdyaXRlXCIsICgwLCBfcmVsYXRpdml6ZVVybCkucmVsYXRpdml6ZVVSTChTdHJpbmcocmV3cml0ZVVybCksIFN0cmluZyhyZXF1ZXN0VXJsKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBGb3IgcmVkaXJlY3RzIHdlIHdpbGwgbm90IGluY2x1ZGUgdGhlIGxvY2FsZSBpbiBjYXNlIHdoZW4gaXQgaXMgdGhlXG4gICAqIGRlZmF1bHQgYW5kIHdlIG11c3QgYWxzbyBtYWtlIHN1cmUgdGhlIG91dGdvaW5nIFVSTCBpcyBhIGRhdGEgb25lIGlmXG4gICAqIHRoZSBpbmNvbWluZyByZXF1ZXN0IHdhcyBhIGRhdGEgcmVxdWVzdC5cbiAgICovIGNvbnN0IHJlZGlyZWN0ID0gcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gICAgaWYgKHJlc3BvbnNlICYmIHJlZGlyZWN0KSB7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VVJMID0gbmV3IF9uZXh0VXJsLk5leHRVUkwocmVkaXJlY3QsIHtcbiAgICAgICAgICAgIGZvcmNlTG9jYWxlOiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHBhcmFtcy5yZXF1ZXN0LmhlYWRlcnMsXG4gICAgICAgICAgICBuZXh0Q29uZmlnOiBwYXJhbXMucmVxdWVzdC5uZXh0Q29uZmlnXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgKiBSZXNwb25zZXMgY3JlYXRlZCBmcm9tIHJlZGlyZWN0cyBoYXZlIGltbXV0YWJsZSBoZWFkZXJzIHNvIHdlIGhhdmVcbiAgICAgKiB0byBjbG9uZSB0aGUgcmVzcG9uc2UgdG8gYmUgYWJsZSB0byBtb2RpZnkgaXQuXG4gICAgICovIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlLmJvZHksIHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHJlZGlyZWN0VVJMLmhvc3QgPT09IHJlcXVlc3QubmV4dFVybC5ob3N0KSB7XG4gICAgICAgICAgICByZWRpcmVjdFVSTC5idWlsZElkID0gYnVpbGRJZCB8fCByZWRpcmVjdFVSTC5idWlsZElkO1xuICAgICAgICAgICAgcmVkaXJlY3RVUkwuZmxpZ2h0U2VhcmNoUGFyYW1ldGVycyA9IGZsaWdodFNlYXJjaFBhcmFtZXRlcnMgfHwgcmVkaXJlY3RVUkwuZmxpZ2h0U2VhcmNoUGFyYW1ldGVycztcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgU3RyaW5nKHJlZGlyZWN0VVJMKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICogV2hlbiB0aGUgcmVxdWVzdCBpcyBhIGRhdGEgcmVxdWVzdCB3ZSBjYW4ndCB1c2UgdGhlIGxvY2F0aW9uIGhlYWRlciBhc1xuICAgICAqIGl0IG1heSBlbmQgdXAgd2l0aCBDT1JTIGVycm9yLiBJbnN0ZWFkIHdlIG1hcCB0byBhbiBpbnRlcm5hbCBoZWFkZXIgc29cbiAgICAgKiB0aGUgY2xpZW50IGtub3dzIHRoZSBkZXN0aW5hdGlvbi5cbiAgICAgKi8gaWYgKGlzRGF0YVJlcSkge1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5kZWxldGUoXCJMb2NhdGlvblwiKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwieC1uZXh0anMtcmVkaXJlY3RcIiwgKDAsIF9yZWxhdGl2aXplVXJsKS5yZWxhdGl2aXplVVJMKFN0cmluZyhyZWRpcmVjdFVSTCksIFN0cmluZyhyZXF1ZXN0VXJsKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSB8fCBfcmVzcG9uc2UuTmV4dFJlc3BvbnNlLm5leHQoKSxcbiAgICAgICAgd2FpdFVudGlsOiBQcm9taXNlLmFsbChldmVudFtfZmV0Y2hFdmVudC53YWl0VW50aWxTeW1ib2xdKVxuICAgIH07XG59XG5mdW5jdGlvbiBibG9ja1VuYWxsb3dlZFJlc3BvbnNlKHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKChyZXN1bHQpPT57XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICgocmVmID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmJvZHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBBIG1pZGRsZXdhcmUgY2FuIG5vdCBhbHRlciByZXNwb25zZSdzIGJvZHkuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3JldHVybmluZy1yZXNwb25zZS1ib2R5LWluLW1pZGRsZXdhcmVgKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogbmV3IFJlc3BvbnNlKFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0VW5zdXBwb3J0ZWRNb2R1bGVFcnJvck1lc3NhZ2UobW9kdWxlKSB7XG4gICAgLy8gd2FybmluZzogaWYgeW91IGNoYW5nZSB0aGVzZSBtZXNzYWdlcywgeW91IG11c3QgYWRqdXN0IGhvdyByZWFjdC1kZXYtb3ZlcmxheSdzIG1pZGRsZXdhcmUgZGV0ZWN0cyBtb2R1bGVzIG5vdCBmb3VuZFxuICAgIHJldHVybiBgVGhlIGVkZ2UgcnVudGltZSBkb2VzIG5vdCBzdXBwb3J0IE5vZGUuanMgJyR7bW9kdWxlfScgbW9kdWxlLlxuTGVhcm4gTW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm9kZS1tb2R1bGUtaW4tZWRnZS1ydW50aW1lYDtcbn1cbmZ1bmN0aW9uIF9faW1wb3J0X3Vuc3VwcG9ydGVkKG1vZHVsZU5hbWUpIHtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShmdW5jdGlvbigpIHt9LCB7XG4gICAgICAgIGdldCAoX29iaiwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwidGhlblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldFVuc3VwcG9ydGVkTW9kdWxlRXJyb3JNZXNzYWdlKG1vZHVsZU5hbWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uc3RydWN0ICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRVbnN1cHBvcnRlZE1vZHVsZUVycm9yTWVzc2FnZShtb2R1bGVOYW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5IChfdGFyZ2V0LCBfdGhpcywgYXJncykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXShwcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0VW5zdXBwb3J0ZWRNb2R1bGVFcnJvck1lc3NhZ2UobW9kdWxlTmFtZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQ6ICgpPT5wcm94eVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZW5oYW5jZUdsb2JhbHMoKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbiBpcyB0cnVlIHdoZW4gdGhlIFwicHJvY2Vzc1wiIG1vZHVsZSBpcyBwcm92aWRlZFxuICAgIGlmIChwcm9jZXNzICE9PSBnbG9iYWwucHJvY2Vzcykge1xuICAgICAgICAvLyBwcmVmZXIgbG9jYWwgcHJvY2VzcyBidXQgZ2xvYmFsLnByb2Nlc3MgaGFzIGNvcnJlY3QgXCJlbnZcIlxuICAgICAgICBwcm9jZXNzLmVudiA9IGdsb2JhbC5wcm9jZXNzLmVudjtcbiAgICAgICAgZ2xvYmFsLnByb2Nlc3MgPSBwcm9jZXNzO1xuICAgIH1cbiAgICAvLyB0byBhbGxvdyBidWlsZGluZyBjb2RlIHRoYXQgaW1wb3J0IGJ1dCBkb2VzIG5vdCB1c2Ugbm9kZS5qcyBtb2R1bGVzLFxuICAgIC8vIHdlYnBhY2sgd2lsbCBleHBlY3QgdGhpcyBmdW5jdGlvbiB0byBleGlzdCBpbiBnbG9iYWwgc2NvcGVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgXCJfX2ltcG9ydF91bnN1cHBvcnRlZFwiLCB7XG4gICAgICAgIHZhbHVlOiBfX2ltcG9ydF91bnN1cHBvcnRlZCxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/web/adapter.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/web/error.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/server/web/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nclass PageSignatureError extends Error {\n    constructor({ page  }){\n        super(`The middleware \"${page}\" accepts an async API directly with the form:\n  \n  export function middleware(request, event) {\n    return NextResponse.redirect('/new-location')\n  }\n  \n  Read more: https://nextjs.org/docs/messages/middleware-new-signature\n  `);\n    }\n}\nexports.PageSignatureError = PageSignatureError;\nclass RemovedPageError extends Error {\n    constructor(){\n        super(`The request.page has been deprecated in favour of \\`URLPattern\\`.\n  Read more: https://nextjs.org/docs/messages/middleware-request-page\n  `);\n    }\n}\nexports.RemovedPageError = RemovedPageError;\nclass RemovedUAError extends Error {\n    constructor(){\n        super(`The request.ua has been removed in favour of \\`userAgent\\` function.\n  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent\n  `);\n    }\n}\nexports.RemovedUAError = RemovedUAError;\n\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL2Vycm9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9lcnJvci5qcz82YjEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuY2xhc3MgUGFnZVNpZ25hdHVyZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcGFnZSAgfSl7XG4gICAgICAgIHN1cGVyKGBUaGUgbWlkZGxld2FyZSBcIiR7cGFnZX1cIiBhY2NlcHRzIGFuIGFzeW5jIEFQSSBkaXJlY3RseSB3aXRoIHRoZSBmb3JtOlxuICBcbiAgZXhwb3J0IGZ1bmN0aW9uIG1pZGRsZXdhcmUocmVxdWVzdCwgZXZlbnQpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLnJlZGlyZWN0KCcvbmV3LWxvY2F0aW9uJylcbiAgfVxuICBcbiAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9taWRkbGV3YXJlLW5ldy1zaWduYXR1cmVcbiAgYCk7XG4gICAgfVxufVxuZXhwb3J0cy5QYWdlU2lnbmF0dXJlRXJyb3IgPSBQYWdlU2lnbmF0dXJlRXJyb3I7XG5jbGFzcyBSZW1vdmVkUGFnZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKGBUaGUgcmVxdWVzdC5wYWdlIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIFxcYFVSTFBhdHRlcm5cXGAuXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1yZXF1ZXN0LXBhZ2VcbiAgYCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZW1vdmVkUGFnZUVycm9yID0gUmVtb3ZlZFBhZ2VFcnJvcjtcbmNsYXNzIFJlbW92ZWRVQUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKGBUaGUgcmVxdWVzdC51YSBoYXMgYmVlbiByZW1vdmVkIGluIGZhdm91ciBvZiBcXGB1c2VyQWdlbnRcXGAgZnVuY3Rpb24uXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1wYXJzZS11c2VyLWFnZW50XG4gIGApO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3ZlZFVBRXJyb3IgPSBSZW1vdmVkVUFFcnJvcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/web/error.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/web/next-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/server/web/next-url.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _detectDomainLocale = __webpack_require__(/*! ../../shared/lib/i18n/detect-domain-locale */ \"(middleware)/./node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js\");\nvar _formatNextPathnameInfo = __webpack_require__(/*! ../../shared/lib/router/utils/format-next-pathname-info */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _getHostname = __webpack_require__(/*! ../../shared/lib/get-hostname */ \"(middleware)/./node_modules/next/dist/shared/lib/get-hostname.js\");\nvar _getNextPathnameInfo = __webpack_require__(/*! ../../shared/lib/router/utils/get-next-pathname-info */ \"(middleware)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst FLIGHT_PARAMETERS = [\n    \"__flight__\",\n    \"__flight_router_state_tree__\",\n    \"__flight_prefetch__\", \n];\nconst REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\\/\\/)(127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|::1|localhost)/;\nfunction parseURL(url, base) {\n    return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, \"localhost\"), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, \"localhost\"));\n}\nfunction parseFlightParameters(searchParams) {\n    let flightSearchParameters = {};\n    let flightSearchParametersUpdated = false;\n    for (const name of FLIGHT_PARAMETERS){\n        const value = searchParams.get(name);\n        if (value === null) {\n            continue;\n        }\n        flightSearchParameters[name] = value;\n        flightSearchParametersUpdated = true;\n    }\n    if (!flightSearchParametersUpdated) {\n        return undefined;\n    }\n    return flightSearchParameters;\n}\nconst Internal = Symbol(\"NextURLInternal\");\nclass NextURL {\n    constructor(input, baseOrOpts, opts){\n        let base;\n        let options;\n        if (typeof baseOrOpts === \"object\" && \"pathname\" in baseOrOpts || typeof baseOrOpts === \"string\") {\n            base = baseOrOpts;\n            options = opts || {};\n        } else {\n            options = opts || baseOrOpts || {};\n        }\n        this[Internal] = {\n            url: parseURL(input, base != null ? base : options.base),\n            options: options,\n            basePath: \"\"\n        };\n        this.analyzeUrl();\n    }\n    analyzeUrl() {\n        var ref, ref1, ref2, ref3, ref4;\n        const pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(this[Internal].url.pathname, {\n            nextConfig: this[Internal].options.nextConfig,\n            parseData: true\n        });\n        this[Internal].domainLocale = (0, _detectDomainLocale).detectDomainLocale((ref = this[Internal].options.nextConfig) == null ? void 0 : (ref1 = ref.i18n) == null ? void 0 : ref1.domains, (0, _getHostname).getHostname(this[Internal].url, this[Internal].options.headers));\n        const defaultLocale = ((ref2 = this[Internal].domainLocale) == null ? void 0 : ref2.defaultLocale) || ((ref3 = this[Internal].options.nextConfig) == null ? void 0 : (ref4 = ref3.i18n) == null ? void 0 : ref4.defaultLocale);\n        this[Internal].url.pathname = pathnameInfo.pathname;\n        this[Internal].defaultLocale = defaultLocale;\n        var _basePath;\n        this[Internal].basePath = (_basePath = pathnameInfo.basePath) != null ? _basePath : \"\";\n        this[Internal].buildId = pathnameInfo.buildId;\n        var _locale;\n        this[Internal].locale = (_locale = pathnameInfo.locale) != null ? _locale : defaultLocale;\n        this[Internal].trailingSlash = pathnameInfo.trailingSlash;\n        this[Internal].flightSearchParameters = parseFlightParameters(this[Internal].url.searchParams);\n    }\n    formatPathname() {\n        return (0, _formatNextPathnameInfo).formatNextPathnameInfo({\n            basePath: this[Internal].basePath,\n            buildId: this[Internal].buildId,\n            defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : undefined,\n            locale: this[Internal].locale,\n            pathname: this[Internal].url.pathname,\n            trailingSlash: this[Internal].trailingSlash\n        });\n    }\n    formatSearch() {\n        const flightSearchParameters = this[Internal].flightSearchParameters;\n        // If no flight parameters are set, return the search string as is.\n        // This is a fast path to ensure URLSearchParams only has to be recreated on Flight requests.\n        if (!flightSearchParameters) {\n            return this[Internal].url.search;\n        }\n        // Create separate URLSearchParams to ensure the original search string is not modified.\n        const searchParams = new URLSearchParams(this[Internal].url.searchParams);\n        // If any exist this loop is always limited to the amount of FLIGHT_PARAMETERS.\n        for(const name in flightSearchParameters){\n            searchParams.set(name, flightSearchParameters[name]);\n        }\n        const params = searchParams.toString();\n        return params === \"\" ? \"\" : `?${params}`;\n    }\n    get buildId() {\n        return this[Internal].buildId;\n    }\n    set buildId(buildId) {\n        this[Internal].buildId = buildId;\n    }\n    get flightSearchParameters() {\n        return this[Internal].flightSearchParameters;\n    }\n    set flightSearchParameters(flightSearchParams) {\n        if (flightSearchParams) {\n            for (const name of FLIGHT_PARAMETERS){\n                // Ensure only the provided values are set\n                if (flightSearchParams[name]) {\n                    this[Internal].url.searchParams.set(name, flightSearchParams[name]);\n                } else {\n                    // Delete the ones that are not provided as flightData should be overridden.\n                    this[Internal].url.searchParams.delete(name);\n                }\n            }\n        } else {\n            for (const name of FLIGHT_PARAMETERS){\n                this[Internal].url.searchParams.delete(name);\n            }\n        }\n        this[Internal].flightSearchParameters = flightSearchParams;\n    }\n    get locale() {\n        var _locale;\n        return (_locale = this[Internal].locale) != null ? _locale : \"\";\n    }\n    set locale(locale) {\n        var ref, ref5;\n        if (!this[Internal].locale || !((ref = this[Internal].options.nextConfig) == null ? void 0 : (ref5 = ref.i18n) == null ? void 0 : ref5.locales.includes(locale))) {\n            throw new TypeError(`The NextURL configuration includes no locale \"${locale}\"`);\n        }\n        this[Internal].locale = locale;\n    }\n    get defaultLocale() {\n        return this[Internal].defaultLocale;\n    }\n    get domainLocale() {\n        return this[Internal].domainLocale;\n    }\n    get searchParams() {\n        return this[Internal].url.searchParams;\n    }\n    get host() {\n        return this[Internal].url.host;\n    }\n    set host(value) {\n        this[Internal].url.host = value;\n    }\n    get hostname() {\n        return this[Internal].url.hostname;\n    }\n    set hostname(value) {\n        this[Internal].url.hostname = value;\n    }\n    get port() {\n        return this[Internal].url.port;\n    }\n    set port(value) {\n        this[Internal].url.port = value;\n    }\n    get protocol() {\n        return this[Internal].url.protocol;\n    }\n    set protocol(value) {\n        this[Internal].url.protocol = value;\n    }\n    get href() {\n        const pathname = this.formatPathname();\n        const search = this.formatSearch();\n        return `${this.protocol}//${this.host}${pathname}${search}`;\n    }\n    set href(url) {\n        this[Internal].url = parseURL(url);\n        this.analyzeUrl();\n    }\n    get origin() {\n        return this[Internal].url.origin;\n    }\n    get pathname() {\n        return this[Internal].url.pathname;\n    }\n    set pathname(value) {\n        this[Internal].url.pathname = value;\n    }\n    get hash() {\n        return this[Internal].url.hash;\n    }\n    set hash(value) {\n        this[Internal].url.hash = value;\n    }\n    get search() {\n        return this[Internal].url.search;\n    }\n    set search(value) {\n        this[Internal].url.search = value;\n    }\n    get password() {\n        return this[Internal].url.password;\n    }\n    set password(value) {\n        this[Internal].url.password = value;\n    }\n    get username() {\n        return this[Internal].url.username;\n    }\n    set username(value) {\n        this[Internal].url.username = value;\n    }\n    get basePath() {\n        return this[Internal].basePath;\n    }\n    set basePath(value) {\n        this[Internal].basePath = value.startsWith(\"/\") ? value : `/${value}`;\n    }\n    toString() {\n        return this.href;\n    }\n    toJSON() {\n        return this.href;\n    }\n    [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n        return {\n            href: this.href,\n            origin: this.origin,\n            protocol: this.protocol,\n            username: this.username,\n            password: this.password,\n            host: this.host,\n            hostname: this.hostname,\n            port: this.port,\n            pathname: this.pathname,\n            search: this.search,\n            searchParams: this.searchParams,\n            hash: this.hash\n        };\n    }\n    clone() {\n        return new NextURL(String(this), this[Internal].options);\n    }\n}\nexports.NextURL = NextURL;\n\n//# sourceMappingURL=next-url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL25leHQtdXJsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMEJBQTBCLG1CQUFPLENBQUMsaUlBQTRDO0FBQzlFLDhCQUE4QixtQkFBTyxDQUFDLDJKQUF5RDtBQUMvRixtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBK0I7QUFDMUQsMkJBQTJCLG1CQUFPLENBQUMscUpBQXNEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsRUFBRTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLE9BQU87QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWMsSUFBSSxVQUFVLEVBQUUsU0FBUyxFQUFFLE9BQU87QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE1BQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvbmV4dC11cmwuanM/MjBjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbnZhciBfZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xudmFyIF9nZXRIb3N0bmFtZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2dldC1ob3N0bmFtZVwiKTtcbnZhciBfZ2V0TmV4dFBhdGhuYW1lSW5mbyA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgRkxJR0hUX1BBUkFNRVRFUlMgPSBbXG4gICAgXCJfX2ZsaWdodF9fXCIsXG4gICAgXCJfX2ZsaWdodF9yb3V0ZXJfc3RhdGVfdHJlZV9fXCIsXG4gICAgXCJfX2ZsaWdodF9wcmVmZXRjaF9fXCIsIFxuXTtcbmNvbnN0IFJFR0VYX0xPQ0FMSE9TVF9IT1NUTkFNRSA9IC8oPyFeaHR0cHM/OlxcL1xcLykoMTI3KD86XFwuKD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSl7M318OjoxfGxvY2FsaG9zdCkvO1xuZnVuY3Rpb24gcGFyc2VVUkwodXJsLCBiYXNlKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoU3RyaW5nKHVybCkucmVwbGFjZShSRUdFWF9MT0NBTEhPU1RfSE9TVE5BTUUsIFwibG9jYWxob3N0XCIpLCBiYXNlICYmIFN0cmluZyhiYXNlKS5yZXBsYWNlKFJFR0VYX0xPQ0FMSE9TVF9IT1NUTkFNRSwgXCJsb2NhbGhvc3RcIikpO1xufVxuZnVuY3Rpb24gcGFyc2VGbGlnaHRQYXJhbWV0ZXJzKHNlYXJjaFBhcmFtcykge1xuICAgIGxldCBmbGlnaHRTZWFyY2hQYXJhbWV0ZXJzID0ge307XG4gICAgbGV0IGZsaWdodFNlYXJjaFBhcmFtZXRlcnNVcGRhdGVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIEZMSUdIVF9QQVJBTUVURVJTKXtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzZWFyY2hQYXJhbXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZsaWdodFNlYXJjaFBhcmFtZXRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgZmxpZ2h0U2VhcmNoUGFyYW1ldGVyc1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWZsaWdodFNlYXJjaFBhcmFtZXRlcnNVcGRhdGVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbGlnaHRTZWFyY2hQYXJhbWV0ZXJzO1xufVxuY29uc3QgSW50ZXJuYWwgPSBTeW1ib2woXCJOZXh0VVJMSW50ZXJuYWxcIik7XG5jbGFzcyBOZXh0VVJMIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCwgYmFzZU9yT3B0cywgb3B0cyl7XG4gICAgICAgIGxldCBiYXNlO1xuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlT3JPcHRzID09PSBcIm9iamVjdFwiICYmIFwicGF0aG5hbWVcIiBpbiBiYXNlT3JPcHRzIHx8IHR5cGVvZiBiYXNlT3JPcHRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBiYXNlID0gYmFzZU9yT3B0cztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdHMgfHwgYmFzZU9yT3B0cyB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0ludGVybmFsXSA9IHtcbiAgICAgICAgICAgIHVybDogcGFyc2VVUkwoaW5wdXQsIGJhc2UgIT0gbnVsbCA/IGJhc2UgOiBvcHRpb25zLmJhc2UpLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGJhc2VQYXRoOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYW5hbHl6ZVVybCgpO1xuICAgIH1cbiAgICBhbmFseXplVXJsKCkge1xuICAgICAgICB2YXIgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0O1xuICAgICAgICBjb25zdCBwYXRobmFtZUluZm8gPSAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8odGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICBuZXh0Q29uZmlnOiB0aGlzW0ludGVybmFsXS5vcHRpb25zLm5leHRDb25maWcsXG4gICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmRvbWFpbkxvY2FsZSA9ICgwLCBfZGV0ZWN0RG9tYWluTG9jYWxlKS5kZXRlY3REb21haW5Mb2NhbGUoKHJlZiA9IHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMubmV4dENvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWYxID0gcmVmLmkxOG4pID09IG51bGwgPyB2b2lkIDAgOiByZWYxLmRvbWFpbnMsICgwLCBfZ2V0SG9zdG5hbWUpLmdldEhvc3RuYW1lKHRoaXNbSW50ZXJuYWxdLnVybCwgdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5oZWFkZXJzKSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMb2NhbGUgPSAoKHJlZjIgPSB0aGlzW0ludGVybmFsXS5kb21haW5Mb2NhbGUpID09IG51bGwgPyB2b2lkIDAgOiByZWYyLmRlZmF1bHRMb2NhbGUpIHx8ICgocmVmMyA9IHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMubmV4dENvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWY0ID0gcmVmMy5pMThuKSA9PSBudWxsID8gdm9pZCAwIDogcmVmNC5kZWZhdWx0TG9jYWxlKTtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLnBhdGhuYW1lID0gcGF0aG5hbWVJbmZvLnBhdGhuYW1lO1xuICAgICAgICB0aGlzW0ludGVybmFsXS5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgdmFyIF9iYXNlUGF0aDtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0uYmFzZVBhdGggPSAoX2Jhc2VQYXRoID0gcGF0aG5hbWVJbmZvLmJhc2VQYXRoKSAhPSBudWxsID8gX2Jhc2VQYXRoIDogXCJcIjtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0uYnVpbGRJZCA9IHBhdGhuYW1lSW5mby5idWlsZElkO1xuICAgICAgICB2YXIgX2xvY2FsZTtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0ubG9jYWxlID0gKF9sb2NhbGUgPSBwYXRobmFtZUluZm8ubG9jYWxlKSAhPSBudWxsID8gX2xvY2FsZSA6IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnRyYWlsaW5nU2xhc2ggPSBwYXRobmFtZUluZm8udHJhaWxpbmdTbGFzaDtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0uZmxpZ2h0U2VhcmNoUGFyYW1ldGVycyA9IHBhcnNlRmxpZ2h0UGFyYW1ldGVycyh0aGlzW0ludGVybmFsXS51cmwuc2VhcmNoUGFyYW1zKTtcbiAgICB9XG4gICAgZm9ybWF0UGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAoMCwgX2Zvcm1hdE5leHRQYXRobmFtZUluZm8pLmZvcm1hdE5leHRQYXRobmFtZUluZm8oe1xuICAgICAgICAgICAgYmFzZVBhdGg6IHRoaXNbSW50ZXJuYWxdLmJhc2VQYXRoLFxuICAgICAgICAgICAgYnVpbGRJZDogdGhpc1tJbnRlcm5hbF0uYnVpbGRJZCxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6ICF0aGlzW0ludGVybmFsXS5vcHRpb25zLmZvcmNlTG9jYWxlID8gdGhpc1tJbnRlcm5hbF0uZGVmYXVsdExvY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpc1tJbnRlcm5hbF0ubG9jYWxlLFxuICAgICAgICAgICAgcGF0aG5hbWU6IHRoaXNbSW50ZXJuYWxdLnVybC5wYXRobmFtZSxcbiAgICAgICAgICAgIHRyYWlsaW5nU2xhc2g6IHRoaXNbSW50ZXJuYWxdLnRyYWlsaW5nU2xhc2hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvcm1hdFNlYXJjaCgpIHtcbiAgICAgICAgY29uc3QgZmxpZ2h0U2VhcmNoUGFyYW1ldGVycyA9IHRoaXNbSW50ZXJuYWxdLmZsaWdodFNlYXJjaFBhcmFtZXRlcnM7XG4gICAgICAgIC8vIElmIG5vIGZsaWdodCBwYXJhbWV0ZXJzIGFyZSBzZXQsIHJldHVybiB0aGUgc2VhcmNoIHN0cmluZyBhcyBpcy5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBlbnN1cmUgVVJMU2VhcmNoUGFyYW1zIG9ubHkgaGFzIHRvIGJlIHJlY3JlYXRlZCBvbiBGbGlnaHQgcmVxdWVzdHMuXG4gICAgICAgIGlmICghZmxpZ2h0U2VhcmNoUGFyYW1ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2g7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHNlcGFyYXRlIFVSTFNlYXJjaFBhcmFtcyB0byBlbnN1cmUgdGhlIG9yaWdpbmFsIHNlYXJjaCBzdHJpbmcgaXMgbm90IG1vZGlmaWVkLlxuICAgICAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICAvLyBJZiBhbnkgZXhpc3QgdGhpcyBsb29wIGlzIGFsd2F5cyBsaW1pdGVkIHRvIHRoZSBhbW91bnQgb2YgRkxJR0hUX1BBUkFNRVRFUlMuXG4gICAgICAgIGZvcihjb25zdCBuYW1lIGluIGZsaWdodFNlYXJjaFBhcmFtZXRlcnMpe1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLnNldChuYW1lLCBmbGlnaHRTZWFyY2hQYXJhbWV0ZXJzW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcyA9PT0gXCJcIiA/IFwiXCIgOiBgPyR7cGFyYW1zfWA7XG4gICAgfVxuICAgIGdldCBidWlsZElkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0uYnVpbGRJZDtcbiAgICB9XG4gICAgc2V0IGJ1aWxkSWQoYnVpbGRJZCkge1xuICAgICAgICB0aGlzW0ludGVybmFsXS5idWlsZElkID0gYnVpbGRJZDtcbiAgICB9XG4gICAgZ2V0IGZsaWdodFNlYXJjaFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5mbGlnaHRTZWFyY2hQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICBzZXQgZmxpZ2h0U2VhcmNoUGFyYW1ldGVycyhmbGlnaHRTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgaWYgKGZsaWdodFNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIEZMSUdIVF9QQVJBTUVURVJTKXtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgb25seSB0aGUgcHJvdmlkZWQgdmFsdWVzIGFyZSBzZXRcbiAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0U2VhcmNoUGFyYW1zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2hQYXJhbXMuc2V0KG5hbWUsIGZsaWdodFNlYXJjaFBhcmFtc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBvbmVzIHRoYXQgYXJlIG5vdCBwcm92aWRlZCBhcyBmbGlnaHREYXRhIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICAgICAgICAgICAgICAgICAgICB0aGlzW0ludGVybmFsXS51cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgRkxJR0hUX1BBUkFNRVRFUlMpe1xuICAgICAgICAgICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmZsaWdodFNlYXJjaFBhcmFtZXRlcnMgPSBmbGlnaHRTZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGdldCBsb2NhbGUoKSB7XG4gICAgICAgIHZhciBfbG9jYWxlO1xuICAgICAgICByZXR1cm4gKF9sb2NhbGUgPSB0aGlzW0ludGVybmFsXS5sb2NhbGUpICE9IG51bGwgPyBfbG9jYWxlIDogXCJcIjtcbiAgICB9XG4gICAgc2V0IGxvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmNTtcbiAgICAgICAgaWYgKCF0aGlzW0ludGVybmFsXS5sb2NhbGUgfHwgISgocmVmID0gdGhpc1tJbnRlcm5hbF0ub3B0aW9ucy5uZXh0Q29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogKHJlZjUgPSByZWYuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZjUubG9jYWxlcy5pbmNsdWRlcyhsb2NhbGUpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIE5leHRVUkwgY29uZmlndXJhdGlvbiBpbmNsdWRlcyBubyBsb2NhbGUgXCIke2xvY2FsZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRMb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS5kZWZhdWx0TG9jYWxlO1xuICAgIH1cbiAgICBnZXQgZG9tYWluTG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0uZG9tYWluTG9jYWxlO1xuICAgIH1cbiAgICBnZXQgc2VhcmNoUGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgZ2V0IGhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuaG9zdDtcbiAgICB9XG4gICAgc2V0IGhvc3QodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLmhvc3QgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGhvc3RuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLmhvc3RuYW1lO1xuICAgIH1cbiAgICBzZXQgaG9zdG5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnBvcnQ7XG4gICAgfVxuICAgIHNldCBwb3J0KHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5wb3J0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5wcm90b2NvbDtcbiAgICB9XG4gICAgc2V0IHByb3RvY29sKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbSW50ZXJuYWxdLnVybC5wcm90b2NvbCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSB0aGlzLmZvcm1hdFBhdGhuYW1lKCk7XG4gICAgICAgIGNvbnN0IHNlYXJjaCA9IHRoaXMuZm9ybWF0U2VhcmNoKCk7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sfS8vJHt0aGlzLmhvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH1gO1xuICAgIH1cbiAgICBzZXQgaHJlZih1cmwpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsID0gcGFyc2VVUkwodXJsKTtcbiAgICAgICAgdGhpcy5hbmFseXplVXJsKCk7XG4gICAgfVxuICAgIGdldCBvcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwub3JpZ2luO1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwucGF0aG5hbWU7XG4gICAgfVxuICAgIHNldCBwYXRobmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzW0ludGVybmFsXS51cmwucGF0aG5hbWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwuaGFzaDtcbiAgICB9XG4gICAgc2V0IGhhc2godmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLmhhc2ggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHNlYXJjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLnVybC5zZWFyY2g7XG4gICAgfVxuICAgIHNldCBzZWFyY2godmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLnNlYXJjaCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ludGVybmFsXS51cmwucGFzc3dvcmQ7XG4gICAgfVxuICAgIHNldCBwYXNzd29yZCh2YWx1ZSkge1xuICAgICAgICB0aGlzW0ludGVybmFsXS51cmwucGFzc3dvcmQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHVzZXJuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbnRlcm5hbF0udXJsLnVzZXJuYW1lO1xuICAgIH1cbiAgICBzZXQgdXNlcm5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0udXJsLnVzZXJuYW1lID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW50ZXJuYWxdLmJhc2VQYXRoO1xuICAgIH1cbiAgICBzZXQgYmFzZVBhdGgodmFsdWUpIHtcbiAgICAgICAgdGhpc1tJbnRlcm5hbF0uYmFzZVBhdGggPSB2YWx1ZS5zdGFydHNXaXRoKFwiL1wiKSA/IHZhbHVlIDogYC8ke3ZhbHVlfWA7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ocmVmO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhyZWY7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKFwiZWRnZS1ydW50aW1lLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHRoaXMuaHJlZixcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4sXG4gICAgICAgICAgICBwcm90b2NvbDogdGhpcy5wcm90b2NvbCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMucGFzc3dvcmQsXG4gICAgICAgICAgICBob3N0OiB0aGlzLmhvc3QsXG4gICAgICAgICAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICAgICAgICAgIHBhdGhuYW1lOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgc2VhcmNoOiB0aGlzLnNlYXJjaCxcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogdGhpcy5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICBoYXNoOiB0aGlzLmhhc2hcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFVSTChTdHJpbmcodGhpcyksIHRoaXNbSW50ZXJuYWxdLm9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV4dFVSTCA9IE5leHRVUkw7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQtdXJsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/web/next-url.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/web/spec-extension/cookies.js":
/*!*********************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/cookies.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _cookie = _interopRequireDefault(__webpack_require__(/*! next/dist/compiled/cookie */ \"(middleware)/./node_modules/next/dist/compiled/cookie/index.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst normalizeCookieOptions = (options)=>{\n    options = Object.assign({}, options);\n    if (options.maxAge) {\n        options.expires = new Date(Date.now() + options.maxAge * 1000);\n    }\n    if (options.path == null) {\n        options.path = \"/\";\n    }\n    return options;\n};\nconst serializeValue = (value)=>typeof value === \"object\" ? `j:${JSON.stringify(value)}` : String(value);\nconst serializeExpiredCookie = (key, options = {})=>_cookie.default.serialize(key, \"\", {\n        expires: new Date(0),\n        path: \"/\",\n        ...options\n    });\nconst deserializeCookie = (input)=>{\n    const value = input.headers.get(\"set-cookie\");\n    return value !== undefined && value !== null ? value.split(\", \") : [];\n};\nconst serializeCookie = (input)=>input.join(\", \");\nclass Cookies extends Map {\n    constructor(input){\n        const parsedInput = typeof input === \"string\" ? _cookie.default.parse(input) : {};\n        super(Object.entries(parsedInput));\n    }\n    set(key, value, options = {}) {\n        return super.set(key, _cookie.default.serialize(key, serializeValue(value), normalizeCookieOptions(options)));\n    }\n    [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n        return Object.fromEntries(this.entries());\n    }\n}\nexports.Cookies = Cookies;\nclass NextCookies extends Cookies {\n    constructor(response){\n        super(response.headers.get(\"cookie\"));\n        this.response = response;\n    }\n    get = (...args)=>{\n        return this.getWithOptions(...args).value;\n    };\n    getWithOptions = (...args)=>{\n        const raw = super.get(...args);\n        if (typeof raw !== \"string\") return {\n            value: raw,\n            options: {}\n        };\n        const { [args[0]]: value , ...options } = _cookie.default.parse(raw);\n        return {\n            value,\n            options\n        };\n    };\n    set = (...args)=>{\n        const isAlreadyAdded = super.has(args[0]);\n        super.set(...args);\n        const currentCookie = super.get(args[0]);\n        if (typeof currentCookie !== \"string\") {\n            throw new Error(`Invariant: failed to generate cookie for ${JSON.stringify(args)}`);\n        }\n        if (isAlreadyAdded) {\n            const setCookie = serializeCookie(deserializeCookie(this.response).filter((value)=>!value.startsWith(`${args[0]}=`)));\n            if (setCookie) {\n                this.response.headers.set(\"set-cookie\", [\n                    currentCookie,\n                    setCookie\n                ].join(\", \"));\n            } else {\n                this.response.headers.set(\"set-cookie\", currentCookie);\n            }\n        } else {\n            this.response.headers.append(\"set-cookie\", currentCookie);\n        }\n        return this;\n    };\n    delete = (key, options = {})=>{\n        const isDeleted = super.delete(key);\n        if (isDeleted) {\n            const setCookie = serializeCookie(deserializeCookie(this.response).filter((value)=>!value.startsWith(`${key}=`)));\n            const expiredCookie = serializeExpiredCookie(key, options);\n            this.response.headers.set(\"set-cookie\", [\n                expiredCookie,\n                setCookie\n            ].join(\", \"));\n        }\n        return isDeleted;\n    };\n    clear = (options = {})=>{\n        const expiredCookies = Array.from(super.keys()).map((key)=>serializeExpiredCookie(key, options)).join(\", \");\n        if (expiredCookies) this.response.headers.set(\"set-cookie\", expiredCookies);\n        return super.clear();\n    };\n}\nexports.NextCookies = NextCookies;\n\n//# sourceMappingURL=cookies.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2Nvb2tpZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixxQ0FBcUMsbUJBQU8sQ0FBQyxpR0FBMkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0JBQXNCO0FBQ3ZGLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHFCQUFxQjtBQUM3RjtBQUNBO0FBQ0Esb0hBQW9ILFFBQVE7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxvSEFBb0gsSUFBSTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9jb29raWVzLmpzP2U0MjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgX2Nvb2tpZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9jb29raWVcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuY29uc3Qgbm9ybWFsaXplQ29va2llT3B0aW9ucyA9IChvcHRpb25zKT0+e1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UpIHtcbiAgICAgICAgb3B0aW9ucy5leHBpcmVzID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIG9wdGlvbnMubWF4QWdlICogMTAwMCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhdGggPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnBhdGggPSBcIi9cIjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuY29uc3Qgc2VyaWFsaXplVmFsdWUgPSAodmFsdWUpPT50eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBgajoke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gIDogU3RyaW5nKHZhbHVlKTtcbmNvbnN0IHNlcmlhbGl6ZUV4cGlyZWRDb29raWUgPSAoa2V5LCBvcHRpb25zID0ge30pPT5fY29va2llLmRlZmF1bHQuc2VyaWFsaXplKGtleSwgXCJcIiwge1xuICAgICAgICBleHBpcmVzOiBuZXcgRGF0ZSgwKSxcbiAgICAgICAgcGF0aDogXCIvXCIsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbmNvbnN0IGRlc2VyaWFsaXplQ29va2llID0gKGlucHV0KT0+e1xuICAgIGNvbnN0IHZhbHVlID0gaW5wdXQuaGVhZGVycy5nZXQoXCJzZXQtY29va2llXCIpO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsID8gdmFsdWUuc3BsaXQoXCIsIFwiKSA6IFtdO1xufTtcbmNvbnN0IHNlcmlhbGl6ZUNvb2tpZSA9IChpbnB1dCk9PmlucHV0LmpvaW4oXCIsIFwiKTtcbmNsYXNzIENvb2tpZXMgZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KXtcbiAgICAgICAgY29uc3QgcGFyc2VkSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBfY29va2llLmRlZmF1bHQucGFyc2UoaW5wdXQpIDoge307XG4gICAgICAgIHN1cGVyKE9iamVjdC5lbnRyaWVzKHBhcnNlZElucHV0KSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldChrZXksIF9jb29raWUuZGVmYXVsdC5zZXJpYWxpemUoa2V5LCBzZXJpYWxpemVWYWx1ZSh2YWx1ZSksIG5vcm1hbGl6ZUNvb2tpZU9wdGlvbnMob3B0aW9ucykpKTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoXCJlZGdlLXJ1bnRpbWUuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuZW50cmllcygpKTtcbiAgICB9XG59XG5leHBvcnRzLkNvb2tpZXMgPSBDb29raWVzO1xuY2xhc3MgTmV4dENvb2tpZXMgZXh0ZW5kcyBDb29raWVzIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSl7XG4gICAgICAgIHN1cGVyKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29va2llXCIpKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICBnZXQgPSAoLi4uYXJncyk9PntcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2l0aE9wdGlvbnMoLi4uYXJncykudmFsdWU7XG4gICAgfTtcbiAgICBnZXRXaXRoT3B0aW9ucyA9ICguLi5hcmdzKT0+e1xuICAgICAgICBjb25zdCByYXcgPSBzdXBlci5nZXQoLi4uYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmF3ICE9PSBcInN0cmluZ1wiKSByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJhdyxcbiAgICAgICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgW2FyZ3NbMF1dOiB2YWx1ZSAsIC4uLm9wdGlvbnMgfSA9IF9jb29raWUuZGVmYXVsdC5wYXJzZShyYXcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBzZXQgPSAoLi4uYXJncyk9PntcbiAgICAgICAgY29uc3QgaXNBbHJlYWR5QWRkZWQgPSBzdXBlci5oYXMoYXJnc1swXSk7XG4gICAgICAgIHN1cGVyLnNldCguLi5hcmdzKTtcbiAgICAgICAgY29uc3QgY3VycmVudENvb2tpZSA9IHN1cGVyLmdldChhcmdzWzBdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q29va2llICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFyaWFudDogZmFpbGVkIHRvIGdlbmVyYXRlIGNvb2tpZSBmb3IgJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbHJlYWR5QWRkZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldENvb2tpZSA9IHNlcmlhbGl6ZUNvb2tpZShkZXNlcmlhbGl6ZUNvb2tpZSh0aGlzLnJlc3BvbnNlKS5maWx0ZXIoKHZhbHVlKT0+IXZhbHVlLnN0YXJ0c1dpdGgoYCR7YXJnc1swXX09YCkpKTtcbiAgICAgICAgICAgIGlmIChzZXRDb29raWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuc2V0KFwic2V0LWNvb2tpZVwiLCBbXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb29raWUsXG4gICAgICAgICAgICAgICAgICAgIHNldENvb2tpZVxuICAgICAgICAgICAgICAgIF0uam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5oZWFkZXJzLnNldChcInNldC1jb29raWVcIiwgY3VycmVudENvb2tpZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuYXBwZW5kKFwic2V0LWNvb2tpZVwiLCBjdXJyZW50Q29va2llKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGRlbGV0ZSA9IChrZXksIG9wdGlvbnMgPSB7fSk9PntcbiAgICAgICAgY29uc3QgaXNEZWxldGVkID0gc3VwZXIuZGVsZXRlKGtleSk7XG4gICAgICAgIGlmIChpc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldENvb2tpZSA9IHNlcmlhbGl6ZUNvb2tpZShkZXNlcmlhbGl6ZUNvb2tpZSh0aGlzLnJlc3BvbnNlKS5maWx0ZXIoKHZhbHVlKT0+IXZhbHVlLnN0YXJ0c1dpdGgoYCR7a2V5fT1gKSkpO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlZENvb2tpZSA9IHNlcmlhbGl6ZUV4cGlyZWRDb29raWUoa2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UuaGVhZGVycy5zZXQoXCJzZXQtY29va2llXCIsIFtcbiAgICAgICAgICAgICAgICBleHBpcmVkQ29va2llLFxuICAgICAgICAgICAgICAgIHNldENvb2tpZVxuICAgICAgICAgICAgXS5qb2luKFwiLCBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0RlbGV0ZWQ7XG4gICAgfTtcbiAgICBjbGVhciA9IChvcHRpb25zID0ge30pPT57XG4gICAgICAgIGNvbnN0IGV4cGlyZWRDb29raWVzID0gQXJyYXkuZnJvbShzdXBlci5rZXlzKCkpLm1hcCgoa2V5KT0+c2VyaWFsaXplRXhwaXJlZENvb2tpZShrZXksIG9wdGlvbnMpKS5qb2luKFwiLCBcIik7XG4gICAgICAgIGlmIChleHBpcmVkQ29va2llcykgdGhpcy5yZXNwb25zZS5oZWFkZXJzLnNldChcInNldC1jb29raWVcIiwgZXhwaXJlZENvb2tpZXMpO1xuICAgICAgICByZXR1cm4gc3VwZXIuY2xlYXIoKTtcbiAgICB9O1xufVxuZXhwb3J0cy5OZXh0Q29va2llcyA9IE5leHRDb29raWVzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb29raWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/web/spec-extension/cookies.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/web/spec-extension/fetch-event.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/fetch-event.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.waitUntilSymbol = void 0;\nvar _error = __webpack_require__(/*! ../error */ \"(middleware)/./node_modules/next/dist/server/web/error.js\");\nconst responseSymbol = Symbol(\"response\");\nconst passThroughSymbol = Symbol(\"passThrough\");\nconst waitUntilSymbol = Symbol(\"waitUntil\");\nexports.waitUntilSymbol = waitUntilSymbol;\nclass FetchEvent {\n    [waitUntilSymbol] = [];\n    [passThroughSymbol] = false;\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(_request){}\n    respondWith(response) {\n        if (!this[responseSymbol]) {\n            this[responseSymbol] = Promise.resolve(response);\n        }\n    }\n    passThroughOnException() {\n        this[passThroughSymbol] = true;\n    }\n    waitUntil(promise) {\n        this[waitUntilSymbol].push(promise);\n    }\n}\nclass NextFetchEvent extends FetchEvent {\n    constructor(params){\n        super(params.request);\n        this.sourcePage = params.page;\n    }\n    /**\n   * @deprecated The `request` is now the first parameter and the API is now async.\n   *\n   * Read more: https://nextjs.org/docs/messages/middleware-new-signature\n   */ get request() {\n        throw new _error.PageSignatureError({\n            page: this.sourcePage\n        });\n    }\n    /**\n   * @deprecated Using `respondWith` is no longer needed.\n   *\n   * Read more: https://nextjs.org/docs/messages/middleware-new-signature\n   */ respondWith() {\n        throw new _error.PageSignatureError({\n            page: this.sourcePage\n        });\n    }\n}\nexports.NextFetchEvent = NextFetchEvent;\n\n//# sourceMappingURL=fetch-event.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2ZldGNoLWV2ZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUJBQXVCO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQywyRUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9mZXRjaC1ldmVudC5qcz9iODMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy53YWl0VW50aWxTeW1ib2wgPSB2b2lkIDA7XG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuY29uc3QgcmVzcG9uc2VTeW1ib2wgPSBTeW1ib2woXCJyZXNwb25zZVwiKTtcbmNvbnN0IHBhc3NUaHJvdWdoU3ltYm9sID0gU3ltYm9sKFwicGFzc1Rocm91Z2hcIik7XG5jb25zdCB3YWl0VW50aWxTeW1ib2wgPSBTeW1ib2woXCJ3YWl0VW50aWxcIik7XG5leHBvcnRzLndhaXRVbnRpbFN5bWJvbCA9IHdhaXRVbnRpbFN5bWJvbDtcbmNsYXNzIEZldGNoRXZlbnQge1xuICAgIFt3YWl0VW50aWxTeW1ib2xdID0gW107XG4gICAgW3Bhc3NUaHJvdWdoU3ltYm9sXSA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlbGVzcy1jb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdG9yKF9yZXF1ZXN0KXt9XG4gICAgcmVzcG9uZFdpdGgocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzW3Jlc3BvbnNlU3ltYm9sXSkge1xuICAgICAgICAgICAgdGhpc1tyZXNwb25zZVN5bWJvbF0gPSBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhc3NUaHJvdWdoT25FeGNlcHRpb24oKSB7XG4gICAgICAgIHRoaXNbcGFzc1Rocm91Z2hTeW1ib2xdID0gdHJ1ZTtcbiAgICB9XG4gICAgd2FpdFVudGlsKHByb21pc2UpIHtcbiAgICAgICAgdGhpc1t3YWl0VW50aWxTeW1ib2xdLnB1c2gocHJvbWlzZSk7XG4gICAgfVxufVxuY2xhc3MgTmV4dEZldGNoRXZlbnQgZXh0ZW5kcyBGZXRjaEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpe1xuICAgICAgICBzdXBlcihwYXJhbXMucmVxdWVzdCk7XG4gICAgICAgIHRoaXMuc291cmNlUGFnZSA9IHBhcmFtcy5wYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGByZXF1ZXN0YCBpcyBub3cgdGhlIGZpcnN0IHBhcmFtZXRlciBhbmQgdGhlIEFQSSBpcyBub3cgYXN5bmMuXG4gICAqXG4gICAqIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1uZXctc2lnbmF0dXJlXG4gICAqLyBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9lcnJvci5QYWdlU2lnbmF0dXJlRXJyb3Ioe1xuICAgICAgICAgICAgcGFnZTogdGhpcy5zb3VyY2VQYWdlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNpbmcgYHJlc3BvbmRXaXRoYCBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgKlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pZGRsZXdhcmUtbmV3LXNpZ25hdHVyZVxuICAgKi8gcmVzcG9uZFdpdGgoKSB7XG4gICAgICAgIHRocm93IG5ldyBfZXJyb3IuUGFnZVNpZ25hdHVyZUVycm9yKHtcbiAgICAgICAgICAgIHBhZ2U6IHRoaXMuc291cmNlUGFnZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk5leHRGZXRjaEV2ZW50ID0gTmV4dEZldGNoRXZlbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLWV2ZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/web/spec-extension/fetch-event.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/web/spec-extension/request.js":
/*!*********************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/request.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.INTERNALS = void 0;\nvar _nextUrl = __webpack_require__(/*! ../next-url */ \"(middleware)/./node_modules/next/dist/server/web/next-url.js\");\nvar _utils = __webpack_require__(/*! ../utils */ \"(middleware)/./node_modules/next/dist/server/web/utils.js\");\nvar _error = __webpack_require__(/*! ../error */ \"(middleware)/./node_modules/next/dist/server/web/error.js\");\nvar _cookies = __webpack_require__(/*! ./cookies */ \"(middleware)/./node_modules/next/dist/server/web/spec-extension/cookies.js\");\nconst INTERNALS = Symbol(\"internal request\");\nexports.INTERNALS = INTERNALS;\nclass NextRequest extends Request {\n    constructor(input, init = {}){\n        const url = typeof input !== \"string\" && \"url\" in input ? input.url : String(input);\n        (0, _utils).validateURL(url);\n        super(url, init);\n        this[INTERNALS] = {\n            cookies: new _cookies.NextCookies(this),\n            geo: init.geo || {},\n            ip: init.ip,\n            url: new _nextUrl.NextURL(url, {\n                headers: (0, _utils).toNodeHeaders(this.headers),\n                nextConfig: init.nextConfig\n            })\n        };\n    }\n    [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n        return {\n            cookies: this.cookies,\n            geo: this.geo,\n            ip: this.ip,\n            nextUrl: this.nextUrl,\n            url: this.url,\n            // rest of props come from Request\n            bodyUsed: this.bodyUsed,\n            cache: this.cache,\n            credentials: this.credentials,\n            destination: this.destination,\n            headers: Object.fromEntries(this.headers),\n            integrity: this.integrity,\n            keepalive: this.keepalive,\n            method: this.method,\n            mode: this.mode,\n            redirect: this.redirect,\n            referrer: this.referrer,\n            referrerPolicy: this.referrerPolicy,\n            signal: this.signal\n        };\n    }\n    get cookies() {\n        return this[INTERNALS].cookies;\n    }\n    get geo() {\n        return this[INTERNALS].geo;\n    }\n    get ip() {\n        return this[INTERNALS].ip;\n    }\n    get nextUrl() {\n        return this[INTERNALS].url;\n    }\n    /**\n   * @deprecated\n   * `page` has been deprecated in favour of `URLPattern`.\n   * Read more: https://nextjs.org/docs/messages/middleware-request-page\n   */ get page() {\n        throw new _error.RemovedPageError();\n    }\n    /**\n   * @deprecated\n   * `ua` has been removed in favour of \\`userAgent\\` function.\n   * Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent\n   */ get ua() {\n        throw new _error.RemovedUAError();\n    }\n    get url() {\n        return this[INTERNALS].url.toString();\n    }\n}\nexports.NextRequest = NextRequest;\n\n//# sourceMappingURL=request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL3JlcXVlc3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixpQkFBaUI7QUFDakIsZUFBZSxtQkFBTyxDQUFDLGlGQUFhO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQywyRUFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsMkVBQVU7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLDZGQUFXO0FBQ2xDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9yZXF1ZXN0LmpzPzgzNzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLklOVEVSTkFMUyA9IHZvaWQgMDtcbnZhciBfbmV4dFVybCA9IHJlcXVpcmUoXCIuLi9uZXh0LXVybFwiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xudmFyIF9jb29raWVzID0gcmVxdWlyZShcIi4vY29va2llc1wiKTtcbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbChcImludGVybmFsIHJlcXVlc3RcIik7XG5leHBvcnRzLklOVEVSTkFMUyA9IElOVEVSTkFMUztcbmNsYXNzIE5leHRSZXF1ZXN0IGV4dGVuZHMgUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQsIGluaXQgPSB7fSl7XG4gICAgICAgIGNvbnN0IHVybCA9IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIiAmJiBcInVybFwiIGluIGlucHV0ID8gaW5wdXQudXJsIDogU3RyaW5nKGlucHV0KTtcbiAgICAgICAgKDAsIF91dGlscykudmFsaWRhdGVVUkwodXJsKTtcbiAgICAgICAgc3VwZXIodXJsLCBpbml0KTtcbiAgICAgICAgdGhpc1tJTlRFUk5BTFNdID0ge1xuICAgICAgICAgICAgY29va2llczogbmV3IF9jb29raWVzLk5leHRDb29raWVzKHRoaXMpLFxuICAgICAgICAgICAgZ2VvOiBpbml0LmdlbyB8fCB7fSxcbiAgICAgICAgICAgIGlwOiBpbml0LmlwLFxuICAgICAgICAgICAgdXJsOiBuZXcgX25leHRVcmwuTmV4dFVSTCh1cmwsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiAoMCwgX3V0aWxzKS50b05vZGVIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZzogaW5pdC5uZXh0Q29uZmlnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcihcImVkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb29raWVzOiB0aGlzLmNvb2tpZXMsXG4gICAgICAgICAgICBnZW86IHRoaXMuZ2VvLFxuICAgICAgICAgICAgaXA6IHRoaXMuaXAsXG4gICAgICAgICAgICBuZXh0VXJsOiB0aGlzLm5leHRVcmwsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgLy8gcmVzdCBvZiBwcm9wcyBjb21lIGZyb20gUmVxdWVzdFxuICAgICAgICAgICAgYm9keVVzZWQ6IHRoaXMuYm9keVVzZWQsXG4gICAgICAgICAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHRoaXMuZGVzdGluYXRpb24sXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIGludGVncml0eTogdGhpcy5pbnRlZ3JpdHksXG4gICAgICAgICAgICBrZWVwYWxpdmU6IHRoaXMua2VlcGFsaXZlLFxuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0LFxuICAgICAgICAgICAgcmVmZXJyZXI6IHRoaXMucmVmZXJyZXIsXG4gICAgICAgICAgICByZWZlcnJlclBvbGljeTogdGhpcy5yZWZlcnJlclBvbGljeSxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGNvb2tpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMU10uY29va2llcztcbiAgICB9XG4gICAgZ2V0IGdlbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTXS5nZW87XG4gICAgfVxuICAgIGdldCBpcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTXS5pcDtcbiAgICB9XG4gICAgZ2V0IG5leHRVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMU10udXJsO1xuICAgIH1cbiAgICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogYHBhZ2VgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGBVUkxQYXR0ZXJuYC5cbiAgICogUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9taWRkbGV3YXJlLXJlcXVlc3QtcGFnZVxuICAgKi8gZ2V0IHBhZ2UoKSB7XG4gICAgICAgIHRocm93IG5ldyBfZXJyb3IuUmVtb3ZlZFBhZ2VFcnJvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogYHVhYCBoYXMgYmVlbiByZW1vdmVkIGluIGZhdm91ciBvZiBcXGB1c2VyQWdlbnRcXGAgZnVuY3Rpb24uXG4gICAqIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1wYXJzZS11c2VyLWFnZW50XG4gICAqLyBnZXQgdWEoKSB7XG4gICAgICAgIHRocm93IG5ldyBfZXJyb3IuUmVtb3ZlZFVBRXJyb3IoKTtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTXS51cmwudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLk5leHRSZXF1ZXN0ID0gTmV4dFJlcXVlc3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/web/spec-extension/request.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/web/spec-extension/response.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/response.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _nextUrl = __webpack_require__(/*! ../next-url */ \"(middleware)/./node_modules/next/dist/server/web/next-url.js\");\nvar _utils = __webpack_require__(/*! ../utils */ \"(middleware)/./node_modules/next/dist/server/web/utils.js\");\nvar _cookies = __webpack_require__(/*! ./cookies */ \"(middleware)/./node_modules/next/dist/server/web/spec-extension/cookies.js\");\nconst INTERNALS = Symbol(\"internal response\");\nconst REDIRECTS = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nclass NextResponse extends Response {\n    constructor(body, init = {}){\n        super(body, init);\n        this[INTERNALS] = {\n            cookies: new _cookies.NextCookies(this),\n            url: init.url ? new _nextUrl.NextURL(init.url, {\n                headers: (0, _utils).toNodeHeaders(this.headers),\n                nextConfig: init.nextConfig\n            }) : undefined\n        };\n    }\n    [Symbol.for(\"edge-runtime.inspect.custom\")]() {\n        return {\n            cookies: this.cookies,\n            url: this.url,\n            // rest of props come from Response\n            body: this.body,\n            bodyUsed: this.bodyUsed,\n            headers: Object.fromEntries(this.headers),\n            ok: this.ok,\n            redirected: this.redirected,\n            status: this.status,\n            statusText: this.statusText,\n            type: this.type\n        };\n    }\n    get cookies() {\n        return this[INTERNALS].cookies;\n    }\n    static json(body, init) {\n        // @ts-expect-error This is not in lib/dom right now, and we can't augment it.\n        const response = Response.json(body, init);\n        return new NextResponse(response.body, response);\n    }\n    static redirect(url, init) {\n        var ref;\n        const status = typeof init === \"number\" ? init : (ref = init == null ? void 0 : init.status) != null ? ref : 307;\n        if (!REDIRECTS.has(status)) {\n            throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n        }\n        const initObj = typeof init === \"object\" ? init : {};\n        const headers = new Headers(initObj == null ? void 0 : initObj.headers);\n        headers.set(\"Location\", (0, _utils).validateURL(url));\n        return new NextResponse(null, {\n            ...initObj,\n            headers,\n            status\n        });\n    }\n    static rewrite(destination, init) {\n        const headers = new Headers(init == null ? void 0 : init.headers);\n        headers.set(\"x-middleware-rewrite\", (0, _utils).validateURL(destination));\n        return new NextResponse(null, {\n            ...init,\n            headers\n        });\n    }\n    static next(init) {\n        const headers = new Headers(init == null ? void 0 : init.headers);\n        headers.set(\"x-middleware-next\", \"1\");\n        return new NextResponse(null, {\n            ...init,\n            headers\n        });\n    }\n}\nexports.NextResponse = NextResponse;\n\n//# sourceMappingURL=response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL3Jlc3BvbnNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZUFBZSxtQkFBTyxDQUFDLGlGQUFhO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQywyRUFBVTtBQUMvQixlQUFlLG1CQUFPLENBQUMsNkZBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9yZXNwb25zZS5qcz8wMTc0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF9uZXh0VXJsID0gcmVxdWlyZShcIi4uL25leHQtdXJsXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBfY29va2llcyA9IHJlcXVpcmUoXCIuL2Nvb2tpZXNcIik7XG5jb25zdCBJTlRFUk5BTFMgPSBTeW1ib2woXCJpbnRlcm5hbCByZXNwb25zZVwiKTtcbmNvbnN0IFJFRElSRUNUUyA9IG5ldyBTZXQoW1xuICAgIDMwMSxcbiAgICAzMDIsXG4gICAgMzAzLFxuICAgIDMwNyxcbiAgICAzMDhcbl0pO1xuY2xhc3MgTmV4dFJlc3BvbnNlIGV4dGVuZHMgUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJvZHksIGluaXQgPSB7fSl7XG4gICAgICAgIHN1cGVyKGJvZHksIGluaXQpO1xuICAgICAgICB0aGlzW0lOVEVSTkFMU10gPSB7XG4gICAgICAgICAgICBjb29raWVzOiBuZXcgX2Nvb2tpZXMuTmV4dENvb2tpZXModGhpcyksXG4gICAgICAgICAgICB1cmw6IGluaXQudXJsID8gbmV3IF9uZXh0VXJsLk5leHRVUkwoaW5pdC51cmwsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiAoMCwgX3V0aWxzKS50b05vZGVIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZzogaW5pdC5uZXh0Q29uZmlnXG4gICAgICAgICAgICB9KSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcihcImVkZ2UtcnVudGltZS5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb29raWVzOiB0aGlzLmNvb2tpZXMsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgLy8gcmVzdCBvZiBwcm9wcyBjb21lIGZyb20gUmVzcG9uc2VcbiAgICAgICAgICAgIGJvZHk6IHRoaXMuYm9keSxcbiAgICAgICAgICAgIGJvZHlVc2VkOiB0aGlzLmJvZHlVc2VkLFxuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICBvazogdGhpcy5vayxcbiAgICAgICAgICAgIHJlZGlyZWN0ZWQ6IHRoaXMucmVkaXJlY3RlZCxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGNvb2tpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMU10uY29va2llcztcbiAgICB9XG4gICAgc3RhdGljIGpzb24oYm9keSwgaW5pdCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgaXMgbm90IGluIGxpYi9kb20gcmlnaHQgbm93LCBhbmQgd2UgY2FuJ3QgYXVnbWVudCBpdC5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBSZXNwb25zZS5qc29uKGJvZHksIGluaXQpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShyZXNwb25zZS5ib2R5LCByZXNwb25zZSk7XG4gICAgfVxuICAgIHN0YXRpYyByZWRpcmVjdCh1cmwsIGluaXQpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyBpbml0IDogKHJlZiA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gcmVmIDogMzA3O1xuICAgICAgICBpZiAoIVJFRElSRUNUUy5oYXMoc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFwicmVkaXJlY3RcIiBvbiBcInJlc3BvbnNlXCI6IEludmFsaWQgc3RhdHVzIGNvZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0T2JqID0gdHlwZW9mIGluaXQgPT09IFwib2JqZWN0XCIgPyBpbml0IDoge307XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0T2JqID09IG51bGwgPyB2b2lkIDAgOiBpbml0T2JqLmhlYWRlcnMpO1xuICAgICAgICBoZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsICgwLCBfdXRpbHMpLnZhbGlkYXRlVVJMKHVybCkpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICAuLi5pbml0T2JqLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1c1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHJld3JpdGUoZGVzdGluYXRpb24sIGluaXQpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycyk7XG4gICAgICAgIGhlYWRlcnMuc2V0KFwieC1taWRkbGV3YXJlLXJld3JpdGVcIiwgKDAsIF91dGlscykudmFsaWRhdGVVUkwoZGVzdGluYXRpb24pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBuZXh0KGluaXQpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycyk7XG4gICAgICAgIGhlYWRlcnMuc2V0KFwieC1taWRkbGV3YXJlLW5leHRcIiwgXCIxXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk5leHRSZXNwb25zZSA9IE5leHRSZXNwb25zZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzcG9uc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/web/spec-extension/response.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/next/dist/server/web/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/server/web/utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fromNodeHeaders = fromNodeHeaders;\nexports.splitCookiesString = splitCookiesString;\nexports.toNodeHeaders = toNodeHeaders;\nexports.validateURL = validateURL;\nfunction fromNodeHeaders(object) {\n    const headers = new Headers();\n    for (let [key, value] of Object.entries(object)){\n        const values = Array.isArray(value) ? value : [\n            value\n        ];\n        for (let v of values){\n            if (v !== undefined) {\n                headers.append(key, v);\n            }\n        }\n    }\n    return headers;\n}\nfunction splitCookiesString(cookiesString) {\n    var cookiesStrings = [];\n    var pos = 0;\n    var start;\n    var ch;\n    var lastComma;\n    var nextStart;\n    var cookiesSeparatorFound;\n    function skipWhitespace() {\n        while(pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))){\n            pos += 1;\n        }\n        return pos < cookiesString.length;\n    }\n    function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n    }\n    while(pos < cookiesString.length){\n        start = pos;\n        cookiesSeparatorFound = false;\n        while(skipWhitespace()){\n            ch = cookiesString.charAt(pos);\n            if (ch === \",\") {\n                // ',' is a cookie separator if we have later first '=', not ';' or ','\n                lastComma = pos;\n                pos += 1;\n                skipWhitespace();\n                nextStart = pos;\n                while(pos < cookiesString.length && notSpecialChar()){\n                    pos += 1;\n                }\n                // currently special character\n                if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n                    // we found cookies separator\n                    cookiesSeparatorFound = true;\n                    // pos is inside the next cookie, so back up and return it.\n                    pos = nextStart;\n                    cookiesStrings.push(cookiesString.substring(start, lastComma));\n                    start = pos;\n                } else {\n                    // in param ',' or param separator ';',\n                    // we continue from that comma\n                    pos = lastComma + 1;\n                }\n            } else {\n                pos += 1;\n            }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n    }\n    return cookiesStrings;\n}\nfunction toNodeHeaders(headers) {\n    const result = {};\n    if (headers) {\n        for (const [key, value] of headers.entries()){\n            result[key] = value;\n            if (key.toLowerCase() === \"set-cookie\") {\n                result[key] = splitCookiesString(value);\n            }\n        }\n    }\n    return result;\n}\nfunction validateURL(url) {\n    try {\n        return String(new URL(String(url)));\n    } catch (error) {\n        throw new Error(`URLs is malformed. Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, {\n            cause: error\n        });\n    }\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi91dGlscy5qcz81MTE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mcm9tTm9kZUhlYWRlcnMgPSBmcm9tTm9kZUhlYWRlcnM7XG5leHBvcnRzLnNwbGl0Q29va2llc1N0cmluZyA9IHNwbGl0Q29va2llc1N0cmluZztcbmV4cG9ydHMudG9Ob2RlSGVhZGVycyA9IHRvTm9kZUhlYWRlcnM7XG5leHBvcnRzLnZhbGlkYXRlVVJMID0gdmFsaWRhdGVVUkw7XG5mdW5jdGlvbiBmcm9tTm9kZUhlYWRlcnMob2JqZWN0KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpe1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChsZXQgdiBvZiB2YWx1ZXMpe1xuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llc1N0cmluZykge1xuICAgIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBzdGFydDtcbiAgICB2YXIgY2g7XG4gICAgdmFyIGxhc3RDb21tYTtcbiAgICB2YXIgbmV4dFN0YXJ0O1xuICAgIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG4gICAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHdoaWxlKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIC9cXHMvLnRlc3QoY29va2llc1N0cmluZy5jaGFyQXQocG9zKSkpe1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3RTcGVjaWFsQ2hhcigpIHtcbiAgICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gICAgfVxuICAgIHdoaWxlKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKXtcbiAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZShza2lwV2hpdGVzcGFjZSgpKXtcbiAgICAgICAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAvLyAnLCcgaXMgYSBjb29raWUgc2VwYXJhdG9yIGlmIHdlIGhhdmUgbGF0ZXIgZmlyc3QgJz0nLCBub3QgJzsnIG9yICcsJ1xuICAgICAgICAgICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgICB3aGlsZShwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKXtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSBzcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBjb29raWVzIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBwb3MgaXMgaW5zaWRlIHRoZSBuZXh0IGNvb2tpZSwgc28gYmFjayB1cCBhbmQgcmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBwYXJhbSAnLCcgb3IgcGFyYW0gc2VwYXJhdG9yICc7JyxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY29udGludWUgZnJvbSB0aGF0IGNvbW1hXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xufVxuZnVuY3Rpb24gdG9Ob2RlSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaGVhZGVycy5lbnRyaWVzKCkpe1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJzZXQtY29va2llXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHNwbGl0Q29va2llc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVVJMKHVybCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcobmV3IFVSTChTdHJpbmcodXJsKSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVVJMcyBpcyBtYWxmb3JtZWQuIFBsZWFzZSB1c2Ugb25seSBhYnNvbHV0ZSBVUkxzIC0gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbWlkZGxld2FyZS1yZWxhdGl2ZS11cmxzYCwge1xuICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/server/web/utils.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports[\"default\"] = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBZTtBQUNoQjs7QUFFQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzPzI4ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuXHQvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcblx0Ly8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG5cdC8vIEhvd2V2ZXIsIHRoaXMgY2F1c2VzIENTUCB2aW9sYXRpb25zIGluIENocm9tZSBhcHBzLlxuXHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9XG5cdGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9XG5cdHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jyk7XG59XG5cbnZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZ2xvYmFsLmZldGNoO1xuXG4vLyBOZWVkZWQgZm9yIFR5cGVTY3JpcHQgYW5kIFdlYnBhY2suXG5pZiAoZ2xvYmFsLmZldGNoKSB7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGdsb2JhbC5mZXRjaC5iaW5kKGdsb2JhbCk7XG59XG5cbmV4cG9ydHMuSGVhZGVycyA9IGdsb2JhbC5IZWFkZXJzO1xuZXhwb3J0cy5SZXF1ZXN0ID0gZ2xvYmFsLlJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gZ2xvYmFsLlJlc3BvbnNlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/node-fetch/browser.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/postcss-value-parser/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var parse = __webpack_require__(/*! ./parse */ \"(middleware)/./node_modules/postcss-value-parser/lib/parse.js\");\nvar walk = __webpack_require__(/*! ./walk */ \"(middleware)/./node_modules/postcss-value-parser/lib/walk.js\");\nvar stringify = __webpack_require__(/*! ./stringify */ \"(middleware)/./node_modules/postcss-value-parser/lib/stringify.js\");\n\nfunction ValueParser(value) {\n  if (this instanceof ValueParser) {\n    this.nodes = parse(value);\n    return this;\n  }\n  return new ValueParser(value);\n}\n\nValueParser.prototype.toString = function() {\n  return Array.isArray(this.nodes) ? stringify(this.nodes) : \"\";\n};\n\nValueParser.prototype.walk = function(cb, bubble) {\n  walk(this.nodes, cb, bubble);\n  return this;\n};\n\nValueParser.unit = __webpack_require__(/*! ./unit */ \"(middleware)/./node_modules/postcss-value-parser/lib/unit.js\");\n\nValueParser.walk = walk;\n\nValueParser.stringify = stringify;\n\nmodule.exports = ValueParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsOEVBQVM7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLDRFQUFRO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLHNGQUFhOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVE7O0FBRW5DOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXZhbHVlLXBhcnNlci9saWIvaW5kZXguanM/YmVjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcbnZhciB3YWxrID0gcmVxdWlyZShcIi4vd2Fsa1wiKTtcbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnlcIik7XG5cbmZ1bmN0aW9uIFZhbHVlUGFyc2VyKHZhbHVlKSB7XG4gIGlmICh0aGlzIGluc3RhbmNlb2YgVmFsdWVQYXJzZXIpIHtcbiAgICB0aGlzLm5vZGVzID0gcGFyc2UodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiBuZXcgVmFsdWVQYXJzZXIodmFsdWUpO1xufVxuXG5WYWx1ZVBhcnNlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5ub2RlcykgPyBzdHJpbmdpZnkodGhpcy5ub2RlcykgOiBcIlwiO1xufTtcblxuVmFsdWVQYXJzZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbihjYiwgYnViYmxlKSB7XG4gIHdhbGsodGhpcy5ub2RlcywgY2IsIGJ1YmJsZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmFsdWVQYXJzZXIudW5pdCA9IHJlcXVpcmUoXCIuL3VuaXRcIik7XG5cblZhbHVlUGFyc2VyLndhbGsgPSB3YWxrO1xuXG5WYWx1ZVBhcnNlci5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsdWVQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/postcss-value-parser/lib/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/postcss-value-parser/lib/parse.js":
/*!********************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/parse.js ***!
  \********************************************************/
/***/ ((module) => {

eval("var openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nmodule.exports = function(input) {\n  var tokens = [];\n  var value = input;\n\n  var next,\n    quote,\n    prev,\n    token,\n    escape,\n    escapePos,\n    whitespacePos,\n    parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{ nodes: tokens }];\n  var balanced = 0;\n  var parent;\n\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      token = value.slice(pos, next);\n\n      prev = tokens[tokens.length - 1];\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (\n        code === comma ||\n        code === colon ||\n        (code === slash &&\n          value.charCodeAt(next + 1) !== star &&\n          (!parent ||\n            (parent && parent.type === \"function\" && parent.value !== \"calc\")))\n      ) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n\n      // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n        if (~next) {\n          escapePos = next;\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos);\n\n      // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n\n      pos = next + 2;\n      code = value.charCodeAt(pos);\n\n      // Operation within calc\n    } else if (\n      (code === slash || code === star) &&\n      parent &&\n      parent.type === \"function\" &&\n      parent.value === \"calc\"\n    ) {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n          if (~next) {\n            escapePos = next;\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape);\n        // Whitespaces before closed\n        whitespacePos = next;\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [\n              {\n                type: \"word\",\n                sourceIndex: pos,\n                sourceEndIndex: whitespacePos + 1,\n                value: value.slice(pos, whitespacePos + 1)\n              }\n            ];\n          } else {\n            token.nodes = [];\n          }\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n      name = \"\";\n\n      // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes;\n\n      // Words\n    } else {\n      next = pos;\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (\n        next < max &&\n        !(\n          code <= 32 ||\n          code === singleQuote ||\n          code === doubleQuote ||\n          code === comma ||\n          code === colon ||\n          code === slash ||\n          code === openParentheses ||\n          (code === star &&\n            parent &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === slash &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === closeParentheses && balanced)\n        )\n      );\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if (\n        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&\n        plus === token.charCodeAt(1) &&\n        isUnicodeRange.test(token.slice(2))\n      ) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi9wYXJzZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXZhbHVlLXBhcnNlci9saWIvcGFyc2UuanM/OThiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgb3BlblBhcmVudGhlc2VzID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbnZhciBjbG9zZVBhcmVudGhlc2VzID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzaW5nbGVRdW90ZSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgZG91YmxlUXVvdGUgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG52YXIgYmFja3NsYXNoID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzbGFzaCA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgY29tbWEgPSBcIixcIi5jaGFyQ29kZUF0KDApO1xudmFyIGNvbG9uID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbnZhciBzdGFyID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbnZhciB1TG93ZXIgPSBcInVcIi5jaGFyQ29kZUF0KDApO1xudmFyIHVVcHBlciA9IFwiVVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgcGx1cyA9IFwiK1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgaXNVbmljb2RlUmFuZ2UgPSAvXlthLWYwLTk/LV0rJC9pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgdmFyIG5leHQsXG4gICAgcXVvdGUsXG4gICAgcHJldixcbiAgICB0b2tlbixcbiAgICBlc2NhcGUsXG4gICAgZXNjYXBlUG9zLFxuICAgIHdoaXRlc3BhY2VQb3MsXG4gICAgcGFyZW50aGVzZXNPcGVuUG9zO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG4gIHZhciBtYXggPSB2YWx1ZS5sZW5ndGg7XG4gIHZhciBzdGFjayA9IFt7IG5vZGVzOiB0b2tlbnMgfV07XG4gIHZhciBiYWxhbmNlZCA9IDA7XG4gIHZhciBwYXJlbnQ7XG5cbiAgdmFyIG5hbWUgPSBcIlwiO1xuICB2YXIgYmVmb3JlID0gXCJcIjtcbiAgdmFyIGFmdGVyID0gXCJcIjtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgLy8gV2hpdGVzcGFjZXNcbiAgICBpZiAoY29kZSA8PSAzMikge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgdG9rZW4gPSB2YWx1ZS5zbGljZShwb3MsIG5leHQpO1xuXG4gICAgICBwcmV2ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjb2RlID09PSBjbG9zZVBhcmVudGhlc2VzICYmIGJhbGFuY2VkKSB7XG4gICAgICAgIGFmdGVyID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcImRpdlwiKSB7XG4gICAgICAgIHByZXYuYWZ0ZXIgPSB0b2tlbjtcbiAgICAgICAgcHJldi5zb3VyY2VFbmRJbmRleCArPSB0b2tlbi5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICBjb2RlID09PSBjb2xvbiB8fFxuICAgICAgICAoY29kZSA9PT0gc2xhc2ggJiZcbiAgICAgICAgICB2YWx1ZS5jaGFyQ29kZUF0KG5leHQgKyAxKSAhPT0gc3RhciAmJlxuICAgICAgICAgICghcGFyZW50IHx8XG4gICAgICAgICAgICAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgcGFyZW50LnZhbHVlICE9PSBcImNhbGNcIikpKVxuICAgICAgKSB7XG4gICAgICAgIGJlZm9yZSA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic3BhY2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcblxuICAgICAgLy8gUXVvdGVzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzaW5nbGVRdW90ZSB8fCBjb2RlID09PSBkb3VibGVRdW90ZSkge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIHF1b3RlID0gY29kZSA9PT0gc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyxcbiAgICAgICAgcXVvdGU6IHF1b3RlXG4gICAgICB9O1xuICAgICAgZG8ge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAodmFsdWUuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gYmFja3NsYXNoKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICs9IHF1b3RlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoZXNjYXBlKTtcbiAgICAgIHRva2VuLnZhbHVlID0gdmFsdWUuc2xpY2UocG9zICsgMSwgbmV4dCk7XG4gICAgICB0b2tlbi5zb3VyY2VFbmRJbmRleCA9IHRva2VuLnVuY2xvc2VkID8gbmV4dCA6IG5leHQgKyAxO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAvLyBDb21tZW50c1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gc2xhc2ggJiYgdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gc3Rhcikge1xuICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YoXCIqL1wiLCBwb3MpO1xuXG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0ICsgMlxuICAgICAgfTtcblxuICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdG9rZW4uc291cmNlRW5kSW5kZXggPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi52YWx1ZSA9IHZhbHVlLnNsaWNlKHBvcyArIDIsIG5leHQpO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBwb3MgPSBuZXh0ICsgMjtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZXJhdGlvbiB3aXRoaW4gY2FsY1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAoY29kZSA9PT0gc2xhc2ggfHwgY29kZSA9PT0gc3RhcikgJiZcbiAgICAgIHBhcmVudCAmJlxuICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIlxuICAgICkge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIGJlZm9yZS5sZW5ndGgsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBwb3MgKyB0b2tlbi5sZW5ndGgsXG4gICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgfSk7XG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIERpdmlkZXJzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzbGFzaCB8fCBjb2RlID09PSBjb21tYSB8fCBjb2RlID09PSBjb2xvbikge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZGl2XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MgLSBiZWZvcmUubGVuZ3RoLFxuICAgICAgICBzb3VyY2VFbmRJbmRleDogcG9zICsgdG9rZW4ubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogdG9rZW4sXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBhZnRlcjogXCJcIlxuICAgICAgfSk7XG4gICAgICBiZWZvcmUgPSBcIlwiO1xuXG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZW4gcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgLy8gV2hpdGVzcGFjZXMgYWZ0ZXIgb3BlbiBwYXJlbnRoZXNlc1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgcGFyZW50aGVzZXNPcGVuUG9zID0gcG9zO1xuICAgICAgdG9rZW4gPSB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIG5hbWUubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgYmVmb3JlOiB2YWx1ZS5zbGljZShwYXJlbnRoZXNlc09wZW5Qb3MgKyAxLCBuZXh0KVxuICAgICAgfTtcbiAgICAgIHBvcyA9IG5leHQ7XG5cbiAgICAgIGlmIChuYW1lID09PSBcInVybFwiICYmIGNvZGUgIT09IHNpbmdsZVF1b3RlICYmIGNvZGUgIT09IGRvdWJsZVF1b3RlKSB7XG4gICAgICAgIG5leHQgLT0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKHZhbHVlLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IGJhY2tzbGFzaCkge1xuICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgZXNjYXBlID0gIWVzY2FwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gXCIpXCI7XG4gICAgICAgICAgICBuZXh0ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGVzY2FwZSk7XG4gICAgICAgIC8vIFdoaXRlc3BhY2VzIGJlZm9yZSBjbG9zZWRcbiAgICAgICAgd2hpdGVzcGFjZVBvcyA9IG5leHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB3aGl0ZXNwYWNlUG9zIC09IDE7XG4gICAgICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQod2hpdGVzcGFjZVBvcyk7XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgICBpZiAocGFyZW50aGVzZXNPcGVuUG9zIDwgd2hpdGVzcGFjZVBvcykge1xuICAgICAgICAgIGlmIChwb3MgIT09IHdoaXRlc3BhY2VQb3MgKyAxKSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwid29yZFwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IHdoaXRlc3BhY2VQb3MgKyAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZShwb3MsIHdoaXRlc3BhY2VQb3MgKyAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9rZW4udW5jbG9zZWQgJiYgd2hpdGVzcGFjZVBvcyArIDEgIT09IG5leHQpIHtcbiAgICAgICAgICAgIHRva2VuLmFmdGVyID0gXCJcIjtcbiAgICAgICAgICAgIHRva2VuLm5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInNwYWNlXCIsXG4gICAgICAgICAgICAgIHNvdXJjZUluZGV4OiB3aGl0ZXNwYWNlUG9zICsgMSxcbiAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IG5leHQsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSh3aGl0ZXNwYWNlUG9zICsgMSwgbmV4dClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5hZnRlciA9IHZhbHVlLnNsaWNlKHdoaXRlc3BhY2VQb3MgKyAxLCBuZXh0KTtcbiAgICAgICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4uYWZ0ZXIgPSBcIlwiO1xuICAgICAgICAgIHRva2VuLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gdG9rZW4udW5jbG9zZWQgPyBuZXh0IDogcG9zO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWxhbmNlZCArPSAxO1xuICAgICAgICB0b2tlbi5hZnRlciA9IFwiXCI7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW5zID0gdG9rZW4ubm9kZXMgPSBbXTtcbiAgICAgICAgcGFyZW50ID0gdG9rZW47XG4gICAgICB9XG4gICAgICBuYW1lID0gXCJcIjtcblxuICAgICAgLy8gQ2xvc2UgcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKGNsb3NlUGFyZW50aGVzZXMgPT09IGNvZGUgJiYgYmFsYW5jZWQpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgcGFyZW50LmFmdGVyID0gYWZ0ZXI7XG4gICAgICBwYXJlbnQuc291cmNlRW5kSW5kZXggKz0gYWZ0ZXIubGVuZ3RoO1xuICAgICAgYWZ0ZXIgPSBcIlwiO1xuICAgICAgYmFsYW5jZWQgLT0gMTtcbiAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnNvdXJjZUVuZEluZGV4ID0gcG9zO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBwYXJlbnQgPSBzdGFja1tiYWxhbmNlZF07XG4gICAgICB0b2tlbnMgPSBwYXJlbnQubm9kZXM7XG5cbiAgICAgIC8vIFdvcmRzXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBwb3M7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb2RlID09PSBiYWNrc2xhc2gpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICBuZXh0IDwgbWF4ICYmXG4gICAgICAgICEoXG4gICAgICAgICAgY29kZSA8PSAzMiB8fFxuICAgICAgICAgIGNvZGUgPT09IHNpbmdsZVF1b3RlIHx8XG4gICAgICAgICAgY29kZSA9PT0gZG91YmxlUXVvdGUgfHxcbiAgICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICAgIGNvZGUgPT09IGNvbG9uIHx8XG4gICAgICAgICAgY29kZSA9PT0gc2xhc2ggfHxcbiAgICAgICAgICBjb2RlID09PSBvcGVuUGFyZW50aGVzZXMgfHxcbiAgICAgICAgICAoY29kZSA9PT0gc3RhciAmJlxuICAgICAgICAgICAgcGFyZW50ICYmXG4gICAgICAgICAgICBwYXJlbnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICBwYXJlbnQudmFsdWUgPT09IFwiY2FsY1wiKSB8fFxuICAgICAgICAgIChjb2RlID09PSBzbGFzaCAmJlxuICAgICAgICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIikgfHxcbiAgICAgICAgICAoY29kZSA9PT0gY2xvc2VQYXJlbnRoZXNlcyAmJiBiYWxhbmNlZClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRva2VuID0gdmFsdWUuc2xpY2UocG9zLCBuZXh0KTtcblxuICAgICAgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgICBuYW1lID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodUxvd2VyID09PSB0b2tlbi5jaGFyQ29kZUF0KDApIHx8IHVVcHBlciA9PT0gdG9rZW4uY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgcGx1cyA9PT0gdG9rZW4uY2hhckNvZGVBdCgxKSAmJlxuICAgICAgICBpc1VuaWNvZGVSYW5nZS50ZXN0KHRva2VuLnNsaWNlKDIpKVxuICAgICAgKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInVuaWNvZGUtcmFuZ2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvczsgcG9zIC09IDEpIHtcbiAgICBzdGFja1twb3NdLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICBzdGFja1twb3NdLnNvdXJjZUVuZEluZGV4ID0gdmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrWzBdLm5vZGVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/postcss-value-parser/lib/parse.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/postcss-value-parser/lib/stringify.js":
/*!************************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/stringify.js ***!
  \************************************************************/
/***/ ((module) => {

eval("function stringifyNode(node, custom) {\n  var type = node.type;\n  var value = node.value;\n  var buf;\n  var customResult;\n\n  if (custom && (customResult = custom(node)) !== undefined) {\n    return customResult;\n  } else if (type === \"word\" || type === \"space\") {\n    return value;\n  } else if (type === \"string\") {\n    buf = node.quote || \"\";\n    return buf + value + (node.unclosed ? \"\" : buf);\n  } else if (type === \"comment\") {\n    return \"/*\" + value + (node.unclosed ? \"\" : \"*/\");\n  } else if (type === \"div\") {\n    return (node.before || \"\") + value + (node.after || \"\");\n  } else if (Array.isArray(node.nodes)) {\n    buf = stringify(node.nodes, custom);\n    if (type !== \"function\") {\n      return buf;\n    }\n    return (\n      value +\n      \"(\" +\n      (node.before || \"\") +\n      buf +\n      (node.after || \"\") +\n      (node.unclosed ? \"\" : \")\")\n    );\n  }\n  return value;\n}\n\nfunction stringify(nodes, custom) {\n  var result, i;\n\n  if (Array.isArray(nodes)) {\n    result = \"\";\n    for (i = nodes.length - 1; ~i; i -= 1) {\n      result = stringifyNode(nodes[i], custom) + result;\n    }\n    return result;\n  }\n  return stringifyNode(nodes, custom);\n}\n\nmodule.exports = stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi9zdHJpbmdpZnkuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy12YWx1ZS1wYXJzZXIvbGliL3N0cmluZ2lmeS5qcz8zMTIzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHN0cmluZ2lmeU5vZGUobm9kZSwgY3VzdG9tKSB7XG4gIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB2YXIgYnVmO1xuICB2YXIgY3VzdG9tUmVzdWx0O1xuXG4gIGlmIChjdXN0b20gJiYgKGN1c3RvbVJlc3VsdCA9IGN1c3RvbShub2RlKSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjdXN0b21SZXN1bHQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ3b3JkXCIgfHwgdHlwZSA9PT0gXCJzcGFjZVwiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBidWYgPSBub2RlLnF1b3RlIHx8IFwiXCI7XG4gICAgcmV0dXJuIGJ1ZiArIHZhbHVlICsgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogYnVmKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgIHJldHVybiBcIi8qXCIgKyB2YWx1ZSArIChub2RlLnVuY2xvc2VkID8gXCJcIiA6IFwiKi9cIik7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkaXZcIikge1xuICAgIHJldHVybiAobm9kZS5iZWZvcmUgfHwgXCJcIikgKyB2YWx1ZSArIChub2RlLmFmdGVyIHx8IFwiXCIpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5ub2RlcykpIHtcbiAgICBidWYgPSBzdHJpbmdpZnkobm9kZS5ub2RlcywgY3VzdG9tKTtcbiAgICBpZiAodHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWUgK1xuICAgICAgXCIoXCIgK1xuICAgICAgKG5vZGUuYmVmb3JlIHx8IFwiXCIpICtcbiAgICAgIGJ1ZiArXG4gICAgICAobm9kZS5hZnRlciB8fCBcIlwiKSArXG4gICAgICAobm9kZS51bmNsb3NlZCA/IFwiXCIgOiBcIilcIilcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGVzLCBjdXN0b20pIHtcbiAgdmFyIHJlc3VsdCwgaTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoaSA9IG5vZGVzLmxlbmd0aCAtIDE7IH5pOyBpIC09IDEpIHtcbiAgICAgIHJlc3VsdCA9IHN0cmluZ2lmeU5vZGUobm9kZXNbaV0sIGN1c3RvbSkgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeU5vZGUobm9kZXMsIGN1c3RvbSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/postcss-value-parser/lib/stringify.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/postcss-value-parser/lib/unit.js":
/*!*******************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/unit.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("var minus = \"-\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar dot = \".\".charCodeAt(0);\nvar exp = \"e\".charCodeAt(0);\nvar EXP = \"E\".charCodeAt(0);\n\n// Check if three code points would start a number\n// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number\nfunction likeNumber(value) {\n  var code = value.charCodeAt(0);\n  var nextCode;\n\n  if (code === plus || code === minus) {\n    nextCode = value.charCodeAt(1);\n\n    if (nextCode >= 48 && nextCode <= 57) {\n      return true;\n    }\n\n    var nextNextCode = value.charCodeAt(2);\n\n    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (code === dot) {\n    nextCode = value.charCodeAt(1);\n\n    if (nextCode >= 48 && nextCode <= 57) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (code >= 48 && code <= 57) {\n    return true;\n  }\n\n  return false;\n}\n\n// Consume a number\n// https://www.w3.org/TR/css-syntax-3/#consume-number\nmodule.exports = function(value) {\n  var pos = 0;\n  var length = value.length;\n  var code;\n  var nextCode;\n  var nextNextCode;\n\n  if (length === 0 || !likeNumber(value)) {\n    return false;\n  }\n\n  code = value.charCodeAt(pos);\n\n  if (code === plus || code === minus) {\n    pos++;\n  }\n\n  while (pos < length) {\n    code = value.charCodeAt(pos);\n\n    if (code < 48 || code > 57) {\n      break;\n    }\n\n    pos += 1;\n  }\n\n  code = value.charCodeAt(pos);\n  nextCode = value.charCodeAt(pos + 1);\n\n  if (code === dot && nextCode >= 48 && nextCode <= 57) {\n    pos += 2;\n\n    while (pos < length) {\n      code = value.charCodeAt(pos);\n\n      if (code < 48 || code > 57) {\n        break;\n      }\n\n      pos += 1;\n    }\n  }\n\n  code = value.charCodeAt(pos);\n  nextCode = value.charCodeAt(pos + 1);\n  nextNextCode = value.charCodeAt(pos + 2);\n\n  if (\n    (code === exp || code === EXP) &&\n    ((nextCode >= 48 && nextCode <= 57) ||\n      ((nextCode === plus || nextCode === minus) &&\n        nextNextCode >= 48 &&\n        nextNextCode <= 57))\n  ) {\n    pos += nextCode === plus || nextCode === minus ? 3 : 2;\n\n    while (pos < length) {\n      code = value.charCodeAt(pos);\n\n      if (code < 48 || code > 57) {\n        break;\n      }\n\n      pos += 1;\n    }\n  }\n\n  return {\n    number: value.slice(0, pos),\n    unit: value.slice(pos)\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi91bml0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi91bml0LmpzP2Y2MGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG1pbnVzID0gXCItXCIuY2hhckNvZGVBdCgwKTtcbnZhciBwbHVzID0gXCIrXCIuY2hhckNvZGVBdCgwKTtcbnZhciBkb3QgPSBcIi5cIi5jaGFyQ29kZUF0KDApO1xudmFyIGV4cCA9IFwiZVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgRVhQID0gXCJFXCIuY2hhckNvZGVBdCgwKTtcblxuLy8gQ2hlY2sgaWYgdGhyZWUgY29kZSBwb2ludHMgd291bGQgc3RhcnQgYSBudW1iZXJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI3N0YXJ0cy13aXRoLWEtbnVtYmVyXG5mdW5jdGlvbiBsaWtlTnVtYmVyKHZhbHVlKSB7XG4gIHZhciBjb2RlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgdmFyIG5leHRDb2RlO1xuXG4gIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG4gICAgbmV4dENvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDEpO1xuXG4gICAgaWYgKG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dE5leHRDb2RlID0gdmFsdWUuY2hhckNvZGVBdCgyKTtcblxuICAgIGlmIChuZXh0Q29kZSA9PT0gZG90ICYmIG5leHROZXh0Q29kZSA+PSA0OCAmJiBuZXh0TmV4dENvZGUgPD0gNTcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjb2RlID09PSBkb3QpIHtcbiAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cbiAgICBpZiAobmV4dENvZGUgPj0gNDggJiYgbmV4dENvZGUgPD0gNTcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gQ29uc3VtZSBhIG51bWJlclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jY29uc3VtZS1udW1iZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIHBvcyA9IDA7XG4gIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIHZhciBjb2RlO1xuICB2YXIgbmV4dENvZGU7XG4gIHZhciBuZXh0TmV4dENvZGU7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCB8fCAhbGlrZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG4gICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MgKz0gMTtcbiAgfVxuXG4gIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG4gIG5leHRDb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKTtcblxuICBpZiAoY29kZSA9PT0gZG90ICYmIG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB7XG4gICAgcG9zICs9IDI7XG5cbiAgICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9zICs9IDE7XG4gICAgfVxuICB9XG5cbiAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcbiAgbmV4dENvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICBuZXh0TmV4dENvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyArIDIpO1xuXG4gIGlmIChcbiAgICAoY29kZSA9PT0gZXhwIHx8IGNvZGUgPT09IEVYUCkgJiZcbiAgICAoKG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB8fFxuICAgICAgKChuZXh0Q29kZSA9PT0gcGx1cyB8fCBuZXh0Q29kZSA9PT0gbWludXMpICYmXG4gICAgICAgIG5leHROZXh0Q29kZSA+PSA0OCAmJlxuICAgICAgICBuZXh0TmV4dENvZGUgPD0gNTcpKVxuICApIHtcbiAgICBwb3MgKz0gbmV4dENvZGUgPT09IHBsdXMgfHwgbmV4dENvZGUgPT09IG1pbnVzID8gMyA6IDI7XG5cbiAgICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9zICs9IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBudW1iZXI6IHZhbHVlLnNsaWNlKDAsIHBvcyksXG4gICAgdW5pdDogdmFsdWUuc2xpY2UocG9zKVxuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/postcss-value-parser/lib/unit.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/postcss-value-parser/lib/walk.js":
/*!*******************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/walk.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = function walk(nodes, cb, bubble) {\n  var i, max, node, result;\n\n  for (i = 0, max = nodes.length; i < max; i += 1) {\n    node = nodes[i];\n    if (!bubble) {\n      result = cb(node, i, nodes);\n    }\n\n    if (\n      result !== false &&\n      node.type === \"function\" &&\n      Array.isArray(node.nodes)\n    ) {\n      walk(node.nodes, cb, bubble);\n    }\n\n    if (bubble) {\n      cb(node, i, nodes);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi93YWxrLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy12YWx1ZS1wYXJzZXIvbGliL3dhbGsuanM/ZGFkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdhbGsobm9kZXMsIGNiLCBidWJibGUpIHtcbiAgdmFyIGksIG1heCwgbm9kZSwgcmVzdWx0O1xuXG4gIGZvciAoaSA9IDAsIG1heCA9IG5vZGVzLmxlbmd0aDsgaSA8IG1heDsgaSArPSAxKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghYnViYmxlKSB7XG4gICAgICByZXN1bHQgPSBjYihub2RlLCBpLCBub2Rlcyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcmVzdWx0ICE9PSBmYWxzZSAmJlxuICAgICAgbm9kZS50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobm9kZS5ub2RlcylcbiAgICApIHtcbiAgICAgIHdhbGsobm9kZS5ub2RlcywgY2IsIGJ1YmJsZSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1YmJsZSkge1xuICAgICAgY2Iobm9kZSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/postcss-value-parser/lib/walk.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"(middleware)/./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMseURBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxN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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FB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QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzY5NTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuXG57XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var ReactVersion = '18.2.0';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\n/**\n * Keeps track of the current dispatcher.\n */\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\nvar ReactCurrentBatchConfig = {\n  transition: null\n};\n\nvar ReactCurrentActQueue = {\n  current: null,\n  // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n  isBatchingLegacy: false,\n  didScheduleLegacyUpdate: false\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar ReactDebugCurrentFrame = {};\nvar currentExtraStackFrame = null;\nfunction setExtraStackFrame(stack) {\n  {\n    currentExtraStackFrame = stack;\n  }\n}\n\n{\n  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n    {\n      currentExtraStackFrame = stack;\n    }\n  }; // Stack implementation injected by the current renderer.\n\n\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = ''; // Add an extra top frame while an element is being validated\n\n    if (currentExtraStackFrame) {\n      stack += currentExtraStackFrame;\n    } // Delegate to the injected renderer-specific implementation\n\n\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar ReactSharedInternals = {\n  ReactCurrentDispatcher: ReactCurrentDispatcher,\n  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n  ReactCurrentOwner: ReactCurrentOwner\n};\n\n{\n  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n  ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n}\n\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n}\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + \".\" + callerName;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar assign = Object.assign;\n\nvar emptyObject = {};\n\n{\n  Object.freeze(emptyObject);\n}\n/**\n * Base class helpers for the updating state of a component.\n */\n\n\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n  // renderer.\n\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n\nComponent.prototype.setState = function (partialState, callback) {\n  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n    throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n\n\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n\n\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\n        return undefined;\n      }\n    });\n  };\n\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\n\nComponentDummy.prototype = Component.prototype;\n/**\n * Convenience component with default shallow equality check for sCU.\n */\n\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n\n  {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nfunction createElement(type, config, children) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nfunction cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n  }\n\n  var propName; // Original props are copied\n\n  var props = assign({}, element.props); // Reserved names are extracted\n\n  var key = element.key;\n  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    var defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = key.replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nvar didWarnAboutMaps = false;\nvar userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getElementKey(element, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    {\n      checkKeyStringCoercion(element.key);\n    }\n\n    return escape('' + element.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    var _child = children;\n    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n\n    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\n    if (isArray(mappedChild)) {\n      var escapedChildKey = '';\n\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n\n      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n        return c;\n      });\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n            checkKeyStringCoercion(mappedChild.key);\n          }\n        }\n\n        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n      }\n\n      array.push(mappedChild);\n    }\n\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      var iterableChildren = children;\n\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(iterableChildren);\n      var step;\n      var ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n      }\n    } else if (type === 'object') {\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      var childrenString = String(children);\n      throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var result = [];\n  var count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  var n = 0;\n  mapChildren(children, function () {\n    n++; // Don't return anything\n  });\n  return n;\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  mapChildren(children, function () {\n    forEachFunc.apply(this, arguments); // Don't return anything.\n  }, forEachContext);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  return mapChildren(children, function (child) {\n    return child;\n  }) || [];\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    throw new Error('React.Children.only expected to receive a single React element child.');\n  }\n\n  return children;\n}\n\nfunction createContext(defaultValue) {\n  // TODO: Second argument used to be an optional `calculateChangedBits`\n  // function. Warn to reserve for future use?\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null,\n    // Add these to use same hidden class in VM as ServerContext\n    _defaultValue: null,\n    _globalName: null\n  };\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  var hasWarnedAboutUsingNestedContextConsumers = false;\n  var hasWarnedAboutUsingConsumerProvider = false;\n  var hasWarnedAboutDisplayNameOnConsumer = false;\n\n  {\n    // A separate object, but proxies back to the original context object for\n    // backwards compatibility. It has a different $$typeof, so we can properly\n    // warn for the incorrect usage of Context as a Consumer.\n    var Consumer = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _context: context\n    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n    Object.defineProperties(Consumer, {\n      Provider: {\n        get: function () {\n          if (!hasWarnedAboutUsingConsumerProvider) {\n            hasWarnedAboutUsingConsumerProvider = true;\n\n            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n          }\n\n          return context.Provider;\n        },\n        set: function (_Provider) {\n          context.Provider = _Provider;\n        }\n      },\n      _currentValue: {\n        get: function () {\n          return context._currentValue;\n        },\n        set: function (_currentValue) {\n          context._currentValue = _currentValue;\n        }\n      },\n      _currentValue2: {\n        get: function () {\n          return context._currentValue2;\n        },\n        set: function (_currentValue2) {\n          context._currentValue2 = _currentValue2;\n        }\n      },\n      _threadCount: {\n        get: function () {\n          return context._threadCount;\n        },\n        set: function (_threadCount) {\n          context._threadCount = _threadCount;\n        }\n      },\n      Consumer: {\n        get: function () {\n          if (!hasWarnedAboutUsingNestedContextConsumers) {\n            hasWarnedAboutUsingNestedContextConsumers = true;\n\n            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n          }\n\n          return context.Consumer;\n        }\n      },\n      displayName: {\n        get: function () {\n          return context.displayName;\n        },\n        set: function (displayName) {\n          if (!hasWarnedAboutDisplayNameOnConsumer) {\n            warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n\n            hasWarnedAboutDisplayNameOnConsumer = true;\n          }\n        }\n      }\n    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n    context.Consumer = Consumer;\n  }\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nvar Uninitialized = -1;\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction lazyInitializer(payload) {\n  if (payload._status === Uninitialized) {\n    var ctor = payload._result;\n    var thenable = ctor(); // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n\n    thenable.then(function (moduleObject) {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        var resolved = payload;\n        resolved._status = Resolved;\n        resolved._result = moduleObject;\n      }\n    }, function (error) {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        var rejected = payload;\n        rejected._status = Rejected;\n        rejected._result = error;\n      }\n    });\n\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      var pending = payload;\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n\n  if (payload._status === Resolved) {\n    var moduleObject = payload._result;\n\n    {\n      if (moduleObject === undefined) {\n        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n      }\n    }\n\n    {\n      if (!('default' in moduleObject)) {\n        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n      }\n    }\n\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nfunction lazy(ctor) {\n  var payload = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor\n  };\n  var lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer\n  };\n\n  {\n    // In production, this would just set it on the object.\n    var defaultProps;\n    var propTypes; // $FlowFixMe\n\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get: function () {\n          return defaultProps;\n        },\n        set: function (newDefaultProps) {\n          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n      },\n      propTypes: {\n        configurable: true,\n        get: function () {\n          return propTypes;\n        },\n        set: function (newPropTypes) {\n          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          propTypes = newPropTypes; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n      }\n    });\n  }\n\n  return lazyType;\n}\n\nfunction forwardRef(render) {\n  {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n    } else if (typeof render !== 'function') {\n      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null || render.propTypes != null) {\n        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n      }\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.forwardRef((props, ref) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n        if (!render.name && !render.displayName) {\n          render.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction memo(type, compare) {\n  {\n    if (!isValidElementType(type)) {\n      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: compare === undefined ? null : compare\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.memo((props) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n        if (!type.name && !type.displayName) {\n          type.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current;\n\n  {\n    if (dispatcher === null) {\n      error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n    }\n  } // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n\n\n  return dispatcher;\n}\nfunction useContext(Context) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    // TODO: add a more generic warning for invalid values.\n    if (Context._context !== undefined) {\n      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context);\n}\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nfunction useRef(initialValue) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nfunction useEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\nfunction useInsertionEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\nfunction useLayoutEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\nfunction useCallback(callback, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\nfunction useMemo(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\nfunction useImperativeHandle(ref, create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\nfunction useDebugValue(value, formatterFn) {\n  {\n    var dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\nfunction useTransition() {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\nfunction useDeferredValue(value) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value);\n}\nfunction useId() {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\nfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher$1.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher$1.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      setExtraStackFrame(stack);\n    } else {\n      setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n  }\n\n  {\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    {\n      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nvar didWarnAboutDeprecatedCreateFactory = false;\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n\n  {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n\n      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n    } // Legacy hook: remove it\n\n\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nfunction startTransition(scope, options) {\n  var prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = {};\n  var currentTransition = ReactCurrentBatchConfig.transition;\n\n  {\n    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n  }\n\n  try {\n    scope();\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nvar didWarnAboutMessageChannel = false;\nvar enqueueTaskImpl = null;\nfunction enqueueTask(task) {\n  if (enqueueTaskImpl === null) {\n    try {\n      // read require off the module object to get around the bundlers.\n      // we don't want them to detect a require and bundle a Node polyfill.\n      var requireString = ('require' + Math.random()).slice(0, 7);\n      var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n      // version of setImmediate, bypassing fake timers if any.\n\n      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n    } catch (_err) {\n      // we're in a browser\n      // we can't use regular timers because they may still be faked\n      // so we try MessageChannel+postMessage instead\n      enqueueTaskImpl = function (callback) {\n        {\n          if (didWarnAboutMessageChannel === false) {\n            didWarnAboutMessageChannel = true;\n\n            if (typeof MessageChannel === 'undefined') {\n              error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n            }\n          }\n        }\n\n        var channel = new MessageChannel();\n        channel.port1.onmessage = callback;\n        channel.port2.postMessage(undefined);\n      };\n    }\n  }\n\n  return enqueueTaskImpl(task);\n}\n\nvar actScopeDepth = 0;\nvar didWarnNoAwaitAct = false;\nfunction act(callback) {\n  {\n    // `act` calls can be nested, so we track the depth. This represents the\n    // number of `act` scopes on the stack.\n    var prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n\n    if (ReactCurrentActQueue.current === null) {\n      // This is the outermost `act` scope. Initialize the queue. The reconciler\n      // will detect the queue and use it instead of Scheduler.\n      ReactCurrentActQueue.current = [];\n    }\n\n    var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    var result;\n\n    try {\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n      // set to `true` while the given callback is executed, not for updates\n      // triggered during an async event, because this is how the legacy\n      // implementation of `act` behaved.\n      ReactCurrentActQueue.isBatchingLegacy = true;\n      result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n\n      if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n        var queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n          flushActQueue(queue);\n        }\n      }\n    } catch (error) {\n      popActScope(prevActScopeDepth);\n      throw error;\n    } finally {\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    }\n\n    if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n      var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n      // for it to resolve before exiting the current scope.\n\n      var wasAwaited = false;\n      var thenable = {\n        then: function (resolve, reject) {\n          wasAwaited = true;\n          thenableResult.then(function (returnValue) {\n            popActScope(prevActScopeDepth);\n\n            if (actScopeDepth === 0) {\n              // We've exited the outermost act scope. Recursively flush the\n              // queue until there's no remaining work.\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }, function (error) {\n            // The callback threw an error.\n            popActScope(prevActScopeDepth);\n            reject(error);\n          });\n        }\n      };\n\n      {\n        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n          // eslint-disable-next-line no-undef\n          Promise.resolve().then(function () {}).then(function () {\n            if (!wasAwaited) {\n              didWarnNoAwaitAct = true;\n\n              error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n            }\n          });\n        }\n      }\n\n      return thenable;\n    } else {\n      var returnValue = result; // The callback is not an async function. Exit the current scope\n      // immediately, without awaiting.\n\n      popActScope(prevActScopeDepth);\n\n      if (actScopeDepth === 0) {\n        // Exiting the outermost act scope. Flush the queue.\n        var _queue = ReactCurrentActQueue.current;\n\n        if (_queue !== null) {\n          flushActQueue(_queue);\n          ReactCurrentActQueue.current = null;\n        } // Return a thenable. If the user awaits it, we'll flush again in\n        // case additional work was scheduled by a microtask.\n\n\n        var _thenable = {\n          then: function (resolve, reject) {\n            // Confirm we haven't re-entered another `act` scope, in case\n            // the user does something weird like await the thenable\n            // multiple times.\n            if (ReactCurrentActQueue.current === null) {\n              // Recursively flush the queue until there's no remaining work.\n              ReactCurrentActQueue.current = [];\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }\n        };\n        return _thenable;\n      } else {\n        // Since we're inside a nested `act` scope, the returned thenable\n        // immediately resolves. The outer scope will flush the queue.\n        var _thenable2 = {\n          then: function (resolve, reject) {\n            resolve(returnValue);\n          }\n        };\n        return _thenable2;\n      }\n    }\n  }\n}\n\nfunction popActScope(prevActScopeDepth) {\n  {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n    }\n\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n  {\n    var queue = ReactCurrentActQueue.current;\n\n    if (queue !== null) {\n      try {\n        flushActQueue(queue);\n        enqueueTask(function () {\n          if (queue.length === 0) {\n            // No additional work was scheduled. Finish.\n            ReactCurrentActQueue.current = null;\n            resolve(returnValue);\n          } else {\n            // Keep flushing work until there's none left.\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nvar isFlushing = false;\n\nfunction flushActQueue(queue) {\n  {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      var i = 0;\n\n      try {\n        for (; i < queue.length; i++) {\n          var callback = queue[i];\n\n          do {\n            callback = callback(true);\n          } while (callback !== null);\n        }\n\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue = queue.slice(i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}\n\nvar createElement$1 =  createElementWithValidation ;\nvar cloneElement$1 =  cloneElementWithValidation ;\nvar createFactory =  createFactoryWithValidation ;\nvar Children = {\n  map: mapChildren,\n  forEach: forEachChildren,\n  count: countChildren,\n  toArray: toArray,\n  only: onlyChild\n};\n\nexports.Children = Children;\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\nexports.cloneElement = cloneElement$1;\nexports.createContext = createContext;\nexports.createElement = createElement$1;\nexports.createFactory = createFactory;\nexports.createRef = createRef;\nexports.forwardRef = forwardRef;\nexports.isValidElement = isValidElement;\nexports.lazy = lazy;\nexports.memo = memo;\nexports.startTransition = startTransition;\nexports.unstable_act = act;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useDebugValue = useDebugValue;\nexports.useDeferredValue = useDeferredValue;\nexports.useEffect = useEffect;\nexports.useId = useId;\nexports.useImperativeHandle = useImperativeHandle;\nexports.useInsertionEffect = useInsertionEffect;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useRef = useRef;\nexports.useState = useState;\nexports.useSyncExternalStore = useSyncExternalStore;\nexports.useTransition = useTransition;\nexports.version = ReactVersion;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixhQUFhO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4TUFBOE07O0FBRTlNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFdBQVc7QUFDeEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckIsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFdBQVc7QUFDeEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVB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O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEdBQUc7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQSwwT0FBME87QUFDMU87QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTixnQ0FBZ0M7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQiwwREFBMEQ7QUFDMUQsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWixZQUFZO0FBQ1osdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanM/YjJkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdFZlcnNpb24gPSAnMTguMi4wJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IG51bGxcbn07XG5cbnZhciBSZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS5cbiAgaXNCYXRjaGluZ0xlZ2FjeTogZmFsc2UsXG4gIGRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlOiBmYWxzZVxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lclxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiBwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICsgJ2Z1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIpO1xuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAge1xuICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChpc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGBpZmAgc3RhdGVtZW50IGhlcmUgcHJldmVudHMgYXV0by1kaXNhYmxpbmcgb2YgdGhlIHNhZmVcbiAgICAgICAgICAvLyBjb2VyY2lvbiBFU0xpbnQgcnVsZSwgc28gd2UgbXVzdCBtYW51YWxseSBkaXNhYmxlIGl0IGJlbG93LlxuICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICAgIGlmIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSkge1xuICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXBwZWRDaGlsZC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICAvLyBUT0RPOiBTZWNvbmQgYXJndW1lbnQgdXNlZCB0byBiZSBhbiBvcHRpb25hbCBgY2FsY3VsYXRlQ2hhbmdlZEJpdHNgXG4gIC8vIGZ1bmN0aW9uLiBXYXJuIHRvIHJlc2VydmUgZm9yIGZ1dHVyZSB1c2U/XG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbCxcbiAgICAvLyBBZGQgdGhlc2UgdG8gdXNlIHNhbWUgaGlkZGVuIGNsYXNzIGluIFZNIGFzIFNlcnZlckNvbnRleHRcbiAgICBfZGVmYXVsdFZhbHVlOiBudWxsLFxuICAgIF9nbG9iYWxOYW1lOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dFxuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgLy8gVGhpcyBtaWdodCB0aHJvdyBlaXRoZXIgYmVjYXVzZSBpdCdzIG1pc3Npbmcgb3IgdGhyb3dzLiBJZiBzbywgd2UgdHJlYXQgaXRcbiAgICAvLyBhcyBzdGlsbCB1bmluaXRpYWxpemVkIGFuZCB0cnkgYWdhaW4gbmV4dCB0aW1lLiBXaGljaCBpcyB0aGUgc2FtZSBhcyB3aGF0XG4gICAgLy8gaGFwcGVucyBpZiB0aGUgY3RvciBvciBhbnkgd3JhcHBlcnMgcHJvY2Vzc2luZyB0aGUgY3RvciB0aHJvd3MuIFRoaXMgbWlnaHRcbiAgICAvLyBlbmQgdXAgZml4aW5nIGl0IGlmIHRoZSByZXNvbHV0aW9uIHdhcyBhIGNvbmN1cnJlbmN5IGJ1Zy5cblxuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAvLyBJbiBjYXNlLCB3ZSdyZSBzdGlsbCB1bmluaXRpYWxpemVkLCB0aGVuIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSB0aGVuYWJsZVxuICAgICAgLy8gdG8gcmVzb2x2ZS4gU2V0IGl0IGFzIHBlbmRpbmcgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgdmFyIG1vZHVsZU9iamVjdCA9IHBheWxvYWQuX3Jlc3VsdDtcblxuICAgIHtcbiAgICAgIGlmIChtb2R1bGVPYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wJyArICdvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXFxuXFxuXCIgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcHV0IGN1cmx5IGJyYWNlcyBhcm91bmQgdGhlIGltcG9ydD8nLCBtb2R1bGVPYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICghKCdkZWZhdWx0JyBpbiBtb2R1bGVPYmplY3QpKSB7XG4gICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogVW5pbml0aWFsaXplZCxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7Li4ufSk7XG4gICAgICAgIC8vIFRoaXMga2luZCBvZiBpbm5lciBmdW5jdGlvbiBpcyBub3QgdXNlZCBlbHNld2hlcmUgc28gdGhlIHNpZGUgZWZmZWN0IGlzIG9rYXkuXG5cbiAgICAgICAgaWYgKCFyZW5kZXIubmFtZSAmJiAhcmVuZGVyLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5tZW1vKChwcm9wcykgPT4gey4uLn0pO1xuICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG4gICAgICAgIGlmICghdHlwZS5uYW1lICYmICF0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoZGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgICB9XG4gIH0gLy8gV2lsbCByZXN1bHQgaW4gYSBudWxsIGFjY2VzcyBlcnJvciBpZiBhY2Nlc3NlZCBvdXRzaWRlIHJlbmRlciBwaGFzZS4gV2VcbiAgLy8gaW50ZW50aW9uYWxseSBkb24ndCB0aHJvdyBvdXIgb3duIGVycm9yIGJlY2F1c2UgdGhpcyBpcyBpbiBhIGhvdCBwYXRoLlxuICAvLyBBbHNvIGhlbHBzIGVuc3VyZSB0aGlzIGlzIGlubGluZWQuXG5cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKCk7XG59XG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJZCgpO1xufVxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzY29wZSwgb3B0aW9ucykge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0ge307XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHNjb3BlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IGZhbHNlO1xudmFyIGVucXVldWVUYXNrSW1wbCA9IG51bGw7XG5mdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gIGlmIChlbnF1ZXVlVGFza0ltcGwgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlbSB0byBkZXRlY3QgYSByZXF1aXJlIGFuZCBidW5kbGUgYSBOb2RlIHBvbHlmaWxsLlxuICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoJ3JlcXVpcmUnICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyk7XG4gICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuICAgICAgLy8gdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUsIGJ5cGFzc2luZyBmYWtlIHRpbWVycyBpZiBhbnkuXG5cbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAndGltZXJzJykuc2V0SW1tZWRpYXRlO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIC8vIHdlJ3JlIGluIGEgYnJvd3NlclxuICAgICAgLy8gd2UgY2FuJ3QgdXNlIHJlZ3VsYXIgdGltZXJzIGJlY2F1c2UgdGhleSBtYXkgc3RpbGwgYmUgZmFrZWRcbiAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG4gICAgICBlbnF1ZXVlVGFza0ltcGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sICcgKyAnc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3VlcyAnICsgJ2lmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVucXVldWVUYXNrSW1wbCh0YXNrKTtcbn1cblxudmFyIGFjdFNjb3BlRGVwdGggPSAwO1xudmFyIGRpZFdhcm5Ob0F3YWl0QWN0ID0gZmFsc2U7XG5mdW5jdGlvbiBhY3QoY2FsbGJhY2spIHtcbiAge1xuICAgIC8vIGBhY3RgIGNhbGxzIGNhbiBiZSBuZXN0ZWQsIHNvIHdlIHRyYWNrIHRoZSBkZXB0aC4gVGhpcyByZXByZXNlbnRzIHRoZVxuICAgIC8vIG51bWJlciBvZiBgYWN0YCBzY29wZXMgb24gdGhlIHN0YWNrLlxuICAgIHZhciBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG4gICAgYWN0U2NvcGVEZXB0aCsrO1xuXG4gICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIG91dGVybW9zdCBgYWN0YCBzY29wZS4gSW5pdGlhbGl6ZSB0aGUgcXVldWUuIFRoZSByZWNvbmNpbGVyXG4gICAgICAvLyB3aWxsIGRldGVjdCB0aGUgcXVldWUgYW5kIHVzZSBpdCBpbnN0ZWFkIG9mIFNjaGVkdWxlci5cbiAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgcHJldklzQmF0Y2hpbmdMZWdhY3kgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5O1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS4gT25seVxuICAgICAgLy8gc2V0IHRvIGB0cnVlYCB3aGlsZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgaXMgZXhlY3V0ZWQsIG5vdCBmb3IgdXBkYXRlc1xuICAgICAgLy8gdHJpZ2dlcmVkIGR1cmluZyBhbiBhc3luYyBldmVudCwgYmVjYXVzZSB0aGlzIGlzIGhvdyB0aGUgbGVnYWN5XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBgYWN0YCBiZWhhdmVkLlxuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHRydWU7XG4gICAgICByZXN1bHQgPSBjYWxsYmFjaygpOyAvLyBSZXBsaWNhdGUgYmVoYXZpb3Igb2Ygb3JpZ2luYWwgYGFjdGAgaW1wbGVtZW50YXRpb24gaW4gbGVnYWN5IG1vZGUsXG4gICAgICAvLyB3aGljaCBmbHVzaGVkIHVwZGF0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHNjb3BlIGZ1bmN0aW9uIGV4aXRzLCBldmVuXG4gICAgICAvLyBpZiBpdCdzIGFuIGFzeW5jIGZ1bmN0aW9uLlxuXG4gICAgICBpZiAoIXByZXZJc0JhdGNoaW5nTGVnYWN5ICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHByZXZJc0JhdGNoaW5nTGVnYWN5O1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGhlbmFibGVSZXN1bHQgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBhbiBhc3luYyBmdW5jdGlvbiAoaS5lLiByZXR1cm5lZCBhIHByb21pc2UpLiBXYWl0XG4gICAgICAvLyBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgZXhpdGluZyB0aGUgY3VycmVudCBzY29wZS5cblxuICAgICAgdmFyIHdhc0F3YWl0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHdhc0F3YWl0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoZW5hYmxlUmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG5cbiAgICAgICAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aXRlZCB0aGUgb3V0ZXJtb3N0IGFjdCBzY29wZS4gUmVjdXJzaXZlbHkgZmx1c2ggdGhlXG4gICAgICAgICAgICAgIC8vIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayB0aHJldyBhbiBlcnJvci5cbiAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuTm9Bd2FpdEFjdCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHt9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghd2FzQXdhaXRlZCkge1xuICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ1lvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gJyArICdUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgJyArICdpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgJyArICdzY29wZXMuICcgKyAnWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVzdWx0OyAvLyBUaGUgY2FsbGJhY2sgaXMgbm90IGFuIGFzeW5jIGZ1bmN0aW9uLiBFeGl0IHRoZSBjdXJyZW50IHNjb3BlXG4gICAgICAvLyBpbW1lZGlhdGVseSwgd2l0aG91dCBhd2FpdGluZy5cblxuICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuXG4gICAgICBpZiAoYWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAvLyBFeGl0aW5nIHRoZSBvdXRlcm1vc3QgYWN0IHNjb3BlLiBGbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIHZhciBfcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuXG4gICAgICAgIGlmIChfcXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBmbHVzaEFjdFF1ZXVlKF9xdWV1ZSk7XG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0gLy8gUmV0dXJuIGEgdGhlbmFibGUuIElmIHRoZSB1c2VyIGF3YWl0cyBpdCwgd2UnbGwgZmx1c2ggYWdhaW4gaW5cbiAgICAgICAgLy8gY2FzZSBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZCBieSBhIG1pY3JvdGFzay5cblxuXG4gICAgICAgIHZhciBfdGhlbmFibGUgPSB7XG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gQ29uZmlybSB3ZSBoYXZlbid0IHJlLWVudGVyZWQgYW5vdGhlciBgYWN0YCBzY29wZSwgaW4gY2FzZVxuICAgICAgICAgICAgLy8gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgd2VpcmQgbGlrZSBhd2FpdCB0aGUgdGhlbmFibGVcbiAgICAgICAgICAgIC8vIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmx1c2ggdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG4gICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGVuYWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIGluc2lkZSBhIG5lc3RlZCBgYWN0YCBzY29wZSwgdGhlIHJldHVybmVkIHRoZW5hYmxlXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmVzLiBUaGUgb3V0ZXIgc2NvcGUgd2lsbCBmbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIHZhciBfdGhlbmFibGUyID0ge1xuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGVuYWJsZTI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKSB7XG4gIHtcbiAgICBpZiAocHJldkFjdFNjb3BlRGVwdGggIT09IGFjdFNjb3BlRGVwdGggLSAxKSB7XG4gICAgICBlcnJvcignWW91IHNlZW0gdG8gaGF2ZSBvdmVybGFwcGluZyBhY3QoKSBjYWxscywgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0JlIHN1cmUgdG8gYXdhaXQgcHJldmlvdXMgYWN0KCkgY2FsbHMgYmVmb3JlIG1ha2luZyBhIG5ldyBvbmUuICcpO1xuICAgIH1cblxuICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpIHtcbiAge1xuICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpO1xuICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gYWRkaXRpb25hbCB3b3JrIHdhcyBzY2hlZHVsZWQuIEZpbmlzaC5cbiAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEtlZXAgZmx1c2hpbmcgd29yayB1bnRpbCB0aGVyZSdzIG5vbmUgbGVmdC5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSB7XG4gIHtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuICAgICAgICBxdWV1ZSA9IHF1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gc3RhcnRUcmFuc2l0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9hY3QgPSBhY3Q7XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IHVzZURlZmVycmVkVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSWQgPSB1c2VJZDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdDtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTtcbmV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IHVzZVRyYW5zaXRpb247XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"(middleware)/./node_modules/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxvSUFBc0Q7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzPzc4MWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/react/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(middleware)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsb0tBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/Nzc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/react/jsx-dev-runtime.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/@resvg/resvg-wasm/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@resvg/resvg-wasm/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Resvg\": () => (/* binding */ Resvg2),\n/* harmony export */   \"initWasm\": () => (/* binding */ initWasm)\n/* harmony export */ });\n// wasm/dist/index.js\nvar wasm;\nvar heap = new Array(32).fill(void 0);\nheap.push(void 0, null, true, false);\nfunction getObject(idx) {\n  return heap[idx];\n}\nvar WASM_VECTOR_LEN = 0;\nvar cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachegetUint8Memory0;\n}\nvar cachedTextEncoder = new TextEncoder(\"utf-8\");\nvar encodeString = typeof cachedTextEncoder.encodeInto === \"function\" ? function(arg, view) {\n  return cachedTextEncoder.encodeInto(arg, view);\n} : function(arg, view) {\n  const buf = cachedTextEncoder.encode(arg);\n  view.set(buf);\n  return {\n    read: arg.length,\n    written: buf.length\n  };\n};\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === void 0) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr2 = malloc(buf.length);\n    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr2;\n  }\n  let len = arg.length;\n  let ptr = malloc(len);\n  const mem = getUint8Memory0();\n  let offset = 0;\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 127)\n      break;\n    mem[ptr + offset] = code;\n  }\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, len = offset + arg.length * 3);\n    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n    offset += ret.written;\n  }\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\nfunction isLikeNone(x) {\n  return x === void 0 || x === null;\n}\nvar cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n  return cachegetInt32Memory0;\n}\nvar heap_next = heap.length;\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length)\n    heap.push(heap.length + 1);\n  const idx = heap_next;\n  heap_next = heap[idx];\n  heap[idx] = obj;\n  return idx;\n}\nfunction dropObject(idx) {\n  if (idx < 36)\n    return;\n  heap[idx] = heap_next;\n  heap_next = idx;\n}\nfunction takeObject(idx) {\n  const ret = getObject(idx);\n  dropObject(idx);\n  return ret;\n}\nvar cachedTextDecoder = new TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true });\ncachedTextDecoder.decode();\nfunction getStringFromWasm0(ptr, len) {\n  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\nvar Resvg = class {\n  static __wrap(ptr) {\n    const obj = Object.create(Resvg.prototype);\n    obj.ptr = ptr;\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.ptr;\n    this.ptr = 0;\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_resvg_free(ptr);\n  }\n  get width() {\n    var ret = wasm.resvg_width(this.ptr);\n    return ret;\n  }\n  get height() {\n    var ret = wasm.resvg_height(this.ptr);\n    return ret;\n  }\n  toString() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.resvg_toString(retptr, this.ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      return getStringFromWasm0(r0, r1);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n      wasm.__wbindgen_free(r0, r1);\n    }\n  }\n  constructor(svg, options) {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      var ptr0 = isLikeNone(options) ? 0 : passStringToWasm0(options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n      var len0 = WASM_VECTOR_LEN;\n      wasm.resvg_new(retptr, addHeapObject(svg), ptr0, len0);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      var r2 = getInt32Memory0()[retptr / 4 + 2];\n      if (r2) {\n        throw takeObject(r1);\n      }\n      return Resvg.__wrap(r0);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n  render() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.resvg_render(retptr, this.ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      var r2 = getInt32Memory0()[retptr / 4 + 2];\n      if (r2) {\n        throw takeObject(r1);\n      }\n      return takeObject(r0);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n};\nasync function load(module, imports) {\n  if (typeof Response === \"function\" && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n          console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n        } else {\n          throw e;\n        }\n      }\n    }\n    const bytes = await module.arrayBuffer();\n    return await __next_webassembly_instantiate__(function() { return WebAssembly.instantiate(bytes, imports)});\n  } else {\n    const instance = await __next_webassembly_instantiate__(function() { return WebAssembly.instantiate(module, imports)});\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\nasync function init(input) {\n  if (typeof input === \"undefined\") {\n    input = new URL(\"index_bg.wasm\", void 0);\n  }\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbg_new_f2ab1043dfd47875 = function(arg0, arg1) {\n    var ret = new TypeError(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_instanceof_Uint8Array_8a8537f46e056474 = function(arg0) {\n    var ret = getObject(arg0) instanceof Uint8Array;\n    return ret;\n  };\n  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof obj === \"string\" ? obj : void 0;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n  };\n  imports.wbg.__wbg_length_30803400a8f15c59 = function(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n  };\n  imports.wbg.__wbindgen_memory = function() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_buffer_5e74a88a1424a2e0 = function(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_new_e3b800e570795b3c = function(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n  };\n  imports.wbg.__wbg_set_5b8081e9d002f0df = function(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n  };\n  imports.wbg.__wbg_newwithbyteoffsetandlength_278ec7532799393a = function(arg0, arg1, arg2) {\n    var ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n  if (typeof input === \"string\" || typeof Request === \"function\" && input instanceof Request || typeof URL === \"function\" && input instanceof URL) {\n    input = fetch(input);\n  }\n  const { instance, module } = await load(await input, imports);\n  wasm = instance.exports;\n  init.__wbindgen_wasm_module = module;\n  return wasm;\n}\nvar dist_default = init;\n\n// wasm-binding.ts\nvar initialized = false;\nvar initWasm = async (module_or_path) => {\n  if (initialized) {\n    throw new Error(\"Already initialized. The `initWasm()` function can be used only once.\");\n  }\n  await dist_default(await module_or_path);\n  initialized = true;\n};\nvar Resvg2 = class extends Resvg {\n  constructor(svg, options) {\n    if (!initialized)\n      throw new Error(\"WASM has not been initialized. Call `initWasm()` function.\");\n    super(svg, JSON.stringify(options));\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL0ByZXN2Zy9yZXN2Zy13YXNtL2luZGV4Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhCQUE4QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0RkFBdUM7QUFDeEQsSUFBSTtBQUNKLDJCQUEyQiw2RkFBd0M7QUFDbkU7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVzdmcvcmVzdmctd2FzbS9pbmRleC5tanM/ZjBkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB3YXNtL2Rpc3QvaW5kZXguanNcbnZhciB3YXNtO1xudmFyIGhlYXAgPSBuZXcgQXJyYXkoMzIpLmZpbGwodm9pZCAwKTtcbmhlYXAucHVzaCh2b2lkIDAsIG51bGwsIHRydWUsIGZhbHNlKTtcbmZ1bmN0aW9uIGdldE9iamVjdChpZHgpIHtcbiAgcmV0dXJuIGhlYXBbaWR4XTtcbn1cbnZhciBXQVNNX1ZFQ1RPUl9MRU4gPSAwO1xudmFyIGNhY2hlZ2V0VWludDhNZW1vcnkwID0gbnVsbDtcbmZ1bmN0aW9uIGdldFVpbnQ4TWVtb3J5MCgpIHtcbiAgaWYgKGNhY2hlZ2V0VWludDhNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZ2V0VWludDhNZW1vcnkwLmJ1ZmZlciAhPT0gd2FzbS5tZW1vcnkuYnVmZmVyKSB7XG4gICAgY2FjaGVnZXRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICB9XG4gIHJldHVybiBjYWNoZWdldFVpbnQ4TWVtb3J5MDtcbn1cbnZhciBjYWNoZWRUZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcihcInV0Zi04XCIpO1xudmFyIGVuY29kZVN0cmluZyA9IHR5cGVvZiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihhcmcsIHZpZXcpIHtcbiAgcmV0dXJuIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8oYXJnLCB2aWV3KTtcbn0gOiBmdW5jdGlvbihhcmcsIHZpZXcpIHtcbiAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gIHZpZXcuc2V0KGJ1Zik7XG4gIHJldHVybiB7XG4gICAgcmVhZDogYXJnLmxlbmd0aCxcbiAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gIH07XG59O1xuZnVuY3Rpb24gcGFzc1N0cmluZ1RvV2FzbTAoYXJnLCBtYWxsb2MsIHJlYWxsb2MpIHtcbiAgaWYgKHJlYWxsb2MgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgIGNvbnN0IHB0cjIgPSBtYWxsb2MoYnVmLmxlbmd0aCk7XG4gICAgZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyMiwgcHRyMiArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgIFdBU01fVkVDVE9SX0xFTiA9IGJ1Zi5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjI7XG4gIH1cbiAgbGV0IGxlbiA9IGFyZy5sZW5ndGg7XG4gIGxldCBwdHIgPSBtYWxsb2MobGVuKTtcbiAgY29uc3QgbWVtID0gZ2V0VWludDhNZW1vcnkwKCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgIGNvbnN0IGNvZGUgPSBhcmcuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgIGlmIChjb2RlID4gMTI3KVxuICAgICAgYnJlYWs7XG4gICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICB9XG4gIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIGFyZyA9IGFyZy5zbGljZShvZmZzZXQpO1xuICAgIH1cbiAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMyk7XG4gICAgY29uc3QgdmlldyA9IGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciArIG9mZnNldCwgcHRyICsgbGVuKTtcbiAgICBjb25zdCByZXQgPSBlbmNvZGVTdHJpbmcoYXJnLCB2aWV3KTtcbiAgICBvZmZzZXQgKz0gcmV0LndyaXR0ZW47XG4gIH1cbiAgV0FTTV9WRUNUT1JfTEVOID0gb2Zmc2V0O1xuICByZXR1cm4gcHRyO1xufVxuZnVuY3Rpb24gaXNMaWtlTm9uZSh4KSB7XG4gIHJldHVybiB4ID09PSB2b2lkIDAgfHwgeCA9PT0gbnVsbDtcbn1cbnZhciBjYWNoZWdldEludDMyTWVtb3J5MCA9IG51bGw7XG5mdW5jdGlvbiBnZXRJbnQzMk1lbW9yeTAoKSB7XG4gIGlmIChjYWNoZWdldEludDMyTWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWdldEludDMyTWVtb3J5MC5idWZmZXIgIT09IHdhc20ubWVtb3J5LmJ1ZmZlcikge1xuICAgIGNhY2hlZ2V0SW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgfVxuICByZXR1cm4gY2FjaGVnZXRJbnQzMk1lbW9yeTA7XG59XG52YXIgaGVhcF9uZXh0ID0gaGVhcC5sZW5ndGg7XG5mdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikge1xuICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aClcbiAgICBoZWFwLnB1c2goaGVhcC5sZW5ndGggKyAxKTtcbiAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICBoZWFwX25leHQgPSBoZWFwW2lkeF07XG4gIGhlYXBbaWR4XSA9IG9iajtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGRyb3BPYmplY3QoaWR4KSB7XG4gIGlmIChpZHggPCAzNilcbiAgICByZXR1cm47XG4gIGhlYXBbaWR4XSA9IGhlYXBfbmV4dDtcbiAgaGVhcF9uZXh0ID0gaWR4O1xufVxuZnVuY3Rpb24gdGFrZU9iamVjdChpZHgpIHtcbiAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGlkeCk7XG4gIGRyb3BPYmplY3QoaWR4KTtcbiAgcmV0dXJuIHJldDtcbn1cbnZhciBjYWNoZWRUZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIsIHsgaWdub3JlQk9NOiB0cnVlLCBmYXRhbDogdHJ1ZSB9KTtcbmNhY2hlZFRleHREZWNvZGVyLmRlY29kZSgpO1xuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBsZW4pKTtcbn1cbnZhciBSZXN2ZyA9IGNsYXNzIHtcbiAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJlc3ZnLnByb3RvdHlwZSk7XG4gICAgb2JqLnB0ciA9IHB0cjtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICB0aGlzLnB0ciA9IDA7XG4gICAgcmV0dXJuIHB0cjtcbiAgfVxuICBmcmVlKCkge1xuICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgd2FzbS5fX3diZ19yZXN2Z19mcmVlKHB0cik7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHZhciByZXQgPSB3YXNtLnJlc3ZnX3dpZHRoKHRoaXMucHRyKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgdmFyIHJldCA9IHdhc20ucmVzdmdfaGVpZ2h0KHRoaXMucHRyKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgIHdhc20ucmVzdmdfdG9TdHJpbmcocmV0cHRyLCB0aGlzLnB0cik7XG4gICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihzdmcsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUob3B0aW9ucykgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAob3B0aW9ucywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICB3YXNtLnJlc3ZnX25ldyhyZXRwdHIsIGFkZEhlYXBPYmplY3Qoc3ZnKSwgcHRyMCwgbGVuMCk7XG4gICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICBpZiAocjIpIHtcbiAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVzdmcuX193cmFwKHIwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgIHdhc20ucmVzdmdfcmVuZGVyKHJldHB0ciwgdGhpcy5wdHIpO1xuICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgaWYgKHIyKSB7XG4gICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGxvYWQobW9kdWxlLCBpbXBvcnRzKSB7XG4gIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09IFwiZnVuY3Rpb25cIiAmJiBtb2R1bGUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG1vZHVsZSwgaW1wb3J0cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChtb2R1bGUuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgIT0gXCJhcHBsaWNhdGlvbi93YXNtXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIHdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxcblwiLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgbW9kdWxlLmFycmF5QnVmZmVyKCk7XG4gICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZHVsZSwgaW1wb3J0cyk7XG4gICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiB7IGluc3RhbmNlLCBtb2R1bGUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaW5pdChpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaW5wdXQgPSBuZXcgVVJMKFwiaW5kZXhfYmcud2FzbVwiLCB2b2lkIDApO1xuICB9XG4gIGNvbnN0IGltcG9ydHMgPSB7fTtcbiAgaW1wb3J0cy53YmcgPSB7fTtcbiAgaW1wb3J0cy53YmcuX193YmdfbmV3X2YyYWIxMDQzZGZkNDc4NzUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgdmFyIHJldCA9IG5ldyBUeXBlRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX1VpbnQ4QXJyYXlfOGE4NTM3ZjQ2ZTA1NjQ3NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICB2YXIgcmV0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3N0cmluZ19nZXQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgY29uc3Qgb2JqID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIHZhciByZXQgPSB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiID8gb2JqIDogdm9pZCAwO1xuICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19sZW5ndGhfMzA4MDM0MDBhOGYxNWM1OSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICB2YXIgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX21lbW9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB3YXNtLm1lbW9yeTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19idWZmZXJfNWU3NGE4OGExNDI0YTJlMCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICB2YXIgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ1ZmZlcjtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19uZXdfZTNiODAwZTU3MDc5NWIzYyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICB2YXIgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICB0YWtlT2JqZWN0KGFyZzApO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19zZXRfNWI4MDgxZTlkMDAyZjBkZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICBnZXRPYmplY3QoYXJnMCkuc2V0KGdldE9iamVjdChhcmcxKSwgYXJnMiA+Pj4gMCk7XG4gIH07XG4gIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoXzI3OGVjNzUzMjc5OTM5M2EgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgdmFyIHJldCA9IG5ldyBVaW50OEFycmF5KGdldE9iamVjdChhcmcwKSwgYXJnMSA+Pj4gMCwgYXJnMiA+Pj4gMCk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgfTtcbiAgaW1wb3J0cy53YmcuX193YmluZGdlbl90aHJvdyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgUmVxdWVzdCA9PT0gXCJmdW5jdGlvblwiICYmIGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCB8fCB0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiYgaW5wdXQgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBpbnB1dCA9IGZldGNoKGlucHV0KTtcbiAgfVxuICBjb25zdCB7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IGxvYWQoYXdhaXQgaW5wdXQsIGltcG9ydHMpO1xuICB3YXNtID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgaW5pdC5fX3diaW5kZ2VuX3dhc21fbW9kdWxlID0gbW9kdWxlO1xuICByZXR1cm4gd2FzbTtcbn1cbnZhciBkaXN0X2RlZmF1bHQgPSBpbml0O1xuXG4vLyB3YXNtLWJpbmRpbmcudHNcbnZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xudmFyIGluaXRXYXNtID0gYXN5bmMgKG1vZHVsZV9vcl9wYXRoKSA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgaW5pdGlhbGl6ZWQuIFRoZSBgaW5pdFdhc20oKWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgb25seSBvbmNlLlwiKTtcbiAgfVxuICBhd2FpdCBkaXN0X2RlZmF1bHQoYXdhaXQgbW9kdWxlX29yX3BhdGgpO1xuICBpbml0aWFsaXplZCA9IHRydWU7XG59O1xudmFyIFJlc3ZnMiA9IGNsYXNzIGV4dGVuZHMgUmVzdmcge1xuICBjb25zdHJ1Y3RvcihzdmcsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWluaXRpYWxpemVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV0FTTSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIENhbGwgYGluaXRXYXNtKClgIGZ1bmN0aW9uLlwiKTtcbiAgICBzdXBlcihzdmcsIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIFJlc3ZnMiBhcyBSZXN2ZyxcbiAgaW5pdFdhc21cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/@resvg/resvg-wasm/index.mjs\n");

/***/ }),

/***/ "(middleware)/./node_modules/@vercel/og/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@vercel/og/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageResponse\": () => (/* binding */ p)\n/* harmony export */ });\n/* harmony import */ var satori_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! satori/wasm */ \"(middleware)/./node_modules/satori/dist/esm/index.wasm.js\");\n/* harmony import */ var yoga_wasm_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yoga-wasm-web */ \"(middleware)/./node_modules/yoga-wasm-web/dist/index.js\");\n/* harmony import */ var _resvg_resvg_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @resvg/resvg-wasm */ \"(middleware)/./node_modules/@resvg/resvg-wasm/index.mjs\");\n/* harmony import */ var _vendor_resvg_simd_wasm_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vendor/resvg.simd.wasm?module */ \"(middleware)/./node_modules/@vercel/og/vendor/resvg.simd.wasm?module\");\n/* harmony import */ var _vendor_yoga_wasm_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vendor/yoga.wasm?module */ \"(middleware)/./node_modules/@vercel/og/vendor/yoga.wasm?module\");\nvar v=String.fromCharCode(8205),j=/\\uFE0F/g;function c(t){return y(t.indexOf(v)<0?t.replace(j,\"\"):t)}function y(t){for(var n=[],e=0,o=0,s=0;s<t.length;)e=t.charCodeAt(s++),o?(n.push((65536+(o-55296<<10)+(e-56320)).toString(16)),o=0):55296<=e&&e<=56319?o=e:n.push(e.toString(16));return n.join(\"-\")}var r={twemoji:t=>\"https://twemoji.maxcdn.com/v/latest/svg/\"+t.toLowerCase()+\".svg\",openmoji:\"https://cdn.jsdelivr.net/npm/@svgmoji/openmoji@2.0.0/svg/\",blobmoji:\"https://cdn.jsdelivr.net/npm/@svgmoji/blob@2.0.0/svg/\",noto:\"https://cdn.jsdelivr.net/gh/svgmoji/svgmoji/packages/svgmoji__noto/svg/\",fluent:t=>\"https://cdn.jsdelivr.net/gh/shuding/fluentui-emoji-unicode/assets/\"+t.toLowerCase()+\"_color.svg\",fluentFlat:t=>\"https://cdn.jsdelivr.net/gh/shuding/fluentui-emoji-unicode/assets/\"+t.toLowerCase()+\"_flat.svg\"};function m(t,n){(!n||!r[n])&&(n=\"twemoji\");let e=r[n];return fetch(typeof e==\"function\"?e(t):`${e}${t.toUpperCase()}.svg`)}var C=_resvg_resvg_wasm__WEBPACK_IMPORTED_MODULE_4__.initWasm(_vendor_resvg_simd_wasm_module__WEBPACK_IMPORTED_MODULE_2__),x=(0,yoga_wasm_web__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_vendor_yoga_wasm_module__WEBPACK_IMPORTED_MODULE_3__).then(t=>(0,satori_wasm__WEBPACK_IMPORTED_MODULE_0__.init)(t)),_=fetch(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ../vendor/noto-sans-v27-latin-regular.ttf */ \"(edge-asset)/./node_modules/@vercel/og/vendor/noto-sans-v27-latin-regular.ttf\"))).then(t=>t.arrayBuffer()),f,u,R=((u=(f=globalThis==null?void 0:globalThis.process)==null?void 0:f.env)==null?void 0:u.NODE_ENV)===\"development\",l={zh:\"Noto+Sans+SC\",ja:\"Noto+Sans+JP\",ko:\"Noto+Sans+KR\",th:\"Noto+Sans+Thai\",he:\"Noto+Sans+Hebrew\",ar:\"Noto+Sans+Arabic\",bn:\"Noto+Sans+Bengali\",ta:\"Noto+Sans+Tamil\",te:\"Noto+Sans+Telugu\",ml:\"Noto+Sans+Malayalam\",devanagari:\"Noto+Sans+Devanagari\",unknown:\"Noto+Sans\"};async function k(t,n){if(!t||!n)return;let e=`https://fonts.googleapis.com/css2?family=${t}&text=${encodeURIComponent(n)}`,s=(await(await fetch(e,{headers:{\"User-Agent\":\"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; de-at) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5 Safari/533.21.1\"}})).text()).match(/src: url\\((.+)\\) format\\('(opentype|truetype)'\\)/);if(!s)throw new Error(\"Failed to load font\");return fetch(s[1]).then(a=>a.arrayBuffer())}var g=new Map,F=({emoji:t})=>{let n=async(e,o)=>{if(e===\"emoji\")return\"data:image/svg+xml;base64,\"+btoa(await(await m(c(o),t)).text());l[e]||(e=\"unknown\");try{let s=await k(l[e],o);if(s)return{name:`satori_${e}_fallback_${o}`,data:s,weight:400,style:\"normal\"}}catch(s){console.error(\"Failed to load dynamic font for\",o,\". Error:\",s)}};return async(...e)=>{let o=JSON.stringify(e),s=g.get(o);if(s)return s;let a=await n(...e);return g.set(o,a),a}},p=class{constructor(n,e={}){let o=Object.assign({width:1200,height:630,debug:!1},e),s=new ReadableStream({async start(a){await x,await C;let d=await _,h=await (0,satori_wasm__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(n,{width:o.width,height:o.height,debug:o.debug,fonts:o.fonts||[{name:\"sans serif\",data:d,weight:700,style:\"normal\"}],loadAdditionalAsset:F({emoji:o.emoji})}),w=new _resvg_resvg_wasm__WEBPACK_IMPORTED_MODULE_4__.Resvg(h,{fitTo:{mode:\"width\",value:o.width}});a.enqueue(w.render()),a.close()}});return new Response(s,{headers:{\"content-type\":\"image/png\",\"cache-control\":R?\"no-cache, no-store\":\"public, immutable, no-transform, max-age=31536000\",...o.headers},status:o.status,statusText:o.statusText})}};\n/*! Copyright Twitter Inc. and other contributors. Licensed under MIT */\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvb2cvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaU0sNENBQTRDLGNBQWMsMkNBQTJDLGNBQWMseUJBQXlCLFdBQVcsZ0lBQWdJLG1CQUFtQixPQUFPLDhmQUE4ZixnQkFBZ0IsMkJBQTJCLFdBQVcsMENBQTBDLEVBQUUsRUFBRSxnQkFBZ0IsT0FBTyxNQUFNLHVEQUFVLENBQUMsMkRBQUMsSUFBSSx5REFBQyxDQUFDLHFEQUFDLFVBQVUsaURBQUMsYUFBYSxtTUFBb0Usb0pBQW9KLHdRQUF3USxzQkFBc0IsaUJBQWlCLGtEQUFrRCxFQUFFLFFBQVEsc0JBQXNCLDBCQUEwQixTQUFTLHNDQUFzQyxHQUFHLHVCQUF1QixnRkFBZ0YscUVBQXFFLDZDQUE2Qyw0Q0FBNEMsa0JBQWtCLFFBQVEsSUFBSSxtQkFBbUIseUNBQXlDLDZDQUE2QyxvQkFBb0IsSUFBSSxzQkFBc0IsWUFBWSxlQUFlLEVBQUUsWUFBWSxFQUFFLG9DQUFvQyxTQUFTLGtFQUFrRSxxQkFBcUIsbUNBQW1DLGNBQWMsb0JBQW9CLHFCQUFxQixTQUFTLGtCQUFrQixFQUFFLHFCQUFxQiwrQkFBK0IsMEJBQTBCLGVBQWUsZ0JBQWdCLHNCQUFzQix1REFBQyxJQUFJLDZEQUE2RCxtREFBbUQseUJBQXlCLGNBQWMsRUFBRSxRQUFRLG9EQUFPLElBQUksT0FBTyw0QkFBNEIsRUFBRSxpQ0FBaUMsRUFBRSx1QkFBdUIsU0FBUyxtSUFBbUkseUNBQXlDLElBQStCO0FBQ3hvRztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL29nL2Rpc3QvaW5kZXguanM/ZmFmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYix7aW5pdCBhcyBTfWZyb21cInNhdG9yaS93YXNtXCI7aW1wb3J0IEUgZnJvbVwieW9nYS13YXNtLXdlYlwiO2ltcG9ydCphcyBpIGZyb21cIkByZXN2Zy9yZXN2Zy13YXNtXCI7aW1wb3J0IE4gZnJvbVwiLi4vdmVuZG9yL3Jlc3ZnLnNpbWQud2FzbT9tb2R1bGVcIjtpbXBvcnQgVCBmcm9tXCIuLi92ZW5kb3IveW9nYS53YXNtP21vZHVsZVwiO3ZhciB2PVN0cmluZy5mcm9tQ2hhckNvZGUoODIwNSksaj0vXFx1RkUwRi9nO2Z1bmN0aW9uIGModCl7cmV0dXJuIHkodC5pbmRleE9mKHYpPDA/dC5yZXBsYWNlKGosXCJcIik6dCl9ZnVuY3Rpb24geSh0KXtmb3IodmFyIG49W10sZT0wLG89MCxzPTA7czx0Lmxlbmd0aDspZT10LmNoYXJDb2RlQXQocysrKSxvPyhuLnB1c2goKDY1NTM2KyhvLTU1Mjk2PDwxMCkrKGUtNTYzMjApKS50b1N0cmluZygxNikpLG89MCk6NTUyOTY8PWUmJmU8PTU2MzE5P289ZTpuLnB1c2goZS50b1N0cmluZygxNikpO3JldHVybiBuLmpvaW4oXCItXCIpfXZhciByPXt0d2Vtb2ppOnQ9PlwiaHR0cHM6Ly90d2Vtb2ppLm1heGNkbi5jb20vdi9sYXRlc3Qvc3ZnL1wiK3QudG9Mb3dlckNhc2UoKStcIi5zdmdcIixvcGVubW9qaTpcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHN2Z21vamkvb3Blbm1vamlAMi4wLjAvc3ZnL1wiLGJsb2Jtb2ppOlwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9Ac3ZnbW9qaS9ibG9iQDIuMC4wL3N2Zy9cIixub3RvOlwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3N2Z21vamkvc3ZnbW9qaS9wYWNrYWdlcy9zdmdtb2ppX19ub3RvL3N2Zy9cIixmbHVlbnQ6dD0+XCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvc2h1ZGluZy9mbHVlbnR1aS1lbW9qaS11bmljb2RlL2Fzc2V0cy9cIit0LnRvTG93ZXJDYXNlKCkrXCJfY29sb3Iuc3ZnXCIsZmx1ZW50RmxhdDp0PT5cImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9zaHVkaW5nL2ZsdWVudHVpLWVtb2ppLXVuaWNvZGUvYXNzZXRzL1wiK3QudG9Mb3dlckNhc2UoKStcIl9mbGF0LnN2Z1wifTtmdW5jdGlvbiBtKHQsbil7KCFufHwhcltuXSkmJihuPVwidHdlbW9qaVwiKTtsZXQgZT1yW25dO3JldHVybiBmZXRjaCh0eXBlb2YgZT09XCJmdW5jdGlvblwiP2UodCk6YCR7ZX0ke3QudG9VcHBlckNhc2UoKX0uc3ZnYCl9dmFyIEM9aS5pbml0V2FzbShOKSx4PUUoVCkudGhlbih0PT5TKHQpKSxfPWZldGNoKG5ldyBVUkwoXCIuLi92ZW5kb3Ivbm90by1zYW5zLXYyNy1sYXRpbi1yZWd1bGFyLnR0ZlwiLGltcG9ydC5tZXRhLnVybCkpLnRoZW4odD0+dC5hcnJheUJ1ZmZlcigpKSxmLHUsUj0oKHU9KGY9Z2xvYmFsVGhpcz09bnVsbD92b2lkIDA6Z2xvYmFsVGhpcy5wcm9jZXNzKT09bnVsbD92b2lkIDA6Zi5lbnYpPT1udWxsP3ZvaWQgMDp1Lk5PREVfRU5WKT09PVwiZGV2ZWxvcG1lbnRcIixsPXt6aDpcIk5vdG8rU2FucytTQ1wiLGphOlwiTm90bytTYW5zK0pQXCIsa286XCJOb3RvK1NhbnMrS1JcIix0aDpcIk5vdG8rU2FucytUaGFpXCIsaGU6XCJOb3RvK1NhbnMrSGVicmV3XCIsYXI6XCJOb3RvK1NhbnMrQXJhYmljXCIsYm46XCJOb3RvK1NhbnMrQmVuZ2FsaVwiLHRhOlwiTm90bytTYW5zK1RhbWlsXCIsdGU6XCJOb3RvK1NhbnMrVGVsdWd1XCIsbWw6XCJOb3RvK1NhbnMrTWFsYXlhbGFtXCIsZGV2YW5hZ2FyaTpcIk5vdG8rU2FucytEZXZhbmFnYXJpXCIsdW5rbm93bjpcIk5vdG8rU2Fuc1wifTthc3luYyBmdW5jdGlvbiBrKHQsbil7aWYoIXR8fCFuKXJldHVybjtsZXQgZT1gaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT0ke3R9JnRleHQ9JHtlbmNvZGVVUklDb21wb25lbnQobil9YCxzPShhd2FpdChhd2FpdCBmZXRjaChlLHtoZWFkZXJzOntcIlVzZXItQWdlbnRcIjpcIk1vemlsbGEvNS4wIChNYWNpbnRvc2g7IFU7IEludGVsIE1hYyBPUyBYIDEwXzZfODsgZGUtYXQpIEFwcGxlV2ViS2l0LzUzMy4yMS4xIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi81LjAuNSBTYWZhcmkvNTMzLjIxLjFcIn19KSkudGV4dCgpKS5tYXRjaCgvc3JjOiB1cmxcXCgoLispXFwpIGZvcm1hdFxcKCcob3BlbnR5cGV8dHJ1ZXR5cGUpJ1xcKS8pO2lmKCFzKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGZvbnRcIik7cmV0dXJuIGZldGNoKHNbMV0pLnRoZW4oYT0+YS5hcnJheUJ1ZmZlcigpKX12YXIgZz1uZXcgTWFwLEY9KHtlbW9qaTp0fSk9PntsZXQgbj1hc3luYyhlLG8pPT57aWYoZT09PVwiZW1vamlcIilyZXR1cm5cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsXCIrYnRvYShhd2FpdChhd2FpdCBtKGMobyksdCkpLnRleHQoKSk7bFtlXXx8KGU9XCJ1bmtub3duXCIpO3RyeXtsZXQgcz1hd2FpdCBrKGxbZV0sbyk7aWYocylyZXR1cm57bmFtZTpgc2F0b3JpXyR7ZX1fZmFsbGJhY2tfJHtvfWAsZGF0YTpzLHdlaWdodDo0MDAsc3R5bGU6XCJub3JtYWxcIn19Y2F0Y2gocyl7Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGR5bmFtaWMgZm9udCBmb3JcIixvLFwiLiBFcnJvcjpcIixzKX19O3JldHVybiBhc3luYyguLi5lKT0+e2xldCBvPUpTT04uc3RyaW5naWZ5KGUpLHM9Zy5nZXQobyk7aWYocylyZXR1cm4gcztsZXQgYT1hd2FpdCBuKC4uLmUpO3JldHVybiBnLnNldChvLGEpLGF9fSxwPWNsYXNze2NvbnN0cnVjdG9yKG4sZT17fSl7bGV0IG89T2JqZWN0LmFzc2lnbih7d2lkdGg6MTIwMCxoZWlnaHQ6NjMwLGRlYnVnOiExfSxlKSxzPW5ldyBSZWFkYWJsZVN0cmVhbSh7YXN5bmMgc3RhcnQoYSl7YXdhaXQgeCxhd2FpdCBDO2xldCBkPWF3YWl0IF8saD1hd2FpdCBiKG4se3dpZHRoOm8ud2lkdGgsaGVpZ2h0Om8uaGVpZ2h0LGRlYnVnOm8uZGVidWcsZm9udHM6by5mb250c3x8W3tuYW1lOlwic2FucyBzZXJpZlwiLGRhdGE6ZCx3ZWlnaHQ6NzAwLHN0eWxlOlwibm9ybWFsXCJ9XSxsb2FkQWRkaXRpb25hbEFzc2V0OkYoe2Vtb2ppOm8uZW1vaml9KX0pLHc9bmV3IGkuUmVzdmcoaCx7Zml0VG86e21vZGU6XCJ3aWR0aFwiLHZhbHVlOm8ud2lkdGh9fSk7YS5lbnF1ZXVlKHcucmVuZGVyKCkpLGEuY2xvc2UoKX19KTtyZXR1cm4gbmV3IFJlc3BvbnNlKHMse2hlYWRlcnM6e1wiY29udGVudC10eXBlXCI6XCJpbWFnZS9wbmdcIixcImNhY2hlLWNvbnRyb2xcIjpSP1wibm8tY2FjaGUsIG5vLXN0b3JlXCI6XCJwdWJsaWMsIGltbXV0YWJsZSwgbm8tdHJhbnNmb3JtLCBtYXgtYWdlPTMxNTM2MDAwXCIsLi4uby5oZWFkZXJzfSxzdGF0dXM6by5zdGF0dXMsc3RhdHVzVGV4dDpvLnN0YXR1c1RleHR9KX19O2V4cG9ydHtwIGFzIEltYWdlUmVzcG9uc2V9O1xuLyohIENvcHlyaWdodCBUd2l0dGVyIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy4gTGljZW5zZWQgdW5kZXIgTUlUICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/@vercel/og/dist/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/satori/dist/esm/index.wasm.js":
/*!****************************************************!*\
  !*** ./node_modules/satori/dist/esm/index.wasm.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ vu),\n/* harmony export */   \"init\": () => (/* binding */ Eu)\n/* harmony export */ });\n/* harmony import */ var css_to_react_native__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! css-to-react-native */ \"(middleware)/./node_modules/css-to-react-native/index.js\");\n/* harmony import */ var css_background_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! css-background-parser */ \"(middleware)/./node_modules/css-background-parser/index.js\");\n/* harmony import */ var css_box_shadow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! css-box-shadow */ \"(middleware)/./node_modules/css-box-shadow/index.js\");\n/* harmony import */ var postcss_value_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! postcss-value-parser */ \"(middleware)/./node_modules/postcss-value-parser/lib/index.js\");\n/* harmony import */ var _shuding_opentype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shuding/opentype.js */ \"(middleware)/./node_modules/@shuding/opentype.js/dist/opentype.module.js\");\nvar xu=Object.create;var or=Object.defineProperty;var wu=Object.getOwnPropertyDescriptor;var _u=Object.getOwnPropertyNames;var Su=Object.getPrototypeOf,ku=Object.prototype.hasOwnProperty;var Br=(e,t)=>()=>(e&&(t=e(e=0)),t);var R=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),co=(e,t)=>{for(var n in t)or(e,n,{get:t[n],enumerable:!0})},po=(e,t,n,r)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let i of _u(t))!ku.call(e,i)&&i!==n&&or(e,i,{get:()=>t[i],enumerable:!(r=wu(t,i))||r.enumerable});return e};var Tu=(e,t,n)=>(n=e!=null?xu(Su(e)):{},po(t||!e||!e.__esModule?or(n,\"default\",{value:e,enumerable:!0}):n,e)),ar=e=>po(or({},\"__esModule\",{value:!0}),e);var c=Br(()=>{});var mn=R(hn=>{\"use strict\";c();Object.defineProperty(hn,\"__esModule\",{value:!0});Object.defineProperty(hn,\"default\",{enumerable:!0,get:()=>al});function al(e){if(e=`${e}`,e===\"0\")return\"0\";if(/^[+-]?(\\d+|\\d*\\.\\d+)(e[+-]?\\d+)?(%|\\w+)?$/.test(e))return e.replace(/^[+-]?/,t=>t===\"-\"?\"\":\"-\");if(e.includes(\"var(\")||e.includes(\"calc(\"))return`calc(${e} * -1)`}});var No=R(gn=>{\"use strict\";c();Object.defineProperty(gn,\"__esModule\",{value:!0});Object.defineProperty(gn,\"default\",{enumerable:!0,get:()=>sl});var sl=[\"preflight\",\"container\",\"accessibility\",\"pointerEvents\",\"visibility\",\"position\",\"inset\",\"isolation\",\"zIndex\",\"order\",\"gridColumn\",\"gridColumnStart\",\"gridColumnEnd\",\"gridRow\",\"gridRowStart\",\"gridRowEnd\",\"float\",\"clear\",\"margin\",\"boxSizing\",\"display\",\"aspectRatio\",\"height\",\"maxHeight\",\"minHeight\",\"width\",\"minWidth\",\"maxWidth\",\"flex\",\"flexShrink\",\"flexGrow\",\"flexBasis\",\"tableLayout\",\"borderCollapse\",\"borderSpacing\",\"transformOrigin\",\"translate\",\"rotate\",\"skew\",\"scale\",\"transform\",\"animation\",\"cursor\",\"touchAction\",\"userSelect\",\"resize\",\"scrollSnapType\",\"scrollSnapAlign\",\"scrollSnapStop\",\"scrollMargin\",\"scrollPadding\",\"listStylePosition\",\"listStyleType\",\"appearance\",\"columns\",\"breakBefore\",\"breakInside\",\"breakAfter\",\"gridAutoColumns\",\"gridAutoFlow\",\"gridAutoRows\",\"gridTemplateColumns\",\"gridTemplateRows\",\"flexDirection\",\"flexWrap\",\"placeContent\",\"placeItems\",\"alignContent\",\"alignItems\",\"justifyContent\",\"justifyItems\",\"gap\",\"space\",\"divideWidth\",\"divideStyle\",\"divideColor\",\"divideOpacity\",\"placeSelf\",\"alignSelf\",\"justifySelf\",\"overflow\",\"overscrollBehavior\",\"scrollBehavior\",\"textOverflow\",\"whitespace\",\"wordBreak\",\"borderRadius\",\"borderWidth\",\"borderStyle\",\"borderColor\",\"borderOpacity\",\"backgroundColor\",\"backgroundOpacity\",\"backgroundImage\",\"gradientColorStops\",\"boxDecorationBreak\",\"backgroundSize\",\"backgroundAttachment\",\"backgroundClip\",\"backgroundPosition\",\"backgroundRepeat\",\"backgroundOrigin\",\"fill\",\"stroke\",\"strokeWidth\",\"objectFit\",\"objectPosition\",\"padding\",\"textAlign\",\"textIndent\",\"verticalAlign\",\"fontFamily\",\"fontSize\",\"fontWeight\",\"textTransform\",\"fontStyle\",\"fontVariantNumeric\",\"lineHeight\",\"letterSpacing\",\"textColor\",\"textOpacity\",\"textDecoration\",\"textDecorationColor\",\"textDecorationStyle\",\"textDecorationThickness\",\"textUnderlineOffset\",\"fontSmoothing\",\"placeholderColor\",\"placeholderOpacity\",\"caretColor\",\"accentColor\",\"opacity\",\"backgroundBlendMode\",\"mixBlendMode\",\"boxShadow\",\"boxShadowColor\",\"outlineStyle\",\"outlineWidth\",\"outlineOffset\",\"outlineColor\",\"ringWidth\",\"ringColor\",\"ringOpacity\",\"ringOffsetWidth\",\"ringOffsetColor\",\"blur\",\"brightness\",\"contrast\",\"dropShadow\",\"grayscale\",\"hueRotate\",\"invert\",\"saturate\",\"sepia\",\"filter\",\"backdropBlur\",\"backdropBrightness\",\"backdropContrast\",\"backdropGrayscale\",\"backdropHueRotate\",\"backdropInvert\",\"backdropOpacity\",\"backdropSaturate\",\"backdropSepia\",\"backdropFilter\",\"transitionProperty\",\"transitionDelay\",\"transitionDuration\",\"transitionTimingFunction\",\"willChange\",\"content\"]});var Wo=R(vn=>{\"use strict\";c();Object.defineProperty(vn,\"__esModule\",{value:!0});Object.defineProperty(vn,\"default\",{enumerable:!0,get:()=>ul});function ul(e,t){return e===void 0?t:Array.isArray(e)?e:[...new Set(t.filter(r=>e!==!1&&e[r]!==!1).concat(Object.keys(e).filter(r=>e[r]!==!1)))]}});var bn=R((Hm,$o)=>{c();$o.exports={content:[],presets:[],darkMode:\"media\",theme:{screens:{sm:\"640px\",md:\"768px\",lg:\"1024px\",xl:\"1280px\",\"2xl\":\"1536px\"},colors:({colors:e})=>({inherit:e.inherit,current:e.current,transparent:e.transparent,black:e.black,white:e.white,slate:e.slate,gray:e.gray,zinc:e.zinc,neutral:e.neutral,stone:e.stone,red:e.red,orange:e.orange,amber:e.amber,yellow:e.yellow,lime:e.lime,green:e.green,emerald:e.emerald,teal:e.teal,cyan:e.cyan,sky:e.sky,blue:e.blue,indigo:e.indigo,violet:e.violet,purple:e.purple,fuchsia:e.fuchsia,pink:e.pink,rose:e.rose}),columns:{auto:\"auto\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",10:\"10\",11:\"11\",12:\"12\",\"3xs\":\"16rem\",\"2xs\":\"18rem\",xs:\"20rem\",sm:\"24rem\",md:\"28rem\",lg:\"32rem\",xl:\"36rem\",\"2xl\":\"42rem\",\"3xl\":\"48rem\",\"4xl\":\"56rem\",\"5xl\":\"64rem\",\"6xl\":\"72rem\",\"7xl\":\"80rem\"},spacing:{px:\"1px\",0:\"0px\",.5:\"0.125rem\",1:\"0.25rem\",1.5:\"0.375rem\",2:\"0.5rem\",2.5:\"0.625rem\",3:\"0.75rem\",3.5:\"0.875rem\",4:\"1rem\",5:\"1.25rem\",6:\"1.5rem\",7:\"1.75rem\",8:\"2rem\",9:\"2.25rem\",10:\"2.5rem\",11:\"2.75rem\",12:\"3rem\",14:\"3.5rem\",16:\"4rem\",20:\"5rem\",24:\"6rem\",28:\"7rem\",32:\"8rem\",36:\"9rem\",40:\"10rem\",44:\"11rem\",48:\"12rem\",52:\"13rem\",56:\"14rem\",60:\"15rem\",64:\"16rem\",72:\"18rem\",80:\"20rem\",96:\"24rem\"},animation:{none:\"none\",spin:\"spin 1s linear infinite\",ping:\"ping 1s cubic-bezier(0, 0, 0.2, 1) infinite\",pulse:\"pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite\",bounce:\"bounce 1s infinite\"},aspectRatio:{auto:\"auto\",square:\"1 / 1\",video:\"16 / 9\"},backdropBlur:({theme:e})=>e(\"blur\"),backdropBrightness:({theme:e})=>e(\"brightness\"),backdropContrast:({theme:e})=>e(\"contrast\"),backdropGrayscale:({theme:e})=>e(\"grayscale\"),backdropHueRotate:({theme:e})=>e(\"hueRotate\"),backdropInvert:({theme:e})=>e(\"invert\"),backdropOpacity:({theme:e})=>e(\"opacity\"),backdropSaturate:({theme:e})=>e(\"saturate\"),backdropSepia:({theme:e})=>e(\"sepia\"),backgroundColor:({theme:e})=>e(\"colors\"),backgroundImage:{none:\"none\",\"gradient-to-t\":\"linear-gradient(to top, var(--tw-gradient-stops))\",\"gradient-to-tr\":\"linear-gradient(to top right, var(--tw-gradient-stops))\",\"gradient-to-r\":\"linear-gradient(to right, var(--tw-gradient-stops))\",\"gradient-to-br\":\"linear-gradient(to bottom right, var(--tw-gradient-stops))\",\"gradient-to-b\":\"linear-gradient(to bottom, var(--tw-gradient-stops))\",\"gradient-to-bl\":\"linear-gradient(to bottom left, var(--tw-gradient-stops))\",\"gradient-to-l\":\"linear-gradient(to left, var(--tw-gradient-stops))\",\"gradient-to-tl\":\"linear-gradient(to top left, var(--tw-gradient-stops))\"},backgroundOpacity:({theme:e})=>e(\"opacity\"),backgroundPosition:{bottom:\"bottom\",center:\"center\",left:\"left\",\"left-bottom\":\"left bottom\",\"left-top\":\"left top\",right:\"right\",\"right-bottom\":\"right bottom\",\"right-top\":\"right top\",top:\"top\"},backgroundSize:{auto:\"auto\",cover:\"cover\",contain:\"contain\"},blur:{0:\"0\",none:\"0\",sm:\"4px\",DEFAULT:\"8px\",md:\"12px\",lg:\"16px\",xl:\"24px\",\"2xl\":\"40px\",\"3xl\":\"64px\"},brightness:{0:\"0\",50:\".5\",75:\".75\",90:\".9\",95:\".95\",100:\"1\",105:\"1.05\",110:\"1.1\",125:\"1.25\",150:\"1.5\",200:\"2\"},borderColor:({theme:e})=>({...e(\"colors\"),DEFAULT:e(\"colors.gray.200\",\"currentColor\")}),borderOpacity:({theme:e})=>e(\"opacity\"),borderRadius:{none:\"0px\",sm:\"0.125rem\",DEFAULT:\"0.25rem\",md:\"0.375rem\",lg:\"0.5rem\",xl:\"0.75rem\",\"2xl\":\"1rem\",\"3xl\":\"1.5rem\",full:\"9999px\"},borderSpacing:({theme:e})=>({...e(\"spacing\")}),borderWidth:{DEFAULT:\"1px\",0:\"0px\",2:\"2px\",4:\"4px\",8:\"8px\"},boxShadow:{sm:\"0 1px 2px 0 rgb(0 0 0 / 0.05)\",DEFAULT:\"0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)\",md:\"0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)\",lg:\"0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)\",xl:\"0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)\",\"2xl\":\"0 25px 50px -12px rgb(0 0 0 / 0.25)\",inner:\"inset 0 2px 4px 0 rgb(0 0 0 / 0.05)\",none:\"none\"},boxShadowColor:({theme:e})=>e(\"colors\"),caretColor:({theme:e})=>e(\"colors\"),accentColor:({theme:e})=>({...e(\"colors\"),auto:\"auto\"}),contrast:{0:\"0\",50:\".5\",75:\".75\",100:\"1\",125:\"1.25\",150:\"1.5\",200:\"2\"},container:{},content:{none:\"none\"},cursor:{auto:\"auto\",default:\"default\",pointer:\"pointer\",wait:\"wait\",text:\"text\",move:\"move\",help:\"help\",\"not-allowed\":\"not-allowed\",none:\"none\",\"context-menu\":\"context-menu\",progress:\"progress\",cell:\"cell\",crosshair:\"crosshair\",\"vertical-text\":\"vertical-text\",alias:\"alias\",copy:\"copy\",\"no-drop\":\"no-drop\",grab:\"grab\",grabbing:\"grabbing\",\"all-scroll\":\"all-scroll\",\"col-resize\":\"col-resize\",\"row-resize\":\"row-resize\",\"n-resize\":\"n-resize\",\"e-resize\":\"e-resize\",\"s-resize\":\"s-resize\",\"w-resize\":\"w-resize\",\"ne-resize\":\"ne-resize\",\"nw-resize\":\"nw-resize\",\"se-resize\":\"se-resize\",\"sw-resize\":\"sw-resize\",\"ew-resize\":\"ew-resize\",\"ns-resize\":\"ns-resize\",\"nesw-resize\":\"nesw-resize\",\"nwse-resize\":\"nwse-resize\",\"zoom-in\":\"zoom-in\",\"zoom-out\":\"zoom-out\"},divideColor:({theme:e})=>e(\"borderColor\"),divideOpacity:({theme:e})=>e(\"borderOpacity\"),divideWidth:({theme:e})=>e(\"borderWidth\"),dropShadow:{sm:\"0 1px 1px rgb(0 0 0 / 0.05)\",DEFAULT:[\"0 1px 2px rgb(0 0 0 / 0.1)\",\"0 1px 1px rgb(0 0 0 / 0.06)\"],md:[\"0 4px 3px rgb(0 0 0 / 0.07)\",\"0 2px 2px rgb(0 0 0 / 0.06)\"],lg:[\"0 10px 8px rgb(0 0 0 / 0.04)\",\"0 4px 3px rgb(0 0 0 / 0.1)\"],xl:[\"0 20px 13px rgb(0 0 0 / 0.03)\",\"0 8px 5px rgb(0 0 0 / 0.08)\"],\"2xl\":\"0 25px 25px rgb(0 0 0 / 0.15)\",none:\"0 0 #0000\"},fill:({theme:e})=>e(\"colors\"),grayscale:{0:\"0\",DEFAULT:\"100%\"},hueRotate:{0:\"0deg\",15:\"15deg\",30:\"30deg\",60:\"60deg\",90:\"90deg\",180:\"180deg\"},invert:{0:\"0\",DEFAULT:\"100%\"},flex:{1:\"1 1 0%\",auto:\"1 1 auto\",initial:\"0 1 auto\",none:\"none\"},flexBasis:({theme:e})=>({auto:\"auto\",...e(\"spacing\"),\"1/2\":\"50%\",\"1/3\":\"33.333333%\",\"2/3\":\"66.666667%\",\"1/4\":\"25%\",\"2/4\":\"50%\",\"3/4\":\"75%\",\"1/5\":\"20%\",\"2/5\":\"40%\",\"3/5\":\"60%\",\"4/5\":\"80%\",\"1/6\":\"16.666667%\",\"2/6\":\"33.333333%\",\"3/6\":\"50%\",\"4/6\":\"66.666667%\",\"5/6\":\"83.333333%\",\"1/12\":\"8.333333%\",\"2/12\":\"16.666667%\",\"3/12\":\"25%\",\"4/12\":\"33.333333%\",\"5/12\":\"41.666667%\",\"6/12\":\"50%\",\"7/12\":\"58.333333%\",\"8/12\":\"66.666667%\",\"9/12\":\"75%\",\"10/12\":\"83.333333%\",\"11/12\":\"91.666667%\",full:\"100%\"}),flexGrow:{0:\"0\",DEFAULT:\"1\"},flexShrink:{0:\"0\",DEFAULT:\"1\"},fontFamily:{sans:[\"ui-sans-serif\",\"system-ui\",\"-apple-system\",\"BlinkMacSystemFont\",'\"Segoe UI\"',\"Roboto\",'\"Helvetica Neue\"',\"Arial\",'\"Noto Sans\"',\"sans-serif\",'\"Apple Color Emoji\"','\"Segoe UI Emoji\"','\"Segoe UI Symbol\"','\"Noto Color Emoji\"'],serif:[\"ui-serif\",\"Georgia\",\"Cambria\",'\"Times New Roman\"',\"Times\",\"serif\"],mono:[\"ui-monospace\",\"SFMono-Regular\",\"Menlo\",\"Monaco\",\"Consolas\",'\"Liberation Mono\"','\"Courier New\"',\"monospace\"]},fontSize:{xs:[\"0.75rem\",{lineHeight:\"1rem\"}],sm:[\"0.875rem\",{lineHeight:\"1.25rem\"}],base:[\"1rem\",{lineHeight:\"1.5rem\"}],lg:[\"1.125rem\",{lineHeight:\"1.75rem\"}],xl:[\"1.25rem\",{lineHeight:\"1.75rem\"}],\"2xl\":[\"1.5rem\",{lineHeight:\"2rem\"}],\"3xl\":[\"1.875rem\",{lineHeight:\"2.25rem\"}],\"4xl\":[\"2.25rem\",{lineHeight:\"2.5rem\"}],\"5xl\":[\"3rem\",{lineHeight:\"1\"}],\"6xl\":[\"3.75rem\",{lineHeight:\"1\"}],\"7xl\":[\"4.5rem\",{lineHeight:\"1\"}],\"8xl\":[\"6rem\",{lineHeight:\"1\"}],\"9xl\":[\"8rem\",{lineHeight:\"1\"}]},fontWeight:{thin:\"100\",extralight:\"200\",light:\"300\",normal:\"400\",medium:\"500\",semibold:\"600\",bold:\"700\",extrabold:\"800\",black:\"900\"},gap:({theme:e})=>e(\"spacing\"),gradientColorStops:({theme:e})=>e(\"colors\"),gridAutoColumns:{auto:\"auto\",min:\"min-content\",max:\"max-content\",fr:\"minmax(0, 1fr)\"},gridAutoRows:{auto:\"auto\",min:\"min-content\",max:\"max-content\",fr:\"minmax(0, 1fr)\"},gridColumn:{auto:\"auto\",\"span-1\":\"span 1 / span 1\",\"span-2\":\"span 2 / span 2\",\"span-3\":\"span 3 / span 3\",\"span-4\":\"span 4 / span 4\",\"span-5\":\"span 5 / span 5\",\"span-6\":\"span 6 / span 6\",\"span-7\":\"span 7 / span 7\",\"span-8\":\"span 8 / span 8\",\"span-9\":\"span 9 / span 9\",\"span-10\":\"span 10 / span 10\",\"span-11\":\"span 11 / span 11\",\"span-12\":\"span 12 / span 12\",\"span-full\":\"1 / -1\"},gridColumnEnd:{auto:\"auto\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",10:\"10\",11:\"11\",12:\"12\",13:\"13\"},gridColumnStart:{auto:\"auto\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",10:\"10\",11:\"11\",12:\"12\",13:\"13\"},gridRow:{auto:\"auto\",\"span-1\":\"span 1 / span 1\",\"span-2\":\"span 2 / span 2\",\"span-3\":\"span 3 / span 3\",\"span-4\":\"span 4 / span 4\",\"span-5\":\"span 5 / span 5\",\"span-6\":\"span 6 / span 6\",\"span-full\":\"1 / -1\"},gridRowStart:{auto:\"auto\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\"},gridRowEnd:{auto:\"auto\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\"},gridTemplateColumns:{none:\"none\",1:\"repeat(1, minmax(0, 1fr))\",2:\"repeat(2, minmax(0, 1fr))\",3:\"repeat(3, minmax(0, 1fr))\",4:\"repeat(4, minmax(0, 1fr))\",5:\"repeat(5, minmax(0, 1fr))\",6:\"repeat(6, minmax(0, 1fr))\",7:\"repeat(7, minmax(0, 1fr))\",8:\"repeat(8, minmax(0, 1fr))\",9:\"repeat(9, minmax(0, 1fr))\",10:\"repeat(10, minmax(0, 1fr))\",11:\"repeat(11, minmax(0, 1fr))\",12:\"repeat(12, minmax(0, 1fr))\"},gridTemplateRows:{none:\"none\",1:\"repeat(1, minmax(0, 1fr))\",2:\"repeat(2, minmax(0, 1fr))\",3:\"repeat(3, minmax(0, 1fr))\",4:\"repeat(4, minmax(0, 1fr))\",5:\"repeat(5, minmax(0, 1fr))\",6:\"repeat(6, minmax(0, 1fr))\"},height:({theme:e})=>({auto:\"auto\",...e(\"spacing\"),\"1/2\":\"50%\",\"1/3\":\"33.333333%\",\"2/3\":\"66.666667%\",\"1/4\":\"25%\",\"2/4\":\"50%\",\"3/4\":\"75%\",\"1/5\":\"20%\",\"2/5\":\"40%\",\"3/5\":\"60%\",\"4/5\":\"80%\",\"1/6\":\"16.666667%\",\"2/6\":\"33.333333%\",\"3/6\":\"50%\",\"4/6\":\"66.666667%\",\"5/6\":\"83.333333%\",full:\"100%\",screen:\"100vh\",min:\"min-content\",max:\"max-content\",fit:\"fit-content\"}),inset:({theme:e})=>({auto:\"auto\",...e(\"spacing\"),\"1/2\":\"50%\",\"1/3\":\"33.333333%\",\"2/3\":\"66.666667%\",\"1/4\":\"25%\",\"2/4\":\"50%\",\"3/4\":\"75%\",full:\"100%\"}),keyframes:{spin:{to:{transform:\"rotate(360deg)\"}},ping:{\"75%, 100%\":{transform:\"scale(2)\",opacity:\"0\"}},pulse:{\"50%\":{opacity:\".5\"}},bounce:{\"0%, 100%\":{transform:\"translateY(-25%)\",animationTimingFunction:\"cubic-bezier(0.8,0,1,1)\"},\"50%\":{transform:\"none\",animationTimingFunction:\"cubic-bezier(0,0,0.2,1)\"}}},letterSpacing:{tighter:\"-0.05em\",tight:\"-0.025em\",normal:\"0em\",wide:\"0.025em\",wider:\"0.05em\",widest:\"0.1em\"},lineHeight:{none:\"1\",tight:\"1.25\",snug:\"1.375\",normal:\"1.5\",relaxed:\"1.625\",loose:\"2\",3:\".75rem\",4:\"1rem\",5:\"1.25rem\",6:\"1.5rem\",7:\"1.75rem\",8:\"2rem\",9:\"2.25rem\",10:\"2.5rem\"},listStyleType:{none:\"none\",disc:\"disc\",decimal:\"decimal\"},margin:({theme:e})=>({auto:\"auto\",...e(\"spacing\")}),maxHeight:({theme:e})=>({...e(\"spacing\"),full:\"100%\",screen:\"100vh\",min:\"min-content\",max:\"max-content\",fit:\"fit-content\"}),maxWidth:({theme:e,breakpoints:t})=>({none:\"none\",0:\"0rem\",xs:\"20rem\",sm:\"24rem\",md:\"28rem\",lg:\"32rem\",xl:\"36rem\",\"2xl\":\"42rem\",\"3xl\":\"48rem\",\"4xl\":\"56rem\",\"5xl\":\"64rem\",\"6xl\":\"72rem\",\"7xl\":\"80rem\",full:\"100%\",min:\"min-content\",max:\"max-content\",fit:\"fit-content\",prose:\"65ch\",...t(e(\"screens\"))}),minHeight:{0:\"0px\",full:\"100%\",screen:\"100vh\",min:\"min-content\",max:\"max-content\",fit:\"fit-content\"},minWidth:{0:\"0px\",full:\"100%\",min:\"min-content\",max:\"max-content\",fit:\"fit-content\"},objectPosition:{bottom:\"bottom\",center:\"center\",left:\"left\",\"left-bottom\":\"left bottom\",\"left-top\":\"left top\",right:\"right\",\"right-bottom\":\"right bottom\",\"right-top\":\"right top\",top:\"top\"},opacity:{0:\"0\",5:\"0.05\",10:\"0.1\",20:\"0.2\",25:\"0.25\",30:\"0.3\",40:\"0.4\",50:\"0.5\",60:\"0.6\",70:\"0.7\",75:\"0.75\",80:\"0.8\",90:\"0.9\",95:\"0.95\",100:\"1\"},order:{first:\"-9999\",last:\"9999\",none:\"0\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",10:\"10\",11:\"11\",12:\"12\"},padding:({theme:e})=>e(\"spacing\"),placeholderColor:({theme:e})=>e(\"colors\"),placeholderOpacity:({theme:e})=>e(\"opacity\"),outlineColor:({theme:e})=>e(\"colors\"),outlineOffset:{0:\"0px\",1:\"1px\",2:\"2px\",4:\"4px\",8:\"8px\"},outlineWidth:{0:\"0px\",1:\"1px\",2:\"2px\",4:\"4px\",8:\"8px\"},ringColor:({theme:e})=>({DEFAULT:e(\"colors.blue.500\",\"#3b82f6\"),...e(\"colors\")}),ringOffsetColor:({theme:e})=>e(\"colors\"),ringOffsetWidth:{0:\"0px\",1:\"1px\",2:\"2px\",4:\"4px\",8:\"8px\"},ringOpacity:({theme:e})=>({DEFAULT:\"0.5\",...e(\"opacity\")}),ringWidth:{DEFAULT:\"3px\",0:\"0px\",1:\"1px\",2:\"2px\",4:\"4px\",8:\"8px\"},rotate:{0:\"0deg\",1:\"1deg\",2:\"2deg\",3:\"3deg\",6:\"6deg\",12:\"12deg\",45:\"45deg\",90:\"90deg\",180:\"180deg\"},saturate:{0:\"0\",50:\".5\",100:\"1\",150:\"1.5\",200:\"2\"},scale:{0:\"0\",50:\".5\",75:\".75\",90:\".9\",95:\".95\",100:\"1\",105:\"1.05\",110:\"1.1\",125:\"1.25\",150:\"1.5\"},scrollMargin:({theme:e})=>({...e(\"spacing\")}),scrollPadding:({theme:e})=>e(\"spacing\"),sepia:{0:\"0\",DEFAULT:\"100%\"},skew:{0:\"0deg\",1:\"1deg\",2:\"2deg\",3:\"3deg\",6:\"6deg\",12:\"12deg\"},space:({theme:e})=>({...e(\"spacing\")}),stroke:({theme:e})=>e(\"colors\"),strokeWidth:{0:\"0\",1:\"1\",2:\"2\"},textColor:({theme:e})=>e(\"colors\"),textDecorationColor:({theme:e})=>e(\"colors\"),textDecorationThickness:{auto:\"auto\",\"from-font\":\"from-font\",0:\"0px\",1:\"1px\",2:\"2px\",4:\"4px\",8:\"8px\"},textUnderlineOffset:{auto:\"auto\",0:\"0px\",1:\"1px\",2:\"2px\",4:\"4px\",8:\"8px\"},textIndent:({theme:e})=>({...e(\"spacing\")}),textOpacity:({theme:e})=>e(\"opacity\"),transformOrigin:{center:\"center\",top:\"top\",\"top-right\":\"top right\",right:\"right\",\"bottom-right\":\"bottom right\",bottom:\"bottom\",\"bottom-left\":\"bottom left\",left:\"left\",\"top-left\":\"top left\"},transitionDelay:{75:\"75ms\",100:\"100ms\",150:\"150ms\",200:\"200ms\",300:\"300ms\",500:\"500ms\",700:\"700ms\",1e3:\"1000ms\"},transitionDuration:{DEFAULT:\"150ms\",75:\"75ms\",100:\"100ms\",150:\"150ms\",200:\"200ms\",300:\"300ms\",500:\"500ms\",700:\"700ms\",1e3:\"1000ms\"},transitionProperty:{none:\"none\",all:\"all\",DEFAULT:\"color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter\",colors:\"color, background-color, border-color, text-decoration-color, fill, stroke\",opacity:\"opacity\",shadow:\"box-shadow\",transform:\"transform\"},transitionTimingFunction:{DEFAULT:\"cubic-bezier(0.4, 0, 0.2, 1)\",linear:\"linear\",in:\"cubic-bezier(0.4, 0, 1, 1)\",out:\"cubic-bezier(0, 0, 0.2, 1)\",\"in-out\":\"cubic-bezier(0.4, 0, 0.2, 1)\"},translate:({theme:e})=>({...e(\"spacing\"),\"1/2\":\"50%\",\"1/3\":\"33.333333%\",\"2/3\":\"66.666667%\",\"1/4\":\"25%\",\"2/4\":\"50%\",\"3/4\":\"75%\",full:\"100%\"}),width:({theme:e})=>({auto:\"auto\",...e(\"spacing\"),\"1/2\":\"50%\",\"1/3\":\"33.333333%\",\"2/3\":\"66.666667%\",\"1/4\":\"25%\",\"2/4\":\"50%\",\"3/4\":\"75%\",\"1/5\":\"20%\",\"2/5\":\"40%\",\"3/5\":\"60%\",\"4/5\":\"80%\",\"1/6\":\"16.666667%\",\"2/6\":\"33.333333%\",\"3/6\":\"50%\",\"4/6\":\"66.666667%\",\"5/6\":\"83.333333%\",\"1/12\":\"8.333333%\",\"2/12\":\"16.666667%\",\"3/12\":\"25%\",\"4/12\":\"33.333333%\",\"5/12\":\"41.666667%\",\"6/12\":\"50%\",\"7/12\":\"58.333333%\",\"8/12\":\"66.666667%\",\"9/12\":\"75%\",\"10/12\":\"83.333333%\",\"11/12\":\"91.666667%\",full:\"100%\",screen:\"100vw\",min:\"min-content\",max:\"max-content\",fit:\"fit-content\"}),willChange:{auto:\"auto\",scroll:\"scroll-position\",contents:\"contents\",transform:\"transform\"},zIndex:{auto:\"auto\",0:\"0\",10:\"10\",20:\"20\",30:\"30\",40:\"40\",50:\"50\"}},variantOrder:[\"first\",\"last\",\"odd\",\"even\",\"visited\",\"checked\",\"empty\",\"read-only\",\"group-hover\",\"group-focus\",\"focus-within\",\"hover\",\"focus\",\"focus-visible\",\"active\",\"disabled\"],plugins:[]}});var vr={};co(vr,{default:()=>ll});var ll,br=Br(()=>{c();ll={info(e,t){console.info(...Array.isArray(e)?[e]:[t,e])},warn(e,t){console.warn(...Array.isArray(e)?[e]:[t,e])},risk(e,t){console.error(...Array.isArray(e)?[e]:[t,e])}}});var qo=R(yn=>{\"use strict\";c();Object.defineProperty(yn,\"__esModule\",{value:!0});Object.defineProperty(yn,\"default\",{enumerable:!0,get:()=>dl});var fl=cl((br(),ar(vr)));function cl(e){return e&&e.__esModule?e:{default:e}}function bt({version:e,from:t,to:n}){fl.default.warn(`${t}-color-renamed`,[`As of Tailwind CSS ${e}, \\`${t}\\` has been renamed to \\`${n}\\`.`,\"Update your configuration file to silence this warning.\"])}var dl={inherit:\"inherit\",current:\"currentColor\",transparent:\"transparent\",black:\"#000\",white:\"#fff\",slate:{50:\"#f8fafc\",100:\"#f1f5f9\",200:\"#e2e8f0\",300:\"#cbd5e1\",400:\"#94a3b8\",500:\"#64748b\",600:\"#475569\",700:\"#334155\",800:\"#1e293b\",900:\"#0f172a\"},gray:{50:\"#f9fafb\",100:\"#f3f4f6\",200:\"#e5e7eb\",300:\"#d1d5db\",400:\"#9ca3af\",500:\"#6b7280\",600:\"#4b5563\",700:\"#374151\",800:\"#1f2937\",900:\"#111827\"},zinc:{50:\"#fafafa\",100:\"#f4f4f5\",200:\"#e4e4e7\",300:\"#d4d4d8\",400:\"#a1a1aa\",500:\"#71717a\",600:\"#52525b\",700:\"#3f3f46\",800:\"#27272a\",900:\"#18181b\"},neutral:{50:\"#fafafa\",100:\"#f5f5f5\",200:\"#e5e5e5\",300:\"#d4d4d4\",400:\"#a3a3a3\",500:\"#737373\",600:\"#525252\",700:\"#404040\",800:\"#262626\",900:\"#171717\"},stone:{50:\"#fafaf9\",100:\"#f5f5f4\",200:\"#e7e5e4\",300:\"#d6d3d1\",400:\"#a8a29e\",500:\"#78716c\",600:\"#57534e\",700:\"#44403c\",800:\"#292524\",900:\"#1c1917\"},red:{50:\"#fef2f2\",100:\"#fee2e2\",200:\"#fecaca\",300:\"#fca5a5\",400:\"#f87171\",500:\"#ef4444\",600:\"#dc2626\",700:\"#b91c1c\",800:\"#991b1b\",900:\"#7f1d1d\"},orange:{50:\"#fff7ed\",100:\"#ffedd5\",200:\"#fed7aa\",300:\"#fdba74\",400:\"#fb923c\",500:\"#f97316\",600:\"#ea580c\",700:\"#c2410c\",800:\"#9a3412\",900:\"#7c2d12\"},amber:{50:\"#fffbeb\",100:\"#fef3c7\",200:\"#fde68a\",300:\"#fcd34d\",400:\"#fbbf24\",500:\"#f59e0b\",600:\"#d97706\",700:\"#b45309\",800:\"#92400e\",900:\"#78350f\"},yellow:{50:\"#fefce8\",100:\"#fef9c3\",200:\"#fef08a\",300:\"#fde047\",400:\"#facc15\",500:\"#eab308\",600:\"#ca8a04\",700:\"#a16207\",800:\"#854d0e\",900:\"#713f12\"},lime:{50:\"#f7fee7\",100:\"#ecfccb\",200:\"#d9f99d\",300:\"#bef264\",400:\"#a3e635\",500:\"#84cc16\",600:\"#65a30d\",700:\"#4d7c0f\",800:\"#3f6212\",900:\"#365314\"},green:{50:\"#f0fdf4\",100:\"#dcfce7\",200:\"#bbf7d0\",300:\"#86efac\",400:\"#4ade80\",500:\"#22c55e\",600:\"#16a34a\",700:\"#15803d\",800:\"#166534\",900:\"#14532d\"},emerald:{50:\"#ecfdf5\",100:\"#d1fae5\",200:\"#a7f3d0\",300:\"#6ee7b7\",400:\"#34d399\",500:\"#10b981\",600:\"#059669\",700:\"#047857\",800:\"#065f46\",900:\"#064e3b\"},teal:{50:\"#f0fdfa\",100:\"#ccfbf1\",200:\"#99f6e4\",300:\"#5eead4\",400:\"#2dd4bf\",500:\"#14b8a6\",600:\"#0d9488\",700:\"#0f766e\",800:\"#115e59\",900:\"#134e4a\"},cyan:{50:\"#ecfeff\",100:\"#cffafe\",200:\"#a5f3fc\",300:\"#67e8f9\",400:\"#22d3ee\",500:\"#06b6d4\",600:\"#0891b2\",700:\"#0e7490\",800:\"#155e75\",900:\"#164e63\"},sky:{50:\"#f0f9ff\",100:\"#e0f2fe\",200:\"#bae6fd\",300:\"#7dd3fc\",400:\"#38bdf8\",500:\"#0ea5e9\",600:\"#0284c7\",700:\"#0369a1\",800:\"#075985\",900:\"#0c4a6e\"},blue:{50:\"#eff6ff\",100:\"#dbeafe\",200:\"#bfdbfe\",300:\"#93c5fd\",400:\"#60a5fa\",500:\"#3b82f6\",600:\"#2563eb\",700:\"#1d4ed8\",800:\"#1e40af\",900:\"#1e3a8a\"},indigo:{50:\"#eef2ff\",100:\"#e0e7ff\",200:\"#c7d2fe\",300:\"#a5b4fc\",400:\"#818cf8\",500:\"#6366f1\",600:\"#4f46e5\",700:\"#4338ca\",800:\"#3730a3\",900:\"#312e81\"},violet:{50:\"#f5f3ff\",100:\"#ede9fe\",200:\"#ddd6fe\",300:\"#c4b5fd\",400:\"#a78bfa\",500:\"#8b5cf6\",600:\"#7c3aed\",700:\"#6d28d9\",800:\"#5b21b6\",900:\"#4c1d95\"},purple:{50:\"#faf5ff\",100:\"#f3e8ff\",200:\"#e9d5ff\",300:\"#d8b4fe\",400:\"#c084fc\",500:\"#a855f7\",600:\"#9333ea\",700:\"#7e22ce\",800:\"#6b21a8\",900:\"#581c87\"},fuchsia:{50:\"#fdf4ff\",100:\"#fae8ff\",200:\"#f5d0fe\",300:\"#f0abfc\",400:\"#e879f9\",500:\"#d946ef\",600:\"#c026d3\",700:\"#a21caf\",800:\"#86198f\",900:\"#701a75\"},pink:{50:\"#fdf2f8\",100:\"#fce7f3\",200:\"#fbcfe8\",300:\"#f9a8d4\",400:\"#f472b6\",500:\"#ec4899\",600:\"#db2777\",700:\"#be185d\",800:\"#9d174d\",900:\"#831843\"},rose:{50:\"#fff1f2\",100:\"#ffe4e6\",200:\"#fecdd3\",300:\"#fda4af\",400:\"#fb7185\",500:\"#f43f5e\",600:\"#e11d48\",700:\"#be123c\",800:\"#9f1239\",900:\"#881337\"},get lightBlue(){return bt({version:\"v2.2\",from:\"lightBlue\",to:\"sky\"}),this.sky},get warmGray(){return bt({version:\"v3.0\",from:\"warmGray\",to:\"stone\"}),this.stone},get trueGray(){return bt({version:\"v3.0\",from:\"trueGray\",to:\"neutral\"}),this.neutral},get coolGray(){return bt({version:\"v3.0\",from:\"coolGray\",to:\"gray\"}),this.gray},get blueGray(){return bt({version:\"v3.0\",from:\"blueGray\",to:\"slate\"}),this.slate}}});var Bo=R(xn=>{\"use strict\";c();Object.defineProperty(xn,\"__esModule\",{value:!0});Object.defineProperty(xn,\"defaults\",{enumerable:!0,get:()=>pl});function pl(e,...t){for(let i of t){for(let a in i){var n;!(e==null||(n=e.hasOwnProperty)===null||n===void 0)&&n.call(e,a)||(e[a]=i[a])}for(let a of Object.getOwnPropertySymbols(i)){var r;!(e==null||(r=e.hasOwnProperty)===null||r===void 0)&&r.call(e,a)||(e[a]=i[a])}}return e}});var Uo=R(wn=>{\"use strict\";c();Object.defineProperty(wn,\"__esModule\",{value:!0});Object.defineProperty(wn,\"toPath\",{enumerable:!0,get:()=>hl});function hl(e){if(Array.isArray(e))return e;let t=e.split(\"[\").length-1,n=e.split(\"]\").length-1;if(t!==n)throw new Error(`Path is invalid. Has unbalanced brackets: ${e}`);return e.split(/\\.(?![^\\[]*\\])|[\\[\\]]/g).filter(Boolean)}});var Go=R(_n=>{\"use strict\";c();Object.defineProperty(_n,\"__esModule\",{value:!0});Object.defineProperty(_n,\"normalizeConfig\",{enumerable:!0,get:()=>gl});var yt=ml((br(),ar(vr)));function zo(e){if(typeof WeakMap!=\"function\")return null;var t=new WeakMap,n=new WeakMap;return(zo=function(r){return r?n:t})(e)}function ml(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!=\"object\"&&typeof e!=\"function\")return{default:e};var n=zo(t);if(n&&n.has(e))return n.get(e);var r={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(a!==\"default\"&&Object.prototype.hasOwnProperty.call(e,a)){var o=i?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a]}return r.default=e,n&&n.set(e,r),r}function gl(e){if((()=>{if(e.purge||!e.content||!Array.isArray(e.content)&&!(typeof e.content==\"object\"&&e.content!==null))return!1;if(Array.isArray(e.content))return e.content.every(r=>typeof r==\"string\"?!0:!(typeof(r==null?void 0:r.raw)!=\"string\"||(r==null?void 0:r.extension)&&typeof(r==null?void 0:r.extension)!=\"string\"));if(typeof e.content==\"object\"&&e.content!==null){if(Object.keys(e.content).some(r=>![\"files\",\"extract\",\"transform\"].includes(r)))return!1;if(Array.isArray(e.content.files)){if(!e.content.files.every(r=>typeof r==\"string\"?!0:!(typeof(r==null?void 0:r.raw)!=\"string\"||(r==null?void 0:r.extension)&&typeof(r==null?void 0:r.extension)!=\"string\")))return!1;if(typeof e.content.extract==\"object\"){for(let r of Object.values(e.content.extract))if(typeof r!=\"function\")return!1}else if(!(e.content.extract===void 0||typeof e.content.extract==\"function\"))return!1;if(typeof e.content.transform==\"object\"){for(let r of Object.values(e.content.transform))if(typeof r!=\"function\")return!1}else if(!(e.content.transform===void 0||typeof e.content.transform==\"function\"))return!1}return!0}return!1})()||yt.default.warn(\"purge-deprecation\",[\"The `purge`/`content` options have changed in Tailwind CSS v3.0.\",\"Update your configuration file to eliminate this warning.\",\"https://tailwindcss.com/docs/upgrade-guide#configure-content-sources\"]),e.safelist=(()=>{var r;let{content:i,purge:a,safelist:o}=e;return Array.isArray(o)?o:Array.isArray(i==null?void 0:i.safelist)?i.safelist:Array.isArray(a==null?void 0:a.safelist)?a.safelist:Array.isArray(a==null||(r=a.options)===null||r===void 0?void 0:r.safelist)?a.options.safelist:[]})(),typeof e.prefix==\"function\")yt.default.warn(\"prefix-function\",[\"As of Tailwind CSS v3.0, `prefix` cannot be a function.\",\"Update `prefix` in your configuration to be a string to eliminate this warning.\",\"https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function\"]),e.prefix=\"\";else{var n;e.prefix=(n=e.prefix)!==null&&n!==void 0?n:\"\"}e.content={files:(()=>{let{content:r,purge:i}=e;return Array.isArray(i)?i:Array.isArray(i==null?void 0:i.content)?i.content:Array.isArray(r)?r:Array.isArray(r==null?void 0:r.content)?r.content:Array.isArray(r==null?void 0:r.files)?r.files:[]})(),extract:(()=>{let r=(()=>{var o,s,u,l,f,p,g,m,d,h;return!((o=e.purge)===null||o===void 0)&&o.extract?e.purge.extract:!((s=e.content)===null||s===void 0)&&s.extract?e.content.extract:!((u=e.purge)===null||u===void 0||(l=u.extract)===null||l===void 0)&&l.DEFAULT?e.purge.extract.DEFAULT:!((f=e.content)===null||f===void 0||(p=f.extract)===null||p===void 0)&&p.DEFAULT?e.content.extract.DEFAULT:!((g=e.purge)===null||g===void 0||(m=g.options)===null||m===void 0)&&m.extractors?e.purge.options.extractors:!((d=e.content)===null||d===void 0||(h=d.options)===null||h===void 0)&&h.extractors?e.content.options.extractors:{}})(),i={},a=(()=>{var o,s,u,l;if(!((o=e.purge)===null||o===void 0||(s=o.options)===null||s===void 0)&&s.defaultExtractor)return e.purge.options.defaultExtractor;if(!((u=e.content)===null||u===void 0||(l=u.options)===null||l===void 0)&&l.defaultExtractor)return e.content.options.defaultExtractor})();if(a!==void 0&&(i.DEFAULT=a),typeof r==\"function\")i.DEFAULT=r;else if(Array.isArray(r))for(let{extensions:o,extractor:s}of r!=null?r:[])for(let u of o)i[u]=s;else typeof r==\"object\"&&r!==null&&Object.assign(i,r);return i})(),transform:(()=>{let r=(()=>{var a,o,s,u,l,f;return!((a=e.purge)===null||a===void 0)&&a.transform?e.purge.transform:!((o=e.content)===null||o===void 0)&&o.transform?e.content.transform:!((s=e.purge)===null||s===void 0||(u=s.transform)===null||u===void 0)&&u.DEFAULT?e.purge.transform.DEFAULT:!((l=e.content)===null||l===void 0||(f=l.transform)===null||f===void 0)&&f.DEFAULT?e.content.transform.DEFAULT:{}})(),i={};return typeof r==\"function\"&&(i.DEFAULT=r),typeof r==\"object\"&&r!==null&&Object.assign(i,r),i})()};for(let r of e.content.files)if(typeof r==\"string\"&&/{([^,]*?)}/g.test(r)){yt.default.warn(\"invalid-glob-braces\",[`The glob pattern ${(0,yt.dim)(r)} in your Tailwind CSS configuration is invalid.`,`Update it to ${(0,yt.dim)(r.replace(/{([^,]*?)}/g,\"$1\"))} to silence this warning.`]);break}return e}});var jo=R(Sn=>{\"use strict\";c();Object.defineProperty(Sn,\"__esModule\",{value:!0});Object.defineProperty(Sn,\"default\",{enumerable:!0,get:()=>vl});function vl(e){if(Object.prototype.toString.call(e)!==\"[object Object]\")return!1;let t=Object.getPrototypeOf(e);return t===null||t===Object.prototype}});var Vo=R(Tn=>{\"use strict\";c();Object.defineProperty(Tn,\"__esModule\",{value:!0});Object.defineProperty(Tn,\"cloneDeep\",{enumerable:!0,get:()=>kn});function kn(e){return Array.isArray(e)?e.map(t=>kn(t)):typeof e==\"object\"&&e!==null?Object.fromEntries(Object.entries(e).map(([t,n])=>[t,kn(n)])):e}});var En=R((yr,Ho)=>{\"use strict\";c();yr.__esModule=!0;yr.default=xl;function bl(e){for(var t=e.toLowerCase(),n=\"\",r=!1,i=0;i<6&&t[i]!==void 0;i++){var a=t.charCodeAt(i),o=a>=97&&a<=102||a>=48&&a<=57;if(r=a===32,!o)break;n+=t[i]}if(n.length!==0){var s=parseInt(n,16),u=s>=55296&&s<=57343;return u||s===0||s>1114111?[\"\\uFFFD\",n.length+(r?1:0)]:[String.fromCodePoint(s),n.length+(r?1:0)]}}var yl=/\\\\/;function xl(e){var t=yl.test(e);if(!t)return e;for(var n=\"\",r=0;r<e.length;r++){if(e[r]===\"\\\\\"){var i=bl(e.slice(r+1,r+7));if(i!==void 0){n+=i[0],r+=i[1];continue}if(e[r+1]===\"\\\\\"){n+=\"\\\\\",r++;continue}e.length===r+1&&(n+=e[r]);continue}n+=e[r]}return n}Ho.exports=yr.default});var Xo=R((xr,Yo)=>{\"use strict\";c();xr.__esModule=!0;xr.default=wl;function wl(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(;n.length>0;){var i=n.shift();if(!e[i])return;e=e[i]}return e}Yo.exports=xr.default});var Jo=R((wr,Qo)=>{\"use strict\";c();wr.__esModule=!0;wr.default=_l;function _l(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(;n.length>0;){var i=n.shift();e[i]||(e[i]={}),e=e[i]}}Qo.exports=wr.default});var Zo=R((_r,Ko)=>{\"use strict\";c();_r.__esModule=!0;_r.default=Sl;function Sl(e){for(var t=\"\",n=e.indexOf(\"/*\"),r=0;n>=0;){t=t+e.slice(r,n);var i=e.indexOf(\"*/\",n+2);if(i<0)return t;r=i+2,n=e.indexOf(\"/*\",r)}return t=t+e.slice(r),t}Ko.exports=_r.default});var xt=R(Te=>{\"use strict\";c();Te.__esModule=!0;Te.stripComments=Te.ensureObject=Te.getProp=Te.unesc=void 0;var kl=Sr(En());Te.unesc=kl.default;var Tl=Sr(Xo());Te.getProp=Tl.default;var El=Sr(Jo());Te.ensureObject=El.default;var Ol=Sr(Zo());Te.stripComments=Ol.default;function Sr(e){return e&&e.__esModule?e:{default:e}}});var Ie=R((wt,ra)=>{\"use strict\";c();wt.__esModule=!0;wt.default=void 0;var ea=xt();function ta(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Pl(e,t,n){return t&&ta(e.prototype,t),n&&ta(e,n),e}var Al=function e(t,n){if(typeof t!=\"object\"||t===null)return t;var r=new t.constructor;for(var i in t)if(!!t.hasOwnProperty(i)){var a=t[i],o=typeof a;i===\"parent\"&&o===\"object\"?n&&(r[i]=n):a instanceof Array?r[i]=a.map(function(s){return e(s,r)}):r[i]=e(a,r)}return r},Il=function(){function e(n){n===void 0&&(n={}),Object.assign(this,n),this.spaces=this.spaces||{},this.spaces.before=this.spaces.before||\"\",this.spaces.after=this.spaces.after||\"\"}var t=e.prototype;return t.remove=function(){return this.parent&&this.parent.removeChild(this),this.parent=void 0,this},t.replaceWith=function(){if(this.parent){for(var r in arguments)this.parent.insertBefore(this,arguments[r]);this.remove()}return this},t.next=function(){return this.parent.at(this.parent.index(this)+1)},t.prev=function(){return this.parent.at(this.parent.index(this)-1)},t.clone=function(r){r===void 0&&(r={});var i=Al(this);for(var a in r)i[a]=r[a];return i},t.appendToPropertyAndEscape=function(r,i,a){this.raws||(this.raws={});var o=this[r],s=this.raws[r];this[r]=o+i,s||a!==i?this.raws[r]=(s||o)+a:delete this.raws[r]},t.setPropertyAndEscape=function(r,i,a){this.raws||(this.raws={}),this[r]=i,this.raws[r]=a},t.setPropertyWithoutEscape=function(r,i){this[r]=i,this.raws&&delete this.raws[r]},t.isAtPosition=function(r,i){if(this.source&&this.source.start&&this.source.end)return!(this.source.start.line>r||this.source.end.line<r||this.source.start.line===r&&this.source.start.column>i||this.source.end.line===r&&this.source.end.column<i)},t.stringifyProperty=function(r){return this.raws&&this.raws[r]||this[r]},t.valueToString=function(){return String(this.stringifyProperty(\"value\"))},t.toString=function(){return[this.rawSpaceBefore,this.valueToString(),this.rawSpaceAfter].join(\"\")},Pl(e,[{key:\"rawSpaceBefore\",get:function(){var r=this.raws&&this.raws.spaces&&this.raws.spaces.before;return r===void 0&&(r=this.spaces&&this.spaces.before),r||\"\"},set:function(r){(0,ea.ensureObject)(this,\"raws\",\"spaces\"),this.raws.spaces.before=r}},{key:\"rawSpaceAfter\",get:function(){var r=this.raws&&this.raws.spaces&&this.raws.spaces.after;return r===void 0&&(r=this.spaces.after),r||\"\"},set:function(r){(0,ea.ensureObject)(this,\"raws\",\"spaces\"),this.raws.spaces.after=r}}]),e}();wt.default=Il;ra.exports=wt.default});var ne=R(j=>{\"use strict\";c();j.__esModule=!0;j.UNIVERSAL=j.ATTRIBUTE=j.CLASS=j.COMBINATOR=j.COMMENT=j.ID=j.NESTING=j.PSEUDO=j.ROOT=j.SELECTOR=j.STRING=j.TAG=void 0;var Rl=\"tag\";j.TAG=Rl;var Ll=\"string\";j.STRING=Ll;var Cl=\"selector\";j.SELECTOR=Cl;var Dl=\"root\";j.ROOT=Dl;var Fl=\"pseudo\";j.PSEUDO=Fl;var Ml=\"nesting\";j.NESTING=Ml;var Nl=\"id\";j.ID=Nl;var Wl=\"comment\";j.COMMENT=Wl;var $l=\"combinator\";j.COMBINATOR=$l;var ql=\"class\";j.CLASS=ql;var Bl=\"attribute\";j.ATTRIBUTE=Bl;var Ul=\"universal\";j.UNIVERSAL=Ul});var kr=R((_t,aa)=>{\"use strict\";c();_t.__esModule=!0;_t.default=void 0;var zl=jl(Ie()),Re=Gl(ne());function oa(){if(typeof WeakMap!=\"function\")return null;var e=new WeakMap;return oa=function(){return e},e}function Gl(e){if(e&&e.__esModule)return e;if(e===null||typeof e!=\"object\"&&typeof e!=\"function\")return{default:e};var t=oa();if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=r?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(n,i,a):n[i]=e[i]}return n.default=e,t&&t.set(e,n),n}function jl(e){return e&&e.__esModule?e:{default:e}}function Vl(e,t){var n;if(typeof Symbol>\"u\"||e[Symbol.iterator]==null){if(Array.isArray(e)||(n=Hl(e))||t&&e&&typeof e.length==\"number\"){n&&(e=n);var r=0;return function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}return n=e[Symbol.iterator](),n.next.bind(n)}function Hl(e,t){if(!!e){if(typeof e==\"string\")return na(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n===\"Object\"&&e.constructor&&(n=e.constructor.name),n===\"Map\"||n===\"Set\")return Array.from(e);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return na(e,t)}}function na(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function ia(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Yl(e,t,n){return t&&ia(e.prototype,t),n&&ia(e,n),e}function Xl(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,On(e,t)}function On(e,t){return On=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},On(e,t)}var Ql=function(e){Xl(t,e);function t(r){var i;return i=e.call(this,r)||this,i.nodes||(i.nodes=[]),i}var n=t.prototype;return n.append=function(i){return i.parent=this,this.nodes.push(i),this},n.prepend=function(i){return i.parent=this,this.nodes.unshift(i),this},n.at=function(i){return this.nodes[i]},n.index=function(i){return typeof i==\"number\"?i:this.nodes.indexOf(i)},n.removeChild=function(i){i=this.index(i),this.at(i).parent=void 0,this.nodes.splice(i,1);var a;for(var o in this.indexes)a=this.indexes[o],a>=i&&(this.indexes[o]=a-1);return this},n.removeAll=function(){for(var i=Vl(this.nodes),a;!(a=i()).done;){var o=a.value;o.parent=void 0}return this.nodes=[],this},n.empty=function(){return this.removeAll()},n.insertAfter=function(i,a){a.parent=this;var o=this.index(i);this.nodes.splice(o+1,0,a),a.parent=this;var s;for(var u in this.indexes)s=this.indexes[u],o<=s&&(this.indexes[u]=s+1);return this},n.insertBefore=function(i,a){a.parent=this;var o=this.index(i);this.nodes.splice(o,0,a),a.parent=this;var s;for(var u in this.indexes)s=this.indexes[u],s<=o&&(this.indexes[u]=s+1);return this},n._findChildAtPosition=function(i,a){var o=void 0;return this.each(function(s){if(s.atPosition){var u=s.atPosition(i,a);if(u)return o=u,!1}else if(s.isAtPosition(i,a))return o=s,!1}),o},n.atPosition=function(i,a){if(this.isAtPosition(i,a))return this._findChildAtPosition(i,a)||this},n._inferEndPosition=function(){this.last&&this.last.source&&this.last.source.end&&(this.source=this.source||{},this.source.end=this.source.end||{},Object.assign(this.source.end,this.last.source.end))},n.each=function(i){this.lastEach||(this.lastEach=0),this.indexes||(this.indexes={}),this.lastEach++;var a=this.lastEach;if(this.indexes[a]=0,!!this.length){for(var o,s;this.indexes[a]<this.length&&(o=this.indexes[a],s=i(this.at(o),o),s!==!1);)this.indexes[a]+=1;if(delete this.indexes[a],s===!1)return!1}},n.walk=function(i){return this.each(function(a,o){var s=i(a,o);if(s!==!1&&a.length&&(s=a.walk(i)),s===!1)return!1})},n.walkAttributes=function(i){var a=this;return this.walk(function(o){if(o.type===Re.ATTRIBUTE)return i.call(a,o)})},n.walkClasses=function(i){var a=this;return this.walk(function(o){if(o.type===Re.CLASS)return i.call(a,o)})},n.walkCombinators=function(i){var a=this;return this.walk(function(o){if(o.type===Re.COMBINATOR)return i.call(a,o)})},n.walkComments=function(i){var a=this;return this.walk(function(o){if(o.type===Re.COMMENT)return i.call(a,o)})},n.walkIds=function(i){var a=this;return this.walk(function(o){if(o.type===Re.ID)return i.call(a,o)})},n.walkNesting=function(i){var a=this;return this.walk(function(o){if(o.type===Re.NESTING)return i.call(a,o)})},n.walkPseudos=function(i){var a=this;return this.walk(function(o){if(o.type===Re.PSEUDO)return i.call(a,o)})},n.walkTags=function(i){var a=this;return this.walk(function(o){if(o.type===Re.TAG)return i.call(a,o)})},n.walkUniversals=function(i){var a=this;return this.walk(function(o){if(o.type===Re.UNIVERSAL)return i.call(a,o)})},n.split=function(i){var a=this,o=[];return this.reduce(function(s,u,l){var f=i.call(a,u);return o.push(u),f?(s.push(o),o=[]):l===a.length-1&&s.push(o),s},[])},n.map=function(i){return this.nodes.map(i)},n.reduce=function(i,a){return this.nodes.reduce(i,a)},n.every=function(i){return this.nodes.every(i)},n.some=function(i){return this.nodes.some(i)},n.filter=function(i){return this.nodes.filter(i)},n.sort=function(i){return this.nodes.sort(i)},n.toString=function(){return this.map(String).join(\"\")},Yl(t,[{key:\"first\",get:function(){return this.at(0)}},{key:\"last\",get:function(){return this.at(this.length-1)}},{key:\"length\",get:function(){return this.nodes.length}}]),t}(zl.default);_t.default=Ql;aa.exports=_t.default});var An=R((St,ua)=>{\"use strict\";c();St.__esModule=!0;St.default=void 0;var Jl=Zl(kr()),Kl=ne();function Zl(e){return e&&e.__esModule?e:{default:e}}function sa(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function ef(e,t,n){return t&&sa(e.prototype,t),n&&sa(e,n),e}function tf(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Pn(e,t)}function Pn(e,t){return Pn=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},Pn(e,t)}var rf=function(e){tf(t,e);function t(r){var i;return i=e.call(this,r)||this,i.type=Kl.ROOT,i}var n=t.prototype;return n.toString=function(){var i=this.reduce(function(a,o){return a.push(String(o)),a},[]).join(\",\");return this.trailingComma?i+\",\":i},n.error=function(i,a){return this._error?this._error(i,a):new Error(i)},ef(t,[{key:\"errorGenerator\",set:function(i){this._error=i}}]),t}(Jl.default);St.default=rf;ua.exports=St.default});var Rn=R((kt,la)=>{\"use strict\";c();kt.__esModule=!0;kt.default=void 0;var nf=af(kr()),of=ne();function af(e){return e&&e.__esModule?e:{default:e}}function sf(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,In(e,t)}function In(e,t){return In=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},In(e,t)}var uf=function(e){sf(t,e);function t(n){var r;return r=e.call(this,n)||this,r.type=of.SELECTOR,r}return t}(nf.default);kt.default=uf;la.exports=kt.default});var Tr=R((rg,fa)=>{\"use strict\";c();var lf={},ff=lf.hasOwnProperty,cf=function(t,n){if(!t)return n;var r={};for(var i in n)r[i]=ff.call(t,i)?t[i]:n[i];return r},df=/[ -,\\.\\/:-@\\[-\\^`\\{-~]/,pf=/[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/,hf=/(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g,Ln=function e(t,n){n=cf(n,e.options),n.quotes!=\"single\"&&n.quotes!=\"double\"&&(n.quotes=\"single\");for(var r=n.quotes==\"double\"?'\"':\"'\",i=n.isIdentifier,a=t.charAt(0),o=\"\",s=0,u=t.length;s<u;){var l=t.charAt(s++),f=l.charCodeAt(),p=void 0;if(f<32||f>126){if(f>=55296&&f<=56319&&s<u){var g=t.charCodeAt(s++);(g&64512)==56320?f=((f&1023)<<10)+(g&1023)+65536:s--}p=\"\\\\\"+f.toString(16).toUpperCase()+\" \"}else n.escapeEverything?df.test(l)?p=\"\\\\\"+l:p=\"\\\\\"+f.toString(16).toUpperCase()+\" \":/[\\t\\n\\f\\r\\x0B]/.test(l)?p=\"\\\\\"+f.toString(16).toUpperCase()+\" \":l==\"\\\\\"||!i&&(l=='\"'&&r==l||l==\"'\"&&r==l)||i&&pf.test(l)?p=\"\\\\\"+l:p=l;o+=p}return i&&(/^-[-\\d]/.test(o)?o=\"\\\\-\"+o.slice(1):/\\d/.test(a)&&(o=\"\\\\3\"+a+\" \"+o.slice(1))),o=o.replace(hf,function(m,d,h){return d&&d.length%2?m:(d||\"\")+h}),!i&&n.wrap?r+o+r:o};Ln.options={escapeEverything:!1,isIdentifier:!1,quotes:\"single\",wrap:!1};Ln.version=\"3.0.0\";fa.exports=Ln});var Dn=R((Tt,pa)=>{\"use strict\";c();Tt.__esModule=!0;Tt.default=void 0;var mf=da(Tr()),gf=xt(),vf=da(Ie()),bf=ne();function da(e){return e&&e.__esModule?e:{default:e}}function ca(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function yf(e,t,n){return t&&ca(e.prototype,t),n&&ca(e,n),e}function xf(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Cn(e,t)}function Cn(e,t){return Cn=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},Cn(e,t)}var wf=function(e){xf(t,e);function t(r){var i;return i=e.call(this,r)||this,i.type=bf.CLASS,i._constructed=!0,i}var n=t.prototype;return n.valueToString=function(){return\".\"+e.prototype.valueToString.call(this)},yf(t,[{key:\"value\",get:function(){return this._value},set:function(i){if(this._constructed){var a=(0,mf.default)(i,{isIdentifier:!0});a!==i?((0,gf.ensureObject)(this,\"raws\"),this.raws.value=a):this.raws&&delete this.raws.value}this._value=i}}]),t}(vf.default);Tt.default=wf;pa.exports=Tt.default});var Mn=R((Et,ha)=>{\"use strict\";c();Et.__esModule=!0;Et.default=void 0;var _f=kf(Ie()),Sf=ne();function kf(e){return e&&e.__esModule?e:{default:e}}function Tf(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Fn(e,t)}function Fn(e,t){return Fn=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},Fn(e,t)}var Ef=function(e){Tf(t,e);function t(n){var r;return r=e.call(this,n)||this,r.type=Sf.COMMENT,r}return t}(_f.default);Et.default=Ef;ha.exports=Et.default});var Wn=R((Ot,ma)=>{\"use strict\";c();Ot.__esModule=!0;Ot.default=void 0;var Of=Af(Ie()),Pf=ne();function Af(e){return e&&e.__esModule?e:{default:e}}function If(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Nn(e,t)}function Nn(e,t){return Nn=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},Nn(e,t)}var Rf=function(e){If(t,e);function t(r){var i;return i=e.call(this,r)||this,i.type=Pf.ID,i}var n=t.prototype;return n.valueToString=function(){return\"#\"+e.prototype.valueToString.call(this)},t}(Of.default);Ot.default=Rf;ma.exports=Ot.default});var Er=R((Pt,ba)=>{\"use strict\";c();Pt.__esModule=!0;Pt.default=void 0;var Lf=va(Tr()),Cf=xt(),Df=va(Ie());function va(e){return e&&e.__esModule?e:{default:e}}function ga(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Ff(e,t,n){return t&&ga(e.prototype,t),n&&ga(e,n),e}function Mf(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,$n(e,t)}function $n(e,t){return $n=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},$n(e,t)}var Nf=function(e){Mf(t,e);function t(){return e.apply(this,arguments)||this}var n=t.prototype;return n.qualifiedName=function(i){return this.namespace?this.namespaceString+\"|\"+i:i},n.valueToString=function(){return this.qualifiedName(e.prototype.valueToString.call(this))},Ff(t,[{key:\"namespace\",get:function(){return this._namespace},set:function(i){if(i===!0||i===\"*\"||i===\"&\"){this._namespace=i,this.raws&&delete this.raws.namespace;return}var a=(0,Lf.default)(i,{isIdentifier:!0});this._namespace=i,a!==i?((0,Cf.ensureObject)(this,\"raws\"),this.raws.namespace=a):this.raws&&delete this.raws.namespace}},{key:\"ns\",get:function(){return this._namespace},set:function(i){this.namespace=i}},{key:\"namespaceString\",get:function(){if(this.namespace){var i=this.stringifyProperty(\"namespace\");return i===!0?\"\":i}else return\"\"}}]),t}(Df.default);Pt.default=Nf;ba.exports=Pt.default});var Bn=R((At,ya)=>{\"use strict\";c();At.__esModule=!0;At.default=void 0;var Wf=qf(Er()),$f=ne();function qf(e){return e&&e.__esModule?e:{default:e}}function Bf(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,qn(e,t)}function qn(e,t){return qn=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},qn(e,t)}var Uf=function(e){Bf(t,e);function t(n){var r;return r=e.call(this,n)||this,r.type=$f.TAG,r}return t}(Wf.default);At.default=Uf;ya.exports=At.default});var zn=R((It,xa)=>{\"use strict\";c();It.__esModule=!0;It.default=void 0;var zf=jf(Ie()),Gf=ne();function jf(e){return e&&e.__esModule?e:{default:e}}function Vf(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Un(e,t)}function Un(e,t){return Un=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},Un(e,t)}var Hf=function(e){Vf(t,e);function t(n){var r;return r=e.call(this,n)||this,r.type=Gf.STRING,r}return t}(zf.default);It.default=Hf;xa.exports=It.default});var jn=R((Rt,wa)=>{\"use strict\";c();Rt.__esModule=!0;Rt.default=void 0;var Yf=Qf(kr()),Xf=ne();function Qf(e){return e&&e.__esModule?e:{default:e}}function Jf(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Gn(e,t)}function Gn(e,t){return Gn=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},Gn(e,t)}var Kf=function(e){Jf(t,e);function t(r){var i;return i=e.call(this,r)||this,i.type=Xf.PSEUDO,i}var n=t.prototype;return n.toString=function(){var i=this.length?\"(\"+this.map(String).join(\",\")+\")\":\"\";return[this.rawSpaceBefore,this.stringifyProperty(\"value\"),i,this.rawSpaceAfter].join(\"\")},t}(Yf.default);Rt.default=Kf;wa.exports=Rt.default});var Sa=R((ng,_a)=>{c();_a.exports=function(t,n){return function(...r){return console.warn(n),t(...r)}}});var Jn=R(Dt=>{\"use strict\";c();Dt.__esModule=!0;Dt.unescapeValue=Qn;Dt.default=void 0;var Lt=Xn(Tr()),Zf=Xn(En()),ec=Xn(Er()),tc=ne(),Vn;function Xn(e){return e&&e.__esModule?e:{default:e}}function ka(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function rc(e,t,n){return t&&ka(e.prototype,t),n&&ka(e,n),e}function nc(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Yn(e,t)}function Yn(e,t){return Yn=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},Yn(e,t)}var Ct=Sa(),ic=/^('|\")([^]*)\\1$/,oc=Ct(function(){},\"Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.\"),ac=Ct(function(){},\"Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.\"),sc=Ct(function(){},\"Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.\");function Qn(e){var t=!1,n=null,r=e,i=r.match(ic);return i&&(n=i[1],r=i[2]),r=(0,Zf.default)(r),r!==e&&(t=!0),{deprecatedUsage:t,unescaped:r,quoteMark:n}}function uc(e){if(e.quoteMark!==void 0||e.value===void 0)return e;sc();var t=Qn(e.value),n=t.quoteMark,r=t.unescaped;return e.raws||(e.raws={}),e.raws.value===void 0&&(e.raws.value=e.value),e.value=r,e.quoteMark=n,e}var Or=function(e){nc(t,e);function t(r){var i;return r===void 0&&(r={}),i=e.call(this,uc(r))||this,i.type=tc.ATTRIBUTE,i.raws=i.raws||{},Object.defineProperty(i.raws,\"unquoted\",{get:Ct(function(){return i.value},\"attr.raws.unquoted is deprecated. Call attr.value instead.\"),set:Ct(function(){return i.value},\"Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.\")}),i._constructed=!0,i}var n=t.prototype;return n.getQuotedValue=function(i){i===void 0&&(i={});var a=this._determineQuoteMark(i),o=Hn[a],s=(0,Lt.default)(this._value,o);return s},n._determineQuoteMark=function(i){return i.smart?this.smartQuoteMark(i):this.preferredQuoteMark(i)},n.setValue=function(i,a){a===void 0&&(a={}),this._value=i,this._quoteMark=this._determineQuoteMark(a),this._syncRawValue()},n.smartQuoteMark=function(i){var a=this.value,o=a.replace(/[^']/g,\"\").length,s=a.replace(/[^\"]/g,\"\").length;if(o+s===0){var u=(0,Lt.default)(a,{isIdentifier:!0});if(u===a)return t.NO_QUOTE;var l=this.preferredQuoteMark(i);if(l===t.NO_QUOTE){var f=this.quoteMark||i.quoteMark||t.DOUBLE_QUOTE,p=Hn[f],g=(0,Lt.default)(a,p);if(g.length<u.length)return f}return l}else return s===o?this.preferredQuoteMark(i):s<o?t.DOUBLE_QUOTE:t.SINGLE_QUOTE},n.preferredQuoteMark=function(i){var a=i.preferCurrentQuoteMark?this.quoteMark:i.quoteMark;return a===void 0&&(a=i.preferCurrentQuoteMark?i.quoteMark:this.quoteMark),a===void 0&&(a=t.DOUBLE_QUOTE),a},n._syncRawValue=function(){var i=(0,Lt.default)(this._value,Hn[this.quoteMark]);i===this._value?this.raws&&delete this.raws.value:this.raws.value=i},n._handleEscapes=function(i,a){if(this._constructed){var o=(0,Lt.default)(a,{isIdentifier:!0});o!==a?this.raws[i]=o:delete this.raws[i]}},n._spacesFor=function(i){var a={before:\"\",after:\"\"},o=this.spaces[i]||{},s=this.raws.spaces&&this.raws.spaces[i]||{};return Object.assign(a,o,s)},n._stringFor=function(i,a,o){a===void 0&&(a=i),o===void 0&&(o=Ta);var s=this._spacesFor(a);return o(this.stringifyProperty(i),s)},n.offsetOf=function(i){var a=1,o=this._spacesFor(\"attribute\");if(a+=o.before.length,i===\"namespace\"||i===\"ns\")return this.namespace?a:-1;if(i===\"attributeNS\"||(a+=this.namespaceString.length,this.namespace&&(a+=1),i===\"attribute\"))return a;a+=this.stringifyProperty(\"attribute\").length,a+=o.after.length;var s=this._spacesFor(\"operator\");a+=s.before.length;var u=this.stringifyProperty(\"operator\");if(i===\"operator\")return u?a:-1;a+=u.length,a+=s.after.length;var l=this._spacesFor(\"value\");a+=l.before.length;var f=this.stringifyProperty(\"value\");if(i===\"value\")return f?a:-1;a+=f.length,a+=l.after.length;var p=this._spacesFor(\"insensitive\");return a+=p.before.length,i===\"insensitive\"&&this.insensitive?a:-1},n.toString=function(){var i=this,a=[this.rawSpaceBefore,\"[\"];return a.push(this._stringFor(\"qualifiedAttribute\",\"attribute\")),this.operator&&(this.value||this.value===\"\")&&(a.push(this._stringFor(\"operator\")),a.push(this._stringFor(\"value\")),a.push(this._stringFor(\"insensitiveFlag\",\"insensitive\",function(o,s){return o.length>0&&!i.quoted&&s.before.length===0&&!(i.spaces.value&&i.spaces.value.after)&&(s.before=\" \"),Ta(o,s)}))),a.push(\"]\"),a.push(this.rawSpaceAfter),a.join(\"\")},rc(t,[{key:\"quoted\",get:function(){var i=this.quoteMark;return i===\"'\"||i==='\"'},set:function(i){ac()}},{key:\"quoteMark\",get:function(){return this._quoteMark},set:function(i){if(!this._constructed){this._quoteMark=i;return}this._quoteMark!==i&&(this._quoteMark=i,this._syncRawValue())}},{key:\"qualifiedAttribute\",get:function(){return this.qualifiedName(this.raws.attribute||this.attribute)}},{key:\"insensitiveFlag\",get:function(){return this.insensitive?\"i\":\"\"}},{key:\"value\",get:function(){return this._value},set:function(i){if(this._constructed){var a=Qn(i),o=a.deprecatedUsage,s=a.unescaped,u=a.quoteMark;if(o&&oc(),s===this._value&&u===this._quoteMark)return;this._value=s,this._quoteMark=u,this._syncRawValue()}else this._value=i}},{key:\"attribute\",get:function(){return this._attribute},set:function(i){this._handleEscapes(\"attribute\",i),this._attribute=i}}]),t}(ec.default);Dt.default=Or;Or.NO_QUOTE=null;Or.SINGLE_QUOTE=\"'\";Or.DOUBLE_QUOTE='\"';var Hn=(Vn={\"'\":{quotes:\"single\",wrap:!0},'\"':{quotes:\"double\",wrap:!0}},Vn[null]={isIdentifier:!0},Vn);function Ta(e,t){return\"\"+t.before+e+t.after}});var Zn=R((Ft,Ea)=>{\"use strict\";c();Ft.__esModule=!0;Ft.default=void 0;var lc=cc(Er()),fc=ne();function cc(e){return e&&e.__esModule?e:{default:e}}function dc(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Kn(e,t)}function Kn(e,t){return Kn=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},Kn(e,t)}var pc=function(e){dc(t,e);function t(n){var r;return r=e.call(this,n)||this,r.type=fc.UNIVERSAL,r.value=\"*\",r}return t}(lc.default);Ft.default=pc;Ea.exports=Ft.default});var ti=R((Mt,Oa)=>{\"use strict\";c();Mt.__esModule=!0;Mt.default=void 0;var hc=gc(Ie()),mc=ne();function gc(e){return e&&e.__esModule?e:{default:e}}function vc(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,ei(e,t)}function ei(e,t){return ei=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},ei(e,t)}var bc=function(e){vc(t,e);function t(n){var r;return r=e.call(this,n)||this,r.type=mc.COMBINATOR,r}return t}(hc.default);Mt.default=bc;Oa.exports=Mt.default});var ni=R((Nt,Pa)=>{\"use strict\";c();Nt.__esModule=!0;Nt.default=void 0;var yc=wc(Ie()),xc=ne();function wc(e){return e&&e.__esModule?e:{default:e}}function _c(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,ri(e,t)}function ri(e,t){return ri=Object.setPrototypeOf||function(r,i){return r.__proto__=i,r},ri(e,t)}var Sc=function(e){_c(t,e);function t(n){var r;return r=e.call(this,n)||this,r.type=xc.NESTING,r.value=\"&\",r}return t}(yc.default);Nt.default=Sc;Pa.exports=Nt.default});var Ia=R((Pr,Aa)=>{\"use strict\";c();Pr.__esModule=!0;Pr.default=kc;function kc(e){return e.sort(function(t,n){return t-n})}Aa.exports=Pr.default});var ii=R(O=>{\"use strict\";c();O.__esModule=!0;O.combinator=O.word=O.comment=O.str=O.tab=O.newline=O.feed=O.cr=O.backslash=O.bang=O.slash=O.doubleQuote=O.singleQuote=O.space=O.greaterThan=O.pipe=O.equals=O.plus=O.caret=O.tilde=O.dollar=O.closeSquare=O.openSquare=O.closeParenthesis=O.openParenthesis=O.semicolon=O.colon=O.comma=O.at=O.asterisk=O.ampersand=void 0;var Tc=38;O.ampersand=Tc;var Ec=42;O.asterisk=Ec;var Oc=64;O.at=Oc;var Pc=44;O.comma=Pc;var Ac=58;O.colon=Ac;var Ic=59;O.semicolon=Ic;var Rc=40;O.openParenthesis=Rc;var Lc=41;O.closeParenthesis=Lc;var Cc=91;O.openSquare=Cc;var Dc=93;O.closeSquare=Dc;var Fc=36;O.dollar=Fc;var Mc=126;O.tilde=Mc;var Nc=94;O.caret=Nc;var Wc=43;O.plus=Wc;var $c=61;O.equals=$c;var qc=124;O.pipe=qc;var Bc=62;O.greaterThan=Bc;var Uc=32;O.space=Uc;var Ra=39;O.singleQuote=Ra;var zc=34;O.doubleQuote=zc;var Gc=47;O.slash=Gc;var jc=33;O.bang=jc;var Vc=92;O.backslash=Vc;var Hc=13;O.cr=Hc;var Yc=12;O.feed=Yc;var Xc=10;O.newline=Xc;var Qc=9;O.tab=Qc;var Jc=Ra;O.str=Jc;var Kc=-1;O.comment=Kc;var Zc=-2;O.word=Zc;var ed=-3;O.combinator=ed});var Da=R(Wt=>{\"use strict\";c();Wt.__esModule=!0;Wt.default=sd;Wt.FIELDS=void 0;var k=td(ii()),it,G;function Ca(){if(typeof WeakMap!=\"function\")return null;var e=new WeakMap;return Ca=function(){return e},e}function td(e){if(e&&e.__esModule)return e;if(e===null||typeof e!=\"object\"&&typeof e!=\"function\")return{default:e};var t=Ca();if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=r?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(n,i,a):n[i]=e[i]}return n.default=e,t&&t.set(e,n),n}var rd=(it={},it[k.tab]=!0,it[k.newline]=!0,it[k.cr]=!0,it[k.feed]=!0,it),nd=(G={},G[k.space]=!0,G[k.tab]=!0,G[k.newline]=!0,G[k.cr]=!0,G[k.feed]=!0,G[k.ampersand]=!0,G[k.asterisk]=!0,G[k.bang]=!0,G[k.comma]=!0,G[k.colon]=!0,G[k.semicolon]=!0,G[k.openParenthesis]=!0,G[k.closeParenthesis]=!0,G[k.openSquare]=!0,G[k.closeSquare]=!0,G[k.singleQuote]=!0,G[k.doubleQuote]=!0,G[k.plus]=!0,G[k.pipe]=!0,G[k.tilde]=!0,G[k.greaterThan]=!0,G[k.equals]=!0,G[k.dollar]=!0,G[k.caret]=!0,G[k.slash]=!0,G),oi={},La=\"0123456789abcdefABCDEF\";for(Ar=0;Ar<La.length;Ar++)oi[La.charCodeAt(Ar)]=!0;var Ar;function id(e,t){var n=t,r;do{if(r=e.charCodeAt(n),nd[r])return n-1;r===k.backslash?n=od(e,n)+1:n++}while(n<e.length);return n-1}function od(e,t){var n=t,r=e.charCodeAt(n+1);if(!rd[r])if(oi[r]){var i=0;do n++,i++,r=e.charCodeAt(n+1);while(oi[r]&&i<6);i<6&&r===k.space&&n++}else n++;return n}var ad={TYPE:0,START_LINE:1,START_COL:2,END_LINE:3,END_COL:4,START_POS:5,END_POS:6};Wt.FIELDS=ad;function sd(e){var t=[],n=e.css.valueOf(),r=n,i=r.length,a=-1,o=1,s=0,u=0,l,f,p,g,m,d,h,w,b,_,E,A,D;function M(L,F){if(e.safe)n+=F,b=n.length-1;else throw e.error(\"Unclosed \"+L,o,s-a,s)}for(;s<i;){switch(l=n.charCodeAt(s),l===k.newline&&(a=s,o+=1),l){case k.space:case k.tab:case k.newline:case k.cr:case k.feed:b=s;do b+=1,l=n.charCodeAt(b),l===k.newline&&(a=b,o+=1);while(l===k.space||l===k.newline||l===k.tab||l===k.cr||l===k.feed);D=k.space,g=o,p=b-a-1,u=b;break;case k.plus:case k.greaterThan:case k.tilde:case k.pipe:b=s;do b+=1,l=n.charCodeAt(b);while(l===k.plus||l===k.greaterThan||l===k.tilde||l===k.pipe);D=k.combinator,g=o,p=s-a,u=b;break;case k.asterisk:case k.ampersand:case k.bang:case k.comma:case k.equals:case k.dollar:case k.caret:case k.openSquare:case k.closeSquare:case k.colon:case k.semicolon:case k.openParenthesis:case k.closeParenthesis:b=s,D=l,g=o,p=s-a,u=b+1;break;case k.singleQuote:case k.doubleQuote:A=l===k.singleQuote?\"'\":'\"',b=s;do for(m=!1,b=n.indexOf(A,b+1),b===-1&&M(\"quote\",A),d=b;n.charCodeAt(d-1)===k.backslash;)d-=1,m=!m;while(m);D=k.str,g=o,p=s-a,u=b+1;break;default:l===k.slash&&n.charCodeAt(s+1)===k.asterisk?(b=n.indexOf(\"*/\",s+2)+1,b===0&&M(\"comment\",\"*/\"),f=n.slice(s,b+1),w=f.split(`\n`),h=w.length-1,h>0?(_=o+h,E=b-w[h].length):(_=o,E=a),D=k.comment,o=_,g=_,p=b-E):l===k.slash?(b=s,D=l,g=o,p=s-a,u=b+1):(b=id(n,s),D=k.word,g=o,p=b-a),u=b+1;break}t.push([D,o,s-a,g,p,s,u]),E&&(a=E,E=null),s=u}return t}});var Ua=R(($t,Ba)=>{\"use strict\";c();$t.__esModule=!0;$t.default=void 0;var ud=be(An()),ai=be(Rn()),ld=be(Dn()),Fa=be(Mn()),fd=be(Wn()),cd=be(Bn()),si=be(zn()),dd=be(jn()),Ma=Ir(Jn()),pd=be(Zn()),ui=be(ti()),hd=be(ni()),md=be(Ia()),S=Ir(Da()),T=Ir(ii()),gd=Ir(ne()),Q=xt(),Xe,li;function qa(){if(typeof WeakMap!=\"function\")return null;var e=new WeakMap;return qa=function(){return e},e}function Ir(e){if(e&&e.__esModule)return e;if(e===null||typeof e!=\"object\"&&typeof e!=\"function\")return{default:e};var t=qa();if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=r?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(n,i,a):n[i]=e[i]}return n.default=e,t&&t.set(e,n),n}function be(e){return e&&e.__esModule?e:{default:e}}function Na(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function vd(e,t,n){return t&&Na(e.prototype,t),n&&Na(e,n),e}var di=(Xe={},Xe[T.space]=!0,Xe[T.cr]=!0,Xe[T.feed]=!0,Xe[T.newline]=!0,Xe[T.tab]=!0,Xe),bd=Object.assign({},di,(li={},li[T.comment]=!0,li));function Wa(e){return{line:e[S.FIELDS.START_LINE],column:e[S.FIELDS.START_COL]}}function $a(e){return{line:e[S.FIELDS.END_LINE],column:e[S.FIELDS.END_COL]}}function Qe(e,t,n,r){return{start:{line:e,column:t},end:{line:n,column:r}}}function ot(e){return Qe(e[S.FIELDS.START_LINE],e[S.FIELDS.START_COL],e[S.FIELDS.END_LINE],e[S.FIELDS.END_COL])}function fi(e,t){if(!!e)return Qe(e[S.FIELDS.START_LINE],e[S.FIELDS.START_COL],t[S.FIELDS.END_LINE],t[S.FIELDS.END_COL])}function at(e,t){var n=e[t];if(typeof n==\"string\")return n.indexOf(\"\\\\\")!==-1&&((0,Q.ensureObject)(e,\"raws\"),e[t]=(0,Q.unesc)(n),e.raws[t]===void 0&&(e.raws[t]=n)),e}function ci(e,t){for(var n=-1,r=[];(n=e.indexOf(t,n+1))!==-1;)r.push(n);return r}function yd(){var e=Array.prototype.concat.apply([],arguments);return e.filter(function(t,n){return n===e.indexOf(t)})}var xd=function(){function e(n,r){r===void 0&&(r={}),this.rule=n,this.options=Object.assign({lossy:!1,safe:!1},r),this.position=0,this.css=typeof this.rule==\"string\"?this.rule:this.rule.selector,this.tokens=(0,S.default)({css:this.css,error:this._errorGenerator(),safe:this.options.safe});var i=fi(this.tokens[0],this.tokens[this.tokens.length-1]);this.root=new ud.default({source:i}),this.root.errorGenerator=this._errorGenerator();var a=new ai.default({source:{start:{line:1,column:1}}});this.root.append(a),this.current=a,this.loop()}var t=e.prototype;return t._errorGenerator=function(){var r=this;return function(i,a){return typeof r.rule==\"string\"?new Error(i):r.rule.error(i,a)}},t.attribute=function(){var r=[],i=this.currToken;for(this.position++;this.position<this.tokens.length&&this.currToken[S.FIELDS.TYPE]!==T.closeSquare;)r.push(this.currToken),this.position++;if(this.currToken[S.FIELDS.TYPE]!==T.closeSquare)return this.expected(\"closing square bracket\",this.currToken[S.FIELDS.START_POS]);var a=r.length,o={source:Qe(i[1],i[2],this.currToken[3],this.currToken[4]),sourceIndex:i[S.FIELDS.START_POS]};if(a===1&&!~[T.word].indexOf(r[0][S.FIELDS.TYPE]))return this.expected(\"attribute\",r[0][S.FIELDS.START_POS]);for(var s=0,u=\"\",l=\"\",f=null,p=!1;s<a;){var g=r[s],m=this.content(g),d=r[s+1];switch(g[S.FIELDS.TYPE]){case T.space:if(p=!0,this.options.lossy)break;if(f){(0,Q.ensureObject)(o,\"spaces\",f);var h=o.spaces[f].after||\"\";o.spaces[f].after=h+m;var w=(0,Q.getProp)(o,\"raws\",\"spaces\",f,\"after\")||null;w&&(o.raws.spaces[f].after=w+m)}else u=u+m,l=l+m;break;case T.asterisk:if(d[S.FIELDS.TYPE]===T.equals)o.operator=m,f=\"operator\";else if((!o.namespace||f===\"namespace\"&&!p)&&d){u&&((0,Q.ensureObject)(o,\"spaces\",\"attribute\"),o.spaces.attribute.before=u,u=\"\"),l&&((0,Q.ensureObject)(o,\"raws\",\"spaces\",\"attribute\"),o.raws.spaces.attribute.before=u,l=\"\"),o.namespace=(o.namespace||\"\")+m;var b=(0,Q.getProp)(o,\"raws\",\"namespace\")||null;b&&(o.raws.namespace+=m),f=\"namespace\"}p=!1;break;case T.dollar:if(f===\"value\"){var _=(0,Q.getProp)(o,\"raws\",\"value\");o.value+=\"$\",_&&(o.raws.value=_+\"$\");break}case T.caret:d[S.FIELDS.TYPE]===T.equals&&(o.operator=m,f=\"operator\"),p=!1;break;case T.combinator:if(m===\"~\"&&d[S.FIELDS.TYPE]===T.equals&&(o.operator=m,f=\"operator\"),m!==\"|\"){p=!1;break}d[S.FIELDS.TYPE]===T.equals?(o.operator=m,f=\"operator\"):!o.namespace&&!o.attribute&&(o.namespace=!0),p=!1;break;case T.word:if(d&&this.content(d)===\"|\"&&r[s+2]&&r[s+2][S.FIELDS.TYPE]!==T.equals&&!o.operator&&!o.namespace)o.namespace=m,f=\"namespace\";else if(!o.attribute||f===\"attribute\"&&!p){u&&((0,Q.ensureObject)(o,\"spaces\",\"attribute\"),o.spaces.attribute.before=u,u=\"\"),l&&((0,Q.ensureObject)(o,\"raws\",\"spaces\",\"attribute\"),o.raws.spaces.attribute.before=l,l=\"\"),o.attribute=(o.attribute||\"\")+m;var E=(0,Q.getProp)(o,\"raws\",\"attribute\")||null;E&&(o.raws.attribute+=m),f=\"attribute\"}else if(!o.value&&o.value!==\"\"||f===\"value\"&&!p){var A=(0,Q.unesc)(m),D=(0,Q.getProp)(o,\"raws\",\"value\")||\"\",M=o.value||\"\";o.value=M+A,o.quoteMark=null,(A!==m||D)&&((0,Q.ensureObject)(o,\"raws\"),o.raws.value=(D||M)+m),f=\"value\"}else{var L=m===\"i\"||m===\"I\";(o.value||o.value===\"\")&&(o.quoteMark||p)?(o.insensitive=L,(!L||m===\"I\")&&((0,Q.ensureObject)(o,\"raws\"),o.raws.insensitiveFlag=m),f=\"insensitive\",u&&((0,Q.ensureObject)(o,\"spaces\",\"insensitive\"),o.spaces.insensitive.before=u,u=\"\"),l&&((0,Q.ensureObject)(o,\"raws\",\"spaces\",\"insensitive\"),o.raws.spaces.insensitive.before=l,l=\"\")):(o.value||o.value===\"\")&&(f=\"value\",o.value+=m,o.raws.value&&(o.raws.value+=m))}p=!1;break;case T.str:if(!o.attribute||!o.operator)return this.error(\"Expected an attribute followed by an operator preceding the string.\",{index:g[S.FIELDS.START_POS]});var F=(0,Ma.unescapeValue)(m),N=F.unescaped,U=F.quoteMark;o.value=N,o.quoteMark=U,f=\"value\",(0,Q.ensureObject)(o,\"raws\"),o.raws.value=m,p=!1;break;case T.equals:if(!o.attribute)return this.expected(\"attribute\",g[S.FIELDS.START_POS],m);if(o.value)return this.error('Unexpected \"=\" found; an operator was already defined.',{index:g[S.FIELDS.START_POS]});o.operator=o.operator?o.operator+m:m,f=\"operator\",p=!1;break;case T.comment:if(f)if(p||d&&d[S.FIELDS.TYPE]===T.space||f===\"insensitive\"){var q=(0,Q.getProp)(o,\"spaces\",f,\"after\")||\"\",K=(0,Q.getProp)(o,\"raws\",\"spaces\",f,\"after\")||q;(0,Q.ensureObject)(o,\"raws\",\"spaces\",f),o.raws.spaces[f].after=K+m}else{var ee=o[f]||\"\",z=(0,Q.getProp)(o,\"raws\",f)||ee;(0,Q.ensureObject)(o,\"raws\"),o.raws[f]=z+m}else l=l+m;break;default:return this.error('Unexpected \"'+m+'\" found.',{index:g[S.FIELDS.START_POS]})}s++}at(o,\"attribute\"),at(o,\"namespace\"),this.newNode(new Ma.default(o)),this.position++},t.parseWhitespaceEquivalentTokens=function(r){r<0&&(r=this.tokens.length);var i=this.position,a=[],o=\"\",s=void 0;do if(di[this.currToken[S.FIELDS.TYPE]])this.options.lossy||(o+=this.content());else if(this.currToken[S.FIELDS.TYPE]===T.comment){var u={};o&&(u.before=o,o=\"\"),s=new Fa.default({value:this.content(),source:ot(this.currToken),sourceIndex:this.currToken[S.FIELDS.START_POS],spaces:u}),a.push(s)}while(++this.position<r);if(o){if(s)s.spaces.after=o;else if(!this.options.lossy){var l=this.tokens[i],f=this.tokens[this.position-1];a.push(new si.default({value:\"\",source:Qe(l[S.FIELDS.START_LINE],l[S.FIELDS.START_COL],f[S.FIELDS.END_LINE],f[S.FIELDS.END_COL]),sourceIndex:l[S.FIELDS.START_POS],spaces:{before:o,after:\"\"}}))}}return a},t.convertWhitespaceNodesToSpace=function(r,i){var a=this;i===void 0&&(i=!1);var o=\"\",s=\"\";r.forEach(function(l){var f=a.lossySpace(l.spaces.before,i),p=a.lossySpace(l.rawSpaceBefore,i);o+=f+a.lossySpace(l.spaces.after,i&&f.length===0),s+=f+l.value+a.lossySpace(l.rawSpaceAfter,i&&p.length===0)}),s===o&&(s=void 0);var u={space:o,rawSpace:s};return u},t.isNamedCombinator=function(r){return r===void 0&&(r=this.position),this.tokens[r+0]&&this.tokens[r+0][S.FIELDS.TYPE]===T.slash&&this.tokens[r+1]&&this.tokens[r+1][S.FIELDS.TYPE]===T.word&&this.tokens[r+2]&&this.tokens[r+2][S.FIELDS.TYPE]===T.slash},t.namedCombinator=function(){if(this.isNamedCombinator()){var r=this.content(this.tokens[this.position+1]),i=(0,Q.unesc)(r).toLowerCase(),a={};i!==r&&(a.value=\"/\"+r+\"/\");var o=new ui.default({value:\"/\"+i+\"/\",source:Qe(this.currToken[S.FIELDS.START_LINE],this.currToken[S.FIELDS.START_COL],this.tokens[this.position+2][S.FIELDS.END_LINE],this.tokens[this.position+2][S.FIELDS.END_COL]),sourceIndex:this.currToken[S.FIELDS.START_POS],raws:a});return this.position=this.position+3,o}else this.unexpected()},t.combinator=function(){var r=this;if(this.content()===\"|\")return this.namespace();var i=this.locateNextMeaningfulToken(this.position);if(i<0||this.tokens[i][S.FIELDS.TYPE]===T.comma){var a=this.parseWhitespaceEquivalentTokens(i);if(a.length>0){var o=this.current.last;if(o){var s=this.convertWhitespaceNodesToSpace(a),u=s.space,l=s.rawSpace;l!==void 0&&(o.rawSpaceAfter+=l),o.spaces.after+=u}else a.forEach(function(D){return r.newNode(D)})}return}var f=this.currToken,p=void 0;i>this.position&&(p=this.parseWhitespaceEquivalentTokens(i));var g;if(this.isNamedCombinator()?g=this.namedCombinator():this.currToken[S.FIELDS.TYPE]===T.combinator?(g=new ui.default({value:this.content(),source:ot(this.currToken),sourceIndex:this.currToken[S.FIELDS.START_POS]}),this.position++):di[this.currToken[S.FIELDS.TYPE]]||p||this.unexpected(),g){if(p){var m=this.convertWhitespaceNodesToSpace(p),d=m.space,h=m.rawSpace;g.spaces.before=d,g.rawSpaceBefore=h}}else{var w=this.convertWhitespaceNodesToSpace(p,!0),b=w.space,_=w.rawSpace;_||(_=b);var E={},A={spaces:{}};b.endsWith(\" \")&&_.endsWith(\" \")?(E.before=b.slice(0,b.length-1),A.spaces.before=_.slice(0,_.length-1)):b.startsWith(\" \")&&_.startsWith(\" \")?(E.after=b.slice(1),A.spaces.after=_.slice(1)):A.value=_,g=new ui.default({value:\" \",source:fi(f,this.tokens[this.position-1]),sourceIndex:f[S.FIELDS.START_POS],spaces:E,raws:A})}return this.currToken&&this.currToken[S.FIELDS.TYPE]===T.space&&(g.spaces.after=this.optionalSpace(this.content()),this.position++),this.newNode(g)},t.comma=function(){if(this.position===this.tokens.length-1){this.root.trailingComma=!0,this.position++;return}this.current._inferEndPosition();var r=new ai.default({source:{start:Wa(this.tokens[this.position+1])}});this.current.parent.append(r),this.current=r,this.position++},t.comment=function(){var r=this.currToken;this.newNode(new Fa.default({value:this.content(),source:ot(r),sourceIndex:r[S.FIELDS.START_POS]})),this.position++},t.error=function(r,i){throw this.root.error(r,i)},t.missingBackslash=function(){return this.error(\"Expected a backslash preceding the semicolon.\",{index:this.currToken[S.FIELDS.START_POS]})},t.missingParenthesis=function(){return this.expected(\"opening parenthesis\",this.currToken[S.FIELDS.START_POS])},t.missingSquareBracket=function(){return this.expected(\"opening square bracket\",this.currToken[S.FIELDS.START_POS])},t.unexpected=function(){return this.error(\"Unexpected '\"+this.content()+\"'. Escaping special characters with \\\\ may help.\",this.currToken[S.FIELDS.START_POS])},t.namespace=function(){var r=this.prevToken&&this.content(this.prevToken)||!0;if(this.nextToken[S.FIELDS.TYPE]===T.word)return this.position++,this.word(r);if(this.nextToken[S.FIELDS.TYPE]===T.asterisk)return this.position++,this.universal(r)},t.nesting=function(){if(this.nextToken){var r=this.content(this.nextToken);if(r===\"|\"){this.position++;return}}var i=this.currToken;this.newNode(new hd.default({value:this.content(),source:ot(i),sourceIndex:i[S.FIELDS.START_POS]})),this.position++},t.parentheses=function(){var r=this.current.last,i=1;if(this.position++,r&&r.type===gd.PSEUDO){var a=new ai.default({source:{start:Wa(this.tokens[this.position-1])}}),o=this.current;for(r.append(a),this.current=a;this.position<this.tokens.length&&i;)this.currToken[S.FIELDS.TYPE]===T.openParenthesis&&i++,this.currToken[S.FIELDS.TYPE]===T.closeParenthesis&&i--,i?this.parse():(this.current.source.end=$a(this.currToken),this.current.parent.source.end=$a(this.currToken),this.position++);this.current=o}else{for(var s=this.currToken,u=\"(\",l;this.position<this.tokens.length&&i;)this.currToken[S.FIELDS.TYPE]===T.openParenthesis&&i++,this.currToken[S.FIELDS.TYPE]===T.closeParenthesis&&i--,l=this.currToken,u+=this.parseParenthesisToken(this.currToken),this.position++;r?r.appendToPropertyAndEscape(\"value\",u,u):this.newNode(new si.default({value:u,source:Qe(s[S.FIELDS.START_LINE],s[S.FIELDS.START_COL],l[S.FIELDS.END_LINE],l[S.FIELDS.END_COL]),sourceIndex:s[S.FIELDS.START_POS]}))}if(i)return this.expected(\"closing parenthesis\",this.currToken[S.FIELDS.START_POS])},t.pseudo=function(){for(var r=this,i=\"\",a=this.currToken;this.currToken&&this.currToken[S.FIELDS.TYPE]===T.colon;)i+=this.content(),this.position++;if(!this.currToken)return this.expected([\"pseudo-class\",\"pseudo-element\"],this.position-1);if(this.currToken[S.FIELDS.TYPE]===T.word)this.splitWord(!1,function(o,s){i+=o,r.newNode(new dd.default({value:i,source:fi(a,r.currToken),sourceIndex:a[S.FIELDS.START_POS]})),s>1&&r.nextToken&&r.nextToken[S.FIELDS.TYPE]===T.openParenthesis&&r.error(\"Misplaced parenthesis.\",{index:r.nextToken[S.FIELDS.START_POS]})});else return this.expected([\"pseudo-class\",\"pseudo-element\"],this.currToken[S.FIELDS.START_POS])},t.space=function(){var r=this.content();this.position===0||this.prevToken[S.FIELDS.TYPE]===T.comma||this.prevToken[S.FIELDS.TYPE]===T.openParenthesis||this.current.nodes.every(function(i){return i.type===\"comment\"})?(this.spaces=this.optionalSpace(r),this.position++):this.position===this.tokens.length-1||this.nextToken[S.FIELDS.TYPE]===T.comma||this.nextToken[S.FIELDS.TYPE]===T.closeParenthesis?(this.current.last.spaces.after=this.optionalSpace(r),this.position++):this.combinator()},t.string=function(){var r=this.currToken;this.newNode(new si.default({value:this.content(),source:ot(r),sourceIndex:r[S.FIELDS.START_POS]})),this.position++},t.universal=function(r){var i=this.nextToken;if(i&&this.content(i)===\"|\")return this.position++,this.namespace();var a=this.currToken;this.newNode(new pd.default({value:this.content(),source:ot(a),sourceIndex:a[S.FIELDS.START_POS]}),r),this.position++},t.splitWord=function(r,i){for(var a=this,o=this.nextToken,s=this.content();o&&~[T.dollar,T.caret,T.equals,T.word].indexOf(o[S.FIELDS.TYPE]);){this.position++;var u=this.content();if(s+=u,u.lastIndexOf(\"\\\\\")===u.length-1){var l=this.nextToken;l&&l[S.FIELDS.TYPE]===T.space&&(s+=this.requiredSpace(this.content(l)),this.position++)}o=this.nextToken}var f=ci(s,\".\").filter(function(d){var h=s[d-1]===\"\\\\\",w=/^\\d+\\.\\d+%$/.test(s);return!h&&!w}),p=ci(s,\"#\").filter(function(d){return s[d-1]!==\"\\\\\"}),g=ci(s,\"#{\");g.length&&(p=p.filter(function(d){return!~g.indexOf(d)}));var m=(0,md.default)(yd([0].concat(f,p)));m.forEach(function(d,h){var w=m[h+1]||s.length,b=s.slice(d,w);if(h===0&&i)return i.call(a,b,m.length);var _,E=a.currToken,A=E[S.FIELDS.START_POS]+m[h],D=Qe(E[1],E[2]+d,E[3],E[2]+(w-1));if(~f.indexOf(d)){var M={value:b.slice(1),source:D,sourceIndex:A};_=new ld.default(at(M,\"value\"))}else if(~p.indexOf(d)){var L={value:b.slice(1),source:D,sourceIndex:A};_=new fd.default(at(L,\"value\"))}else{var F={value:b,source:D,sourceIndex:A};at(F,\"value\"),_=new cd.default(F)}a.newNode(_,r),r=null}),this.position++},t.word=function(r){var i=this.nextToken;return i&&this.content(i)===\"|\"?(this.position++,this.namespace()):this.splitWord(r)},t.loop=function(){for(;this.position<this.tokens.length;)this.parse(!0);return this.current._inferEndPosition(),this.root},t.parse=function(r){switch(this.currToken[S.FIELDS.TYPE]){case T.space:this.space();break;case T.comment:this.comment();break;case T.openParenthesis:this.parentheses();break;case T.closeParenthesis:r&&this.missingParenthesis();break;case T.openSquare:this.attribute();break;case T.dollar:case T.caret:case T.equals:case T.word:this.word();break;case T.colon:this.pseudo();break;case T.comma:this.comma();break;case T.asterisk:this.universal();break;case T.ampersand:this.nesting();break;case T.slash:case T.combinator:this.combinator();break;case T.str:this.string();break;case T.closeSquare:this.missingSquareBracket();case T.semicolon:this.missingBackslash();default:this.unexpected()}},t.expected=function(r,i,a){if(Array.isArray(r)){var o=r.pop();r=r.join(\", \")+\" or \"+o}var s=/^[aeiou]/.test(r[0])?\"an\":\"a\";return a?this.error(\"Expected \"+s+\" \"+r+', found \"'+a+'\" instead.',{index:i}):this.error(\"Expected \"+s+\" \"+r+\".\",{index:i})},t.requiredSpace=function(r){return this.options.lossy?\" \":r},t.optionalSpace=function(r){return this.options.lossy?\"\":r},t.lossySpace=function(r,i){return this.options.lossy?i?\" \":\"\":r},t.parseParenthesisToken=function(r){var i=this.content(r);return r[S.FIELDS.TYPE]===T.space?this.requiredSpace(i):i},t.newNode=function(r,i){return i&&(/^ +$/.test(i)&&(this.options.lossy||(this.spaces=(this.spaces||\"\")+i),i=!0),r.namespace=i,at(r,\"namespace\")),this.spaces&&(r.spaces.before=this.spaces,this.spaces=\"\"),this.current.append(r)},t.content=function(r){return r===void 0&&(r=this.currToken),this.css.slice(r[S.FIELDS.START_POS],r[S.FIELDS.END_POS])},t.locateNextMeaningfulToken=function(r){r===void 0&&(r=this.position+1);for(var i=r;i<this.tokens.length;)if(bd[this.tokens[i][S.FIELDS.TYPE]]){i++;continue}else return i;return-1},vd(e,[{key:\"currToken\",get:function(){return this.tokens[this.position]}},{key:\"nextToken\",get:function(){return this.tokens[this.position+1]}},{key:\"prevToken\",get:function(){return this.tokens[this.position-1]}}]),e}();$t.default=xd;Ba.exports=$t.default});var Ga=R((qt,za)=>{\"use strict\";c();qt.__esModule=!0;qt.default=void 0;var wd=_d(Ua());function _d(e){return e&&e.__esModule?e:{default:e}}var Sd=function(){function e(n,r){this.func=n||function(){},this.funcRes=null,this.options=r}var t=e.prototype;return t._shouldUpdateSelector=function(r,i){i===void 0&&(i={});var a=Object.assign({},this.options,i);return a.updateSelector===!1?!1:typeof r!=\"string\"},t._isLossy=function(r){r===void 0&&(r={});var i=Object.assign({},this.options,r);return i.lossless===!1},t._root=function(r,i){i===void 0&&(i={});var a=new wd.default(r,this._parseOptions(i));return a.root},t._parseOptions=function(r){return{lossy:this._isLossy(r)}},t._run=function(r,i){var a=this;return i===void 0&&(i={}),new Promise(function(o,s){try{var u=a._root(r,i);Promise.resolve(a.func(u)).then(function(l){var f=void 0;return a._shouldUpdateSelector(r,i)&&(f=u.toString(),r.selector=f),{transform:l,root:u,string:f}}).then(o,s)}catch(l){s(l);return}})},t._runSync=function(r,i){i===void 0&&(i={});var a=this._root(r,i),o=this.func(a);if(o&&typeof o.then==\"function\")throw new Error(\"Selector processor returned a promise to a synchronous call.\");var s=void 0;return i.updateSelector&&typeof r!=\"string\"&&(s=a.toString(),r.selector=s),{transform:o,root:a,string:s}},t.ast=function(r,i){return this._run(r,i).then(function(a){return a.root})},t.astSync=function(r,i){return this._runSync(r,i).root},t.transform=function(r,i){return this._run(r,i).then(function(a){return a.transform})},t.transformSync=function(r,i){return this._runSync(r,i).transform},t.process=function(r,i){return this._run(r,i).then(function(a){return a.string||a.root.toString()})},t.processSync=function(r,i){var a=this._runSync(r,i);return a.string||a.root.toString()},e}();qt.default=Sd;za.exports=qt.default});var ja=R(V=>{\"use strict\";c();V.__esModule=!0;V.universal=V.tag=V.string=V.selector=V.root=V.pseudo=V.nesting=V.id=V.comment=V.combinator=V.className=V.attribute=void 0;var kd=ye(Jn()),Td=ye(Dn()),Ed=ye(ti()),Od=ye(Mn()),Pd=ye(Wn()),Ad=ye(ni()),Id=ye(jn()),Rd=ye(An()),Ld=ye(Rn()),Cd=ye(zn()),Dd=ye(Bn()),Fd=ye(Zn());function ye(e){return e&&e.__esModule?e:{default:e}}var Md=function(t){return new kd.default(t)};V.attribute=Md;var Nd=function(t){return new Td.default(t)};V.className=Nd;var Wd=function(t){return new Ed.default(t)};V.combinator=Wd;var $d=function(t){return new Od.default(t)};V.comment=$d;var qd=function(t){return new Pd.default(t)};V.id=qd;var Bd=function(t){return new Ad.default(t)};V.nesting=Bd;var Ud=function(t){return new Id.default(t)};V.pseudo=Ud;var zd=function(t){return new Rd.default(t)};V.root=zd;var Gd=function(t){return new Ld.default(t)};V.selector=Gd;var jd=function(t){return new Cd.default(t)};V.string=jd;var Vd=function(t){return new Dd.default(t)};V.tag=Vd;var Hd=function(t){return new Fd.default(t)};V.universal=Hd});var Xa=R(W=>{\"use strict\";c();W.__esModule=!0;W.isNode=pi;W.isPseudoElement=Ya;W.isPseudoClass=ip;W.isContainer=op;W.isNamespace=ap;W.isUniversal=W.isTag=W.isString=W.isSelector=W.isRoot=W.isPseudo=W.isNesting=W.isIdentifier=W.isComment=W.isCombinator=W.isClassName=W.isAttribute=void 0;var J=ne(),le,Yd=(le={},le[J.ATTRIBUTE]=!0,le[J.CLASS]=!0,le[J.COMBINATOR]=!0,le[J.COMMENT]=!0,le[J.ID]=!0,le[J.NESTING]=!0,le[J.PSEUDO]=!0,le[J.ROOT]=!0,le[J.SELECTOR]=!0,le[J.STRING]=!0,le[J.TAG]=!0,le[J.UNIVERSAL]=!0,le);function pi(e){return typeof e==\"object\"&&Yd[e.type]}function xe(e,t){return pi(t)&&t.type===e}var Va=xe.bind(null,J.ATTRIBUTE);W.isAttribute=Va;var Xd=xe.bind(null,J.CLASS);W.isClassName=Xd;var Qd=xe.bind(null,J.COMBINATOR);W.isCombinator=Qd;var Jd=xe.bind(null,J.COMMENT);W.isComment=Jd;var Kd=xe.bind(null,J.ID);W.isIdentifier=Kd;var Zd=xe.bind(null,J.NESTING);W.isNesting=Zd;var hi=xe.bind(null,J.PSEUDO);W.isPseudo=hi;var ep=xe.bind(null,J.ROOT);W.isRoot=ep;var tp=xe.bind(null,J.SELECTOR);W.isSelector=tp;var rp=xe.bind(null,J.STRING);W.isString=rp;var Ha=xe.bind(null,J.TAG);W.isTag=Ha;var np=xe.bind(null,J.UNIVERSAL);W.isUniversal=np;function Ya(e){return hi(e)&&e.value&&(e.value.startsWith(\"::\")||e.value.toLowerCase()===\":before\"||e.value.toLowerCase()===\":after\"||e.value.toLowerCase()===\":first-letter\"||e.value.toLowerCase()===\":first-line\")}function ip(e){return hi(e)&&!Ya(e)}function op(e){return!!(pi(e)&&e.walk)}function ap(e){return Va(e)||Ha(e)}});var Qa=R(ke=>{\"use strict\";c();ke.__esModule=!0;var mi=ne();Object.keys(mi).forEach(function(e){e===\"default\"||e===\"__esModule\"||e in ke&&ke[e]===mi[e]||(ke[e]=mi[e])});var gi=ja();Object.keys(gi).forEach(function(e){e===\"default\"||e===\"__esModule\"||e in ke&&ke[e]===gi[e]||(ke[e]=gi[e])});var vi=Xa();Object.keys(vi).forEach(function(e){e===\"default\"||e===\"__esModule\"||e in ke&&ke[e]===vi[e]||(ke[e]=vi[e])})});var Za=R((Bt,Ka)=>{\"use strict\";c();Bt.__esModule=!0;Bt.default=void 0;var sp=fp(Ga()),up=lp(Qa());function Ja(){if(typeof WeakMap!=\"function\")return null;var e=new WeakMap;return Ja=function(){return e},e}function lp(e){if(e&&e.__esModule)return e;if(e===null||typeof e!=\"object\"&&typeof e!=\"function\")return{default:e};var t=Ja();if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=r?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(n,i,a):n[i]=e[i]}return n.default=e,t&&t.set(e,n),n}function fp(e){return e&&e.__esModule?e:{default:e}}var bi=function(t){return new sp.default(t)};Object.assign(bi,up);delete bi.__esModule;var cp=bi;Bt.default=cp;Ka.exports=Bt.default});var es=R(yi=>{\"use strict\";c();Object.defineProperty(yi,\"__esModule\",{value:!0});Object.defineProperty(yi,\"default\",{enumerable:!0,get:()=>dp});function dp(e){return e.replace(/\\\\,/g,\"\\\\2c \")}});var rs=R((cg,ts)=>{\"use strict\";c();ts.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}});var wi=R(xi=>{\"use strict\";c();Object.defineProperty(xi,\"__esModule\",{value:!0});function pp(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}pp(xi,{parseColor:()=>yp,formatColor:()=>xp});var ns=hp(rs());function hp(e){return e&&e.__esModule?e:{default:e}}var mp=/^#([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i,gp=/^#([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?$/i,Ne=/(?:\\d+|\\d*\\.\\d+)%?/,Rr=/(?:\\s*,\\s*|\\s+)/,is=/\\s*[,/]\\s*/,We=/var\\(--(?:[^ )]*?)\\)/,vp=new RegExp(`^(rgb)a?\\\\(\\\\s*(${Ne.source}|${We.source})(?:${Rr.source}(${Ne.source}|${We.source}))?(?:${Rr.source}(${Ne.source}|${We.source}))?(?:${is.source}(${Ne.source}|${We.source}))?\\\\s*\\\\)$`),bp=new RegExp(`^(hsl)a?\\\\(\\\\s*((?:${Ne.source})(?:deg|rad|grad|turn)?|${We.source})(?:${Rr.source}(${Ne.source}|${We.source}))?(?:${Rr.source}(${Ne.source}|${We.source}))?(?:${is.source}(${Ne.source}|${We.source}))?\\\\s*\\\\)$`);function yp(e,{loose:t=!1}={}){var n,r;if(typeof e!=\"string\")return null;if(e=e.trim(),e===\"transparent\")return{mode:\"rgb\",color:[\"0\",\"0\",\"0\"],alpha:\"0\"};if(e in ns.default)return{mode:\"rgb\",color:ns.default[e].map(u=>u.toString())};let i=e.replace(gp,(u,l,f,p,g)=>[\"#\",l,l,f,f,p,p,g?g+g:\"\"].join(\"\")).match(mp);if(i!==null)return{mode:\"rgb\",color:[parseInt(i[1],16),parseInt(i[2],16),parseInt(i[3],16)].map(u=>u.toString()),alpha:i[4]?(parseInt(i[4],16)/255).toString():void 0};var a;let o=(a=e.match(vp))!==null&&a!==void 0?a:e.match(bp);if(o===null)return null;let s=[o[2],o[3],o[4]].filter(Boolean).map(u=>u.toString());return!t&&s.length!==3||s.length<3&&!s.some(u=>/^var\\(.*?\\)$/.test(u))?null:{mode:o[1],color:s,alpha:(n=o[5])===null||n===void 0||(r=n.toString)===null||r===void 0?void 0:r.call(n)}}function xp({mode:e,color:t,alpha:n}){let r=n!==void 0;return`${e}(${t.join(\" \")}${r?` / ${n}`:\"\"})`}});var Si=R(_i=>{\"use strict\";c();Object.defineProperty(_i,\"__esModule\",{value:!0});function wp(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}wp(_i,{withAlphaValue:()=>_p,default:()=>Sp});var Lr=wi();function _p(e,t,n){if(typeof e==\"function\")return e({opacityValue:t});let r=(0,Lr.parseColor)(e,{loose:!0});return r===null?n:(0,Lr.formatColor)({...r,alpha:t})}function Sp({color:e,property:t,variable:n}){let r=[].concat(t);if(typeof e==\"function\")return{[n]:\"1\",...Object.fromEntries(r.map(a=>[a,e({opacityVariable:n,opacityValue:`var(${n})`})]))};let i=(0,Lr.parseColor)(e);return i===null?Object.fromEntries(r.map(a=>[a,e])):i.alpha!==void 0?Object.fromEntries(r.map(a=>[a,e])):{[n]:\"1\",...Object.fromEntries(r.map(a=>[a,(0,Lr.formatColor)({...i,alpha:`var(${n})`})]))}}});var ls=R(ki=>{\"use strict\";c();Object.defineProperty(ki,\"__esModule\",{value:!0});function kp(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}kp(ki,{pattern:()=>Ep,withoutCapturing:()=>as,any:()=>ss,optional:()=>Op,zeroOrMore:()=>Pp,nestedBrackets:()=>us,escape:()=>Je});var os=/[\\\\^$.*+?()[\\]{}|]/g,Tp=RegExp(os.source);function Ut(e){return e=Array.isArray(e)?e:[e],e=e.map(t=>t instanceof RegExp?t.source:t),e.join(\"\")}function Ep(e){return new RegExp(Ut(e),\"g\")}function as(e){return new RegExp(`(?:${Ut(e)})`,\"g\")}function ss(e){return`(?:${e.map(Ut).join(\"|\")})`}function Op(e){return`(?:${Ut(e)})?`}function Pp(e){return`(?:${Ut(e)})*`}function us(e,t,n=1){return as([Je(e),/[^\\s]*/,n===1?`[^${Je(e)}${Je(t)}s]*`:ss([`[^${Je(e)}${Je(t)}s]*`,us(e,t,n-1)]),/[^\\s]*/,Je(t)])}function Je(e){return e&&Tp.test(e)?e.replace(os,\"\\\\$&\"):e||\"\"}});var cs=R(Ti=>{\"use strict\";c();Object.defineProperty(Ti,\"__esModule\",{value:!0});Object.defineProperty(Ti,\"splitAtTopLevelOnly\",{enumerable:!0,get:()=>Rp});var Ap=Ip(ls());function fs(e){if(typeof WeakMap!=\"function\")return null;var t=new WeakMap,n=new WeakMap;return(fs=function(r){return r?n:t})(e)}function Ip(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!=\"object\"&&typeof e!=\"function\")return{default:e};var n=fs(t);if(n&&n.has(e))return n.get(e);var r={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(a!==\"default\"&&Object.prototype.hasOwnProperty.call(e,a)){var o=i?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a]}return r.default=e,n&&n.set(e,r),r}function*Rp(e,t){let n=new RegExp(`[(){}\\\\[\\\\]${Ap.escape(t)}]`,\"g\"),r=0,i=0,a=!1,o=0,s=0,u=t.length;for(let l of e.matchAll(n)){let f=l[0]===t[o],p=o===u-1,g=f&&p;l[0]===\"(\"&&r++,l[0]===\")\"&&r--,l[0]===\"[\"&&r++,l[0]===\"]\"&&r--,l[0]===\"{\"&&r++,l[0]===\"}\"&&r--,f&&r===0&&(s===0&&(s=l.index),o++),g&&r===0&&(a=!0,yield e.substring(i,s),i=s+u),o===u&&(o=0,s=0)}a?yield e.substring(i):yield e}});var ps=R(Ei=>{\"use strict\";c();Object.defineProperty(Ei,\"__esModule\",{value:!0});function Lp(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}Lp(Ei,{parseBoxShadowValue:()=>Mp,formatBoxShadowValue:()=>Np});var Cp=cs(),Dp=new Set([\"inset\",\"inherit\",\"initial\",\"revert\",\"unset\"]),Fp=/\\ +(?![^(]*\\))/g,ds=/^-?(\\d+|\\.\\d+)(.*?)$/g;function Mp(e){return Array.from((0,Cp.splitAtTopLevelOnly)(e,\",\")).map(n=>{let r=n.trim(),i={raw:r},a=r.split(Fp),o=new Set;for(let s of a)ds.lastIndex=0,!o.has(\"KEYWORD\")&&Dp.has(s)?(i.keyword=s,o.add(\"KEYWORD\")):ds.test(s)?o.has(\"X\")?o.has(\"Y\")?o.has(\"BLUR\")?o.has(\"SPREAD\")||(i.spread=s,o.add(\"SPREAD\")):(i.blur=s,o.add(\"BLUR\")):(i.y=s,o.add(\"Y\")):(i.x=s,o.add(\"X\")):i.color?(i.unknown||(i.unknown=[]),i.unknown.push(s)):i.color=s;return i.valid=i.x!==void 0&&i.y!==void 0,i})}function Np(e){return e.map(t=>t.valid?[t.keyword,t.x,t.y,t.blur,t.spread,t.color].filter(Boolean).join(\" \"):t.raw).join(\", \")}});var xs=R(Pi=>{\"use strict\";c();Object.defineProperty(Pi,\"__esModule\",{value:!0});function Wp(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}Wp(Pi,{normalize:()=>$e,url:()=>gs,number:()=>Bp,percentage:()=>vs,length:()=>bs,lineWidth:()=>Gp,shadow:()=>jp,color:()=>Vp,image:()=>Hp,gradient:()=>ys,position:()=>Qp,familyName:()=>Jp,genericName:()=>Zp,absoluteSize:()=>th,relativeSize:()=>nh});var $p=wi(),qp=ps(),Oi=[\"min\",\"max\",\"clamp\",\"calc\"],ms=/,(?![^(]*\\))/g,Cr=/_(?![^(]*\\))/g;function $e(e,t=!0){return e.includes(\"url(\")?e.split(/(url\\(.*?\\))/g).filter(Boolean).map(n=>/^url\\(.*?\\)$/.test(n)?n:$e(n,!1)).join(\"\"):(e=e.replace(/([^\\\\])_+/g,(n,r)=>r+\" \".repeat(n.length-1)).replace(/^_/g,\" \").replace(/\\\\_/g,\"_\"),t&&(e=e.trim()),e=e.replace(/(calc|min|max|clamp)\\(.+\\)/g,n=>n.replace(/(-?\\d*\\.?\\d(?!\\b-.+[,)](?![^+\\-/*])\\D)(?:%|[a-z]+)?|\\))([+\\-/*])/g,\"$1 $2 \")),e)}function gs(e){return e.startsWith(\"url(\")}function Bp(e){return!isNaN(Number(e))||Oi.some(t=>new RegExp(`^${t}\\\\(.+?`).test(e))}function vs(e){return e.split(Cr).every(t=>/%$/g.test(t)||Oi.some(n=>new RegExp(`^${n}\\\\(.+?%`).test(t)))}var Up=[\"cm\",\"mm\",\"Q\",\"in\",\"pc\",\"pt\",\"px\",\"em\",\"ex\",\"ch\",\"rem\",\"lh\",\"vw\",\"vh\",\"vmin\",\"vmax\"],hs=`(?:${Up.join(\"|\")})`;function bs(e){return e.split(Cr).every(t=>t===\"0\"||new RegExp(`${hs}$`).test(t)||Oi.some(n=>new RegExp(`^${n}\\\\(.+?${hs}`).test(t)))}var zp=new Set([\"thin\",\"medium\",\"thick\"]);function Gp(e){return zp.has(e)}function jp(e){let t=(0,qp.parseBoxShadowValue)($e(e));for(let n of t)if(!n.valid)return!1;return!0}function Vp(e){let t=0;return e.split(Cr).every(r=>(r=$e(r),r.startsWith(\"var(\")?!0:(0,$p.parseColor)(r,{loose:!0})!==null?(t++,!0):!1))?t>0:!1}function Hp(e){let t=0;return e.split(ms).every(r=>(r=$e(r),r.startsWith(\"var(\")?!0:gs(r)||ys(r)||[\"element(\",\"image(\",\"cross-fade(\",\"image-set(\"].some(i=>r.startsWith(i))?(t++,!0):!1))?t>0:!1}var Yp=new Set([\"linear-gradient\",\"radial-gradient\",\"repeating-linear-gradient\",\"repeating-radial-gradient\",\"conic-gradient\"]);function ys(e){e=$e(e);for(let t of Yp)if(e.startsWith(`${t}(`))return!0;return!1}var Xp=new Set([\"center\",\"top\",\"right\",\"bottom\",\"left\"]);function Qp(e){let t=0;return e.split(Cr).every(r=>(r=$e(r),r.startsWith(\"var(\")?!0:Xp.has(r)||bs(r)||vs(r)?(t++,!0):!1))?t>0:!1}function Jp(e){let t=0;return e.split(ms).every(r=>(r=$e(r),r.startsWith(\"var(\")?!0:r.includes(\" \")&&!/(['\"])([^\"']+)\\1/g.test(r)||/^\\d/g.test(r)?!1:(t++,!0)))?t>0:!1}var Kp=new Set([\"serif\",\"sans-serif\",\"monospace\",\"cursive\",\"fantasy\",\"system-ui\",\"ui-serif\",\"ui-sans-serif\",\"ui-monospace\",\"ui-rounded\",\"math\",\"emoji\",\"fangsong\"]);function Zp(e){return Kp.has(e)}var eh=new Set([\"xx-small\",\"x-small\",\"small\",\"medium\",\"large\",\"x-large\",\"x-large\",\"xxx-large\"]);function th(e){return eh.has(e)}var rh=new Set([\"larger\",\"smaller\"]);function nh(e){return rh.has(e)}});var Ps=R(Ri=>{\"use strict\";c();Object.defineProperty(Ri,\"__esModule\",{value:!0});function ih(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}ih(Ri,{updateAllClasses:()=>sh,asValue:()=>Gt,parseColorFormat:()=>Ai,asColor:()=>Ts,asLookupValue:()=>Es,coerceValue:()=>ch});var oh=Ii(Za()),ah=Ii(es()),ws=Si(),fe=xs(),_s=Ii(mn());function Ii(e){return e&&e.__esModule?e:{default:e}}function sh(e,t){return(0,oh.default)(i=>{i.walkClasses(a=>{let o=t(a.value);a.value=o,a.raws&&a.raws.value&&(a.raws.value=(0,ah.default)(a.raws.value))})}).processSync(e)}function ks(e,t){if(!zt(e))return;let n=e.slice(1,-1);if(!!t(n))return(0,fe.normalize)(n)}function uh(e,t={},n){let r=t[e];if(r!==void 0)return(0,_s.default)(r);if(zt(e)){let i=ks(e,n);return i===void 0?void 0:(0,_s.default)(i)}}function Gt(e,t={},{validate:n=()=>!0}={}){var r;let i=(r=t.values)===null||r===void 0?void 0:r[e];return i!==void 0?i:t.supportsNegativeValues&&e.startsWith(\"-\")?uh(e.slice(1),t.values,n):ks(e,n)}function zt(e){return e.startsWith(\"[\")&&e.endsWith(\"]\")}function lh(e){let t=e.lastIndexOf(\"/\");return t===-1||t===e.length-1?[e]:[e.slice(0,t),e.slice(t+1)]}function Ai(e){if(typeof e==\"string\"&&e.includes(\"<alpha-value>\")){let t=e;return({opacityValue:n=1})=>t.replace(\"<alpha-value>\",n)}return e}function Ts(e,t={},{tailwindConfig:n={}}={}){var r;if(((r=t.values)===null||r===void 0?void 0:r[e])!==void 0){var i;return Ai((i=t.values)===null||i===void 0?void 0:i[e])}let[a,o]=lh(e);if(o!==void 0){var s,u,l,f;let p=(f=(s=t.values)===null||s===void 0?void 0:s[a])!==null&&f!==void 0?f:zt(a)?a.slice(1,-1):void 0;return p===void 0?void 0:(p=Ai(p),zt(o)?(0,ws.withAlphaValue)(p,o.slice(1,-1)):((u=n.theme)===null||u===void 0||(l=u.opacity)===null||l===void 0?void 0:l[o])===void 0?void 0:(0,ws.withAlphaValue)(p,n.theme.opacity[o]))}return Gt(e,t,{validate:fe.color})}function Es(e,t={}){var n;return(n=t.values)===null||n===void 0?void 0:n[e]}function we(e){return(t,n)=>Gt(t,n,{validate:e})}var Os={any:Gt,color:Ts,url:we(fe.url),image:we(fe.image),length:we(fe.length),percentage:we(fe.percentage),position:we(fe.position),lookup:Es,\"generic-name\":we(fe.genericName),\"family-name\":we(fe.familyName),number:we(fe.number),\"line-width\":we(fe.lineWidth),\"absolute-size\":we(fe.absoluteSize),\"relative-size\":we(fe.relativeSize),shadow:we(fe.shadow)},Ss=Object.keys(Os);function fh(e,t){let n=e.indexOf(t);return n===-1?[void 0,e]:[e.slice(0,n),e.slice(n+1)]}function ch(e,t,n,r){if(zt(t)){let i=t.slice(1,-1),[a,o]=fh(i,\":\");if(!/^[\\w-_]+$/g.test(a))o=i;else if(a!==void 0&&!Ss.includes(a))return[];if(o.length>0&&Ss.includes(a))return[Gt(`[${o}]`,n),a]}for(let i of[].concat(e)){let a=Os[i](t,n,{tailwindConfig:r});if(a!==void 0)return[a,i]}return[]}});var As=R(Li=>{\"use strict\";c();Object.defineProperty(Li,\"__esModule\",{value:!0});Object.defineProperty(Li,\"default\",{enumerable:!0,get:()=>dh});function dh(e){return typeof e==\"function\"?e({}):e}});var Ds=R(Di=>{\"use strict\";c();Object.defineProperty(Di,\"__esModule\",{value:!0});Object.defineProperty(Di,\"default\",{enumerable:!0,get:()=>Lh});var ph=Ke(mn()),hh=Ke(No()),mh=Ke(Wo()),gh=Ke(bn()),vh=Ke(qo()),Ls=Bo(),Is=Uo(),bh=Go(),yh=Ke(jo()),xh=Vo(),wh=Ps(),_h=Si(),Sh=Ke(As());function Ke(e){return e&&e.__esModule?e:{default:e}}function st(e){return typeof e==\"function\"}function jt(e){return typeof e==\"object\"&&e!==null}function Vt(e,...t){let n=t.pop();for(let r of t)for(let i in r){let a=n(e[i],r[i]);a===void 0?jt(e[i])&&jt(r[i])?e[i]=Vt(e[i],r[i],n):e[i]=r[i]:e[i]=a}return e}var Ci={colors:vh.default,negative(e){return Object.keys(e).filter(t=>e[t]!==\"0\").reduce((t,n)=>{let r=(0,ph.default)(e[n]);return r!==void 0&&(t[`-${n}`]=r),t},{})},breakpoints(e){return Object.keys(e).filter(t=>typeof e[t]==\"string\").reduce((t,n)=>({...t,[`screen-${n}`]:e[n]}),{})}};function kh(e,...t){return st(e)?e(...t):e}function Th(e){return e.reduce((t,{extend:n})=>Vt(t,n,(r,i)=>r===void 0?[i]:Array.isArray(r)?[i,...r]:[i,r]),{})}function Eh(e){return{...e.reduce((t,n)=>(0,Ls.defaults)(t,n),{}),extend:Th(e)}}function Rs(e,t){if(Array.isArray(e)&&jt(e[0]))return e.concat(t);if(Array.isArray(t)&&jt(t[0])&&jt(e))return[e,...t];if(Array.isArray(t))return t}function Oh({extend:e,...t}){return Vt(t,e,(n,r)=>!st(n)&&!r.some(st)?Vt({},n,...r,Rs):(i,a)=>Vt({},...[n,...r].map(o=>kh(o,i,a)),Rs))}function*Ph(e){let t=(0,Is.toPath)(e);if(t.length===0||(yield t,Array.isArray(e)))return;let n=/^(.*?)\\s*\\/\\s*([^/]+)$/,r=e.match(n);if(r!==null){let[,i,a]=r,o=(0,Is.toPath)(i);o.alpha=a,yield o}}function Ah(e){let t=(n,r)=>{for(let i of Ph(n)){let a=0,o=e;for(;o!=null&&a<i.length;)o=o[i[a++]],o=st(o)&&(i.alpha===void 0||a<=i.length-1)?o(t,Ci):o;if(o!==void 0){if(i.alpha!==void 0){let s=(0,wh.parseColorFormat)(o);return(0,_h.withAlphaValue)(s,i.alpha,(0,Sh.default)(s))}return(0,yh.default)(o)?(0,xh.cloneDeep)(o):o}}return r};return Object.assign(t,{theme:t,...Ci}),Object.keys(e).reduce((n,r)=>(n[r]=st(e[r])?e[r](t,Ci):e[r],n),{})}function Cs(e){let t=[];return e.forEach(n=>{t=[...t,n];var r;let i=(r=n==null?void 0:n.plugins)!==null&&r!==void 0?r:[];i.length!==0&&i.forEach(a=>{a.__isOptionsFunction&&(a=a());var o;t=[...t,...Cs([(o=a==null?void 0:a.config)!==null&&o!==void 0?o:{}])]})}),t}function Ih(e){return[...e].reduceRight((n,r)=>st(r)?r({corePlugins:n}):(0,mh.default)(r,n),hh.default)}function Rh(e){return[...e].reduceRight((n,r)=>[...n,...r],[])}function Lh(e){let t=[...Cs(e),{prefix:\"\",important:!1,separator:\":\",variantOrder:gh.default.variantOrder}];var n,r;return(0,bh.normalizeConfig)((0,Ls.defaults)({theme:Ah(Oh(Eh(t.map(i=>(n=i==null?void 0:i.theme)!==null&&n!==void 0?n:{})))),corePlugins:Ih(t.map(i=>i.corePlugins)),plugins:Rh(e.map(i=>(r=i==null?void 0:i.plugins)!==null&&r!==void 0?r:[]))},...t))}});var Fs={};co(Fs,{default:()=>Ch});var Ch,Ms=Br(()=>{c();Ch={yellow:e=>e}});var qs=R(Fi=>{\"use strict\";c();Object.defineProperty(Fi,\"__esModule\",{value:!0});function Dh(e,t){for(var n in t)Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}Dh(Fi,{flagEnabled:()=>Nh,issueFlagNotices:()=>Wh,default:()=>$h});var Fh=$s((Ms(),ar(Fs))),Mh=$s((br(),ar(vr)));function $s(e){return e&&e.__esModule?e:{default:e}}var Ns={optimizeUniversalDefaults:!1},Ht={future:[\"hoverOnlyWhenSupported\",\"respectDefaultRingColorOpacity\"],experimental:[\"optimizeUniversalDefaults\",\"matchVariant\"]};function Nh(e,t){if(Ht.future.includes(t)){var n,r,i;return e.future===\"all\"||((i=(r=e==null||(n=e.future)===null||n===void 0?void 0:n[t])!==null&&r!==void 0?r:Ns[t])!==null&&i!==void 0?i:!1)}if(Ht.experimental.includes(t)){var a,o,s;return e.experimental===\"all\"||((s=(o=e==null||(a=e.experimental)===null||a===void 0?void 0:a[t])!==null&&o!==void 0?o:Ns[t])!==null&&s!==void 0?s:!1)}return!1}function Ws(e){if(e.experimental===\"all\")return Ht.experimental;var t;return Object.keys((t=e==null?void 0:e.experimental)!==null&&t!==void 0?t:{}).filter(n=>Ht.experimental.includes(n)&&e.experimental[n])}function Wh(e){if(process.env.JEST_WORKER_ID===void 0&&Ws(e).length>0){let t=Ws(e).map(n=>Fh.default.yellow(n)).join(\", \");Mh.default.warn(\"experimental-flags-enabled\",[`You have enabled experimental features: ${t}`,\"Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time.\"])}}var $h=Ht});var Us=R(Mi=>{\"use strict\";c();Object.defineProperty(Mi,\"__esModule\",{value:!0});Object.defineProperty(Mi,\"default\",{enumerable:!0,get:()=>Bs});var qh=Uh(bn()),Bh=qs();function Uh(e){return e&&e.__esModule?e:{default:e}}function Bs(e){var t;let n=((t=e==null?void 0:e.presets)!==null&&t!==void 0?t:[qh.default]).slice().reverse().flatMap(a=>Bs(typeof a==\"function\"?a():a)),r={respectDefaultRingColorOpacity:{theme:{ringColor:{DEFAULT:\"#3b82f67f\"}}}},i=Object.keys(r).filter(a=>(0,Bh.flagEnabled)(e,a)).map(a=>r[a]);return[e,...i,...n]}});var Gs=R(Ni=>{\"use strict\";c();Object.defineProperty(Ni,\"__esModule\",{value:!0});Object.defineProperty(Ni,\"default\",{enumerable:!0,get:()=>jh});var zh=zs(Ds()),Gh=zs(Us());function zs(e){return e&&e.__esModule?e:{default:e}}function jh(...e){let[,...t]=(0,Gh.default)(e[0]);return(0,zh.default)([...e,...t])}});var Vs=R((kg,js)=>{c();var Wi=Gs();js.exports=(Wi.__esModule?Wi:{default:Wi}).default});c();c();c();c();var ho={};var Ur;Ur=ho.default;function Eu(e){Ur=e}function Ae(){return Ur}c();c();c();var dt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ou=dt((e,t)=>{t.exports=[\"em\",\"ex\",\"ch\",\"rem\",\"vh\",\"vw\",\"vmin\",\"vmax\",\"px\",\"mm\",\"cm\",\"in\",\"pt\",\"pc\",\"mozmm\"]}),Pu=dt((e,t)=>{t.exports=[\"deg\",\"grad\",\"rad\",\"turn\"]}),Au=dt((e,t)=>{t.exports=[\"dpi\",\"dpcm\",\"dppx\"]}),Iu=dt((e,t)=>{t.exports=[\"Hz\",\"kHz\"]}),Ru=dt((e,t)=>{t.exports=[\"s\",\"ms\"]}),Lu=Ou(),mo=Pu(),go=Au(),vo=Iu(),bo=Ru();function Gr(e){if(/\\.\\D?$/.test(e))throw new Error(\"The dot should be followed by a number\");if(/^[+-]{2}/.test(e))throw new Error(\"Only one leading +/- is allowed\");if(Cu(e)>1)throw new Error(\"Only one dot is allowed\");if(/%$/.test(e)){this.type=\"percentage\",this.value=zr(e),this.unit=\"%\";return}var t=Fu(e);if(!t){this.type=\"number\",this.value=zr(e);return}this.type=Nu(t),this.value=zr(e.substr(0,e.length-t.length)),this.unit=t}Gr.prototype.valueOf=function(){return this.value};Gr.prototype.toString=function(){return this.value+(this.unit||\"\")};function Fe(e){return new Gr(e)}function Cu(e){var t=e.match(/\\./g);return t?t.length:0}function zr(e){var t=parseFloat(e);if(isNaN(t))throw new Error(\"Invalid number: \"+e);return t}var Du=[].concat(mo,vo,Lu,go,bo);function Fu(e){var t=e.match(/\\D+$/),n=t&&t[0];if(n&&Du.indexOf(n)===-1)throw new Error(\"Invalid unit: \"+n);return n}var Mu=Object.assign(sr(mo,\"angle\"),sr(vo,\"frequency\"),sr(go,\"resolution\"),sr(bo,\"time\"));function sr(e,t){return Object.fromEntries(e.map(n=>[n,t]))}function Nu(e){return Mu[e]||\"length\"}function Yr(e){let t=typeof e;return!(t===\"number\"||t===\"bigint\"||t===\"string\"||t===\"boolean\")}function xo(e){return/^class\\s/.test(e.toString())}function wo(e){let t=typeof e>\"u\"?[]:[].concat(e).flat(1/0),n=[];for(let r=0;r<t.length;r++){let i=t[r];typeof i>\"u\"||typeof i==\"boolean\"||i===null||(typeof i==\"number\"&&(i=String(i)),typeof i==\"string\"&&n.length&&typeof n[n.length-1]==\"string\"?n[n.length-1]+=i:n.push(i))}return n}function Ge(e,t,n,r,i=!1){if(typeof e==\"number\")return e;try{if(e=e.trim(),/[ /\\(,]/.test(e))return;let a=new Fe(e);if(a.type===\"length\")switch(a.unit){case\"em\":return a.value*t;case\"rem\":return a.value*16;case\"vw\":return~~(a.value*r._viewportWidth/100);case\"vh\":return~~(a.value*r._viewportHeight/100);default:return a.value}else if(a.type===\"angle\")switch(a.unit){case\"deg\":return a.value;case\"rad\":return a.value*180/Math.PI;default:return a.value}else if(a.type===\"percentage\"&&i)return a.value/100*n}catch{}}function pt(e,t){return[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]]}function ae(e,t,n,r){let i=t[e];if(typeof i>\"u\"){if(r&&typeof e<\"u\")throw new Error(`Invalid value for CSS property \"${r}\". Allowed values: ${Object.keys(t).map(a=>`\"${a}\"`).join(\" | \")}. Received: \"${e}\".`);i=n}return i}var yo=void 0,jr,Vr,ur=[32,160,4961,65792,65793,4153,4241,10].map(e=>String.fromCodePoint(e));function je(e,t){if(!jr||!Vr){if(!(typeof Intl<\"u\"&&\"Segmenter\"in Intl))throw new Error(\"Intl.Segmenter does not exist, please use import a polyfill.\");jr=new Intl.Segmenter(yo,{granularity:\"word\"}),Vr=new Intl.Segmenter(yo,{granularity:\"grapheme\"})}return t===\"word\"?[...jr.segment(e)].map(n=>n.segment):[...Vr.segment(e)].map(n=>n.segment)}function P(e,t,n){let r=\"\";for(let[i,a]of Object.entries(t))typeof a<\"u\"&&(r+=` ${i}=\"${a}\"`);return n?`<${e}${r}>${n}</${e}>`:`<${e}${r}/>`}function _o(e=20){let t=new Map;function n(i,a){if(t.size>=e){let o=t.keys().next().value;t.delete(o)}t.set(i,a)}function r(i){if(!t.has(i))return;let o=t.get(i);return t.delete(i),t.set(i,o),o}return{set:n,get:r}}var So={accentHeight:\"accent-height\",alignmentBaseline:\"alignment-baseline\",arabicForm:\"arabic-form\",baselineShift:\"baseline-shift\",capHeight:\"cap-height\",clipPath:\"clip-path\",clipRule:\"clip-rule\",colorInterpolation:\"color-interpolation\",colorInterpolationFilters:\"color-interpolation-filters\",colorProfile:\"color-profile\",colorRendering:\"color-rendering\",dominantBaseline:\"dominant-baseline\",enableBackground:\"enable-background\",fillOpacity:\"fill-opacity\",fillRule:\"fill-rule\",floodColor:\"flood-color\",floodOpacity:\"flood-opacity\",fontFamily:\"font-family\",fontSize:\"font-size\",fontSizeAdjust:\"font-size-adjust\",fontStretch:\"font-stretch\",fontStyle:\"font-style\",fontVariant:\"font-variant\",fontWeight:\"font-weight\",glyphName:\"glyph-name\",glyphOrientationHorizontal:\"glyph-orientation-horizontal\",glyphOrientationVertical:\"glyph-orientation-vertical\",horizAdvX:\"horiz-adv-x\",horizOriginX:\"horiz-origin-x\",imageRendering:\"image-rendering\",letterSpacing:\"letter-spacing\",lightingColor:\"lighting-color\",markerEnd:\"marker-end\",markerMid:\"marker-mid\",markerStart:\"marker-start\",overlinePosition:\"overline-position\",overlineThickness:\"overline-thickness\",paintOrder:\"paint-order\",panose1:\"panose-1\",pointerEvents:\"pointer-events\",renderingIntent:\"rendering-intent\",shapeRendering:\"shape-rendering\",stopColor:\"stop-color\",stopOpacity:\"stop-opacity\",strikethroughPosition:\"strikethrough-position\",strikethroughThickness:\"strikethrough-thickness\",strokeDasharray:\"stroke-dasharray\",strokeDashoffset:\"stroke-dashoffset\",strokeLinecap:\"stroke-linecap\",strokeLinejoin:\"stroke-linejoin\",strokeMiterlimit:\"stroke-miterlimit\",strokeOpacity:\"stroke-opacity\",strokeWidth:\"stroke-width\",textAnchor:\"text-anchor\",textDecoration:\"text-decoration\",textRendering:\"text-rendering\",underlinePosition:\"underline-position\",underlineThickness:\"underline-thickness\",unicodeBidi:\"unicode-bidi\",unicodeRange:\"unicode-range\",unitsPerEm:\"units-per-em\",vAlphabetic:\"v-alphabetic\",vHanging:\"v-hanging\",vIdeographic:\"v-ideographic\",vMathematical:\"v-mathematical\",vectorEffect:\"vector-effect\",vertAdvY:\"vert-adv-y\",vertOriginX:\"vert-origin-x\",vertOriginY:\"vert-origin-y\",wordSpacing:\"word-spacing\",writingMode:\"writing-mode\",xHeight:\"x-height\",xlinkActuate:\"xlink:actuate\",xlinkArcrole:\"xlink:arcrole\",xlinkHref:\"xlink:href\",xlinkRole:\"xlink:role\",xlinkShow:\"xlink:show\",xlinkTitle:\"xlink:title\",xlinkType:\"xlink:type\",xmlBase:\"xml:base\",xmlLang:\"xml:lang\",xmlSpace:\"xml:space\",xmlnsXlink:\"xmlns:xlink\"},Wu=/[\\r\\n%#()<>?[\\\\\\]^`{|}\"']/g;function Hr(e){if(!e)return\"\";if(Array.isArray(e))return e.map(Hr).join(\"\");if(typeof e!=\"object\")return String(e);let t=e.type;if(t===\"text\")throw new Error(\"<text> nodes are not currently supported, please convert them to <path>\");let{children:n,...r}=e.props||{};return`<${t}${Object.entries(r).map(([i,a])=>` ${So[i]||i}=\"${a}\"`).join(\"\")}>${Hr(n)}</${t}>`}function ko(e){let{viewBox:t,viewbox:n,width:r,height:i,className:a,style:o,children:s,...u}=e.props||{};t||(t=n);let l=t.split(\" \").map(f=>parseInt(f,10));return u.xmlns=\"http://www.w3.org/2000/svg\",u.viewBox=t,u.width=l[2],u.height=l[3],`data:image/svg+xml;utf8,${`<svg${Object.entries(u).map(([f,p])=>` ${So[f]||f}=\"${p}\"`).join(\"\")}>${Hr(s)}</svg>`.replace(Wu,encodeURIComponent)}`}c();c();var ve=\"flex\",To={p:{display:ve,marginTop:\"1em\",marginBottom:\"1em\"},div:{display:ve},blockquote:{display:ve,marginTop:\"1em\",marginBottom:\"1em\",marginLeft:40,marginRight:40},center:{display:ve,textAlign:\"center\"},hr:{display:ve,marginTop:\"0.5em\",marginBottom:\"0.5em\",marginLeft:\"auto\",marginRight:\"auto\",borderWidth:1,borderStyle:\"solid\"},h1:{display:ve,fontSize:\"2em\",marginTop:\"0.67em\",marginBottom:\"0.67em\",marginLeft:0,marginRight:0,fontWeight:\"bold\"},h2:{display:ve,fontSize:\"1.5em\",marginTop:\"0.83em\",marginBottom:\"0.83em\",marginLeft:0,marginRight:0,fontWeight:\"bold\"},h3:{display:ve,fontSize:\"1.17em\",marginTop:\"1em\",marginBottom:\"1em\",marginLeft:0,marginRight:0,fontWeight:\"bold\"},h4:{display:ve,marginTop:\"1.33em\",marginBottom:\"1.33em\",marginLeft:0,marginRight:0,fontWeight:\"bold\"},h5:{display:ve,fontSize:\"0.83em\",marginTop:\"1.67em\",marginBottom:\"1.67em\",marginLeft:0,marginRight:0,fontWeight:\"bold\"},h6:{display:ve,fontSize:\"0.67em\",marginTop:\"2.33em\",marginBottom:\"2.33em\",marginLeft:0,marginRight:0,fontWeight:\"bold\"},u:{textDecoration:\"underline\"},strong:{fontWeight:\"bold\"},b:{fontWeight:\"bold\"},i:{fontStyle:\"italic\"},em:{fontStyle:\"italic\"},code:{fontFamily:\"monospace\"},kbd:{fontFamily:\"monospace\"},pre:{display:ve,fontFamily:\"monospace\",whiteSpace:\"pre\",marginTop:\"1em\",marginBottom:\"1em\"},mark:{backgroundColor:\"yellow\",color:\"black\"},big:{fontSize:\"larger\"},small:{fontSize:\"smaller\"},s:{textDecoration:\"line-through\"}};c();var $u=new Set([\"color\",\"font\",\"fontFamily\",\"fontSize\",\"fontStyle\",\"fontWeight\",\"letterSpacing\",\"lineHeight\",\"textAlign\",\"textTransform\",\"textShadowOffset\",\"textShadowColor\",\"textShadowRadius\",\"textDecorationLine\",\"textDecorationStyle\",\"textDecorationColor\",\"whiteSpace\",\"transform\",\"wordBreak\",\"opacity\",\"filter\",\"_viewportWidth\",\"_viewportHeight\",\"_inheritedClipPathId\",\"_inheritedMaskId\",\"_inheritedBackgroundClipTextPath\"]);function Xr(e){let t={};for(let n in e)$u.has(n)&&(t[n]=e[n]);return t}c();c();function Bu(e,t){try{let n=new Fe(e);switch(n.unit){case\"px\":return{absolute:n.value};case\"em\":return{absolute:n.value*t};case\"rem\":return{absolute:n.value*16};case\"%\":return{relative:n.value};default:return{}}}catch{return{}}}function Qr(e,t,n){switch(e){case\"top\":return{yRelative:0};case\"left\":return{xRelative:0};case\"right\":return{xRelative:100};case\"bottom\":return{yRelative:100};case\"center\":return{};default:let r=Bu(e,t);return r.absolute?{[n?\"xAbsolute\":\"yAbsolute\"]:r.absolute}:r.relative?{[n?\"xRelative\":\"yRelative\"]:r.relative}:{}}}function Jr(e,t){if(typeof e==\"number\")return{xAbsolute:e};let n;try{n=postcss_value_parser__WEBPACK_IMPORTED_MODULE_3__(e).nodes.filter(r=>r.type===\"word\").map(r=>r.value)}catch{return{}}return n.length===1?Qr(n[0],t,!0):n.length===2?((n[0]===\"top\"||n[0]===\"bottom\"||n[1]===\"left\"||n[1]===\"right\")&&n.reverse(),{...Qr(n[0],t,!0),...Qr(n[1],t,!1)}):{}}var ju=new Set([\"flex\",\"flexGrow\",\"flexShrink\",\"flexBasis\",\"fontWeight\",\"lineHeight\",\"opacity\",\"scale\",\"scaleX\",\"scaleY\"]),Vu=new Set([\"lineHeight\"]);function Hu(e,t,n,r){return e===\"textDecoration\"&&!n.includes(t.textDecorationColor)&&(t.textDecorationColor=r),t}function ht(e,t){return typeof t==\"number\"?ju.has(e)?Vu.has(e)?t:String(t):t+\"px\":t}function Yu(e,t,n){if(e===\"lineHeight\")return{lineHeight:ht(e,t)};if(e===\"fontFamily\")return{fontFamily:t.split(\",\").map(r=>r.trim().replace(/(^['\"])|(['\"]$)/g,\"\").toLocaleLowerCase())};if(e===\"borderRadius\"){if(typeof t!=\"string\"||!t.includes(\"/\"))return;let[r,i]=t.split(\"/\"),a=(0,css_to_react_native__WEBPACK_IMPORTED_MODULE_0__.getStylesForProperty)(e,r,!0),o=(0,css_to_react_native__WEBPACK_IMPORTED_MODULE_0__.getStylesForProperty)(e,i,!0);for(let s in a)o[s]=ht(e,a[s])+\" \"+ht(e,o[s]);return o}if(/^border(Top|Right|Bottom|Left)?$/.test(e)){let r=(0,css_to_react_native__WEBPACK_IMPORTED_MODULE_0__.getStylesForProperty)(\"border\",t,!0);r.borderWidth===1&&!String(t).includes(\"1px\")&&(r.borderWidth=3),r.borderColor===\"black\"&&!String(t).includes(\"black\")&&(r.borderColor=n);let i={Width:ht(e+\"Width\",r.borderWidth),Style:ae(r.borderStyle,{solid:\"solid\",dashed:\"dashed\"},\"solid\",e+\"Style\"),Color:r.borderColor},a={};for(let o of e===\"border\"?[\"Top\",\"Right\",\"Bottom\",\"Left\"]:[e.slice(6)])for(let s in i)a[\"border\"+o+s]=i[s];return a}if(e===\"boxShadow\"){if(!t)throw new Error('Invalid `boxShadow` value: \"'+t+'\".');return{[e]:typeof t==\"string\"?(0,css_box_shadow__WEBPACK_IMPORTED_MODULE_2__.parse)(t):t}}if(e===\"transform\"){if(typeof t!=\"string\")throw new Error(\"Invalid `transform` value.\");let r={},i=t.replace(/(-?[\\d.]+%)/g,(o,s)=>{let u=~~(Math.random()*1e9);return r[u]=s,u+\"px\"}),a=(0,css_to_react_native__WEBPACK_IMPORTED_MODULE_0__.getStylesForProperty)(\"transform\",i,!0);for(let o of a.transform)for(let s in o)r[o[s]]&&(o[s]=r[o[s]]);return a}if(e===\"background\")return t=t.toString().trim(),/^(linear-gradient|radial-gradient|url)\\(/.test(t)?(0,css_to_react_native__WEBPACK_IMPORTED_MODULE_0__.getStylesForProperty)(\"backgroundImage\",t,!0):(0,css_to_react_native__WEBPACK_IMPORTED_MODULE_0__.getStylesForProperty)(\"background\",t,!0)}function Eo(e){return e===\"transform\"?\" Only absolute lengths such as `10px` are supported.\":\"\"}var Oo=/rgb\\((\\d+)\\s+(\\d+)\\s+(\\d+)\\s*\\/\\s*([\\.\\d]+)\\)/;function Po(e){if(typeof e==\"string\"&&Oo.test(e.trim()))return e.trim().replace(Oo,(t,n,r,i,a)=>`rgba(${n}, ${r}, ${i}, ${a})`);if(typeof e==\"object\"&&e!==null){for(let t in e)e[t]=Po(e[t]);return e}return e}function lr(e,t){var i;let n={};for(let a in e){if(a.startsWith(\"_\")){n[a]=e[a];continue}let o=(0,css_to_react_native__WEBPACK_IMPORTED_MODULE_0__.getPropertyName)(a),s=e.color||t.color;try{let u=Yu(o,e[a],s)||Hu(o,(0,css_to_react_native__WEBPACK_IMPORTED_MODULE_0__.getStylesForProperty)(o,ht(o,e[a]),!0),e[a],s);Object.assign(n,u)}catch(u){throw new Error(u.message+(u.message.includes(e[a])?`\n  `+Eo(o):`\n  in CSS rule \\`${o}: ${e[a]}\\`.${Eo(o)}`))}}if(n.backgroundImage){let{backgrounds:a}=(0,css_background_parser__WEBPACK_IMPORTED_MODULE_1__.parseElementStyle)(n);n.backgroundImage=a}let r=typeof n.fontSize==\"number\"?n.fontSize:t.fontSize;if(typeof r==\"string\")try{let a=new Fe(r);switch(a.unit){case\"em\":r=a.value*t.fontSize;break;case\"rem\":r=a.value*16;break}}catch{r=16}typeof n.fontSize<\"u\"&&(n.fontSize=r),n.transformOrigin&&(n.transformOrigin=Jr(n.transformOrigin,r));for(let a in n){let o=n[a];if(a===\"lineHeight\")typeof o==\"string\"&&(o=n[a]=Ge(o,r,r,t,!0)/r);else{if(typeof o==\"string\"){let s=Ge(o,r,r,t);typeof s<\"u\"&&(n[a]=s),o=n[a]}if(typeof o==\"string\"||typeof o==\"object\"){let s=Po(o);s&&(n[a]=s),o=n[a]}}if(a===\"opacity\"&&(o=n[a]=o*t.opacity),a===\"transform\"){let s=o;for(let u of s){let l=Object.keys(u)[0],f=u[l],p=typeof f==\"string\"&&(i=Ge(f,r,r,t))!=null?i:f;u[l]=p}}}return n}c();function Xu(e){let t=new DataView(e),n=4,r=t.byteLength;for(;n<r;){let i=t.getUint16(n,!1);if(i>r)throw new TypeError(\"Invalid JPEG\");let a=t.getUint8(i+1+n);if(a===192||a===193||a===194)return[t.getUint16(i+7+n,!1),t.getUint16(i+5+n,!1)];n+=i+2}throw new TypeError(\"Invalid JPEG\")}function Qu(e){let t=new Uint8Array(e.slice(6,10));return[t[0]|t[1]<<8,t[2]|t[3]<<8]}function Ju(e){let t=new DataView(e);return[t.getUint16(18,!1),t.getUint16(22,!1)]}var Kr=_o(100),Zr=new Map,Ku=[\"image/png\",\"image/jpeg\",\"image/gif\",\"image/svg+xml\"];function Zu(e){let t=\"\",n=new Uint8Array(e);for(let r=0;r<n.byteLength;r++)t+=String.fromCharCode(n[r]);return btoa(t)}async function fr(e){if(!e)throw new Error(\"Image source is not provided.\");if(e.startsWith(\"data:\"))return[e];if(!globalThis.fetch)throw new Error(\"`fetch` is required to be polyfilled to load images.\");if(Zr.has(e))return Zr.get(e);let t=Kr.get(e);if(t)return t;let n=new Promise((r,i)=>{fetch(e).then(a=>{let o=a.headers.get(\"content-type\");return o===\"image/svg+xml\"||o===\"application/svg+xml\"?a.text():a.arrayBuffer()}).then(a=>{if(typeof a==\"string\")try{let p=`data:image/svg+xml;base64,${btoa(a)}`,g=a.match(/<svg[^>]*>/)[0],m=g.match(/viewBox=\"0 0 (\\d+) (\\d+)\"/),d=g.match(/width=\"(\\d+)\"/),h=g.match(/height=\"(\\d+)\"/);!m&&d&&h&&(m=[null,d[1],h[1]]);let w=+m[1]/+m[2],b=d&&h?[+d[1],+h[1]]:d?[+d[1],+d[1]/w]:h?[+h[1]*w,+h[1]]:[+m[1],+m[2]];Kr.set(e,[p,...b]),r([p,...b]);return}catch(p){throw new Error(`Failed to parse SVG image: ${p.message}`)}let o,s;switch([...new Uint8Array(a.slice(0,4))].map(p=>p.toString(16)).join(\"\")){case\"89504e47\":o=\"image/png\",s=Ju(a);break;case\"47494638\":o=\"image/gif\",s=Qu(a);break;case\"ffd8ffe0\":case\"ffd8ffe1\":case\"ffd8ffe2\":case\"ffd8ffe3\":case\"ffd8ffe8\":case\"ffd8ffed\":case\"ffd8ffdb\":o=\"image/jpeg\",s=Xu(a);break}if(!Ku.includes(o))throw new Error(`Unsupported image type: ${o||\"unknown\"}`);let f=`data:${o};base64,${Zu(a)}`;Kr.set(e,[f,...s]),r([f,...s])}).catch(a=>{i(new Error(`Can't load image ${e}: `+a.message))})});return Zr.set(e,n),n}async function en(e,t,n,r,i){let a=Ae(),o={...n,...lr(To[t],n),...lr(r,n)};if(t===\"img\"){let[s,u,l]=await fr(i.src);if(u===void 0&&l===void 0){if(i.width===void 0||i.height===void 0)throw new Error(\"Image size cannot be determined. Please provide the width and height of the image.\");u=parseInt(i.width),l=parseInt(i.height)}let f=l/u,p=(o.borderLeftWidth||0)+(o.borderRightWidth||0)+(o.paddingLeft||0)+(o.paddingRight||0),g=(o.borderTopWidth||0)+(o.borderBottomWidth||0)+(o.paddingTop||0)+(o.paddingBottom||0),m=o.width||i.width,d=o.height||i.height,h=typeof m!=\"string\"&&typeof d!=\"string\";m!==void 0&&h&&(m-=p),d!==void 0&&h&&(d-=g),m===void 0&&d===void 0&&(m=u,d=l),m===void 0&&e.setAspectRatio(1/f),d===void 0&&e.setAspectRatio(1/f),o.width=h?m+p:m,o.height=h?d+g:d,o.__src=s}if(t===\"svg\"){let u=(i.viewBox||i.viewbox).split(\" \").map(g=>parseInt(g,10)),l=u[3]/u[2],{width:f,height:p}=i;typeof f>\"u\"&&p?typeof p==\"string\"&&p.endsWith(\"%\")?f=parseInt(p)/l+\"%\":f=parseInt(p)/l:typeof p>\"u\"&&f?typeof f==\"string\"&&f.endsWith(\"%\")?p=parseInt(f)*l+\"%\":p=parseInt(f)*l:(f||(f=u[2]),p||(p=u[3])),o.width||(o.width=f),o.height||(o.height=p)}return e.setDisplay(ae(o.display,{flex:a.DISPLAY_FLEX,none:a.DISPLAY_NONE},a.DISPLAY_FLEX,\"display\")),e.setAlignContent(ae(o.alignContent,{stretch:a.ALIGN_STRETCH,center:a.ALIGN_CENTER,\"flex-start\":a.ALIGN_FLEX_START,\"flex-end\":a.ALIGN_FLEX_END,\"space-between\":a.ALIGN_SPACE_BETWEEN,\"space-around\":a.ALIGN_SPACE_AROUND,baseline:a.ALIGN_BASELINE,normal:a.ALIGN_AUTO},a.ALIGN_AUTO,\"alignContent\")),e.setAlignItems(ae(o.alignItems,{stretch:a.ALIGN_STRETCH,center:a.ALIGN_CENTER,\"flex-start\":a.ALIGN_FLEX_START,\"flex-end\":a.ALIGN_FLEX_END,baseline:a.ALIGN_BASELINE,normal:a.ALIGN_AUTO},a.ALIGN_FLEX_START,\"alignItems\")),e.setAlignSelf(ae(o.alignSelf,{stretch:a.ALIGN_STRETCH,center:a.ALIGN_CENTER,\"flex-start\":a.ALIGN_FLEX_START,\"flex-end\":a.ALIGN_FLEX_END,baseline:a.ALIGN_BASELINE,normal:a.ALIGN_AUTO},a.ALIGN_AUTO,\"alignSelf\")),e.setJustifyContent(ae(o.justifyContent,{center:a.JUSTIFY_CENTER,\"flex-start\":a.JUSTIFY_FLEX_START,\"flex-end\":a.JUSTIFY_FLEX_END,\"space-between\":a.JUSTIFY_SPACE_BETWEEN,\"space-around\":a.JUSTIFY_SPACE_AROUND},a.JUSTIFY_FLEX_START,\"justifyContent\")),e.setFlexDirection(ae(o.flexDirection,{row:a.FLEX_DIRECTION_ROW,column:a.FLEX_DIRECTION_COLUMN,\"row-reverse\":a.FLEX_DIRECTION_ROW_REVERSE,\"column-reverse\":a.FLEX_DIRECTION_COLUMN_REVERSE},a.FLEX_DIRECTION_ROW,\"flexDirection\")),e.setFlexWrap(ae(o.flexWrap,{wrap:a.WRAP_WRAP,nowrap:a.WRAP_NO_WRAP,\"wrap-reverse\":a.WRAP_WRAP_REVERSE},a.WRAP_NO_WRAP,\"flexWrap\")),typeof o.flexBasis<\"u\"&&e.setFlexBasis(o.flexBasis),e.setFlexGrow(typeof o.flexGrow>\"u\"?0:o.flexGrow),e.setFlexShrink(typeof o.flexShrink>\"u\"?0:o.flexShrink),typeof o.maxHeight<\"u\"&&e.setMaxHeight(o.maxHeight),typeof o.maxWidth<\"u\"&&e.setMaxWidth(o.maxWidth),typeof o.minHeight<\"u\"&&e.setMinHeight(o.minHeight),typeof o.minWidth<\"u\"&&e.setMinWidth(o.minWidth),e.setOverflow(ae(o.overflow,{visible:a.OVERFLOW_VISIBLE,hidden:a.OVERFLOW_HIDDEN},a.OVERFLOW_VISIBLE,\"overflow\")),e.setMargin(a.EDGE_TOP,o.marginTop||0),e.setMargin(a.EDGE_BOTTOM,o.marginBottom||0),e.setMargin(a.EDGE_LEFT,o.marginLeft||0),e.setMargin(a.EDGE_RIGHT,o.marginRight||0),e.setBorder(a.EDGE_TOP,o.borderTopWidth||0),e.setBorder(a.EDGE_BOTTOM,o.borderBottomWidth||0),e.setBorder(a.EDGE_LEFT,o.borderLeftWidth||0),e.setBorder(a.EDGE_RIGHT,o.borderRightWidth||0),e.setPadding(a.EDGE_TOP,o.paddingTop||0),e.setPadding(a.EDGE_BOTTOM,o.paddingBottom||0),e.setPadding(a.EDGE_LEFT,o.paddingLeft||0),e.setPadding(a.EDGE_RIGHT,o.paddingRight||0),e.setPositionType(ae(o.position,{absolute:a.POSITION_TYPE_ABSOLUTE,relative:a.POSITION_TYPE_RELATIVE},a.POSITION_TYPE_RELATIVE,\"position\")),typeof o.top<\"u\"&&e.setPosition(a.EDGE_TOP,o.top),typeof o.bottom<\"u\"&&e.setPosition(a.EDGE_BOTTOM,o.bottom),typeof o.left<\"u\"&&e.setPosition(a.EDGE_LEFT,o.left),typeof o.right<\"u\"&&e.setPosition(a.EDGE_RIGHT,o.right),typeof o.height<\"u\"?e.setHeight(o.height):e.setHeightAuto(),typeof o.width<\"u\"?e.setWidth(o.width):e.setWidthAuto(),[o,Xr(o)]}c();c();c();var Ao=[1,0,0,1,0,0];function el(e,t,n){let r=[...Ao];for(let i of e){let a=Object.keys(i)[0],o=i[a];if(typeof o==\"string\")if(a===\"translateX\")o=parseFloat(o)/100*t,i[a]=o;else if(a===\"translateY\")o=parseFloat(o)/100*n,i[a]=o;else throw new Error(`Invalid transform: \"${a}: ${o}\".`);let s=o,u=[...Ao];switch(a){case\"translateX\":u[4]=s;break;case\"translateY\":u[5]=s;break;case\"scale\":u[0]=s,u[3]=s;break;case\"scaleX\":u[0]=s;break;case\"scaleY\":u[3]=s;break;case\"rotate\":let l=s*Math.PI/180,f=Math.cos(l),p=Math.sin(l);u[0]=f,u[1]=p,u[2]=-p,u[3]=f;break;case\"skewX\":u[2]=Math.tan(s*Math.PI/180);break;case\"skewY\":u[1]=Math.tan(s*Math.PI/180);break}r=pt(u,r)}e.splice(0,e.length),e.push(...r),e.__resolved=!0}function He({left:e,top:t,width:n,height:r},i,a,o){var l,f,p,g;let s;i.__resolved||el(i,n,r);let u=i;if(a)s=u;else{let m=(f=o==null?void 0:o.xAbsolute)!=null?f:((l=o==null?void 0:o.xRelative)!=null?l:50)*n/100,d=(g=o==null?void 0:o.yAbsolute)!=null?g:((p=o==null?void 0:o.yRelative)!=null?p:50)*r/100,h=e+m,w=t+d;s=pt([1,0,0,1,h,w],pt(u,[1,0,0,1,-h,-w])),u.__parent&&(s=pt(u.__parent,s)),u.splice(0,6,...s)}return`matrix(${s.map(m=>m.toFixed(2)).join(\",\")})`}function Io({left:e,top:t,width:n,height:r,isInheritingTransform:i},a){let o=\"\",s=1;return a.transform&&(o=He({left:e,top:t,width:n,height:r},a.transform,i,a.transformOrigin)),a.opacity!==void 0&&(s=+a.opacity),{matrix:o,opacity:s}}function tn({id:e,content:t,filter:n,left:r,top:i,width:a,height:o,matrix:s,opacity:u,image:l,clipPathId:f,debug:p,shape:g,decorationShape:m},d){let h=\"\";if(p&&(h=P(\"rect\",{x:r,y:i-o,width:a,height:o,fill:\"transparent\",stroke:\"#575eff\",\"stroke-width\":1,transform:s||void 0,\"clip-path\":f?`url(#${f})`:void 0})),l){let b={href:l,x:r,y:i,width:a,height:o,transform:s||void 0,\"clip-path\":f?`url(#${f})`:void 0,style:d.filter?`filter:${d.filter}`:void 0};return[(n?`${n}<g filter=\"url(#satori_s-${e})\">`:\"\")+P(\"image\",{...b,opacity:u!==1?u:void 0})+(m||\"\")+(n?\"</g>\":\"\")+h,\"\"]}let w={x:r,y:i,width:a,height:o,\"font-weight\":d.fontWeight,\"font-style\":d.fontStyle,\"font-size\":d.fontSize,\"font-family\":d.fontFamily,\"letter-spacing\":d.letterSpacing||void 0,transform:s||void 0,\"clip-path\":f?`url(#${f})`:void 0,style:d.filter?`filter:${d.filter}`:void 0};return[(n?`${n}<g filter=\"url(#satori_s-${e})\">`:\"\")+P(\"text\",{...w,fill:d.color,opacity:u!==1?u:void 0},t)+(m||\"\")+(n?\"</g>\":\"\")+h,g?P(\"text\",w,t):\"\"]}c();function tl(e,t,n){return e.replace(/([MA])([0-9.-]+),([0-9.-]+)/g,function(r,i,a,o){return i+(parseFloat(a)+t)+\",\"+(parseFloat(o)+n)})}function Ro({id:e,width:t,height:n},r){if(!r.shadowColor||!r.shadowOffset||typeof r.shadowRadius>\"u\")return\"\";let i=r.shadowRadius*r.shadowRadius/4,a=Math.min(r.shadowOffset.width-i,0),o=Math.max(r.shadowOffset.width+i+t,t),s=Math.min(r.shadowOffset.height-i,0),u=Math.max(r.shadowOffset.height+i+n,n);return`<defs><filter id=\"satori_s-${e}\" x=\"${a/t*100}%\" y=\"${s/n*100}%\" width=\"${(o-a)/t*100}%\" height=\"${(u-s)/n*100}%\"><feDropShadow dx=\"${r.shadowOffset.width}\" dy=\"${r.shadowOffset.height}\" stdDeviation=\"${r.shadowRadius/2}\" flood-color=\"${r.shadowColor}\" flood-opacity=\"1\"/></filter></defs>`}function cr({width:e,height:t,shape:n,opacity:r,id:i},a){if(!a.boxShadow)return null;let o=\"\",s=\"\";for(let u=a.boxShadow.length-1;u>=0;u--){let l=\"\",f=a.boxShadow[u];f.spreadRadius&&f.inset&&(f.spreadRadius=-f.spreadRadius);let p=f.blurRadius*f.blurRadius/4+(f.spreadRadius||0),g=Math.min(-p-(f.inset?f.offsetX:0),0),m=Math.max(p+e-(f.inset?f.offsetX:0),e),d=Math.min(-p-(f.inset?f.offsetY:0),0),h=Math.max(p+t-(f.inset?f.offsetY:0),t),w=`satori_s-${i}-${u}`,b=`satori_ms-${i}-${u}`,_=f.spreadRadius?n.replace('stroke-width=\"0\"',`stroke-width=\"${f.spreadRadius*2}\"`):n;l+=P(\"mask\",{id:b,maskUnits:\"userSpaceOnUse\"},P(\"rect\",{x:0,y:0,width:a._viewportWidth,height:a._viewportHeight,fill:f.inset?\"#000\":\"#fff\"})+_.replace('fill=\"#fff\"',f.inset?'fill=\"#fff\"':'fill=\"#000\"').replace('stroke=\"#fff\"',\"\"));let E=_.replace(/d=\"([^\"]+)\"/,(A,D)=>'d=\"'+tl(D,f.offsetX,f.offsetY)+'\"').replace(/x=\"([^\"]+)\"/,(A,D)=>'x=\"'+(parseFloat(D)+f.offsetX)+'\"').replace(/y=\"([^\"]+)\"/,(A,D)=>'y=\"'+(parseFloat(D)+f.offsetY)+'\"');f.spreadRadius&&f.spreadRadius<0&&(l+=P(\"mask\",{id:b+\"-neg\",maskUnits:\"userSpaceOnUse\"},E.replace('stroke=\"#fff\"','stroke=\"#000\"').replace(/stroke-width=\"[^\"]+\"/,`stroke-width=\"${-f.spreadRadius*2}\"`))),f.spreadRadius&&f.spreadRadius<0&&(E=P(\"g\",{mask:`url(#${b}-neg)`},E)),l+=P(\"defs\",{},P(\"filter\",{id:w,x:`${g/e*100}%`,y:`${d/t*100}%`,width:`${(m-g)/e*100}%`,height:`${(h-d)/t*100}%`},P(\"feGaussianBlur\",{stdDeviation:f.blurRadius/2,result:\"b\"})+P(\"feFlood\",{\"flood-color\":f.color,in:\"SourceGraphic\",result:\"f\"})+P(\"feComposite\",{in:\"f\",in2:\"b\",operator:f.inset?\"out\":\"in\"})))+P(\"g\",{mask:`url(#${b})`,filter:`url(#${w})`,opacity:r},E),f.inset?s+=l:o+=l}return[o,s]}c();function rn({width:e,left:t,top:n,ascender:r,clipPathId:i},a){let{textDecorationColor:o,textDecorationStyle:s,textDecorationLine:u,fontSize:l}=a;if(!u||u===\"none\")return\"\";let f=Math.max(1,l*.1),p=u===\"line-through\"?n+r*.5:u===\"underline\"?n+r*1.1:n,g=s===\"dashed\"?`${f*1.2} ${f*2}`:s===\"dotted\"?`0 ${f*2}`:void 0;return P(\"line\",{x1:t,y1:p,x2:t+e,y2:p,stroke:o,\"stroke-width\":f,\"stroke-dasharray\":g,\"stroke-linecap\":s===\"dotted\"?\"round\":\"square\",\"clip-path\":i?`url(#${i})`:void 0})}var nn=void 0;async function*on(e,t){var uo;let n=Ae(),{parentStyle:r,inheritedStyle:i,parent:a,font:o,id:s,isInheritingTransform:u,debug:l,embedFont:f,graphemeImages:p,canLoadAdditionalAssets:g}=t;r.textTransform===\"uppercase\"?e=e.toLocaleUpperCase(nn):r.textTransform===\"lowercase\"?e=e.toLocaleLowerCase(nn):r.textTransform===\"capitalize\"&&(e=je(e,\"word\").map(H=>je(H,\"grapheme\").map((Y,X)=>X===0?Y.toLocaleUpperCase(nn):Y).join(\"\")).join(\"\"));let m=ae(r.wordBreak,{normal:\"word\",\"break-all\":\"grapheme\",\"break-word\":\"grapheme\",\"keep-all\":\"word\"},\"word\",\"wordBreak\"),d=je(e,m),h=n.Node.create();h.setAlignItems(n.ALIGN_BASELINE),h.setJustifyContent(ae(r.textAlign,{left:n.JUSTIFY_FLEX_START,right:n.JUSTIFY_FLEX_END,center:n.JUSTIFY_CENTER,justify:n.JUSTIFY_SPACE_BETWEEN,start:n.JUSTIFY_FLEX_START,end:n.JUSTIFY_FLEX_END},n.JUSTIFY_FLEX_START,\"textAlign\")),a.insertChild(h,a.getChildCount());let{textAlign:w,textOverflow:b,whiteSpace:_,lineHeight:E,filter:A,_inheritedBackgroundClipTextPath:D}=r,M=r.fontSize,L=o.getEngine(M,E,r),F=g?d.filter(H=>!L.has(H)):[];yield F,F.length&&(L=o.getEngine(M,E,r));let N=[],U=[],q=[],K=[],ee=new Map,z=H=>{let Y=0;for(let X of H){if(ee.has(X)){Y+=ee.get(X);continue}let ue=L.measure(X,r);ee.set(X,ue),Y+=ue}return Y},Z=0,se=[],C=0;for(let H of d){let Y=!1,X=p&&p[H];_===\"pre\"?Y=H[0]===`\n`:_!==\"nowrap\"&&(X||ur.includes(H[0]))&&(Y=!0),Y?(_===\"nowrap\"?C+=z(se)+r.fontSize:(Z=Math.max(Z,z(se)),X&&(Z=Math.max(Z,r.fontSize))),se=[]):(!ur.includes(H[0])||!se.length)&&se.push(H===`\n`?\" \":H)}Z=Math.max(Z,z(se)+C);let I=a.getMinWidth(),B=a.getMaxWidth(),Se=a.getWidth();isNaN(Se.value)&&(isNaN(I.value)||I.unit===1&&I.value>Z)&&(isNaN(B.value)||B.unit===1&&(Z=Math.min(Z,B.value)),a.setMinWidth(Z)),typeof r.flexShrink>\"u\"&&a.setFlexShrink(1);let Nr=_===\"pre-wrap\"||_===\"pre\";h.setMeasureFunc(H=>{let Y=0,X=\"\",ue=0,de=0,pe=0,he=-1,Be=0,te=0,Ue=0;N=[],q=[0];for(let De=0;De<d.length;De++){let ie=d[De];if(!Nr&&ur.includes(ie[0]))X||(X=\" \"),ue=z([X]),K[De]=null;else{let ze=Nr&&ie===`\n`,me=ze?0:p&&p[ie]?r.fontSize:z([ie]);de||(X=\"\",ue=0);let oe=ue||\",.!?:-@)>]}%#\".indexOf(ie[0])<0,ge=!de||!!ue;if(ze||De&&oe&&de+ue+me>H&&_!==\"nowrap\"&&_!==\"pre\")N.push(de),U.push(Ue),Y++,Be+=te,de=me,te=me?L.height(ie):0,Ue=me?L.baseline(ie):0,q.push(1),he=-1,ze||(pe=Math.max(pe,H));else{de+=ue+me;let nt=L.height(ie);nt>te&&(te=nt,Ue=L.baseline(ie)),ge&&q[q.length-1]++}X=\"\",ue=0,ge&&he++,pe=Math.max(pe,de),K[De]={y:Be,x:de-me,width:me,line:Y,lineIndex:he}}}return de&&(Y++,N.push(de),U.push(Ue),Be+=te),{width:pe,height:Be}});let[ft,bu]=yield,Wr=\"\",Zt=\"\",Ce=i._inheritedClipPathId,ro=i._inheritedMaskId,{left:no,top:io,width:er,height:oo}=h.getComputedLayout(),$r=a.getComputedWidth()-a.getComputedPadding(n.EDGE_LEFT)-a.getComputedPadding(n.EDGE_RIGHT)-a.getComputedBorder(n.EDGE_LEFT)-a.getComputedBorder(n.EDGE_RIGHT),tt=ft+no,rt=bu+io,{matrix:Pe,opacity:tr}=Io({left:no,top:io,width:er,height:oo,isInheritingTransform:u},r),rr=\"\";r.textShadowOffset&&(rr=Ro({width:er,height:oo,id:s},{shadowColor:r.textShadowColor,shadowOffset:r.textShadowOffset,shadowRadius:r.textShadowRadius}));let ct=\"\",nr=\"\",ao=\"\",qr=-1,so=b===\"ellipsis\"?z([\"\\u2026\"]):0,yu=b===\"ellipsis\"?z([\" \"]):0,ir={};for(let H=0;H<d.length;H++){if(!K[H])continue;let Y=K[H],X=d[H],ue=null,de=p?p[X]:null,pe=Y.y,he=Y.x,Be=Y.width,te=Y.line;if(te===qr)continue;let Ue=!1;if(N.length>1){let oe=er-N[te];if(w===\"right\"||w===\"end\")he+=oe;else if(w===\"center\")he+=oe/2;else if(w===\"justify\"&&te<N.length-1){let ge=q[te];he+=(ge>1?oe/(ge-1):0)*Y.lineIndex,Ue=!0}}if(ir[te]||(ir[te]=[he,Ue?er:N[te]]),b===\"ellipsis\"&&N[te]>$r&&Y.x+Be+so+yu>$r){let oe=je(X,\"grapheme\"),ge=\"\",nt=0;for(let lo of oe){let fo=Y.x+z([ge+lo]);if(ge&&fo+so>$r)break;ge+=lo,nt=fo}X=ge+\"\\u2026\",qr=te,ir[te][1]=nt}let De=U[te],ie=L.baseline(X),ze=L.height(X),me=De-ie;if(de?pe+=0:f?(ue=L.getSVG(X,{...r,left:tt+he,top:rt+pe+ie+me,letterSpacing:r.letterSpacing}),l&&(ao+=P(\"rect\",{x:tt+he,y:rt+pe+me,width:Y.width,height:ze,fill:\"transparent\",stroke:\"#575eff\",\"stroke-width\":1,transform:Pe||void 0,\"clip-path\":Ce?`url(#${Ce})`:void 0})+P(\"line\",{x1:tt+he,x2:tt+he+Y.width,y1:rt+pe+me+ie,y2:rt+pe+me+ie,stroke:\"#14c000\",\"stroke-width\":1,transform:Pe||void 0,\"clip-path\":Ce?`url(#${Ce})`:void 0}))):pe+=ie+me,r.textDecorationLine&&(te!==((uo=K[H+1])==null?void 0:uo.line)||qr===te)){let oe=ir[te];oe&&!oe[2]&&(ct+=rn({left:tt+oe[0],top:rt+ze*+te,width:oe[1],ascender:L.baseline(X),clipPathId:Ce},r),oe[2]=1)}if(ue!==null)nr+=ue+\" \";else{let[oe,ge]=tn({content:X,filter:rr,id:s,left:tt+he,top:rt+pe,width:Be,height:ze,matrix:Pe,opacity:tr,image:de,clipPathId:Ce,debug:l,shape:!!D,decorationShape:ct},r);Wr+=oe,Zt+=ge,ct=\"\"}}if(nr){let H=r.color!==\"transparent\"&&tr!==0?P(\"path\",{fill:r.color,d:nr,transform:Pe||void 0,opacity:tr!==1?tr:void 0,\"clip-path\":Ce?`url(#${Ce})`:void 0,mask:ro?`url(#${ro})`:void 0,style:A?`filter:${A}`:void 0}):\"\";D&&(Zt=P(\"path\",{d:nr,transform:Pe||void 0})),Wr+=(rr?rr+P(\"g\",{filter:`url(#satori_s-${s})`},H+ct):H+ct)+ao}return Zt&&(r._inheritedBackgroundClipTextPath.value+=Zt),Wr}c();c();c();var an=an||{},Lo={type:\"directional\",value:\"bottom\"};an.parse=function(){var e={linearGradient:/^(\\-(webkit|o|ms|moz)\\-)?(linear\\-gradient)/i,repeatingLinearGradient:/^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-linear\\-gradient)/i,radialGradient:/^(\\-(webkit|o|ms|moz)\\-)?(radial\\-gradient)/i,repeatingRadialGradient:/^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-radial\\-gradient)/i,sideOrCorner:/^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,extentKeywords:/^(closest\\-side|closest\\-corner|farthest\\-side|farthest\\-corner|contain|cover)/,positionKeywords:/^(left|center|right|top|bottom)/i,pixelValue:/^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))px/,percentageValue:/^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))\\%/,emValue:/^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))em/,angleValue:/^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))deg/,startCall:/^\\(/,endCall:/^\\)/,comma:/^,/,hexColor:/^\\#([0-9a-fA-F]+)/,literalColor:/^([a-zA-Z]+)/,rgbColor:/^rgb/i,rgbaColor:/^rgba/i,number:/^(([0-9]*\\.[0-9]+)|([0-9]+\\.?))/},t=\"\";function n(C){var I=new Error(t+\": \"+C);throw I.source=t,I}function r(){var C=i();return t.length>0&&n(\"Invalid input not EOF\"),C}function i(){return E(a)}function a(){return o(\"linear-gradient\",e.linearGradient,u,Lo)||o(\"repeating-linear-gradient\",e.repeatingLinearGradient,u,Lo)||o(\"radial-gradient\",e.radialGradient,p)||o(\"repeating-radial-gradient\",e.repeatingRadialGradient,p)}function o(C,I,B,Se){return s(I,function(Nr){var ft=B();return ft?Z(e.comma)||n(\"Missing comma before color stops\"):ft=Se,{type:C,orientation:ft,colorStops:E(A)}})}function s(C,I){var B=Z(C);if(B){Z(e.startCall)||n(\"Missing (\");var Se=I(B);return Z(e.endCall)||n(\"Missing )\"),Se}}function u(){return l()||f()}function l(){return z(\"directional\",e.sideOrCorner,1)}function f(){return z(\"angular\",e.angleValue,1)}function p(){var C,I=g(),B;return I&&(C=[],C.push(I),B=t,Z(e.comma)&&(I=g(),I?C.push(I):t=B)),C}function g(){var C=m()||d();if(C)C.at=w();else{var I=h();if(I){C=I;var B=w();B&&(C.at=B)}else{var Se=b();Se&&(C={type:\"default-radial\",at:Se})}}return C}function m(){var C=z(\"shape\",/^(circle)/i,0);return C&&(C.style=ee()||h()),C}function d(){var C=z(\"shape\",/^(ellipse)/i,0);return C&&(C.style=q()||h()),C}function h(){return z(\"extent-keyword\",e.extentKeywords,1)}function w(){if(z(\"position\",/^at/,0)){var C=b();return C||n(\"Missing positioning value\"),C}}function b(){var C=_();if(C.x||C.y)return{type:\"position\",value:C}}function _(){return{x:q(),y:q()}}function E(C){var I=C(),B=[];if(I)for(B.push(I);Z(e.comma);)I=C(),I?B.push(I):n(\"One extra comma\");return B}function A(){var C=D();return C||n(\"Expected color definition\"),C.length=q(),C}function D(){return L()||N()||F()||M()}function M(){return z(\"literal\",e.literalColor,0)}function L(){return z(\"hex\",e.hexColor,1)}function F(){return s(e.rgbColor,function(){return{type:\"rgb\",value:E(U)}})}function N(){return s(e.rgbaColor,function(){return{type:\"rgba\",value:E(U)}})}function U(){return Z(e.number)[1]}function q(){return z(\"%\",e.percentageValue,1)||K()||ee()}function K(){return z(\"position-keyword\",e.positionKeywords,1)}function ee(){return z(\"px\",e.pixelValue,1)||z(\"em\",e.emValue,1)}function z(C,I,B){var Se=Z(I);if(Se)return{type:C,value:Se[B]}}function Z(C){var I,B;return B=/^[\\n\\r\\t\\s]+/.exec(t),B&&se(B[0].length),I=C.exec(t),I&&se(I[0].length),I}function se(C){t=t.substr(C)}return function(C){return t=C.toString(),r()}}();var sn=an;function rl(e){return e.type===\"literal\"?e.value:e.type===\"hex\"?`#${e.value}`:e.type===\"rgb\"?`rgb(${e.value.join(\",\")})`:e.type===\"rgba\"?`rgba(${e.value.join(\",\")})`:\"transparent\"}function nl(e,t){return typeof e==\"string\"&&e.endsWith(\"%\")?t*parseFloat(e)/100:+e}function un(e,{x:t,y:n,defaultX:r,defaultY:i}){return(e?e.split(\" \").map(a=>{try{let o=new Fe(a);return o.type===\"length\"||o.type===\"number\"?o.value:o.value+o.unit}catch{return null}}).filter(a=>a!==null):[r,i]).map((a,o)=>nl(a,[t,n][o]))}function Co(e,t){let n=[];for(let o of t){let s=rl(o);if(!n.length&&(n.push({offset:0,color:s}),typeof o.length>\"u\"||o.length.value===\"0\"))continue;let u=typeof o.length>\"u\"?void 0:o.length.type===\"%\"?o.length.value/100:o.length.value/e;n.push({offset:u,color:s})}n.length||n.push({offset:0,color:\"transparent\"});let r=n[n.length-1];r.offset!==1&&(typeof r.offset>\"u\"?r.offset=1:n.push({offset:1,color:r.color}));let i=0,a=1;for(let o=0;o<n.length;o++)if(typeof n[o].offset>\"u\"){for(a<o&&(a=o);typeof n[a].offset>\"u\";)a++;n[o].offset=(n[a].offset-n[i].offset)/(a-i)*(o-i)+n[i].offset}else i=o;return n}async function ln({id:e,width:t,height:n},{image:r,size:i,position:a,repeat:o}){o=o||\"repeat\";let s=o===\"repeat-x\"||o===\"repeat\",u=o===\"repeat-y\"||o===\"repeat\",l=un(i,{x:t,y:n,defaultX:t,defaultY:n}),f=un(a,{x:t,y:n,defaultX:0,defaultY:0});if(r.startsWith(\"linear-gradient(\")){let p=sn.parse(r)[0],[g,m]=l,d,h,w,b;if(p.orientation.type===\"directional\")[d,h,w,b]={top:[0,1,0,0],bottom:[0,0,0,1],left:[1,0,0,0],right:[0,0,1,0]}[p.orientation.value];else if(p.orientation.type===\"angular\"){let M=+p.orientation.value/180*Math.PI-Math.PI/2,L=Math.cos(M),F=Math.sin(M);d=0,h=0,w=L,b=F,w<0&&(d-=w,w=0),b<0&&(h-=b,b=0)}let _=Co(t,p.colorStops),E=`satori_bi${e}`,A=`satori_pattern_${e}`,D=P(\"pattern\",{id:A,x:f[0]/t,y:f[1]/n,width:s?g/t:\"1\",height:u?m/n:\"1\",patternUnits:\"objectBoundingBox\"},P(\"linearGradient\",{id:E,x1:d,y1:h,x2:w,y2:b},_.map(M=>P(\"stop\",{offset:M.offset*100+\"%\",\"stop-color\":M.color})).join(\"\"))+P(\"rect\",{x:0,y:0,width:g,height:m,fill:`url(#${E})`}));return[A,D]}if(r.startsWith(\"radial-gradient(\")){let p=sn.parse(r)[0],g=p.orientation[0],[m,d]=l,h=\"circle\",w=m/2,b=d/2;if(g.type===\"shape\"){if(h=g.value,g.at)if(g.at.type===\"position\")w=g.at.value.x.value,b=g.at.value.y.value;else throw new Error(\"orientation.at.type not implemented: \"+g.at.type)}else throw new Error(\"orientation.type not implemented: \"+g.type);let _=Co(t,p.colorStops),E=`satori_radial_${e}`,A=`satori_pattern_${e}`,D=`satori_mask_${e}`,M={},L=Math.max(Math.abs(m-w),Math.abs(w)),F=Math.max(Math.abs(d-b),Math.abs(b));if(h===\"circle\")M.r=Math.sqrt(L*L+F*F);else if(h===\"ellipse\"){let q=F!==0?L/F:1;M.ry=Math.sqrt(L*L+F*F*q*q)/q,M.rx=M.ry*q}let N=P(\"pattern\",{id:A,x:f[0]/t,y:f[1]/n,width:s?m/t:\"1\",height:u?d/n:\"1\",patternUnits:\"objectBoundingBox\"},P(\"radialGradient\",{id:E},_.map(q=>P(\"stop\",{offset:q.offset,\"stop-color\":q.color})).join(\"\"))+P(\"mask\",{id:D},P(\"rect\",{x:0,y:0,width:m,height:d,fill:\"#fff\"}))+P(h,{cx:w,cy:b,width:m,height:d,...M,fill:`url(#${E})`,mask:`url(#${D})`}));return[A,N]}if(r.startsWith(\"url(\")){let p=un(i,{x:t,y:n,defaultX:0,defaultY:0}),[g,m,d]=await fr(r.slice(4,-1)),h=p[0]||m,w=p[1]||d;return[`satori_bi${e}`,P(\"pattern\",{id:`satori_bi${e}`,patternContentUnits:\"userSpaceOnUse\",patternUnits:\"userSpaceOnUse\",x:f[0],y:f[1],width:s?h:\"100%\",height:u?w:\"100%\"},P(\"image\",{x:0,y:0,width:h,height:w,preserveAspectRatio:\"none\",href:g}))]}throw new Error(`Invalid background image: \"${r}\"`)}c();function il([e,t]){return Math.round(e*1e3)===0&&Math.round(t*1e3)===0?0:Math.round(e*t/Math.sqrt(e*e+t*t)*1e3)/1e3}function dr(e,t,n){return n<e+t&&(n/2<e&&n/2<t?e=t=n/2:n/2<e?e=n-t:n/2<t&&(t=n-e)),[e,t]}function pr(e){e[0]=e[1]=Math.min(e[0],e[1])}function hr(e,t,n,r,i){if(typeof e==\"string\"){let a=e.split(\" \").map(s=>s.trim()),o=!a[1]&&!a[0].endsWith(\"%\");return a[1]=a[1]||a[0],[o,[Math.min(Ge(a[0],r,t,i,!0),t),Math.min(Ge(a[1],r,n,i,!0),n)]]}return typeof e==\"number\"?[!0,[Math.min(e,t),Math.min(e,n)]]:[!0,void 0]}function Me({left:e,top:t,width:n,height:r},i,a){let{borderTopLeftRadius:o,borderTopRightRadius:s,borderBottomLeftRadius:u,borderBottomRightRadius:l,fontSize:f}=i,p,g,m,d;if([p,o]=hr(o,n,r,f,i),[g,s]=hr(s,n,r,f,i),[m,u]=hr(u,n,r,f,i),[d,l]=hr(l,n,r,f,i),!a&&!o&&!s&&!u&&!l)return\"\";o||(o=[0,0]),s||(s=[0,0]),u||(u=[0,0]),l||(l=[0,0]),[o[0],s[0]]=dr(o[0],s[0],n),[u[0],l[0]]=dr(u[0],l[0],n),[o[1],u[1]]=dr(o[1],u[1],r),[s[1],l[1]]=dr(s[1],l[1],r),p&&pr(o),g&&pr(s),m&&pr(u),d&&pr(l);let h=[];h[0]=[s,s],h[1]=[l,[-l[0],l[1]]],h[2]=[u,[-u[0],-u[1]]],h[3]=[o,[o[0],-o[1]]];let w=`h${n-o[0]-s[0]} a${h[0][0]} 0 0 1 ${h[0][1]}`,b=`v${r-s[1]-l[1]} a${h[1][0]} 0 0 1 ${h[1][1]}`,_=`h${l[0]+u[0]-n} a${h[2][0]} 0 0 1 ${h[2][1]}`,E=`v${u[1]+o[1]-r} a${h[3][0]} 0 0 1 ${h[3][1]}`;if(a){let D=function(K){let ee=il([o,s,l,u][K]);return K===0?[[e+o[0]-ee,t+o[1]-ee],[e+o[0],t]]:K===1?[[e+n-s[0]+ee,t+s[1]-ee],[e+n,t+s[1]]]:K===2?[[e+n-l[0]+ee,t+r-l[1]+ee],[e+n-l[0],t+r]]:[[e+u[0]-ee,t+r-u[1]+ee],[e,t+r-u[1]]]},A=a.indexOf(!1);if(!a.includes(!0))throw new Error(\"Invalid `partialSides`.\");if(A===-1)A=0;else for(;!a[A];)A=(A+1)%4;let M=\"\",L=D(A),F=`M${L[0]} A${h[(A+3)%4][0]} 0 0 1 ${L[1]}`,N=0;for(;N<4&&a[(A+N)%4];N++)M+=F+\" \",F=[w,b,_,E][(A+N)%4];let U=(A+N)%4;M+=F.split(\" \")[0];let q=D(U);return M+=` A${h[(U+3)%4][0]} 0 0 1 ${q[0]}`,M}return`M${e+o[0]},${t} ${w} ${b} ${_} ${E}`}c();c();c();function Do(e,t,n){return n[e+\"Width\"]===n[t+\"Width\"]&&n[e+\"Style\"]===n[t+\"Style\"]&&n[e+\"Color\"]===n[t+\"Color\"]}function mr({id:e,currentClipPathId:t,borderPath:n,borderType:r,left:i,top:a,width:o,height:s},u){if(!(u.borderTopWidth||u.borderRightWidth||u.borderBottomWidth||u.borderLeftWidth))return null;let f=`satori_bc-${e}`;return[P(\"clipPath\",{id:f,\"clip-path\":t?`url(#${t})`:void 0},P(r,{x:i,y:a,width:o,height:s,d:n||void 0})),f]}function Ye({left:e,top:t,width:n,height:r,props:i,asContentMask:a,maskBorderOnly:o},s){let u=[\"borderTop\",\"borderRight\",\"borderBottom\",\"borderLeft\"];if(!a&&!u.some(m=>s[m+\"Width\"]))return\"\";let l=\"\",f=0;for(;f>0&&Do(u[f],u[(f+3)%4],s);)f=(f+3)%4;let p=[!1,!1,!1,!1],g=[];for(let m=0;m<4;m++){let d=(f+m)%4,h=(f+m+1)%4,w=u[d],b=u[h];if(p[d]=!0,g=[s[w+\"Width\"],s[w+\"Style\"],s[w+\"Color\"],w],!Do(w,b,s)){let _=(g[0]||0)+(a&&!o&&s[w.replace(\"border\",\"padding\")]||0);_&&(l+=P(\"path\",{width:n,height:r,...i,fill:\"none\",stroke:a?\"#000\":g[2],\"stroke-width\":_*2,\"stroke-dasharray\":!a&&g[1]===\"dashed\"?_*2+\" \"+_:void 0,d:Me({left:e,top:t,width:n,height:r},s,p)})),p=[!1,!1,!1,!1]}}if(p.some(Boolean)){let m=(g[0]||0)+(a&&!o&&s[g[3].replace(\"border\",\"padding\")]||0);m&&(l+=P(\"path\",{width:n,height:r,...i,fill:\"none\",stroke:a?\"#000\":g[2],\"stroke-width\":m*2,\"stroke-dasharray\":!a&&g[1]===\"dashed\"?m*2+\" \"+m:void 0,d:Me({left:e,top:t,width:n,height:r},s,p)}))}return l}function mt({id:e,left:t,top:n,width:r,height:i,matrix:a,borderOnly:o},s){let u=(s.borderLeftWidth||0)+(o?0:s.paddingLeft||0),l=(s.borderTopWidth||0)+(o?0:s.paddingTop||0),f=(s.borderRightWidth||0)+(o?0:s.paddingRight||0),p=(s.borderBottomWidth||0)+(o?0:s.paddingBottom||0),g={x:t+u,y:n+l,width:r-u-f,height:i-l-p};return P(\"mask\",{id:e},P(\"rect\",{...g,fill:\"#fff\",mask:s._inheritedMaskId?`url(#${s._inheritedMaskId})`:void 0})+Ye({left:t,top:n,width:r,height:i,props:{transform:a||void 0},asContentMask:!0,maskBorderOnly:o},s))}function fn({left:e,top:t,width:n,height:r,path:i,matrix:a,id:o},s){if(s.overflow!==\"hidden\")return\"\";let u=mt({id:`satori_om-${o}`,left:e,top:t,width:n,height:r,matrix:a,borderOnly:!0},s);return P(\"clipPath\",{id:`satori_cp-${o}`,\"clip-path\":s._inheritedClipPathId?`url(#${s._inheritedClipPathId})`:void 0},P(i?\"path\":\"rect\",{x:e,y:t,width:n,height:r,d:i||void 0}))+u}async function cn({id:e,left:t,top:n,width:r,height:i,isInheritingTransform:a,debug:o},s){if(s.display===\"none\")return\"\";let u=\"rect\",l=\"\",f=\"\",p=[],g=1,m=\"\";s.backgroundColor&&p.push(s.backgroundColor),s.opacity!==void 0&&(g=+s.opacity),s.transform&&(l=He({left:t,top:n,width:r,height:i},s.transform,a,s.transformOrigin));let d=\"\";if(s.backgroundImage){let N=[];for(let U=0;U<s.backgroundImage.length;U++){let q=s.backgroundImage[U],K=await ln({id:e+\"_\"+U,width:r,height:i},q);K&&N.unshift(K)}for(let U of N)p.push(`url(#${U[0]})`),f+=U[1],U[2]&&(d+=U[2])}let h=Me({left:t,top:n,width:r,height:i},s);h&&(u=\"path\");let w=fn({left:t,top:n,width:r,height:i,path:h,id:e,matrix:l},s),b=s._inheritedClipPathId,_=s._inheritedMaskId;o&&(m=P(\"rect\",{x:t,y:n,width:r,height:i,fill:\"transparent\",stroke:\"#ff5757\",\"stroke-width\":1,transform:l||void 0,\"clip-path\":b?`url(#${b})`:void 0}));let{backgroundClip:E,filter:A}=s,D=E===\"text\"?`url(#satori_bct-${e})`:b?`url(#${b})`:void 0,M=p.map(N=>P(u,{x:t,y:n,width:r,height:i,fill:N,d:h||void 0,transform:l||void 0,\"clip-path\":D,style:A?`filter:${A}`:void 0,mask:_?`url(#${_})`:void 0})).join(\"\"),L=mr({id:e,left:t,top:n,width:r,height:i,currentClipPathId:b,borderPath:h,borderType:u},s);if(L){f+=L[0];let N=L[1];M+=Ye({left:t,top:n,width:r,height:i,props:{transform:l||void 0,\"clip-path\":`url(#${N})`}},s)}let F=cr({width:r,height:i,id:e,opacity:g,shape:P(u,{x:t,y:n,width:r,height:i,fill:\"#fff\",stroke:\"#fff\",\"stroke-width\":0,d:h||void 0,transform:l||void 0,\"clip-path\":D,mask:_?`url(#${_})`:void 0})},s);return(f?P(\"defs\",{},f):\"\")+(F?F[0]:\"\")+w+(g!==1?`<g opacity=\"${g}\">`:\"\")+(d||M)+(g!==1?\"</g>\":\"\")+(F?F[1]:\"\")+m}c();function gr({id:e,left:t,top:n,width:r,height:i,src:a,debug:o,isInheritingTransform:s},u){if(u.display===\"none\")return\"\";let l=\"\",f=\"\",p=\"\",g=1,m=\"\",d=\"\",h=\"\";u.transform&&(m=He({left:t,top:n,width:r,height:i},u.transform,s,u.transformOrigin));let w=u.objectFit===\"contain\"?\"xMidYMid\":u.objectFit===\"cover\"?\"xMidYMid slice\":\"none\",b=Me({left:t,top:n,width:r,height:i},u),_=u._inheritedClipPathId,E=u._inheritedMaskId;b&&(p=P(\"clipPath\",{id:`satori_c-${e}`,\"clip-path\":_?`url(#${_})`:void 0},P(\"path\",{x:t,y:n,width:r,height:i,d:b})));let A=mr({id:e,left:t,top:n,width:r,height:i,currentClipPathId:_,borderPath:b,borderType:b?\"path\":\"rect\"},u);if(A){d+=A[0];let U=A[1];h+=Ye({left:t,top:n,width:r,height:i,props:{transform:m||void 0,\"clip-path\":`url(#${U})`,mask:E?`url(#${E})`:void 0}},u)}u.opacity&&(g=+u.opacity);let D=cr({width:r,height:i,id:e,opacity:g,shape:P(b?\"path\":\"rect\",{x:t,y:n,width:r,height:i,fill:\"#fff\",d:b||void 0,transform:m||void 0,\"clip-path\":_?`url(#${_})`:void 0,mask:E?`url(#${E})`:void 0})},u);b&&(l=`satori_cm-${e}`,f=mt({id:`satori_cm-${e}`,left:t,top:n,width:r,height:i,matrix:m},u));let M=(u.borderLeftWidth||0)+(u.paddingLeft||0),L=(u.borderTopWidth||0)+(u.paddingTop||0),F=(u.borderRightWidth||0)+(u.paddingRight||0),N=(u.borderBottomWidth||0)+(u.paddingBottom||0);return(d?P(\"defs\",{},d):\"\")+f+(D?D[0]:\"\")+p+P(\"image\",{x:t+M,y:n+L,width:r-M-F,height:i-L-N,href:a,preserveAspectRatio:w,opacity:g,transform:m||void 0,\"clip-path\":p?`url(#satori_c-${e})`:_?`url(#${_})`:void 0,mask:l?`url(#${l})`:void 0})+(D?D[1]:\"\")+h}async function*gt(e,t){let n=Ae(),{id:r,inheritedStyle:i,parent:a,font:o,debug:s,embedFont:u=!0,graphemeImages:l,canLoadAdditionalAssets:f,getTwStyles:p}=t;if(e===null||typeof e>\"u\")return yield,yield,\"\";if(!Yr(e)||typeof e.type==\"function\"){let I;if(!Yr(e))I=on(String(e),t),yield(await I.next()).value;else{if(xo(e.type))throw new Error(\"Class component is not supported.\");I=gt(e.type(e.props),t),yield(await I.next()).value}await I.next();let B=yield;return(await I.next(B)).value}let{type:g,props:m}=e,{style:d,children:h,tw:w}=m||{};if(w){let I=p(w,d);d=Object.assign(I,d)}let b=n.Node.create();a.insertChild(b,a.getChildCount());let[_,E]=await en(b,g,i,d,m),A=_.transform===i.transform;if(A||(_.transform.__parent=i.transform),_.overflow===\"hidden\"&&(E._inheritedClipPathId=`satori_cp-${r}`,E._inheritedMaskId=`satori_om-${r}`),_.backgroundClip===\"text\"){let I={value:\"\"};E._inheritedBackgroundClipTextPath=I,_._inheritedBackgroundClipTextPath=I}let D=wo(h),M=[],L=0,F=[];for(let I of D){let B=gt(I,{id:r+\"-\"+L++,parentStyle:_,inheritedStyle:E,isInheritingTransform:!0,parent:b,font:o,embedFont:u,debug:s,graphemeImages:l,canLoadAdditionalAssets:f,getTwStyles:p});f?F.push(...(await B.next()).value||[]):await B.next(),M.push(B)}yield F;for(let I of M)await I.next();let[N,U]=yield,{left:q,top:K,width:ee,height:z}=b.getComputedLayout();q+=N,K+=U;let Z=\"\",se=\"\",C=\"\";if(g===\"img\"){let I=_.__src;se=gr({id:r,left:q,top:K,width:ee,height:z,src:I,isInheritingTransform:A,debug:s},_)}else if(g===\"svg\"){let I=ko(e);se=gr({id:r,left:q,top:K,width:ee,height:z,src:I,isInheritingTransform:A,debug:s},_)}else{let I=d==null?void 0:d.display;if(g===\"div\"&&h&&typeof h!=\"string\"&&I!==\"flex\"&&I!==\"none\")throw new Error('Expected <div> to have explicit \"display: flex\" or \"display: none\" if it has more than one child node.');se=await cn({id:r,left:q,top:K,width:ee,height:z,isInheritingTransform:A,debug:s},_)}for(let I of M)Z+=(await I.next([q,K])).value;return _._inheritedBackgroundClipTextPath&&(C+=P(\"clipPath\",{id:`satori_bct-${r}`,\"clip-path\":_._inheritedClipPathId?`url(#${_._inheritedClipPathId})`:void 0},_._inheritedBackgroundClipTextPath.value)),C+se+Z}c();function ol(e,t,[n,r],[i,a]){if(n!==i)return n?!i||n===e?-1:i===e?1:e===400&&n===500||e===500&&n===400?-1:e===400&&i===500||e===500&&i===400?1:e<400?n<e&&i<e?i-n:n<e?-1:i<e?1:n-i:e<n&&e<i?n-i:e<n?-1:e<i?1:i-n:1;if(r!==a){if(r===t)return-1;if(a===t)return 1}return-1}var vt=class{constructor(t){this.fonts=new Map;this.addFonts(t)}get({name:t,weight:n,style:r}){if(!this.fonts.has(t))return null;n===\"normal\"&&(n=400),n===\"bold\"&&(n=700);let i=[...this.fonts.get(t)],a=i[0];for(let o=1;o<i.length;o++){let[,s,u]=a,[,l,f]=i[o];ol(n,r,[s,u],[l,f])>0&&(a=i[o])}return a[0]}addFonts(t){for(let n of t){let r=n.data,i=_shuding_opentype_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].parse(\"buffer\"in r?r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength):r,{lowMemory:!0}),a=i.charToGlyphIndex;i.charToGlyphIndex=s=>{let u=a.call(i,s);return u===0&&i._trackBrokenChars&&i._trackBrokenChars.push(s),u},this.defaultFont||(this.defaultFont=i);let o=n.name.toLowerCase();this.fonts.has(o)||this.fonts.set(o,[]),this.fonts.get(o).push([i,n.weight,n.style])}}getEngine(t=16,n=1.2,{fontFamily:r,fontWeight:i=400,fontStyle:a=\"normal\"}){if(!this.fonts.size)throw new Error(\"No fonts are loaded. At least one font is required to calculate the layout.\");r=(Array.isArray(r)?r:[r]).map(d=>d.toLowerCase());let o=r.map(d=>this.get({name:d,weight:i,style:a})).filter(Boolean),s=Array.from(this.fonts.keys());for(let d of s)r.includes(d)||o.push(this.get({name:d,weight:i,style:a}));let u=new Map,l=(d,h=!0)=>{let w=d.charCodeAt(0);if(u.has(w))return u.get(w);let b=o.find((_,E)=>!!_.charToGlyphIndex(d)||h&&E===o.length-1);return b&&u.set(w,b),b},f=(d,h=!1)=>{var b,_;return((h?(_=(b=d.tables)==null?void 0:b.os2)==null?void 0:_.sTypoAscender:0)||d.ascender)/d.unitsPerEm*t},p=(d,h=!1)=>{var b,_;return((h?(_=(b=d.tables)==null?void 0:b.os2)==null?void 0:_.sTypoDescender:0)||d.descender)/d.unitsPerEm*t},g=d=>l(d,!1),m={has:d=>{if(d===`\n`)return!0;let h=g(d);return h?(h._trackBrokenChars=[],h.stringToGlyphs(d),h._trackBrokenChars.length?(h._trackBrokenChars=void 0,!1):!0):!1},baseline:(d,h=typeof d>\"u\"?o[0]:l(d))=>{let w=f(h,!0),b=p(h,!0),_=m.height(d,h),{yMax:E,yMin:A}=h.tables.head,D=w-b,M=(E/(E-A)-1)*D;return _*((1.2/n+1)/2)+M},height:(d,h=typeof d>\"u\"?o[0]:l(d))=>(f(h)-p(h))*(n/1.2),measure:(d,h)=>this.measure(l,d,h),getSVG:(d,h)=>this.getSVG(l,d,h)};return m}patchFontFallbackResolver(t,n){let r=[];t._trackBrokenChars=r;let i=t.stringToGlyphs;return t.stringToGlyphs=(a,...o)=>{let s=i.call(t,a,...o);for(let u=0;u<s.length;u++)if(s[u].unicode===void 0){let l=r.shift(),f=n(l);if(f!==t){let p=f.charToGlyph(l),g=t.unitsPerEm/f.unitsPerEm,m=new _shuding_opentype_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Path;m.unitsPerEm=t.unitsPerEm,m.commands=p.path.commands.map(h=>{let w={...h};for(let b in w)typeof w[b]==\"number\"&&(w[b]*=g);return w});let d=new _shuding_opentype_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Glyph({...p,advanceWidth:p.advanceWidth*g,xMin:p.xMin*g,xMax:p.xMax*g,yMin:p.yMin*g,yMax:p.yMax*g,path:m});s[u]=d}}return s},()=>{t.stringToGlyphs=i,t._trackBrokenChars=void 0}}measure(t,n,{fontSize:r,letterSpacing:i=0}){let a=t(n),o=this.patchFontFallbackResolver(a,t);try{return a.getAdvanceWidth(n,r,{letterSpacing:i/r})}finally{o()}}getSVG(t,n,{fontSize:r,top:i,left:a,letterSpacing:o=0}){let s=t(n),u=this.patchFontFallbackResolver(s,t);try{return r===0?\"\":s.getPath(n.replace(/\\n/g,\"\"),a,i,r,{letterSpacing:o/r}).toPathData(1)}finally{u()}}};c();function pn({width:e,height:t,content:n}){return P(\"svg\",{width:e,height:t,viewBox:`0 0 ${e} ${t}`,xmlns:\"http://www.w3.org/2000/svg\"},n)}c();var Fo={emoji:/\\p{RI}\\p{RI}|\\p{Emoji}(\\p{EMod}+|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?(\\u{200D}\\p{Emoji}(\\p{EMod}+|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?)+|\\p{EPres}(\\p{EMod}+|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?|\\p{Emoji}(\\p{EMod}+|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})|[\\u{E000}-\\u{F8FF}]|[\\u{F0000}-\\u{FFFFD}]|[\\u{100000}-\\u{10FFFD}]/u,ja:/\\p{scx=Hira}|\\p{scx=Kana}|[，；：]/u,ko:/\\p{scx=Hangul}/u,zh:/\\p{scx=Han}/u,th:/\\p{scx=Thai}/u,bn:/\\p{scx=Bengali}/u,ar:/\\p{scx=Arabic}/u,ta:/\\p{scx=Tamil}/u,ml:/\\p{scx=Malayalam}/u,he:/\\p{scx=Hebrew}/u,te:/\\p{scx=Telugu}/u,devanagari:/\\p{scx=Devanagari}/u};function Mo(e){for(let t in Fo)if(Fo[t].test(e))return t;return\"unknown\"}c();c();var mu=Tu(Vs());c();c();c();c();var Vh=[\"ios\",\"android\",\"windows\",\"macos\",\"web\"];function Ys(e){return Vh.includes(e)}var Hh=[\"portrait\",\"landscape\"];function Xs(e){return Hh.includes(e)}var Hs;(function(e){e.fontSize=\"fontSize\",e.lineHeight=\"lineHeight\"})(Hs||(Hs={}));var $;(function(e){e.rem=\"rem\",e.em=\"em\",e.px=\"px\",e.percent=\"%\",e.vw=\"vw\",e.vh=\"vh\",e.none=\"<no-css-unit>\"})($||($={}));function $i(e){return typeof e==\"string\"}function qi(e){return typeof e==\"object\"}var Bi;function v(e){return{kind:\"complete\",style:e}}function re(e,t={}){let{fractions:n}=t;if(n&&e.includes(\"/\")){let[a=\"\",o=\"\"]=e.split(\"/\",2),s=re(a),u=re(o);return!s||!u?null:[s[0]/u[0],u[1]]}let r=parseFloat(e);if(Number.isNaN(r))return null;let i=e.match(/(([a-z]{2,}|%))$/);if(!i)return[r,$.none];switch(i==null?void 0:i[1]){case\"rem\":return[r,$.rem];case\"px\":return[r,$.px];case\"em\":return[r,$.em];case\"%\":return[r,$.percent];case\"vw\":return[r,$.vw];case\"vh\":return[r,$.vh];default:return null}}function Le(e,t,n={}){let r=Ee(t,n);return r===null?null:v({[e]:r})}function Dr(e,t,n){let r=Ee(t);return r!==null&&(n[e]=r),n}function Js(e,t){let n=Ee(t);return n===null?null:{[e]:n}}function Ee(e,t={}){if(e===void 0)return null;let n=re(String(e),t);return n?qe(...n,t):null}function qe(e,t,n={}){let{isNegative:r,device:i}=n;switch(t){case $.rem:return e*16*(r?-1:1);case $.px:return e*(r?-1:1);case $.percent:return`${r?\"-\":\"\"}${e}%`;case $.none:return e*(r?-1:1);case $.vw:return i!=null&&i.windowDimensions?i.windowDimensions.width*(e/100):(ce(\"`vw` CSS unit requires configuration with `useDeviceContext()`\"),null);case $.vh:return i!=null&&i.windowDimensions?i.windowDimensions.height*(e/100):(ce(\"`vh` CSS unit requires configuration with `useDeviceContext()`\"),null);default:return null}}function Ui(e){let t=re(e);if(!t)return null;let[n,r]=t;switch(r){case $.rem:return n*16;case $.px:return n;default:return null}}var Yh={t:\"Top\",tr:\"TopRight\",tl:\"TopLeft\",b:\"Bottom\",br:\"BottomRight\",bl:\"BottomLeft\",l:\"Left\",r:\"Right\",x:\"Horizontal\",y:\"Vertical\"};function zi(e){return Yh[e!=null?e:\"\"]||\"All\"}function Gi(e){let t=\"All\";return[e.replace(/^-(t|b|r|l|tr|tl|br|bl)(-|$)/,(r,i)=>(t=zi(i),\"\")),t]}function Ze(e,t={}){if(e.includes(\"/\")){let n=Qs(e,{...t,fractions:!0});if(n)return n}return e[0]===\"[\"&&(e=e.slice(1,-1)),Qs(e,t)}function _e(e,t,n={}){let r=Ze(t,n);return r===null?null:v({[e]:r})}function Qs(e,t={}){if(e===\"px\")return 1;let n=re(e,t);if(!n)return null;let[r,i]=n;return t.fractions&&(i=$.percent,r*=100),i===$.none&&(r=r/4,i=$.rem),qe(r,i,t)}function Xh(...e){console.warn(...e)}function Qh(...e){}var ce=typeof process>\"u\"||((Bi=process==null?void 0:process.env)===null||Bi===void 0?void 0:Bi.JEST_WORKER_ID)===void 0?Xh:Qh;var Jh=[[\"aspect-square\",v({aspectRatio:1})],[\"aspect-video\",v({aspectRatio:16/9})],[\"items-center\",v({alignItems:\"center\"})],[\"items-start\",v({alignItems:\"flex-start\"})],[\"items-end\",v({alignItems:\"flex-end\"})],[\"items-baseline\",v({alignItems:\"baseline\"})],[\"items-stretch\",v({alignItems:\"stretch\"})],[\"justify-start\",v({justifyContent:\"flex-start\"})],[\"justify-end\",v({justifyContent:\"flex-end\"})],[\"justify-center\",v({justifyContent:\"center\"})],[\"justify-between\",v({justifyContent:\"space-between\"})],[\"justify-around\",v({justifyContent:\"space-around\"})],[\"justify-evenly\",v({justifyContent:\"space-evenly\"})],[\"content-start\",v({alignContent:\"flex-start\"})],[\"content-end\",v({alignContent:\"flex-end\"})],[\"content-between\",v({alignContent:\"space-between\"})],[\"content-around\",v({alignContent:\"space-around\"})],[\"content-stretch\",v({alignContent:\"stretch\"})],[\"content-center\",v({alignContent:\"center\"})],[\"self-auto\",v({alignSelf:\"auto\"})],[\"self-start\",v({alignSelf:\"flex-start\"})],[\"self-end\",v({alignSelf:\"flex-end\"})],[\"self-center\",v({alignSelf:\"center\"})],[\"self-stretch\",v({alignSelf:\"stretch\"})],[\"self-baseline\",v({alignSelf:\"baseline\"})],[\"direction-inherit\",v({direction:\"inherit\"})],[\"direction-ltr\",v({direction:\"ltr\"})],[\"direction-rtl\",v({direction:\"rtl\"})],[\"hidden\",v({display:\"none\"})],[\"flex\",v({display:\"flex\"})],[\"flex-row\",v({flexDirection:\"row\"})],[\"flex-row-reverse\",v({flexDirection:\"row-reverse\"})],[\"flex-col\",v({flexDirection:\"column\"})],[\"flex-col-reverse\",v({flexDirection:\"column-reverse\"})],[\"flex-wrap\",v({flexWrap:\"wrap\"})],[\"flex-wrap-reverse\",v({flexWrap:\"wrap-reverse\"})],[\"flex-nowrap\",v({flexWrap:\"nowrap\"})],[\"flex-auto\",v({flexGrow:1,flexShrink:1,flexBasis:\"auto\"})],[\"flex-initial\",v({flexGrow:0,flexShrink:1,flexBasis:\"auto\"})],[\"flex-none\",v({flexGrow:0,flexShrink:0,flexBasis:\"auto\"})],[\"overflow-hidden\",v({overflow:\"hidden\"})],[\"overflow-visible\",v({overflow:\"visible\"})],[\"overflow-scroll\",v({overflow:\"scroll\"})],[\"absolute\",v({position:\"absolute\"})],[\"relative\",v({position:\"relative\"})],[\"italic\",v({fontStyle:\"italic\"})],[\"not-italic\",v({fontStyle:\"normal\"})],[\"oldstyle-nums\",Yt(\"oldstyle-nums\")],[\"small-caps\",Yt(\"small-caps\")],[\"lining-nums\",Yt(\"lining-nums\")],[\"tabular-nums\",Yt(\"tabular-nums\")],[\"proportional-nums\",Yt(\"proportional-nums\")],[\"font-thin\",v({fontWeight:\"100\"})],[\"font-100\",v({fontWeight:\"100\"})],[\"font-extralight\",v({fontWeight:\"200\"})],[\"font-200\",v({fontWeight:\"200\"})],[\"font-light\",v({fontWeight:\"300\"})],[\"font-300\",v({fontWeight:\"300\"})],[\"font-normal\",v({fontWeight:\"normal\"})],[\"font-400\",v({fontWeight:\"400\"})],[\"font-medium\",v({fontWeight:\"500\"})],[\"font-500\",v({fontWeight:\"500\"})],[\"font-semibold\",v({fontWeight:\"600\"})],[\"font-600\",v({fontWeight:\"600\"})],[\"font-bold\",v({fontWeight:\"bold\"})],[\"font-700\",v({fontWeight:\"700\"})],[\"font-extrabold\",v({fontWeight:\"800\"})],[\"font-800\",v({fontWeight:\"800\"})],[\"font-black\",v({fontWeight:\"900\"})],[\"font-900\",v({fontWeight:\"900\"})],[\"include-font-padding\",v({includeFontPadding:!0})],[\"remove-font-padding\",v({includeFontPadding:!1})],[\"max-w-none\",v({maxWidth:\"99999%\"})],[\"text-left\",v({textAlign:\"left\"})],[\"text-center\",v({textAlign:\"center\"})],[\"text-right\",v({textAlign:\"right\"})],[\"text-justify\",v({textAlign:\"justify\"})],[\"text-auto\",v({textAlign:\"auto\"})],[\"underline\",v({textDecorationLine:\"underline\"})],[\"line-through\",v({textDecorationLine:\"line-through\"})],[\"no-underline\",v({textDecorationLine:\"none\"})],[\"uppercase\",v({textTransform:\"uppercase\"})],[\"lowercase\",v({textTransform:\"lowercase\"})],[\"capitalize\",v({textTransform:\"capitalize\"})],[\"normal-case\",v({textTransform:\"none\"})],[\"w-auto\",v({width:\"auto\"})],[\"h-auto\",v({height:\"auto\"})],[\"shadow-sm\",v({shadowOffset:{width:1,height:1},shadowColor:\"#000\",shadowRadius:1,shadowOpacity:.025,elevation:1})],[\"shadow\",v({shadowOffset:{width:1,height:1},shadowColor:\"#000\",shadowRadius:1,shadowOpacity:.075,elevation:2})],[\"shadow-md\",v({shadowOffset:{width:1,height:1},shadowColor:\"#000\",shadowRadius:3,shadowOpacity:.125,elevation:3})],[\"shadow-lg\",v({shadowOffset:{width:1,height:1},shadowColor:\"#000\",shadowOpacity:.15,shadowRadius:8,elevation:8})],[\"shadow-xl\",v({shadowOffset:{width:1,height:1},shadowColor:\"#000\",shadowOpacity:.19,shadowRadius:20,elevation:12})],[\"shadow-2xl\",v({shadowOffset:{width:1,height:1},shadowColor:\"#000\",shadowOpacity:.25,shadowRadius:30,elevation:16})],[\"shadow-none\",v({shadowOffset:{width:0,height:0},shadowColor:\"#000\",shadowRadius:0,shadowOpacity:0,elevation:0})]],ji=Jh;function Yt(e){return{kind:\"dependent\",complete(t){(!t.fontVariant||!Array.isArray(t.fontVariant))&&(t.fontVariant=[]),t.fontVariant.push(e)}}}var Xt=class{constructor(t){this.ir=new Map(ji),this.styles=new Map,this.prefixes=new Map,this.ir=new Map([...ji,...t!=null?t:[]])}getStyle(t){return this.styles.get(t)}setStyle(t,n){this.styles.set(t,n)}getIr(t){return this.ir.get(t)}setIr(t,n){this.ir.set(t,n)}getPrefixMatch(t){return this.prefixes.get(t)}setPrefixMatch(t,n){this.prefixes.set(t,n)}};c();c();function Vi(e,t,n={}){let r=t==null?void 0:t[e];if(!r)return _e(\"fontSize\",e,n);if(typeof r==\"string\")return Le(\"fontSize\",r);let i={},[a,o]=r,s=Js(\"fontSize\",a);if(s&&(i=s),typeof o==\"string\")return v(Dr(\"lineHeight\",Ks(o,i),i));let{lineHeight:u,letterSpacing:l}=o;return u&&Dr(\"lineHeight\",Ks(u,i),i),l&&Dr(\"letterSpacing\",l,i),v(i)}function Ks(e,t){let n=re(e);if(n){let[r,i]=n;if((i===$.none||i===$.em)&&typeof t.fontSize==\"number\")return t.fontSize*r}return e}c();function Hi(e,t){var n;let r=(n=t==null?void 0:t[e])!==null&&n!==void 0?n:e.startsWith(\"[\")?e.slice(1,-1):e,i=re(r);if(!i)return null;let[a,o]=i;if(o===$.none)return{kind:\"dependent\",complete(u){if(typeof u.fontSize!=\"number\")return\"relative line-height utilities require that font-size be set\";u.lineHeight=u.fontSize*a}};let s=qe(a,o);return s!==null?v({lineHeight:s}):null}c();function Yi(e,t,n,r,i){let a=\"\";if(r[0]===\"[\")a=r.slice(1,-1);else{let l=i==null?void 0:i[r];if(l)a=l;else{let f=Ze(r);return f&&typeof f==\"number\"?Zs(f,$.px,t,e):null}}if(a===\"auto\")return eu(t,e,\"auto\");let o=re(a);if(!o)return null;let[s,u]=o;return n&&(s=-s),Zs(s,u,t,e)}function Zs(e,t,n,r){let i=qe(e,t);return i===null?null:eu(n,r,i)}function eu(e,t,n){switch(e){case\"All\":return{kind:\"complete\",style:{[`${t}Top`]:n,[`${t}Right`]:n,[`${t}Bottom`]:n,[`${t}Left`]:n}};case\"Bottom\":case\"Top\":case\"Left\":case\"Right\":return{kind:\"complete\",style:{[`${t}${e}`]:n}};case\"Vertical\":return{kind:\"complete\",style:{[`${t}Top`]:n,[`${t}Bottom`]:n}};case\"Horizontal\":return{kind:\"complete\",style:{[`${t}Left`]:n,[`${t}Right`]:n}};default:return null}}c();function Xi(e){if(!e)return{};let t=Object.entries(e).reduce((i,[a,o])=>{let s=[0,1/0,0],u=typeof o==\"string\"?{min:o}:o,l=u.min?Ui(u.min):0;l===null?ce(`invalid screen config value: ${a}->min: ${u.min}`):s[0]=l;let f=u.max?Ui(u.max):1/0;return f===null?ce(`invalid screen config value: ${a}->max: ${u.max}`):s[1]=f,i[a]=s,i},{}),n=Object.values(t);n.sort((i,a)=>{let[o,s]=i,[u,l]=a;return s===1/0||l===1/0?o-u:s-l});let r=0;return n.forEach(i=>i[2]=r++),t}c();function Qi(e,t){let n=t==null?void 0:t[e];if(!n)return null;if(typeof n==\"string\")return v({fontFamily:n});let r=n[0];return r?v({fontFamily:r}):null}c();function et(e,t,n){if(!n)return null;let r;t.includes(\"/\")&&([t=\"\",r]=t.split(\"/\",2));let i=\"\";if(t.startsWith(\"[#\")||t.startsWith(\"[rgb\")?i=t.slice(1,-1):i=nu(t,n),!i)return null;if(r){let a=Number(r);if(!Number.isNaN(a))return i=tu(i,a/100),v({[Fr[e].color]:i})}return{kind:\"dependent\",complete(a){let o=Fr[e].opacity,s=a[o];typeof s==\"number\"&&(i=tu(i,s)),a[Fr[e].color]=i}}}function Qt(e,t){let n=parseInt(t,10);if(Number.isNaN(n))return null;let r=n/100,i={[Fr[e].opacity]:r};return{kind:\"complete\",style:i}}function tu(e,t){return e.startsWith(\"#\")?e=Kh(e):e.startsWith(\"rgb(\")&&(e=e.replace(/^rgb\\(/,\"rgba(\").replace(/\\)$/,\", 1)\")),e.replace(/, ?\\d*\\.?(\\d+)\\)$/,`, ${t})`)}function ru(e){for(let t in e)t.startsWith(\"__opacity_\")&&delete e[t]}var Fr={bg:{opacity:\"__opacity_bg\",color:\"backgroundColor\"},text:{opacity:\"__opacity_text\",color:\"color\"},border:{opacity:\"__opacity_border\",color:\"borderColor\"},borderTop:{opacity:\"__opacity_border\",color:\"borderTopColor\"},borderBottom:{opacity:\"__opacity_border\",color:\"borderBottomColor\"},borderLeft:{opacity:\"__opacity_border\",color:\"borderLeftColor\"},borderRight:{opacity:\"__opacity_border\",color:\"borderRightColor\"},shadow:{opacity:\"__opacity_shadow\",color:\"shadowColor\"},tint:{opacity:\"__opacity_tint\",color:\"tintColor\"}};function Kh(e){let t=e;e=e.replace(Zh,(o,s,u,l)=>s+s+u+u+l+l);let n=e0.exec(e);if(!n)return ce(`invalid config hex color value: ${t}`),\"rgba(0, 0, 0, 1)\";let r=parseInt(n[1],16),i=parseInt(n[2],16),a=parseInt(n[3],16);return`rgba(${r}, ${i}, ${a}, 1)`}function nu(e,t){let n=t[e];if($i(n))return n;if(qi(n)&&$i(n.DEFAULT))return n.DEFAULT;let[r=\"\",...i]=e.split(\"-\");for(;r!==e;){let a=t[r];if(qi(a))return nu(i.join(\"-\"),a);if(i.length===0)return\"\";r=`${r}-${i.shift()}`}return\"\"}var Zh=/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,e0=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;c();function ou(e,t){let[n,r]=Gi(e);if(n.match(/^(-?(\\d)+)?$/))return t0(n,r,t==null?void 0:t.borderWidth);if(n=n.replace(/^-/,\"\"),[\"dashed\",\"solid\",\"dotted\"].includes(n))return v({borderStyle:n});let a=\"border\";switch(r){case\"Bottom\":a=\"borderBottom\";break;case\"Top\":a=\"borderTop\";break;case\"Left\":a=\"borderLeft\";break;case\"Right\":a=\"borderRight\";break}let o=et(a,n,t==null?void 0:t.borderColor);if(o)return o;let s=`border${r===\"All\"?\"\":r}Width`;n=n.replace(/^-/,\"\");let u=n.slice(1,-1),l=_e(s,u);return typeof(l==null?void 0:l.style[s])!=\"number\"?null:l}function t0(e,t,n){if(!n)return null;e=e.replace(/^-/,\"\");let i=n[e===\"\"?\"DEFAULT\":e];if(i===void 0)return null;let a=`border${t===\"All\"?\"\":t}Width`;return Le(a,i)}function au(e,t){if(!t)return null;let[n,r]=Gi(e);n=n.replace(/^-/,\"\"),n===\"\"&&(n=\"DEFAULT\");let i=`border${r===\"All\"?\"\":r}Radius`,a=t[n];if(a)return iu(Le(i,a));let o=_e(i,n);return typeof(o==null?void 0:o.style[i])!=\"number\"?null:iu(o)}function iu(e){if((e==null?void 0:e.kind)!==\"complete\")return e;let t=e.style.borderTopRadius;t!==void 0&&(e.style.borderTopLeftRadius=t,e.style.borderTopRightRadius=t,delete e.style.borderTopRadius);let n=e.style.borderBottomRadius;n!==void 0&&(e.style.borderBottomLeftRadius=n,e.style.borderBottomRightRadius=n,delete e.style.borderBottomRadius);let r=e.style.borderLeftRadius;r!==void 0&&(e.style.borderBottomLeftRadius=r,e.style.borderTopLeftRadius=r,delete e.style.borderLeftRadius);let i=e.style.borderRightRadius;return i!==void 0&&(e.style.borderBottomRightRadius=i,e.style.borderTopRightRadius=i,delete e.style.borderRightRadius),e}c();function ut(e,t,n,r){let i=null;e===\"inset\"&&(t=t.replace(/^(x|y)-/,(s,u)=>(i=u===\"x\"?\"x\":\"y\",\"\")));let a=r==null?void 0:r[t];if(a){let s=Ee(a,{isNegative:n});if(s!==null)return su(e,i,s)}let o=Ze(t,{isNegative:n});return o!==null?su(e,i,o):null}function su(e,t,n){if(e!==\"inset\")return v({[e]:n});switch(t){case null:return v({top:n,left:n,right:n,bottom:n});case\"y\":return v({top:n,bottom:n});case\"x\":return v({left:n,right:n})}}c();function Jt(e,t,n){var r;t=t.replace(/^-/,\"\");let i=t===\"\"?\"DEFAULT\":t,a=Number((r=n==null?void 0:n[i])!==null&&r!==void 0?r:t);return Number.isNaN(a)?null:v({[`flex${e}`]:a})}function uu(e,t){var n,r;if(e=(t==null?void 0:t[e])||e,[\"min-content\",\"revert\",\"unset\"].includes(e))return null;if(e.match(/^\\d+(\\.\\d+)?$/))return v({flexGrow:Number(e),flexBasis:\"0%\"});let i=e.match(/^(\\d+)\\s+(\\d+)$/);if(i)return v({flexGrow:Number(i[1]),flexShrink:Number(i[2])});if(i=e.match(/^(\\d+)\\s+([^ ]+)$/),i){let a=Ee((n=i[2])!==null&&n!==void 0?n:\"\");return a?v({flexGrow:Number(i[1]),flexBasis:a}):null}if(i=e.match(/^(\\d+)\\s+(\\d+)\\s+(.+)$/),i){let a=Ee((r=i[3])!==null&&r!==void 0?r:\"\");return a?v({flexGrow:Number(i[1]),flexShrink:Number(i[2]),flexBasis:a}):null}return null}c();function Ji(e,t,n={},r){let i=r==null?void 0:r[t];return i!==void 0?Le(e,i,n):_e(e,t,n)}function Kt(e,t,n={},r){let i=Ee(r==null?void 0:r[t],n);return i?v({[e]:i}):(t===\"screen\"&&(t=e.includes(\"Width\")?\"100vw\":\"100vh\"),_e(e,t,n))}c();function lu(e,t,n){let r=n==null?void 0:n[e];if(r){let i=re(r,{isNegative:t});if(!i)return null;let[a,o]=i;if(o===$.em)return r0(a);if(o===$.percent)return ce(\"percentage-based letter-spacing configuration currently unsupported, switch to `em`s, or open an issue if you'd like to see support added.\"),null;let s=qe(a,o,{isNegative:t});return s!==null?v({letterSpacing:s}):null}return _e(\"letterSpacing\",e,{isNegative:t})}function r0(e){return{kind:\"dependent\",complete(t){let n=t.fontSize;if(typeof n!=\"number\"||Number.isNaN(n))return\"tracking-X relative letter spacing classes require font-size to be set\";t.letterSpacing=Math.round((e*n+Number.EPSILON)*100)/100}}}c();function fu(e,t){let n=t==null?void 0:t[e];if(n){let i=re(String(n));if(i)return v({opacity:i[0]})}let r=re(e);return r?v({opacity:r[0]/100}):null}c();function cu(e){let t=parseInt(e,10);return Number.isNaN(t)?null:{kind:\"complete\",style:{shadowOpacity:t/100}}}function du(e){if(e.includes(\"/\")){let[n=\"\",r=\"\"]=e.split(\"/\",2),i=Ki(n),a=Ki(r);return i===null||a===null?null:{kind:\"complete\",style:{shadowOffset:{width:i,height:a}}}}let t=Ki(e);return t===null?null:{kind:\"complete\",style:{shadowOffset:{width:t,height:t}}}}function Ki(e){let t=Ze(e);return typeof t==\"number\"?t:null}var lt=class{constructor(t,n={},r,i,a){var o,s,u,l,f,p;this.config=n,this.cache=r,this.position=0,this.isNull=!1,this.isNegative=!1,this.context={},this.context.device=i;let g=t.trim().split(\":\"),m=[];g.length===1?this.string=t:(this.string=(o=g.pop())!==null&&o!==void 0?o:\"\",m=g),this.char=this.string[0];let d=Xi((s=this.config.theme)===null||s===void 0?void 0:s.screens);for(let h of m)if(d[h]){let w=(u=d[h])===null||u===void 0?void 0:u[2];w!==void 0&&(this.order=((l=this.order)!==null&&l!==void 0?l:0)+w);let b=(f=i.windowDimensions)===null||f===void 0?void 0:f.width;if(b){let[_,E]=(p=d[h])!==null&&p!==void 0?p:[0,0];(b<=_||b>E)&&(this.isNull=!0)}else this.isNull=!0}else Ys(h)?this.isNull=h!==a:Xs(h)?i.windowDimensions?(i.windowDimensions.width>i.windowDimensions.height?\"landscape\":\"portrait\")!==h?this.isNull=!0:this.incrementOrder():this.isNull=!0:h===\"retina\"?i.pixelDensity===2?this.incrementOrder():this.isNull=!0:h===\"dark\"?i.colorScheme!==\"dark\"?this.isNull=!0:this.incrementOrder():this.handlePossibleArbitraryBreakpointPrefix(h)||(this.isNull=!0)}parse(){if(this.isNull)return{kind:\"null\"};let t=this.cache.getIr(this.rest);if(t)return t;this.parseIsNegative();let n=this.parseUtility();return n?this.order!==void 0?{kind:\"ordered\",order:this.order,styleIr:n}:n:{kind:\"null\"}}parseUtility(){var t,n,r,i,a;let o=this.config.theme,s=null;switch(this.char){case\"m\":case\"p\":{let u=this.peekSlice(1,3).match(/^(t|b|r|l|x|y)?-/);if(u){let l=this.char===\"m\"?\"margin\":\"padding\";this.advance(((n=(t=u[0])===null||t===void 0?void 0:t.length)!==null&&n!==void 0?n:0)+1);let f=zi(u[1]),p=Yi(l,f,this.isNegative,this.rest,(r=this.config.theme)===null||r===void 0?void 0:r[l]);if(p)return p}}}if(this.consumePeeked(\"h-\")&&(s=Ji(\"height\",this.rest,this.context,o==null?void 0:o.height),s)||this.consumePeeked(\"w-\")&&(s=Ji(\"width\",this.rest,this.context,o==null?void 0:o.width),s)||this.consumePeeked(\"min-w-\")&&(s=Kt(\"minWidth\",this.rest,this.context,o==null?void 0:o.minWidth),s)||this.consumePeeked(\"min-h-\")&&(s=Kt(\"minHeight\",this.rest,this.context,o==null?void 0:o.minHeight),s)||this.consumePeeked(\"max-w-\")&&(s=Kt(\"maxWidth\",this.rest,this.context,o==null?void 0:o.maxWidth),s)||this.consumePeeked(\"max-h-\")&&(s=Kt(\"maxHeight\",this.rest,this.context,o==null?void 0:o.maxHeight),s)||this.consumePeeked(\"leading-\")&&(s=Hi(this.rest,o==null?void 0:o.lineHeight),s)||this.consumePeeked(\"text-\")&&(s=Vi(this.rest,o==null?void 0:o.fontSize,this.context),s||(s=et(\"text\",this.rest,o==null?void 0:o.textColor),s)||this.consumePeeked(\"opacity-\")&&(s=Qt(\"text\",this.rest),s))||this.consumePeeked(\"font-\")&&(s=Qi(this.rest,o==null?void 0:o.fontFamily),s)||this.consumePeeked(\"aspect-\")&&(this.consumePeeked(\"ratio-\")&&ce(\"`aspect-ratio-{ratio}` is deprecated, use `aspect-{ratio}` instead\"),s=Le(\"aspectRatio\",this.rest,{fractions:!0}),s)||this.consumePeeked(\"tint-\")&&(s=et(\"tint\",this.rest,o==null?void 0:o.colors),s)||this.consumePeeked(\"bg-\")&&(s=et(\"bg\",this.rest,o==null?void 0:o.backgroundColor),s||this.consumePeeked(\"opacity-\")&&(s=Qt(\"bg\",this.rest),s))||this.consumePeeked(\"border\")&&(s=ou(this.rest,o),s||this.consumePeeked(\"-opacity-\")&&(s=Qt(\"border\",this.rest),s))||this.consumePeeked(\"rounded\")&&(s=au(this.rest,o==null?void 0:o.borderRadius),s)||this.consumePeeked(\"bottom-\")&&(s=ut(\"bottom\",this.rest,this.isNegative,o==null?void 0:o.inset),s)||this.consumePeeked(\"top-\")&&(s=ut(\"top\",this.rest,this.isNegative,o==null?void 0:o.inset),s)||this.consumePeeked(\"left-\")&&(s=ut(\"left\",this.rest,this.isNegative,o==null?void 0:o.inset),s)||this.consumePeeked(\"right-\")&&(s=ut(\"right\",this.rest,this.isNegative,o==null?void 0:o.inset),s)||this.consumePeeked(\"inset-\")&&(s=ut(\"inset\",this.rest,this.isNegative,o==null?void 0:o.inset),s)||this.consumePeeked(\"flex-\")&&(this.consumePeeked(\"grow\")?s=Jt(\"Grow\",this.rest,o==null?void 0:o.flexGrow):this.consumePeeked(\"shrink\")?s=Jt(\"Shrink\",this.rest,o==null?void 0:o.flexShrink):s=uu(this.rest,o==null?void 0:o.flex),s)||this.consumePeeked(\"grow\")&&(s=Jt(\"Grow\",this.rest,o==null?void 0:o.flexGrow),s)||this.consumePeeked(\"shrink\")&&(s=Jt(\"Shrink\",this.rest,o==null?void 0:o.flexShrink),s)||this.consumePeeked(\"shadow-color-opacity-\")&&(s=Qt(\"shadow\",this.rest),s)||this.consumePeeked(\"shadow-opacity-\")&&(s=cu(this.rest),s)||this.consumePeeked(\"shadow-offset-\")&&(s=du(this.rest),s)||this.consumePeeked(\"shadow-radius-\")&&(s=_e(\"shadowRadius\",this.rest),s)||this.consumePeeked(\"shadow-\")&&(s=et(\"shadow\",this.rest,o==null?void 0:o.colors),s))return s;if(this.consumePeeked(\"elevation-\")){let u=parseInt(this.rest,10);if(!Number.isNaN(u))return v({elevation:u})}if(this.consumePeeked(\"opacity-\")&&(s=fu(this.rest,o==null?void 0:o.opacity),s)||this.consumePeeked(\"tracking-\")&&(s=lu(this.rest,this.isNegative,o==null?void 0:o.letterSpacing),s))return s;if(this.consumePeeked(\"z-\")){let u=Number((a=(i=o==null?void 0:o.zIndex)===null||i===void 0?void 0:i[this.rest])!==null&&a!==void 0?a:this.rest);if(!Number.isNaN(u))return v({zIndex:u})}return ce(`\\`${this.rest}\\` unknown or invalid utility`),null}handlePossibleArbitraryBreakpointPrefix(t){var n;if(t[0]!==\"m\")return!1;let r=t.match(/^(min|max)-(w|h)-\\[([^\\]]+)\\]$/);if(!r)return!1;if(!(!((n=this.context.device)===null||n===void 0)&&n.windowDimensions))return this.isNull=!0,!0;let i=this.context.device.windowDimensions,[,a=\"\",o=\"\",s=\"\"]=r,u=o===\"w\"?i.width:i.height,l=re(s,this.context);if(l===null)return this.isNull=!0,!0;let[f,p]=l;return p!==\"px\"&&(this.isNull=!0),(a===\"min\"?u>=f:u<=f)?this.incrementOrder():this.isNull=!0,!0}advance(t=1){this.position+=t,this.char=this.string[this.position]}get rest(){return this.peekSlice(0,this.string.length)}peekSlice(t,n){return this.string.slice(this.position+t,this.position+n)}consumePeeked(t){return this.peekSlice(0,t.length)===t?(this.advance(t.length),!0):!1}parseIsNegative(){this.char===\"-\"&&(this.advance(),this.isNegative=!0,this.context.isNegative=!0)}incrementOrder(){var t;this.order=((t=this.order)!==null&&t!==void 0?t:0)+1}};c();function pu(e){let t=[],n=null;return e.forEach(r=>{if(typeof r==\"string\")t=[...t,...Zi(r)];else if(Array.isArray(r))t=[...t,...r.flatMap(Zi)];else if(typeof r==\"object\"&&r!==null)for(let[i,a]of Object.entries(r))typeof a==\"boolean\"?t=[...t,...a?Zi(i):[]]:n?n[i]=a:n={[i]:a}}),[t.filter(Boolean).filter(n0),n]}function Zi(e){return e.trim().split(/\\s+/)}function n0(e,t,n){return n.indexOf(e)===t}c();function hu(e){var t;return(t=e==null?void 0:e.reduce((n,r)=>({...n,...i0(r.handler)}),{}))!==null&&t!==void 0?t:{}}function i0(e){let t={};return e({addUtilities:n=>{t=n},...o0}),t}function Oe(e){throw new Error(`tailwindcss plugin function argument object prop \"${e}\" not implemented`)}var o0={addComponents:Oe,addBase:Oe,addVariant:Oe,e:Oe,prefix:Oe,theme:Oe,variants:Oe,config:Oe,corePlugins:Oe,matchUtilities:Oe,postcss:null};function gu(e,t){let n=(0,mu.default)(a0(e)),r={},i=hu(n.plugins),a={},o=Object.entries(i).map(([d,h])=>typeof h==\"string\"?(a[d]=h,[d,{kind:\"null\"}]):[d,v(h)]).filter(([,d])=>d.kind!==\"null\");function s(){return[r.windowDimensions?`w${r.windowDimensions.width}`:!1,r.windowDimensions?`h${r.windowDimensions.height}`:!1,r.fontScale?`fs${r.fontScale}`:!1,r.colorScheme===\"dark\"?\"dark\":!1,r.pixelDensity===2?\"retina\":!1].filter(Boolean).join(\"--\")||\"default\"}let u=s(),l={};function f(){let d=l[u];if(d)return d;let h=new Xt(o);return l[u]=h,h}function p(...d){let h=f(),w={},b=[],_=[],[E,A]=pu(d),D=E.join(\" \"),M=h.getStyle(D);if(M)return{...M,...A||{}};for(let L of E){let F=h.getIr(L);if(!F&&L in a){let U=p(a[L]);h.setIr(L,v(U)),w={...w,...U};continue}switch(F=new lt(L,n,h,r,t).parse(),F.kind){case\"complete\":w={...w,...F.style},h.setIr(L,F);break;case\"dependent\":b.push(F);break;case\"ordered\":_.push(F);break;case\"null\":h.setIr(L,F);break}}if(_.length>0){_.sort((L,F)=>L.order-F.order);for(let L of _)switch(L.styleIr.kind){case\"complete\":w={...w,...L.styleIr.style};break;case\"dependent\":b.push(L.styleIr);break}}if(b.length>0){for(let L of b){let F=L.complete(w);F&&ce(F)}ru(w)}return D!==\"\"&&h.setStyle(D,w),A&&(w={...w,...A}),w}function g(d){let h=p(d.split(/\\s+/g).map(w=>w.replace(/^(bg|text|border)-/,\"\")).map(w=>`bg-${w}`).join(\" \"));return typeof h.backgroundColor==\"string\"?h.backgroundColor:void 0}let m=(d,...h)=>{let w=\"\";return d.forEach((b,_)=>{var E;w+=b+((E=h[_])!==null&&E!==void 0?E:\"\")}),p(w)};return m.style=p,m.color=g,m.prefixMatch=(...d)=>{let h=d.sort().join(\":\"),w=f(),b=w.getPrefixMatch(h);if(b!==void 0)return b;let A=new lt(`${h}:flex`,n,w,r,t).parse().kind!==\"null\";return w.setPrefixMatch(h,A),A},m.setWindowDimensions=d=>{r.windowDimensions=d,u=s()},m.setFontScale=d=>{r.fontScale=d,u=s()},m.setPixelDensity=d=>{r.pixelDensity=d,u=s()},m.setColorScheme=d=>{r.colorScheme=d,u=s()},m}function a0(e){return{...e,content:[\"_no_warnings_please\"]}}var u0={plugins:[{handler:({addUtilities:e})=>{e({\"shadow-sm\":{boxShadow:\"0 1px 2px 0 rgb(0 0 0 / 0.05)\"},shadow:{boxShadow:\"0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)\"},\"shadow-md\":{boxShadow:\"0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)\"},\"shadow-lg\":{boxShadow:\"0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)\"},\"shadow-xl\":{boxShadow:\"0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)\"},\"shadow-2xl\":{boxShadow:\"0 25px 50px -12px rgb(0 0 0 / 0.25)\"},\"shadow-inner\":{boxShadow:\"inset 0 2px 4px 0 rgb(0 0 0 / 0.05)\"},\"shadow-none\":{boxShadow:\"0 0 #0000\"}})}}]};function l0(){return gu(u0,\"web\")}var Mr;function eo({width:e,height:t}){return Mr||(Mr=l0()),Mr.setWindowDimensions({width:+e,height:+t}),Mr}var to=new WeakMap;async function vu(e,t){let n=Ae();if(!n)throw new Error(\"Satori is not initialized.\");let r;to.has(t.fonts)?r=to.get(t.fonts):to.set(t.fonts,r=new vt(t.fonts));let i=n.Node.create();i.setWidth(t.width),i.setHeight(t.height),i.setFlexDirection(n.FLEX_DIRECTION_ROW),i.setFlexWrap(n.WRAP_WRAP),i.setAlignContent(n.ALIGN_AUTO),i.setAlignItems(n.ALIGN_FLEX_START),i.setJustifyContent(n.JUSTIFY_FLEX_START),i.setOverflow(n.OVERFLOW_HIDDEN);let a={...t.graphemeImages},o=gt(e,{id:\"id\",parentStyle:{},inheritedStyle:{fontSize:16,fontWeight:\"normal\",fontFamily:\"serif\",fontStyle:\"normal\",lineHeight:1.2,color:\"black\",opacity:1,whiteSpace:\"normal\",_viewportWidth:t.width,_viewportHeight:t.height},parent:i,font:r,embedFont:t.embedFont,debug:t.debug,graphemeImages:a,canLoadAdditionalAssets:!!t.loadAdditionalAsset,getTwStyles:(l,f)=>{let g={...eo({width:t.width,height:t.height})([l])};return typeof g.lineHeight==\"number\"&&(g.lineHeight=g.lineHeight/(+g.fontSize||f.fontSize||16)),g.shadowColor&&g.boxShadow&&(g.boxShadow=g.boxShadow.replace(/rgba?\\([^)]+\\)/,g.shadowColor)),g}}),s=(await o.next()).value;if(t.loadAdditionalAsset&&s.length){s=Array.from(new Set(je(s.join(\"\"),\"grapheme\")));let l={};s.forEach(g=>{let m=Mo(g);l[m]=l[m]||[],m===\"emoji\"?l[m].push(g):l[m][0]=(l[m][0]||\"\")+g});let f=[],p={};await Promise.all(Object.entries(l).flatMap(([g,m])=>m.map(d=>t.loadAdditionalAsset(g,d).then(h=>{typeof h==\"string\"?p[d]=h:h&&f.push(h)})))),r.addFonts(f),Object.assign(a,p)}await o.next(),i.calculateLayout(t.width,t.height,n.DIRECTION_LTR);let u=(await o.next([0,0])).value;return i.freeRecursive(),pn({width:t.width,height:t.height,content:u})}\n//# sourceMappingURL=index.wasm.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3NhdG9yaS9kaXN0L2VzbS9pbmRleC53YXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUIsNkJBQTZCLHVDQUF1QyxrQ0FBa0MsZ0VBQWdFLG9DQUFvQywyQkFBMkIsV0FBVyxtQ0FBbUMsdUJBQXVCLHVCQUF1QixFQUFFLGdCQUFnQixnR0FBZ0csbURBQW1ELEVBQUUsVUFBVSx1Q0FBdUMseUNBQXlDLHNCQUFzQixzQkFBc0IsZUFBZSxTQUFTLEtBQUssZUFBZSxFQUFFLGNBQWMsYUFBYSxJQUFJLHVDQUF1QyxTQUFTLEVBQUUsb0NBQW9DLHlCQUF5QixFQUFFLGVBQWUsUUFBUSxFQUFFLG9CQUFvQixvR0FBb0cseURBQXlELEdBQUcsUUFBUSxFQUFFLGNBQWMsYUFBYSxJQUFJLHVDQUF1QyxTQUFTLEVBQUUsb0NBQW9DLHlCQUF5QixFQUFFLHc2RUFBdzZFLEVBQUUsY0FBYyxhQUFhLElBQUksdUNBQXVDLFNBQVMsRUFBRSxvQ0FBb0MseUJBQXlCLEVBQUUsaUJBQWlCLGlJQUFpSSxFQUFFLG1CQUFtQixJQUFJLFlBQVksOENBQThDLFNBQVMsNkRBQTZELFVBQVUsU0FBUyxLQUFLLDRZQUE0WSxXQUFXLGlRQUFpUSxVQUFVLHlZQUF5WSxZQUFZLGlMQUFpTCxjQUFjLDBDQUEwQyxnQkFBZ0IsUUFBUSxrQ0FBa0MsUUFBUSxzQ0FBc0MsUUFBUSxxQ0FBcUMsUUFBUSxzQ0FBc0MsUUFBUSxtQ0FBbUMsUUFBUSxpQ0FBaUMsUUFBUSxtQ0FBbUMsUUFBUSxpQ0FBaUMsUUFBUSxnQ0FBZ0MsUUFBUSxnQ0FBZ0Msa2xCQUFrbEIscUJBQXFCLFFBQVEsb0NBQW9DLDRLQUE0SyxpQkFBaUIsNENBQTRDLE9BQU8sOEZBQThGLGFBQWEsa0dBQWtHLGVBQWUsUUFBUSxLQUFLLDJEQUEyRCxrQkFBa0IsUUFBUSw4QkFBOEIsNEhBQTRILGlCQUFpQixRQUFRLEtBQUssZ0JBQWdCLGVBQWUsOENBQThD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T0FBTyxvQkFBb0IsU0FBUyxzQkFBc0IsaUJBQWlCLGlMQUFpTCwwSUFBMEksT0FBTyxPQUFPLDhCQUE4QixRQUFRLGlNQUFpTSwyQkFBMkIsb0NBQW9DLGlEQUFpRCxTQUFTLGNBQWMsWUFBWSwrREFBK0QsRUFBRSxjQUFjLGtHQUFrRyx1Q0FBdUMsc0NBQXNDLG1FQUFtRSxrQ0FBa0MsNkJBQTZCLHdDQUF3QyxFQUFtQztBQUM1LzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zYXRvcmkvZGlzdC9lc20vaW5kZXgud2FzbS5qcz82ZGQ1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB4dT1PYmplY3QuY3JlYXRlO3ZhciBvcj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIHd1PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIF91PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBTdT1PYmplY3QuZ2V0UHJvdG90eXBlT2Ysa3U9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgQnI9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgUj0oZSx0KT0+KCk9Pih0fHxlKCh0PXtleHBvcnRzOnt9fSkuZXhwb3J0cyx0KSx0LmV4cG9ydHMpLGNvPShlLHQpPT57Zm9yKHZhciBuIGluIHQpb3IoZSxuLHtnZXQ6dFtuXSxlbnVtZXJhYmxlOiEwfSl9LHBvPShlLHQsbixyKT0+e2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwifHx0eXBlb2YgdD09XCJmdW5jdGlvblwiKWZvcihsZXQgaSBvZiBfdSh0KSkha3UuY2FsbChlLGkpJiZpIT09biYmb3IoZSxpLHtnZXQ6KCk9PnRbaV0sZW51bWVyYWJsZTohKHI9d3UodCxpKSl8fHIuZW51bWVyYWJsZX0pO3JldHVybiBlfTt2YXIgVHU9KGUsdCxuKT0+KG49ZSE9bnVsbD94dShTdShlKSk6e30scG8odHx8IWV8fCFlLl9fZXNNb2R1bGU/b3IobixcImRlZmF1bHRcIix7dmFsdWU6ZSxlbnVtZXJhYmxlOiEwfSk6bixlKSksYXI9ZT0+cG8ob3Ioe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZSk7dmFyIGM9QnIoKCk9Pnt9KTt2YXIgbW49Uihobj0+e1widXNlIHN0cmljdFwiO2MoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoaG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGhuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLGdldDooKT0+YWx9KTtmdW5jdGlvbiBhbChlKXtpZihlPWAke2V9YCxlPT09XCIwXCIpcmV0dXJuXCIwXCI7aWYoL15bKy1dPyhcXGQrfFxcZCpcXC5cXGQrKShlWystXT9cXGQrKT8oJXxcXHcrKT8kLy50ZXN0KGUpKXJldHVybiBlLnJlcGxhY2UoL15bKy1dPy8sdD0+dD09PVwiLVwiP1wiXCI6XCItXCIpO2lmKGUuaW5jbHVkZXMoXCJ2YXIoXCIpfHxlLmluY2x1ZGVzKFwiY2FsYyhcIikpcmV0dXJuYGNhbGMoJHtlfSAqIC0xKWB9fSk7dmFyIE5vPVIoZ249PntcInVzZSBzdHJpY3RcIjtjKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGduLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShnbixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCxnZXQ6KCk9PnNsfSk7dmFyIHNsPVtcInByZWZsaWdodFwiLFwiY29udGFpbmVyXCIsXCJhY2Nlc3NpYmlsaXR5XCIsXCJwb2ludGVyRXZlbnRzXCIsXCJ2aXNpYmlsaXR5XCIsXCJwb3NpdGlvblwiLFwiaW5zZXRcIixcImlzb2xhdGlvblwiLFwiekluZGV4XCIsXCJvcmRlclwiLFwiZ3JpZENvbHVtblwiLFwiZ3JpZENvbHVtblN0YXJ0XCIsXCJncmlkQ29sdW1uRW5kXCIsXCJncmlkUm93XCIsXCJncmlkUm93U3RhcnRcIixcImdyaWRSb3dFbmRcIixcImZsb2F0XCIsXCJjbGVhclwiLFwibWFyZ2luXCIsXCJib3hTaXppbmdcIixcImRpc3BsYXlcIixcImFzcGVjdFJhdGlvXCIsXCJoZWlnaHRcIixcIm1heEhlaWdodFwiLFwibWluSGVpZ2h0XCIsXCJ3aWR0aFwiLFwibWluV2lkdGhcIixcIm1heFdpZHRoXCIsXCJmbGV4XCIsXCJmbGV4U2hyaW5rXCIsXCJmbGV4R3Jvd1wiLFwiZmxleEJhc2lzXCIsXCJ0YWJsZUxheW91dFwiLFwiYm9yZGVyQ29sbGFwc2VcIixcImJvcmRlclNwYWNpbmdcIixcInRyYW5zZm9ybU9yaWdpblwiLFwidHJhbnNsYXRlXCIsXCJyb3RhdGVcIixcInNrZXdcIixcInNjYWxlXCIsXCJ0cmFuc2Zvcm1cIixcImFuaW1hdGlvblwiLFwiY3Vyc29yXCIsXCJ0b3VjaEFjdGlvblwiLFwidXNlclNlbGVjdFwiLFwicmVzaXplXCIsXCJzY3JvbGxTbmFwVHlwZVwiLFwic2Nyb2xsU25hcEFsaWduXCIsXCJzY3JvbGxTbmFwU3RvcFwiLFwic2Nyb2xsTWFyZ2luXCIsXCJzY3JvbGxQYWRkaW5nXCIsXCJsaXN0U3R5bGVQb3NpdGlvblwiLFwibGlzdFN0eWxlVHlwZVwiLFwiYXBwZWFyYW5jZVwiLFwiY29sdW1uc1wiLFwiYnJlYWtCZWZvcmVcIixcImJyZWFrSW5zaWRlXCIsXCJicmVha0FmdGVyXCIsXCJncmlkQXV0b0NvbHVtbnNcIixcImdyaWRBdXRvRmxvd1wiLFwiZ3JpZEF1dG9Sb3dzXCIsXCJncmlkVGVtcGxhdGVDb2x1bW5zXCIsXCJncmlkVGVtcGxhdGVSb3dzXCIsXCJmbGV4RGlyZWN0aW9uXCIsXCJmbGV4V3JhcFwiLFwicGxhY2VDb250ZW50XCIsXCJwbGFjZUl0ZW1zXCIsXCJhbGlnbkNvbnRlbnRcIixcImFsaWduSXRlbXNcIixcImp1c3RpZnlDb250ZW50XCIsXCJqdXN0aWZ5SXRlbXNcIixcImdhcFwiLFwic3BhY2VcIixcImRpdmlkZVdpZHRoXCIsXCJkaXZpZGVTdHlsZVwiLFwiZGl2aWRlQ29sb3JcIixcImRpdmlkZU9wYWNpdHlcIixcInBsYWNlU2VsZlwiLFwiYWxpZ25TZWxmXCIsXCJqdXN0aWZ5U2VsZlwiLFwib3ZlcmZsb3dcIixcIm92ZXJzY3JvbGxCZWhhdmlvclwiLFwic2Nyb2xsQmVoYXZpb3JcIixcInRleHRPdmVyZmxvd1wiLFwid2hpdGVzcGFjZVwiLFwid29yZEJyZWFrXCIsXCJib3JkZXJSYWRpdXNcIixcImJvcmRlcldpZHRoXCIsXCJib3JkZXJTdHlsZVwiLFwiYm9yZGVyQ29sb3JcIixcImJvcmRlck9wYWNpdHlcIixcImJhY2tncm91bmRDb2xvclwiLFwiYmFja2dyb3VuZE9wYWNpdHlcIixcImJhY2tncm91bmRJbWFnZVwiLFwiZ3JhZGllbnRDb2xvclN0b3BzXCIsXCJib3hEZWNvcmF0aW9uQnJlYWtcIixcImJhY2tncm91bmRTaXplXCIsXCJiYWNrZ3JvdW5kQXR0YWNobWVudFwiLFwiYmFja2dyb3VuZENsaXBcIixcImJhY2tncm91bmRQb3NpdGlvblwiLFwiYmFja2dyb3VuZFJlcGVhdFwiLFwiYmFja2dyb3VuZE9yaWdpblwiLFwiZmlsbFwiLFwic3Ryb2tlXCIsXCJzdHJva2VXaWR0aFwiLFwib2JqZWN0Rml0XCIsXCJvYmplY3RQb3NpdGlvblwiLFwicGFkZGluZ1wiLFwidGV4dEFsaWduXCIsXCJ0ZXh0SW5kZW50XCIsXCJ2ZXJ0aWNhbEFsaWduXCIsXCJmb250RmFtaWx5XCIsXCJmb250U2l6ZVwiLFwiZm9udFdlaWdodFwiLFwidGV4dFRyYW5zZm9ybVwiLFwiZm9udFN0eWxlXCIsXCJmb250VmFyaWFudE51bWVyaWNcIixcImxpbmVIZWlnaHRcIixcImxldHRlclNwYWNpbmdcIixcInRleHRDb2xvclwiLFwidGV4dE9wYWNpdHlcIixcInRleHREZWNvcmF0aW9uXCIsXCJ0ZXh0RGVjb3JhdGlvbkNvbG9yXCIsXCJ0ZXh0RGVjb3JhdGlvblN0eWxlXCIsXCJ0ZXh0RGVjb3JhdGlvblRoaWNrbmVzc1wiLFwidGV4dFVuZGVybGluZU9mZnNldFwiLFwiZm9udFNtb290aGluZ1wiLFwicGxhY2Vob2xkZXJDb2xvclwiLFwicGxhY2Vob2xkZXJPcGFjaXR5XCIsXCJjYXJldENvbG9yXCIsXCJhY2NlbnRDb2xvclwiLFwib3BhY2l0eVwiLFwiYmFja2dyb3VuZEJsZW5kTW9kZVwiLFwibWl4QmxlbmRNb2RlXCIsXCJib3hTaGFkb3dcIixcImJveFNoYWRvd0NvbG9yXCIsXCJvdXRsaW5lU3R5bGVcIixcIm91dGxpbmVXaWR0aFwiLFwib3V0bGluZU9mZnNldFwiLFwib3V0bGluZUNvbG9yXCIsXCJyaW5nV2lkdGhcIixcInJpbmdDb2xvclwiLFwicmluZ09wYWNpdHlcIixcInJpbmdPZmZzZXRXaWR0aFwiLFwicmluZ09mZnNldENvbG9yXCIsXCJibHVyXCIsXCJicmlnaHRuZXNzXCIsXCJjb250cmFzdFwiLFwiZHJvcFNoYWRvd1wiLFwiZ3JheXNjYWxlXCIsXCJodWVSb3RhdGVcIixcImludmVydFwiLFwic2F0dXJhdGVcIixcInNlcGlhXCIsXCJmaWx0ZXJcIixcImJhY2tkcm9wQmx1clwiLFwiYmFja2Ryb3BCcmlnaHRuZXNzXCIsXCJiYWNrZHJvcENvbnRyYXN0XCIsXCJiYWNrZHJvcEdyYXlzY2FsZVwiLFwiYmFja2Ryb3BIdWVSb3RhdGVcIixcImJhY2tkcm9wSW52ZXJ0XCIsXCJiYWNrZHJvcE9wYWNpdHlcIixcImJhY2tkcm9wU2F0dXJhdGVcIixcImJhY2tkcm9wU2VwaWFcIixcImJhY2tkcm9wRmlsdGVyXCIsXCJ0cmFuc2l0aW9uUHJvcGVydHlcIixcInRyYW5zaXRpb25EZWxheVwiLFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsXCJ0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb25cIixcIndpbGxDaGFuZ2VcIixcImNvbnRlbnRcIl19KTt2YXIgV289Uih2bj0+e1widXNlIHN0cmljdFwiO2MoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodm4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHZuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLGdldDooKT0+dWx9KTtmdW5jdGlvbiB1bChlLHQpe3JldHVybiBlPT09dm9pZCAwP3Q6QXJyYXkuaXNBcnJheShlKT9lOlsuLi5uZXcgU2V0KHQuZmlsdGVyKHI9PmUhPT0hMSYmZVtyXSE9PSExKS5jb25jYXQoT2JqZWN0LmtleXMoZSkuZmlsdGVyKHI9PmVbcl0hPT0hMSkpKV19fSk7dmFyIGJuPVIoKEhtLCRvKT0+e2MoKTskby5leHBvcnRzPXtjb250ZW50OltdLHByZXNldHM6W10sZGFya01vZGU6XCJtZWRpYVwiLHRoZW1lOntzY3JlZW5zOntzbTpcIjY0MHB4XCIsbWQ6XCI3NjhweFwiLGxnOlwiMTAyNHB4XCIseGw6XCIxMjgwcHhcIixcIjJ4bFwiOlwiMTUzNnB4XCJ9LGNvbG9yczooe2NvbG9yczplfSk9Pih7aW5oZXJpdDplLmluaGVyaXQsY3VycmVudDplLmN1cnJlbnQsdHJhbnNwYXJlbnQ6ZS50cmFuc3BhcmVudCxibGFjazplLmJsYWNrLHdoaXRlOmUud2hpdGUsc2xhdGU6ZS5zbGF0ZSxncmF5OmUuZ3JheSx6aW5jOmUuemluYyxuZXV0cmFsOmUubmV1dHJhbCxzdG9uZTplLnN0b25lLHJlZDplLnJlZCxvcmFuZ2U6ZS5vcmFuZ2UsYW1iZXI6ZS5hbWJlcix5ZWxsb3c6ZS55ZWxsb3csbGltZTplLmxpbWUsZ3JlZW46ZS5ncmVlbixlbWVyYWxkOmUuZW1lcmFsZCx0ZWFsOmUudGVhbCxjeWFuOmUuY3lhbixza3k6ZS5za3ksYmx1ZTplLmJsdWUsaW5kaWdvOmUuaW5kaWdvLHZpb2xldDplLnZpb2xldCxwdXJwbGU6ZS5wdXJwbGUsZnVjaHNpYTplLmZ1Y2hzaWEscGluazplLnBpbmsscm9zZTplLnJvc2V9KSxjb2x1bW5zOnthdXRvOlwiYXV0b1wiLDE6XCIxXCIsMjpcIjJcIiwzOlwiM1wiLDQ6XCI0XCIsNTpcIjVcIiw2OlwiNlwiLDc6XCI3XCIsODpcIjhcIiw5OlwiOVwiLDEwOlwiMTBcIiwxMTpcIjExXCIsMTI6XCIxMlwiLFwiM3hzXCI6XCIxNnJlbVwiLFwiMnhzXCI6XCIxOHJlbVwiLHhzOlwiMjByZW1cIixzbTpcIjI0cmVtXCIsbWQ6XCIyOHJlbVwiLGxnOlwiMzJyZW1cIix4bDpcIjM2cmVtXCIsXCIyeGxcIjpcIjQycmVtXCIsXCIzeGxcIjpcIjQ4cmVtXCIsXCI0eGxcIjpcIjU2cmVtXCIsXCI1eGxcIjpcIjY0cmVtXCIsXCI2eGxcIjpcIjcycmVtXCIsXCI3eGxcIjpcIjgwcmVtXCJ9LHNwYWNpbmc6e3B4OlwiMXB4XCIsMDpcIjBweFwiLC41OlwiMC4xMjVyZW1cIiwxOlwiMC4yNXJlbVwiLDEuNTpcIjAuMzc1cmVtXCIsMjpcIjAuNXJlbVwiLDIuNTpcIjAuNjI1cmVtXCIsMzpcIjAuNzVyZW1cIiwzLjU6XCIwLjg3NXJlbVwiLDQ6XCIxcmVtXCIsNTpcIjEuMjVyZW1cIiw2OlwiMS41cmVtXCIsNzpcIjEuNzVyZW1cIiw4OlwiMnJlbVwiLDk6XCIyLjI1cmVtXCIsMTA6XCIyLjVyZW1cIiwxMTpcIjIuNzVyZW1cIiwxMjpcIjNyZW1cIiwxNDpcIjMuNXJlbVwiLDE2OlwiNHJlbVwiLDIwOlwiNXJlbVwiLDI0OlwiNnJlbVwiLDI4OlwiN3JlbVwiLDMyOlwiOHJlbVwiLDM2OlwiOXJlbVwiLDQwOlwiMTByZW1cIiw0NDpcIjExcmVtXCIsNDg6XCIxMnJlbVwiLDUyOlwiMTNyZW1cIiw1NjpcIjE0cmVtXCIsNjA6XCIxNXJlbVwiLDY0OlwiMTZyZW1cIiw3MjpcIjE4cmVtXCIsODA6XCIyMHJlbVwiLDk2OlwiMjRyZW1cIn0sYW5pbWF0aW9uOntub25lOlwibm9uZVwiLHNwaW46XCJzcGluIDFzIGxpbmVhciBpbmZpbml0ZVwiLHBpbmc6XCJwaW5nIDFzIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpIGluZmluaXRlXCIscHVsc2U6XCJwdWxzZSAycyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjYsIDEpIGluZmluaXRlXCIsYm91bmNlOlwiYm91bmNlIDFzIGluZmluaXRlXCJ9LGFzcGVjdFJhdGlvOnthdXRvOlwiYXV0b1wiLHNxdWFyZTpcIjEgLyAxXCIsdmlkZW86XCIxNiAvIDlcIn0sYmFja2Ryb3BCbHVyOih7dGhlbWU6ZX0pPT5lKFwiYmx1clwiKSxiYWNrZHJvcEJyaWdodG5lc3M6KHt0aGVtZTplfSk9PmUoXCJicmlnaHRuZXNzXCIpLGJhY2tkcm9wQ29udHJhc3Q6KHt0aGVtZTplfSk9PmUoXCJjb250cmFzdFwiKSxiYWNrZHJvcEdyYXlzY2FsZTooe3RoZW1lOmV9KT0+ZShcImdyYXlzY2FsZVwiKSxiYWNrZHJvcEh1ZVJvdGF0ZTooe3RoZW1lOmV9KT0+ZShcImh1ZVJvdGF0ZVwiKSxiYWNrZHJvcEludmVydDooe3RoZW1lOmV9KT0+ZShcImludmVydFwiKSxiYWNrZHJvcE9wYWNpdHk6KHt0aGVtZTplfSk9PmUoXCJvcGFjaXR5XCIpLGJhY2tkcm9wU2F0dXJhdGU6KHt0aGVtZTplfSk9PmUoXCJzYXR1cmF0ZVwiKSxiYWNrZHJvcFNlcGlhOih7dGhlbWU6ZX0pPT5lKFwic2VwaWFcIiksYmFja2dyb3VuZENvbG9yOih7dGhlbWU6ZX0pPT5lKFwiY29sb3JzXCIpLGJhY2tncm91bmRJbWFnZTp7bm9uZTpcIm5vbmVcIixcImdyYWRpZW50LXRvLXRcIjpcImxpbmVhci1ncmFkaWVudCh0byB0b3AsIHZhcigtLXR3LWdyYWRpZW50LXN0b3BzKSlcIixcImdyYWRpZW50LXRvLXRyXCI6XCJsaW5lYXItZ3JhZGllbnQodG8gdG9wIHJpZ2h0LCB2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpXCIsXCJncmFkaWVudC10by1yXCI6XCJsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHZhcigtLXR3LWdyYWRpZW50LXN0b3BzKSlcIixcImdyYWRpZW50LXRvLWJyXCI6XCJsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tIHJpZ2h0LCB2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpXCIsXCJncmFkaWVudC10by1iXCI6XCJsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCB2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpXCIsXCJncmFkaWVudC10by1ibFwiOlwibGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSBsZWZ0LCB2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpXCIsXCJncmFkaWVudC10by1sXCI6XCJsaW5lYXItZ3JhZGllbnQodG8gbGVmdCwgdmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKVwiLFwiZ3JhZGllbnQtdG8tdGxcIjpcImxpbmVhci1ncmFkaWVudCh0byB0b3AgbGVmdCwgdmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKVwifSxiYWNrZ3JvdW5kT3BhY2l0eTooe3RoZW1lOmV9KT0+ZShcIm9wYWNpdHlcIiksYmFja2dyb3VuZFBvc2l0aW9uOntib3R0b206XCJib3R0b21cIixjZW50ZXI6XCJjZW50ZXJcIixsZWZ0OlwibGVmdFwiLFwibGVmdC1ib3R0b21cIjpcImxlZnQgYm90dG9tXCIsXCJsZWZ0LXRvcFwiOlwibGVmdCB0b3BcIixyaWdodDpcInJpZ2h0XCIsXCJyaWdodC1ib3R0b21cIjpcInJpZ2h0IGJvdHRvbVwiLFwicmlnaHQtdG9wXCI6XCJyaWdodCB0b3BcIix0b3A6XCJ0b3BcIn0sYmFja2dyb3VuZFNpemU6e2F1dG86XCJhdXRvXCIsY292ZXI6XCJjb3ZlclwiLGNvbnRhaW46XCJjb250YWluXCJ9LGJsdXI6ezA6XCIwXCIsbm9uZTpcIjBcIixzbTpcIjRweFwiLERFRkFVTFQ6XCI4cHhcIixtZDpcIjEycHhcIixsZzpcIjE2cHhcIix4bDpcIjI0cHhcIixcIjJ4bFwiOlwiNDBweFwiLFwiM3hsXCI6XCI2NHB4XCJ9LGJyaWdodG5lc3M6ezA6XCIwXCIsNTA6XCIuNVwiLDc1OlwiLjc1XCIsOTA6XCIuOVwiLDk1OlwiLjk1XCIsMTAwOlwiMVwiLDEwNTpcIjEuMDVcIiwxMTA6XCIxLjFcIiwxMjU6XCIxLjI1XCIsMTUwOlwiMS41XCIsMjAwOlwiMlwifSxib3JkZXJDb2xvcjooe3RoZW1lOmV9KT0+KHsuLi5lKFwiY29sb3JzXCIpLERFRkFVTFQ6ZShcImNvbG9ycy5ncmF5LjIwMFwiLFwiY3VycmVudENvbG9yXCIpfSksYm9yZGVyT3BhY2l0eTooe3RoZW1lOmV9KT0+ZShcIm9wYWNpdHlcIiksYm9yZGVyUmFkaXVzOntub25lOlwiMHB4XCIsc206XCIwLjEyNXJlbVwiLERFRkFVTFQ6XCIwLjI1cmVtXCIsbWQ6XCIwLjM3NXJlbVwiLGxnOlwiMC41cmVtXCIseGw6XCIwLjc1cmVtXCIsXCIyeGxcIjpcIjFyZW1cIixcIjN4bFwiOlwiMS41cmVtXCIsZnVsbDpcIjk5OTlweFwifSxib3JkZXJTcGFjaW5nOih7dGhlbWU6ZX0pPT4oey4uLmUoXCJzcGFjaW5nXCIpfSksYm9yZGVyV2lkdGg6e0RFRkFVTFQ6XCIxcHhcIiwwOlwiMHB4XCIsMjpcIjJweFwiLDQ6XCI0cHhcIiw4OlwiOHB4XCJ9LGJveFNoYWRvdzp7c206XCIwIDFweCAycHggMCByZ2IoMCAwIDAgLyAwLjA1KVwiLERFRkFVTFQ6XCIwIDFweCAzcHggMCByZ2IoMCAwIDAgLyAwLjEpLCAwIDFweCAycHggLTFweCByZ2IoMCAwIDAgLyAwLjEpXCIsbWQ6XCIwIDRweCA2cHggLTFweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDJweCA0cHggLTJweCByZ2IoMCAwIDAgLyAwLjEpXCIsbGc6XCIwIDEwcHggMTVweCAtM3B4IHJnYigwIDAgMCAvIDAuMSksIDAgNHB4IDZweCAtNHB4IHJnYigwIDAgMCAvIDAuMSlcIix4bDpcIjAgMjBweCAyNXB4IC01cHggcmdiKDAgMCAwIC8gMC4xKSwgMCA4cHggMTBweCAtNnB4IHJnYigwIDAgMCAvIDAuMSlcIixcIjJ4bFwiOlwiMCAyNXB4IDUwcHggLTEycHggcmdiKDAgMCAwIC8gMC4yNSlcIixpbm5lcjpcImluc2V0IDAgMnB4IDRweCAwIHJnYigwIDAgMCAvIDAuMDUpXCIsbm9uZTpcIm5vbmVcIn0sYm94U2hhZG93Q29sb3I6KHt0aGVtZTplfSk9PmUoXCJjb2xvcnNcIiksY2FyZXRDb2xvcjooe3RoZW1lOmV9KT0+ZShcImNvbG9yc1wiKSxhY2NlbnRDb2xvcjooe3RoZW1lOmV9KT0+KHsuLi5lKFwiY29sb3JzXCIpLGF1dG86XCJhdXRvXCJ9KSxjb250cmFzdDp7MDpcIjBcIiw1MDpcIi41XCIsNzU6XCIuNzVcIiwxMDA6XCIxXCIsMTI1OlwiMS4yNVwiLDE1MDpcIjEuNVwiLDIwMDpcIjJcIn0sY29udGFpbmVyOnt9LGNvbnRlbnQ6e25vbmU6XCJub25lXCJ9LGN1cnNvcjp7YXV0bzpcImF1dG9cIixkZWZhdWx0OlwiZGVmYXVsdFwiLHBvaW50ZXI6XCJwb2ludGVyXCIsd2FpdDpcIndhaXRcIix0ZXh0OlwidGV4dFwiLG1vdmU6XCJtb3ZlXCIsaGVscDpcImhlbHBcIixcIm5vdC1hbGxvd2VkXCI6XCJub3QtYWxsb3dlZFwiLG5vbmU6XCJub25lXCIsXCJjb250ZXh0LW1lbnVcIjpcImNvbnRleHQtbWVudVwiLHByb2dyZXNzOlwicHJvZ3Jlc3NcIixjZWxsOlwiY2VsbFwiLGNyb3NzaGFpcjpcImNyb3NzaGFpclwiLFwidmVydGljYWwtdGV4dFwiOlwidmVydGljYWwtdGV4dFwiLGFsaWFzOlwiYWxpYXNcIixjb3B5OlwiY29weVwiLFwibm8tZHJvcFwiOlwibm8tZHJvcFwiLGdyYWI6XCJncmFiXCIsZ3JhYmJpbmc6XCJncmFiYmluZ1wiLFwiYWxsLXNjcm9sbFwiOlwiYWxsLXNjcm9sbFwiLFwiY29sLXJlc2l6ZVwiOlwiY29sLXJlc2l6ZVwiLFwicm93LXJlc2l6ZVwiOlwicm93LXJlc2l6ZVwiLFwibi1yZXNpemVcIjpcIm4tcmVzaXplXCIsXCJlLXJlc2l6ZVwiOlwiZS1yZXNpemVcIixcInMtcmVzaXplXCI6XCJzLXJlc2l6ZVwiLFwidy1yZXNpemVcIjpcInctcmVzaXplXCIsXCJuZS1yZXNpemVcIjpcIm5lLXJlc2l6ZVwiLFwibnctcmVzaXplXCI6XCJudy1yZXNpemVcIixcInNlLXJlc2l6ZVwiOlwic2UtcmVzaXplXCIsXCJzdy1yZXNpemVcIjpcInN3LXJlc2l6ZVwiLFwiZXctcmVzaXplXCI6XCJldy1yZXNpemVcIixcIm5zLXJlc2l6ZVwiOlwibnMtcmVzaXplXCIsXCJuZXN3LXJlc2l6ZVwiOlwibmVzdy1yZXNpemVcIixcIm53c2UtcmVzaXplXCI6XCJud3NlLXJlc2l6ZVwiLFwiem9vbS1pblwiOlwiem9vbS1pblwiLFwiem9vbS1vdXRcIjpcInpvb20tb3V0XCJ9LGRpdmlkZUNvbG9yOih7dGhlbWU6ZX0pPT5lKFwiYm9yZGVyQ29sb3JcIiksZGl2aWRlT3BhY2l0eTooe3RoZW1lOmV9KT0+ZShcImJvcmRlck9wYWNpdHlcIiksZGl2aWRlV2lkdGg6KHt0aGVtZTplfSk9PmUoXCJib3JkZXJXaWR0aFwiKSxkcm9wU2hhZG93OntzbTpcIjAgMXB4IDFweCByZ2IoMCAwIDAgLyAwLjA1KVwiLERFRkFVTFQ6W1wiMCAxcHggMnB4IHJnYigwIDAgMCAvIDAuMSlcIixcIjAgMXB4IDFweCByZ2IoMCAwIDAgLyAwLjA2KVwiXSxtZDpbXCIwIDRweCAzcHggcmdiKDAgMCAwIC8gMC4wNylcIixcIjAgMnB4IDJweCByZ2IoMCAwIDAgLyAwLjA2KVwiXSxsZzpbXCIwIDEwcHggOHB4IHJnYigwIDAgMCAvIDAuMDQpXCIsXCIwIDRweCAzcHggcmdiKDAgMCAwIC8gMC4xKVwiXSx4bDpbXCIwIDIwcHggMTNweCByZ2IoMCAwIDAgLyAwLjAzKVwiLFwiMCA4cHggNXB4IHJnYigwIDAgMCAvIDAuMDgpXCJdLFwiMnhsXCI6XCIwIDI1cHggMjVweCByZ2IoMCAwIDAgLyAwLjE1KVwiLG5vbmU6XCIwIDAgIzAwMDBcIn0sZmlsbDooe3RoZW1lOmV9KT0+ZShcImNvbG9yc1wiKSxncmF5c2NhbGU6ezA6XCIwXCIsREVGQVVMVDpcIjEwMCVcIn0saHVlUm90YXRlOnswOlwiMGRlZ1wiLDE1OlwiMTVkZWdcIiwzMDpcIjMwZGVnXCIsNjA6XCI2MGRlZ1wiLDkwOlwiOTBkZWdcIiwxODA6XCIxODBkZWdcIn0saW52ZXJ0OnswOlwiMFwiLERFRkFVTFQ6XCIxMDAlXCJ9LGZsZXg6ezE6XCIxIDEgMCVcIixhdXRvOlwiMSAxIGF1dG9cIixpbml0aWFsOlwiMCAxIGF1dG9cIixub25lOlwibm9uZVwifSxmbGV4QmFzaXM6KHt0aGVtZTplfSk9Pih7YXV0bzpcImF1dG9cIiwuLi5lKFwic3BhY2luZ1wiKSxcIjEvMlwiOlwiNTAlXCIsXCIxLzNcIjpcIjMzLjMzMzMzMyVcIixcIjIvM1wiOlwiNjYuNjY2NjY3JVwiLFwiMS80XCI6XCIyNSVcIixcIjIvNFwiOlwiNTAlXCIsXCIzLzRcIjpcIjc1JVwiLFwiMS81XCI6XCIyMCVcIixcIjIvNVwiOlwiNDAlXCIsXCIzLzVcIjpcIjYwJVwiLFwiNC81XCI6XCI4MCVcIixcIjEvNlwiOlwiMTYuNjY2NjY3JVwiLFwiMi82XCI6XCIzMy4zMzMzMzMlXCIsXCIzLzZcIjpcIjUwJVwiLFwiNC82XCI6XCI2Ni42NjY2NjclXCIsXCI1LzZcIjpcIjgzLjMzMzMzMyVcIixcIjEvMTJcIjpcIjguMzMzMzMzJVwiLFwiMi8xMlwiOlwiMTYuNjY2NjY3JVwiLFwiMy8xMlwiOlwiMjUlXCIsXCI0LzEyXCI6XCIzMy4zMzMzMzMlXCIsXCI1LzEyXCI6XCI0MS42NjY2NjclXCIsXCI2LzEyXCI6XCI1MCVcIixcIjcvMTJcIjpcIjU4LjMzMzMzMyVcIixcIjgvMTJcIjpcIjY2LjY2NjY2NyVcIixcIjkvMTJcIjpcIjc1JVwiLFwiMTAvMTJcIjpcIjgzLjMzMzMzMyVcIixcIjExLzEyXCI6XCI5MS42NjY2NjclXCIsZnVsbDpcIjEwMCVcIn0pLGZsZXhHcm93OnswOlwiMFwiLERFRkFVTFQ6XCIxXCJ9LGZsZXhTaHJpbms6ezA6XCIwXCIsREVGQVVMVDpcIjFcIn0sZm9udEZhbWlseTp7c2FuczpbXCJ1aS1zYW5zLXNlcmlmXCIsXCJzeXN0ZW0tdWlcIixcIi1hcHBsZS1zeXN0ZW1cIixcIkJsaW5rTWFjU3lzdGVtRm9udFwiLCdcIlNlZ29lIFVJXCInLFwiUm9ib3RvXCIsJ1wiSGVsdmV0aWNhIE5ldWVcIicsXCJBcmlhbFwiLCdcIk5vdG8gU2Fuc1wiJyxcInNhbnMtc2VyaWZcIiwnXCJBcHBsZSBDb2xvciBFbW9qaVwiJywnXCJTZWdvZSBVSSBFbW9qaVwiJywnXCJTZWdvZSBVSSBTeW1ib2xcIicsJ1wiTm90byBDb2xvciBFbW9qaVwiJ10sc2VyaWY6W1widWktc2VyaWZcIixcIkdlb3JnaWFcIixcIkNhbWJyaWFcIiwnXCJUaW1lcyBOZXcgUm9tYW5cIicsXCJUaW1lc1wiLFwic2VyaWZcIl0sbW9ubzpbXCJ1aS1tb25vc3BhY2VcIixcIlNGTW9uby1SZWd1bGFyXCIsXCJNZW5sb1wiLFwiTW9uYWNvXCIsXCJDb25zb2xhc1wiLCdcIkxpYmVyYXRpb24gTW9ub1wiJywnXCJDb3VyaWVyIE5ld1wiJyxcIm1vbm9zcGFjZVwiXX0sZm9udFNpemU6e3hzOltcIjAuNzVyZW1cIix7bGluZUhlaWdodDpcIjFyZW1cIn1dLHNtOltcIjAuODc1cmVtXCIse2xpbmVIZWlnaHQ6XCIxLjI1cmVtXCJ9XSxiYXNlOltcIjFyZW1cIix7bGluZUhlaWdodDpcIjEuNXJlbVwifV0sbGc6W1wiMS4xMjVyZW1cIix7bGluZUhlaWdodDpcIjEuNzVyZW1cIn1dLHhsOltcIjEuMjVyZW1cIix7bGluZUhlaWdodDpcIjEuNzVyZW1cIn1dLFwiMnhsXCI6W1wiMS41cmVtXCIse2xpbmVIZWlnaHQ6XCIycmVtXCJ9XSxcIjN4bFwiOltcIjEuODc1cmVtXCIse2xpbmVIZWlnaHQ6XCIyLjI1cmVtXCJ9XSxcIjR4bFwiOltcIjIuMjVyZW1cIix7bGluZUhlaWdodDpcIjIuNXJlbVwifV0sXCI1eGxcIjpbXCIzcmVtXCIse2xpbmVIZWlnaHQ6XCIxXCJ9XSxcIjZ4bFwiOltcIjMuNzVyZW1cIix7bGluZUhlaWdodDpcIjFcIn1dLFwiN3hsXCI6W1wiNC41cmVtXCIse2xpbmVIZWlnaHQ6XCIxXCJ9XSxcIjh4bFwiOltcIjZyZW1cIix7bGluZUhlaWdodDpcIjFcIn1dLFwiOXhsXCI6W1wiOHJlbVwiLHtsaW5lSGVpZ2h0OlwiMVwifV19LGZvbnRXZWlnaHQ6e3RoaW46XCIxMDBcIixleHRyYWxpZ2h0OlwiMjAwXCIsbGlnaHQ6XCIzMDBcIixub3JtYWw6XCI0MDBcIixtZWRpdW06XCI1MDBcIixzZW1pYm9sZDpcIjYwMFwiLGJvbGQ6XCI3MDBcIixleHRyYWJvbGQ6XCI4MDBcIixibGFjazpcIjkwMFwifSxnYXA6KHt0aGVtZTplfSk9PmUoXCJzcGFjaW5nXCIpLGdyYWRpZW50Q29sb3JTdG9wczooe3RoZW1lOmV9KT0+ZShcImNvbG9yc1wiKSxncmlkQXV0b0NvbHVtbnM6e2F1dG86XCJhdXRvXCIsbWluOlwibWluLWNvbnRlbnRcIixtYXg6XCJtYXgtY29udGVudFwiLGZyOlwibWlubWF4KDAsIDFmcilcIn0sZ3JpZEF1dG9Sb3dzOnthdXRvOlwiYXV0b1wiLG1pbjpcIm1pbi1jb250ZW50XCIsbWF4OlwibWF4LWNvbnRlbnRcIixmcjpcIm1pbm1heCgwLCAxZnIpXCJ9LGdyaWRDb2x1bW46e2F1dG86XCJhdXRvXCIsXCJzcGFuLTFcIjpcInNwYW4gMSAvIHNwYW4gMVwiLFwic3Bhbi0yXCI6XCJzcGFuIDIgLyBzcGFuIDJcIixcInNwYW4tM1wiOlwic3BhbiAzIC8gc3BhbiAzXCIsXCJzcGFuLTRcIjpcInNwYW4gNCAvIHNwYW4gNFwiLFwic3Bhbi01XCI6XCJzcGFuIDUgLyBzcGFuIDVcIixcInNwYW4tNlwiOlwic3BhbiA2IC8gc3BhbiA2XCIsXCJzcGFuLTdcIjpcInNwYW4gNyAvIHNwYW4gN1wiLFwic3Bhbi04XCI6XCJzcGFuIDggLyBzcGFuIDhcIixcInNwYW4tOVwiOlwic3BhbiA5IC8gc3BhbiA5XCIsXCJzcGFuLTEwXCI6XCJzcGFuIDEwIC8gc3BhbiAxMFwiLFwic3Bhbi0xMVwiOlwic3BhbiAxMSAvIHNwYW4gMTFcIixcInNwYW4tMTJcIjpcInNwYW4gMTIgLyBzcGFuIDEyXCIsXCJzcGFuLWZ1bGxcIjpcIjEgLyAtMVwifSxncmlkQ29sdW1uRW5kOnthdXRvOlwiYXV0b1wiLDE6XCIxXCIsMjpcIjJcIiwzOlwiM1wiLDQ6XCI0XCIsNTpcIjVcIiw2OlwiNlwiLDc6XCI3XCIsODpcIjhcIiw5OlwiOVwiLDEwOlwiMTBcIiwxMTpcIjExXCIsMTI6XCIxMlwiLDEzOlwiMTNcIn0sZ3JpZENvbHVtblN0YXJ0OnthdXRvOlwiYXV0b1wiLDE6XCIxXCIsMjpcIjJcIiwzOlwiM1wiLDQ6XCI0XCIsNTpcIjVcIiw2OlwiNlwiLDc6XCI3XCIsODpcIjhcIiw5OlwiOVwiLDEwOlwiMTBcIiwxMTpcIjExXCIsMTI6XCIxMlwiLDEzOlwiMTNcIn0sZ3JpZFJvdzp7YXV0bzpcImF1dG9cIixcInNwYW4tMVwiOlwic3BhbiAxIC8gc3BhbiAxXCIsXCJzcGFuLTJcIjpcInNwYW4gMiAvIHNwYW4gMlwiLFwic3Bhbi0zXCI6XCJzcGFuIDMgLyBzcGFuIDNcIixcInNwYW4tNFwiOlwic3BhbiA0IC8gc3BhbiA0XCIsXCJzcGFuLTVcIjpcInNwYW4gNSAvIHNwYW4gNVwiLFwic3Bhbi02XCI6XCJzcGFuIDYgLyBzcGFuIDZcIixcInNwYW4tZnVsbFwiOlwiMSAvIC0xXCJ9LGdyaWRSb3dTdGFydDp7YXV0bzpcImF1dG9cIiwxOlwiMVwiLDI6XCIyXCIsMzpcIjNcIiw0OlwiNFwiLDU6XCI1XCIsNjpcIjZcIiw3OlwiN1wifSxncmlkUm93RW5kOnthdXRvOlwiYXV0b1wiLDE6XCIxXCIsMjpcIjJcIiwzOlwiM1wiLDQ6XCI0XCIsNTpcIjVcIiw2OlwiNlwiLDc6XCI3XCJ9LGdyaWRUZW1wbGF0ZUNvbHVtbnM6e25vbmU6XCJub25lXCIsMTpcInJlcGVhdCgxLCBtaW5tYXgoMCwgMWZyKSlcIiwyOlwicmVwZWF0KDIsIG1pbm1heCgwLCAxZnIpKVwiLDM6XCJyZXBlYXQoMywgbWlubWF4KDAsIDFmcikpXCIsNDpcInJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSlcIiw1OlwicmVwZWF0KDUsIG1pbm1heCgwLCAxZnIpKVwiLDY6XCJyZXBlYXQoNiwgbWlubWF4KDAsIDFmcikpXCIsNzpcInJlcGVhdCg3LCBtaW5tYXgoMCwgMWZyKSlcIiw4OlwicmVwZWF0KDgsIG1pbm1heCgwLCAxZnIpKVwiLDk6XCJyZXBlYXQoOSwgbWlubWF4KDAsIDFmcikpXCIsMTA6XCJyZXBlYXQoMTAsIG1pbm1heCgwLCAxZnIpKVwiLDExOlwicmVwZWF0KDExLCBtaW5tYXgoMCwgMWZyKSlcIiwxMjpcInJlcGVhdCgxMiwgbWlubWF4KDAsIDFmcikpXCJ9LGdyaWRUZW1wbGF0ZVJvd3M6e25vbmU6XCJub25lXCIsMTpcInJlcGVhdCgxLCBtaW5tYXgoMCwgMWZyKSlcIiwyOlwicmVwZWF0KDIsIG1pbm1heCgwLCAxZnIpKVwiLDM6XCJyZXBlYXQoMywgbWlubWF4KDAsIDFmcikpXCIsNDpcInJlcGVhdCg0LCBtaW5tYXgoMCwgMWZyKSlcIiw1OlwicmVwZWF0KDUsIG1pbm1heCgwLCAxZnIpKVwiLDY6XCJyZXBlYXQoNiwgbWlubWF4KDAsIDFmcikpXCJ9LGhlaWdodDooe3RoZW1lOmV9KT0+KHthdXRvOlwiYXV0b1wiLC4uLmUoXCJzcGFjaW5nXCIpLFwiMS8yXCI6XCI1MCVcIixcIjEvM1wiOlwiMzMuMzMzMzMzJVwiLFwiMi8zXCI6XCI2Ni42NjY2NjclXCIsXCIxLzRcIjpcIjI1JVwiLFwiMi80XCI6XCI1MCVcIixcIjMvNFwiOlwiNzUlXCIsXCIxLzVcIjpcIjIwJVwiLFwiMi81XCI6XCI0MCVcIixcIjMvNVwiOlwiNjAlXCIsXCI0LzVcIjpcIjgwJVwiLFwiMS82XCI6XCIxNi42NjY2NjclXCIsXCIyLzZcIjpcIjMzLjMzMzMzMyVcIixcIjMvNlwiOlwiNTAlXCIsXCI0LzZcIjpcIjY2LjY2NjY2NyVcIixcIjUvNlwiOlwiODMuMzMzMzMzJVwiLGZ1bGw6XCIxMDAlXCIsc2NyZWVuOlwiMTAwdmhcIixtaW46XCJtaW4tY29udGVudFwiLG1heDpcIm1heC1jb250ZW50XCIsZml0OlwiZml0LWNvbnRlbnRcIn0pLGluc2V0Oih7dGhlbWU6ZX0pPT4oe2F1dG86XCJhdXRvXCIsLi4uZShcInNwYWNpbmdcIiksXCIxLzJcIjpcIjUwJVwiLFwiMS8zXCI6XCIzMy4zMzMzMzMlXCIsXCIyLzNcIjpcIjY2LjY2NjY2NyVcIixcIjEvNFwiOlwiMjUlXCIsXCIyLzRcIjpcIjUwJVwiLFwiMy80XCI6XCI3NSVcIixmdWxsOlwiMTAwJVwifSksa2V5ZnJhbWVzOntzcGluOnt0bzp7dHJhbnNmb3JtOlwicm90YXRlKDM2MGRlZylcIn19LHBpbmc6e1wiNzUlLCAxMDAlXCI6e3RyYW5zZm9ybTpcInNjYWxlKDIpXCIsb3BhY2l0eTpcIjBcIn19LHB1bHNlOntcIjUwJVwiOntvcGFjaXR5OlwiLjVcIn19LGJvdW5jZTp7XCIwJSwgMTAwJVwiOnt0cmFuc2Zvcm06XCJ0cmFuc2xhdGVZKC0yNSUpXCIsYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246XCJjdWJpYy1iZXppZXIoMC44LDAsMSwxKVwifSxcIjUwJVwiOnt0cmFuc2Zvcm06XCJub25lXCIsYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246XCJjdWJpYy1iZXppZXIoMCwwLDAuMiwxKVwifX19LGxldHRlclNwYWNpbmc6e3RpZ2h0ZXI6XCItMC4wNWVtXCIsdGlnaHQ6XCItMC4wMjVlbVwiLG5vcm1hbDpcIjBlbVwiLHdpZGU6XCIwLjAyNWVtXCIsd2lkZXI6XCIwLjA1ZW1cIix3aWRlc3Q6XCIwLjFlbVwifSxsaW5lSGVpZ2h0Ontub25lOlwiMVwiLHRpZ2h0OlwiMS4yNVwiLHNudWc6XCIxLjM3NVwiLG5vcm1hbDpcIjEuNVwiLHJlbGF4ZWQ6XCIxLjYyNVwiLGxvb3NlOlwiMlwiLDM6XCIuNzVyZW1cIiw0OlwiMXJlbVwiLDU6XCIxLjI1cmVtXCIsNjpcIjEuNXJlbVwiLDc6XCIxLjc1cmVtXCIsODpcIjJyZW1cIiw5OlwiMi4yNXJlbVwiLDEwOlwiMi41cmVtXCJ9LGxpc3RTdHlsZVR5cGU6e25vbmU6XCJub25lXCIsZGlzYzpcImRpc2NcIixkZWNpbWFsOlwiZGVjaW1hbFwifSxtYXJnaW46KHt0aGVtZTplfSk9Pih7YXV0bzpcImF1dG9cIiwuLi5lKFwic3BhY2luZ1wiKX0pLG1heEhlaWdodDooe3RoZW1lOmV9KT0+KHsuLi5lKFwic3BhY2luZ1wiKSxmdWxsOlwiMTAwJVwiLHNjcmVlbjpcIjEwMHZoXCIsbWluOlwibWluLWNvbnRlbnRcIixtYXg6XCJtYXgtY29udGVudFwiLGZpdDpcImZpdC1jb250ZW50XCJ9KSxtYXhXaWR0aDooe3RoZW1lOmUsYnJlYWtwb2ludHM6dH0pPT4oe25vbmU6XCJub25lXCIsMDpcIjByZW1cIix4czpcIjIwcmVtXCIsc206XCIyNHJlbVwiLG1kOlwiMjhyZW1cIixsZzpcIjMycmVtXCIseGw6XCIzNnJlbVwiLFwiMnhsXCI6XCI0MnJlbVwiLFwiM3hsXCI6XCI0OHJlbVwiLFwiNHhsXCI6XCI1NnJlbVwiLFwiNXhsXCI6XCI2NHJlbVwiLFwiNnhsXCI6XCI3MnJlbVwiLFwiN3hsXCI6XCI4MHJlbVwiLGZ1bGw6XCIxMDAlXCIsbWluOlwibWluLWNvbnRlbnRcIixtYXg6XCJtYXgtY29udGVudFwiLGZpdDpcImZpdC1jb250ZW50XCIscHJvc2U6XCI2NWNoXCIsLi4udChlKFwic2NyZWVuc1wiKSl9KSxtaW5IZWlnaHQ6ezA6XCIwcHhcIixmdWxsOlwiMTAwJVwiLHNjcmVlbjpcIjEwMHZoXCIsbWluOlwibWluLWNvbnRlbnRcIixtYXg6XCJtYXgtY29udGVudFwiLGZpdDpcImZpdC1jb250ZW50XCJ9LG1pbldpZHRoOnswOlwiMHB4XCIsZnVsbDpcIjEwMCVcIixtaW46XCJtaW4tY29udGVudFwiLG1heDpcIm1heC1jb250ZW50XCIsZml0OlwiZml0LWNvbnRlbnRcIn0sb2JqZWN0UG9zaXRpb246e2JvdHRvbTpcImJvdHRvbVwiLGNlbnRlcjpcImNlbnRlclwiLGxlZnQ6XCJsZWZ0XCIsXCJsZWZ0LWJvdHRvbVwiOlwibGVmdCBib3R0b21cIixcImxlZnQtdG9wXCI6XCJsZWZ0IHRvcFwiLHJpZ2h0OlwicmlnaHRcIixcInJpZ2h0LWJvdHRvbVwiOlwicmlnaHQgYm90dG9tXCIsXCJyaWdodC10b3BcIjpcInJpZ2h0IHRvcFwiLHRvcDpcInRvcFwifSxvcGFjaXR5OnswOlwiMFwiLDU6XCIwLjA1XCIsMTA6XCIwLjFcIiwyMDpcIjAuMlwiLDI1OlwiMC4yNVwiLDMwOlwiMC4zXCIsNDA6XCIwLjRcIiw1MDpcIjAuNVwiLDYwOlwiMC42XCIsNzA6XCIwLjdcIiw3NTpcIjAuNzVcIiw4MDpcIjAuOFwiLDkwOlwiMC45XCIsOTU6XCIwLjk1XCIsMTAwOlwiMVwifSxvcmRlcjp7Zmlyc3Q6XCItOTk5OVwiLGxhc3Q6XCI5OTk5XCIsbm9uZTpcIjBcIiwxOlwiMVwiLDI6XCIyXCIsMzpcIjNcIiw0OlwiNFwiLDU6XCI1XCIsNjpcIjZcIiw3OlwiN1wiLDg6XCI4XCIsOTpcIjlcIiwxMDpcIjEwXCIsMTE6XCIxMVwiLDEyOlwiMTJcIn0scGFkZGluZzooe3RoZW1lOmV9KT0+ZShcInNwYWNpbmdcIikscGxhY2Vob2xkZXJDb2xvcjooe3RoZW1lOmV9KT0+ZShcImNvbG9yc1wiKSxwbGFjZWhvbGRlck9wYWNpdHk6KHt0aGVtZTplfSk9PmUoXCJvcGFjaXR5XCIpLG91dGxpbmVDb2xvcjooe3RoZW1lOmV9KT0+ZShcImNvbG9yc1wiKSxvdXRsaW5lT2Zmc2V0OnswOlwiMHB4XCIsMTpcIjFweFwiLDI6XCIycHhcIiw0OlwiNHB4XCIsODpcIjhweFwifSxvdXRsaW5lV2lkdGg6ezA6XCIwcHhcIiwxOlwiMXB4XCIsMjpcIjJweFwiLDQ6XCI0cHhcIiw4OlwiOHB4XCJ9LHJpbmdDb2xvcjooe3RoZW1lOmV9KT0+KHtERUZBVUxUOmUoXCJjb2xvcnMuYmx1ZS41MDBcIixcIiMzYjgyZjZcIiksLi4uZShcImNvbG9yc1wiKX0pLHJpbmdPZmZzZXRDb2xvcjooe3RoZW1lOmV9KT0+ZShcImNvbG9yc1wiKSxyaW5nT2Zmc2V0V2lkdGg6ezA6XCIwcHhcIiwxOlwiMXB4XCIsMjpcIjJweFwiLDQ6XCI0cHhcIiw4OlwiOHB4XCJ9LHJpbmdPcGFjaXR5Oih7dGhlbWU6ZX0pPT4oe0RFRkFVTFQ6XCIwLjVcIiwuLi5lKFwib3BhY2l0eVwiKX0pLHJpbmdXaWR0aDp7REVGQVVMVDpcIjNweFwiLDA6XCIwcHhcIiwxOlwiMXB4XCIsMjpcIjJweFwiLDQ6XCI0cHhcIiw4OlwiOHB4XCJ9LHJvdGF0ZTp7MDpcIjBkZWdcIiwxOlwiMWRlZ1wiLDI6XCIyZGVnXCIsMzpcIjNkZWdcIiw2OlwiNmRlZ1wiLDEyOlwiMTJkZWdcIiw0NTpcIjQ1ZGVnXCIsOTA6XCI5MGRlZ1wiLDE4MDpcIjE4MGRlZ1wifSxzYXR1cmF0ZTp7MDpcIjBcIiw1MDpcIi41XCIsMTAwOlwiMVwiLDE1MDpcIjEuNVwiLDIwMDpcIjJcIn0sc2NhbGU6ezA6XCIwXCIsNTA6XCIuNVwiLDc1OlwiLjc1XCIsOTA6XCIuOVwiLDk1OlwiLjk1XCIsMTAwOlwiMVwiLDEwNTpcIjEuMDVcIiwxMTA6XCIxLjFcIiwxMjU6XCIxLjI1XCIsMTUwOlwiMS41XCJ9LHNjcm9sbE1hcmdpbjooe3RoZW1lOmV9KT0+KHsuLi5lKFwic3BhY2luZ1wiKX0pLHNjcm9sbFBhZGRpbmc6KHt0aGVtZTplfSk9PmUoXCJzcGFjaW5nXCIpLHNlcGlhOnswOlwiMFwiLERFRkFVTFQ6XCIxMDAlXCJ9LHNrZXc6ezA6XCIwZGVnXCIsMTpcIjFkZWdcIiwyOlwiMmRlZ1wiLDM6XCIzZGVnXCIsNjpcIjZkZWdcIiwxMjpcIjEyZGVnXCJ9LHNwYWNlOih7dGhlbWU6ZX0pPT4oey4uLmUoXCJzcGFjaW5nXCIpfSksc3Ryb2tlOih7dGhlbWU6ZX0pPT5lKFwiY29sb3JzXCIpLHN0cm9rZVdpZHRoOnswOlwiMFwiLDE6XCIxXCIsMjpcIjJcIn0sdGV4dENvbG9yOih7dGhlbWU6ZX0pPT5lKFwiY29sb3JzXCIpLHRleHREZWNvcmF0aW9uQ29sb3I6KHt0aGVtZTplfSk9PmUoXCJjb2xvcnNcIiksdGV4dERlY29yYXRpb25UaGlja25lc3M6e2F1dG86XCJhdXRvXCIsXCJmcm9tLWZvbnRcIjpcImZyb20tZm9udFwiLDA6XCIwcHhcIiwxOlwiMXB4XCIsMjpcIjJweFwiLDQ6XCI0cHhcIiw4OlwiOHB4XCJ9LHRleHRVbmRlcmxpbmVPZmZzZXQ6e2F1dG86XCJhdXRvXCIsMDpcIjBweFwiLDE6XCIxcHhcIiwyOlwiMnB4XCIsNDpcIjRweFwiLDg6XCI4cHhcIn0sdGV4dEluZGVudDooe3RoZW1lOmV9KT0+KHsuLi5lKFwic3BhY2luZ1wiKX0pLHRleHRPcGFjaXR5Oih7dGhlbWU6ZX0pPT5lKFwib3BhY2l0eVwiKSx0cmFuc2Zvcm1PcmlnaW46e2NlbnRlcjpcImNlbnRlclwiLHRvcDpcInRvcFwiLFwidG9wLXJpZ2h0XCI6XCJ0b3AgcmlnaHRcIixyaWdodDpcInJpZ2h0XCIsXCJib3R0b20tcmlnaHRcIjpcImJvdHRvbSByaWdodFwiLGJvdHRvbTpcImJvdHRvbVwiLFwiYm90dG9tLWxlZnRcIjpcImJvdHRvbSBsZWZ0XCIsbGVmdDpcImxlZnRcIixcInRvcC1sZWZ0XCI6XCJ0b3AgbGVmdFwifSx0cmFuc2l0aW9uRGVsYXk6ezc1OlwiNzVtc1wiLDEwMDpcIjEwMG1zXCIsMTUwOlwiMTUwbXNcIiwyMDA6XCIyMDBtc1wiLDMwMDpcIjMwMG1zXCIsNTAwOlwiNTAwbXNcIiw3MDA6XCI3MDBtc1wiLDFlMzpcIjEwMDBtc1wifSx0cmFuc2l0aW9uRHVyYXRpb246e0RFRkFVTFQ6XCIxNTBtc1wiLDc1OlwiNzVtc1wiLDEwMDpcIjEwMG1zXCIsMTUwOlwiMTUwbXNcIiwyMDA6XCIyMDBtc1wiLDMwMDpcIjMwMG1zXCIsNTAwOlwiNTAwbXNcIiw3MDA6XCI3MDBtc1wiLDFlMzpcIjEwMDBtc1wifSx0cmFuc2l0aW9uUHJvcGVydHk6e25vbmU6XCJub25lXCIsYWxsOlwiYWxsXCIsREVGQVVMVDpcImNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgYmFja2Ryb3AtZmlsdGVyXCIsY29sb3JzOlwiY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2VcIixvcGFjaXR5Olwib3BhY2l0eVwiLHNoYWRvdzpcImJveC1zaGFkb3dcIix0cmFuc2Zvcm06XCJ0cmFuc2Zvcm1cIn0sdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOntERUZBVUxUOlwiY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKVwiLGxpbmVhcjpcImxpbmVhclwiLGluOlwiY3ViaWMtYmV6aWVyKDAuNCwgMCwgMSwgMSlcIixvdXQ6XCJjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAxKVwiLFwiaW4tb3V0XCI6XCJjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpXCJ9LHRyYW5zbGF0ZTooe3RoZW1lOmV9KT0+KHsuLi5lKFwic3BhY2luZ1wiKSxcIjEvMlwiOlwiNTAlXCIsXCIxLzNcIjpcIjMzLjMzMzMzMyVcIixcIjIvM1wiOlwiNjYuNjY2NjY3JVwiLFwiMS80XCI6XCIyNSVcIixcIjIvNFwiOlwiNTAlXCIsXCIzLzRcIjpcIjc1JVwiLGZ1bGw6XCIxMDAlXCJ9KSx3aWR0aDooe3RoZW1lOmV9KT0+KHthdXRvOlwiYXV0b1wiLC4uLmUoXCJzcGFjaW5nXCIpLFwiMS8yXCI6XCI1MCVcIixcIjEvM1wiOlwiMzMuMzMzMzMzJVwiLFwiMi8zXCI6XCI2Ni42NjY2NjclXCIsXCIxLzRcIjpcIjI1JVwiLFwiMi80XCI6XCI1MCVcIixcIjMvNFwiOlwiNzUlXCIsXCIxLzVcIjpcIjIwJVwiLFwiMi81XCI6XCI0MCVcIixcIjMvNVwiOlwiNjAlXCIsXCI0LzVcIjpcIjgwJVwiLFwiMS82XCI6XCIxNi42NjY2NjclXCIsXCIyLzZcIjpcIjMzLjMzMzMzMyVcIixcIjMvNlwiOlwiNTAlXCIsXCI0LzZcIjpcIjY2LjY2NjY2NyVcIixcIjUvNlwiOlwiODMuMzMzMzMzJVwiLFwiMS8xMlwiOlwiOC4zMzMzMzMlXCIsXCIyLzEyXCI6XCIxNi42NjY2NjclXCIsXCIzLzEyXCI6XCIyNSVcIixcIjQvMTJcIjpcIjMzLjMzMzMzMyVcIixcIjUvMTJcIjpcIjQxLjY2NjY2NyVcIixcIjYvMTJcIjpcIjUwJVwiLFwiNy8xMlwiOlwiNTguMzMzMzMzJVwiLFwiOC8xMlwiOlwiNjYuNjY2NjY3JVwiLFwiOS8xMlwiOlwiNzUlXCIsXCIxMC8xMlwiOlwiODMuMzMzMzMzJVwiLFwiMTEvMTJcIjpcIjkxLjY2NjY2NyVcIixmdWxsOlwiMTAwJVwiLHNjcmVlbjpcIjEwMHZ3XCIsbWluOlwibWluLWNvbnRlbnRcIixtYXg6XCJtYXgtY29udGVudFwiLGZpdDpcImZpdC1jb250ZW50XCJ9KSx3aWxsQ2hhbmdlOnthdXRvOlwiYXV0b1wiLHNjcm9sbDpcInNjcm9sbC1wb3NpdGlvblwiLGNvbnRlbnRzOlwiY29udGVudHNcIix0cmFuc2Zvcm06XCJ0cmFuc2Zvcm1cIn0sekluZGV4OnthdXRvOlwiYXV0b1wiLDA6XCIwXCIsMTA6XCIxMFwiLDIwOlwiMjBcIiwzMDpcIjMwXCIsNDA6XCI0MFwiLDUwOlwiNTBcIn19LHZhcmlhbnRPcmRlcjpbXCJmaXJzdFwiLFwibGFzdFwiLFwib2RkXCIsXCJldmVuXCIsXCJ2aXNpdGVkXCIsXCJjaGVja2VkXCIsXCJlbXB0eVwiLFwicmVhZC1vbmx5XCIsXCJncm91cC1ob3ZlclwiLFwiZ3JvdXAtZm9jdXNcIixcImZvY3VzLXdpdGhpblwiLFwiaG92ZXJcIixcImZvY3VzXCIsXCJmb2N1cy12aXNpYmxlXCIsXCJhY3RpdmVcIixcImRpc2FibGVkXCJdLHBsdWdpbnM6W119fSk7dmFyIHZyPXt9O2NvKHZyLHtkZWZhdWx0OigpPT5sbH0pO3ZhciBsbCxicj1CcigoKT0+e2MoKTtsbD17aW5mbyhlLHQpe2NvbnNvbGUuaW5mbyguLi5BcnJheS5pc0FycmF5KGUpP1tlXTpbdCxlXSl9LHdhcm4oZSx0KXtjb25zb2xlLndhcm4oLi4uQXJyYXkuaXNBcnJheShlKT9bZV06W3QsZV0pfSxyaXNrKGUsdCl7Y29uc29sZS5lcnJvciguLi5BcnJheS5pc0FycmF5KGUpP1tlXTpbdCxlXSl9fX0pO3ZhciBxbz1SKHluPT57XCJ1c2Ugc3RyaWN0XCI7YygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh5bixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeW4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsZ2V0OigpPT5kbH0pO3ZhciBmbD1jbCgoYnIoKSxhcih2cikpKTtmdW5jdGlvbiBjbChlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gYnQoe3ZlcnNpb246ZSxmcm9tOnQsdG86bn0pe2ZsLmRlZmF1bHQud2FybihgJHt0fS1jb2xvci1yZW5hbWVkYCxbYEFzIG9mIFRhaWx3aW5kIENTUyAke2V9LCBcXGAke3R9XFxgIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgJHtufVxcYC5gLFwiVXBkYXRlIHlvdXIgY29uZmlndXJhdGlvbiBmaWxlIHRvIHNpbGVuY2UgdGhpcyB3YXJuaW5nLlwiXSl9dmFyIGRsPXtpbmhlcml0OlwiaW5oZXJpdFwiLGN1cnJlbnQ6XCJjdXJyZW50Q29sb3JcIix0cmFuc3BhcmVudDpcInRyYW5zcGFyZW50XCIsYmxhY2s6XCIjMDAwXCIsd2hpdGU6XCIjZmZmXCIsc2xhdGU6ezUwOlwiI2Y4ZmFmY1wiLDEwMDpcIiNmMWY1ZjlcIiwyMDA6XCIjZTJlOGYwXCIsMzAwOlwiI2NiZDVlMVwiLDQwMDpcIiM5NGEzYjhcIiw1MDA6XCIjNjQ3NDhiXCIsNjAwOlwiIzQ3NTU2OVwiLDcwMDpcIiMzMzQxNTVcIiw4MDA6XCIjMWUyOTNiXCIsOTAwOlwiIzBmMTcyYVwifSxncmF5Ons1MDpcIiNmOWZhZmJcIiwxMDA6XCIjZjNmNGY2XCIsMjAwOlwiI2U1ZTdlYlwiLDMwMDpcIiNkMWQ1ZGJcIiw0MDA6XCIjOWNhM2FmXCIsNTAwOlwiIzZiNzI4MFwiLDYwMDpcIiM0YjU1NjNcIiw3MDA6XCIjMzc0MTUxXCIsODAwOlwiIzFmMjkzN1wiLDkwMDpcIiMxMTE4MjdcIn0semluYzp7NTA6XCIjZmFmYWZhXCIsMTAwOlwiI2Y0ZjRmNVwiLDIwMDpcIiNlNGU0ZTdcIiwzMDA6XCIjZDRkNGQ4XCIsNDAwOlwiI2ExYTFhYVwiLDUwMDpcIiM3MTcxN2FcIiw2MDA6XCIjNTI1MjViXCIsNzAwOlwiIzNmM2Y0NlwiLDgwMDpcIiMyNzI3MmFcIiw5MDA6XCIjMTgxODFiXCJ9LG5ldXRyYWw6ezUwOlwiI2ZhZmFmYVwiLDEwMDpcIiNmNWY1ZjVcIiwyMDA6XCIjZTVlNWU1XCIsMzAwOlwiI2Q0ZDRkNFwiLDQwMDpcIiNhM2EzYTNcIiw1MDA6XCIjNzM3MzczXCIsNjAwOlwiIzUyNTI1MlwiLDcwMDpcIiM0MDQwNDBcIiw4MDA6XCIjMjYyNjI2XCIsOTAwOlwiIzE3MTcxN1wifSxzdG9uZTp7NTA6XCIjZmFmYWY5XCIsMTAwOlwiI2Y1ZjVmNFwiLDIwMDpcIiNlN2U1ZTRcIiwzMDA6XCIjZDZkM2QxXCIsNDAwOlwiI2E4YTI5ZVwiLDUwMDpcIiM3ODcxNmNcIiw2MDA6XCIjNTc1MzRlXCIsNzAwOlwiIzQ0NDAzY1wiLDgwMDpcIiMyOTI1MjRcIiw5MDA6XCIjMWMxOTE3XCJ9LHJlZDp7NTA6XCIjZmVmMmYyXCIsMTAwOlwiI2ZlZTJlMlwiLDIwMDpcIiNmZWNhY2FcIiwzMDA6XCIjZmNhNWE1XCIsNDAwOlwiI2Y4NzE3MVwiLDUwMDpcIiNlZjQ0NDRcIiw2MDA6XCIjZGMyNjI2XCIsNzAwOlwiI2I5MWMxY1wiLDgwMDpcIiM5OTFiMWJcIiw5MDA6XCIjN2YxZDFkXCJ9LG9yYW5nZTp7NTA6XCIjZmZmN2VkXCIsMTAwOlwiI2ZmZWRkNVwiLDIwMDpcIiNmZWQ3YWFcIiwzMDA6XCIjZmRiYTc0XCIsNDAwOlwiI2ZiOTIzY1wiLDUwMDpcIiNmOTczMTZcIiw2MDA6XCIjZWE1ODBjXCIsNzAwOlwiI2MyNDEwY1wiLDgwMDpcIiM5YTM0MTJcIiw5MDA6XCIjN2MyZDEyXCJ9LGFtYmVyOns1MDpcIiNmZmZiZWJcIiwxMDA6XCIjZmVmM2M3XCIsMjAwOlwiI2ZkZTY4YVwiLDMwMDpcIiNmY2QzNGRcIiw0MDA6XCIjZmJiZjI0XCIsNTAwOlwiI2Y1OWUwYlwiLDYwMDpcIiNkOTc3MDZcIiw3MDA6XCIjYjQ1MzA5XCIsODAwOlwiIzkyNDAwZVwiLDkwMDpcIiM3ODM1MGZcIn0seWVsbG93Ons1MDpcIiNmZWZjZThcIiwxMDA6XCIjZmVmOWMzXCIsMjAwOlwiI2ZlZjA4YVwiLDMwMDpcIiNmZGUwNDdcIiw0MDA6XCIjZmFjYzE1XCIsNTAwOlwiI2VhYjMwOFwiLDYwMDpcIiNjYThhMDRcIiw3MDA6XCIjYTE2MjA3XCIsODAwOlwiIzg1NGQwZVwiLDkwMDpcIiM3MTNmMTJcIn0sbGltZTp7NTA6XCIjZjdmZWU3XCIsMTAwOlwiI2VjZmNjYlwiLDIwMDpcIiNkOWY5OWRcIiwzMDA6XCIjYmVmMjY0XCIsNDAwOlwiI2EzZTYzNVwiLDUwMDpcIiM4NGNjMTZcIiw2MDA6XCIjNjVhMzBkXCIsNzAwOlwiIzRkN2MwZlwiLDgwMDpcIiMzZjYyMTJcIiw5MDA6XCIjMzY1MzE0XCJ9LGdyZWVuOns1MDpcIiNmMGZkZjRcIiwxMDA6XCIjZGNmY2U3XCIsMjAwOlwiI2JiZjdkMFwiLDMwMDpcIiM4NmVmYWNcIiw0MDA6XCIjNGFkZTgwXCIsNTAwOlwiIzIyYzU1ZVwiLDYwMDpcIiMxNmEzNGFcIiw3MDA6XCIjMTU4MDNkXCIsODAwOlwiIzE2NjUzNFwiLDkwMDpcIiMxNDUzMmRcIn0sZW1lcmFsZDp7NTA6XCIjZWNmZGY1XCIsMTAwOlwiI2QxZmFlNVwiLDIwMDpcIiNhN2YzZDBcIiwzMDA6XCIjNmVlN2I3XCIsNDAwOlwiIzM0ZDM5OVwiLDUwMDpcIiMxMGI5ODFcIiw2MDA6XCIjMDU5NjY5XCIsNzAwOlwiIzA0Nzg1N1wiLDgwMDpcIiMwNjVmNDZcIiw5MDA6XCIjMDY0ZTNiXCJ9LHRlYWw6ezUwOlwiI2YwZmRmYVwiLDEwMDpcIiNjY2ZiZjFcIiwyMDA6XCIjOTlmNmU0XCIsMzAwOlwiIzVlZWFkNFwiLDQwMDpcIiMyZGQ0YmZcIiw1MDA6XCIjMTRiOGE2XCIsNjAwOlwiIzBkOTQ4OFwiLDcwMDpcIiMwZjc2NmVcIiw4MDA6XCIjMTE1ZTU5XCIsOTAwOlwiIzEzNGU0YVwifSxjeWFuOns1MDpcIiNlY2ZlZmZcIiwxMDA6XCIjY2ZmYWZlXCIsMjAwOlwiI2E1ZjNmY1wiLDMwMDpcIiM2N2U4ZjlcIiw0MDA6XCIjMjJkM2VlXCIsNTAwOlwiIzA2YjZkNFwiLDYwMDpcIiMwODkxYjJcIiw3MDA6XCIjMGU3NDkwXCIsODAwOlwiIzE1NWU3NVwiLDkwMDpcIiMxNjRlNjNcIn0sc2t5Ons1MDpcIiNmMGY5ZmZcIiwxMDA6XCIjZTBmMmZlXCIsMjAwOlwiI2JhZTZmZFwiLDMwMDpcIiM3ZGQzZmNcIiw0MDA6XCIjMzhiZGY4XCIsNTAwOlwiIzBlYTVlOVwiLDYwMDpcIiMwMjg0YzdcIiw3MDA6XCIjMDM2OWExXCIsODAwOlwiIzA3NTk4NVwiLDkwMDpcIiMwYzRhNmVcIn0sYmx1ZTp7NTA6XCIjZWZmNmZmXCIsMTAwOlwiI2RiZWFmZVwiLDIwMDpcIiNiZmRiZmVcIiwzMDA6XCIjOTNjNWZkXCIsNDAwOlwiIzYwYTVmYVwiLDUwMDpcIiMzYjgyZjZcIiw2MDA6XCIjMjU2M2ViXCIsNzAwOlwiIzFkNGVkOFwiLDgwMDpcIiMxZTQwYWZcIiw5MDA6XCIjMWUzYThhXCJ9LGluZGlnbzp7NTA6XCIjZWVmMmZmXCIsMTAwOlwiI2UwZTdmZlwiLDIwMDpcIiNjN2QyZmVcIiwzMDA6XCIjYTViNGZjXCIsNDAwOlwiIzgxOGNmOFwiLDUwMDpcIiM2MzY2ZjFcIiw2MDA6XCIjNGY0NmU1XCIsNzAwOlwiIzQzMzhjYVwiLDgwMDpcIiMzNzMwYTNcIiw5MDA6XCIjMzEyZTgxXCJ9LHZpb2xldDp7NTA6XCIjZjVmM2ZmXCIsMTAwOlwiI2VkZTlmZVwiLDIwMDpcIiNkZGQ2ZmVcIiwzMDA6XCIjYzRiNWZkXCIsNDAwOlwiI2E3OGJmYVwiLDUwMDpcIiM4YjVjZjZcIiw2MDA6XCIjN2MzYWVkXCIsNzAwOlwiIzZkMjhkOVwiLDgwMDpcIiM1YjIxYjZcIiw5MDA6XCIjNGMxZDk1XCJ9LHB1cnBsZTp7NTA6XCIjZmFmNWZmXCIsMTAwOlwiI2YzZThmZlwiLDIwMDpcIiNlOWQ1ZmZcIiwzMDA6XCIjZDhiNGZlXCIsNDAwOlwiI2MwODRmY1wiLDUwMDpcIiNhODU1ZjdcIiw2MDA6XCIjOTMzM2VhXCIsNzAwOlwiIzdlMjJjZVwiLDgwMDpcIiM2YjIxYThcIiw5MDA6XCIjNTgxYzg3XCJ9LGZ1Y2hzaWE6ezUwOlwiI2ZkZjRmZlwiLDEwMDpcIiNmYWU4ZmZcIiwyMDA6XCIjZjVkMGZlXCIsMzAwOlwiI2YwYWJmY1wiLDQwMDpcIiNlODc5ZjlcIiw1MDA6XCIjZDk0NmVmXCIsNjAwOlwiI2MwMjZkM1wiLDcwMDpcIiNhMjFjYWZcIiw4MDA6XCIjODYxOThmXCIsOTAwOlwiIzcwMWE3NVwifSxwaW5rOns1MDpcIiNmZGYyZjhcIiwxMDA6XCIjZmNlN2YzXCIsMjAwOlwiI2ZiY2ZlOFwiLDMwMDpcIiNmOWE4ZDRcIiw0MDA6XCIjZjQ3MmI2XCIsNTAwOlwiI2VjNDg5OVwiLDYwMDpcIiNkYjI3NzdcIiw3MDA6XCIjYmUxODVkXCIsODAwOlwiIzlkMTc0ZFwiLDkwMDpcIiM4MzE4NDNcIn0scm9zZTp7NTA6XCIjZmZmMWYyXCIsMTAwOlwiI2ZmZTRlNlwiLDIwMDpcIiNmZWNkZDNcIiwzMDA6XCIjZmRhNGFmXCIsNDAwOlwiI2ZiNzE4NVwiLDUwMDpcIiNmNDNmNWVcIiw2MDA6XCIjZTExZDQ4XCIsNzAwOlwiI2JlMTIzY1wiLDgwMDpcIiM5ZjEyMzlcIiw5MDA6XCIjODgxMzM3XCJ9LGdldCBsaWdodEJsdWUoKXtyZXR1cm4gYnQoe3ZlcnNpb246XCJ2Mi4yXCIsZnJvbTpcImxpZ2h0Qmx1ZVwiLHRvOlwic2t5XCJ9KSx0aGlzLnNreX0sZ2V0IHdhcm1HcmF5KCl7cmV0dXJuIGJ0KHt2ZXJzaW9uOlwidjMuMFwiLGZyb206XCJ3YXJtR3JheVwiLHRvOlwic3RvbmVcIn0pLHRoaXMuc3RvbmV9LGdldCB0cnVlR3JheSgpe3JldHVybiBidCh7dmVyc2lvbjpcInYzLjBcIixmcm9tOlwidHJ1ZUdyYXlcIix0bzpcIm5ldXRyYWxcIn0pLHRoaXMubmV1dHJhbH0sZ2V0IGNvb2xHcmF5KCl7cmV0dXJuIGJ0KHt2ZXJzaW9uOlwidjMuMFwiLGZyb206XCJjb29sR3JheVwiLHRvOlwiZ3JheVwifSksdGhpcy5ncmF5fSxnZXQgYmx1ZUdyYXkoKXtyZXR1cm4gYnQoe3ZlcnNpb246XCJ2My4wXCIsZnJvbTpcImJsdWVHcmF5XCIsdG86XCJzbGF0ZVwifSksdGhpcy5zbGF0ZX19fSk7dmFyIEJvPVIoeG49PntcInVzZSBzdHJpY3RcIjtjKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHhuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh4bixcImRlZmF1bHRzXCIse2VudW1lcmFibGU6ITAsZ2V0OigpPT5wbH0pO2Z1bmN0aW9uIHBsKGUsLi4udCl7Zm9yKGxldCBpIG9mIHQpe2ZvcihsZXQgYSBpbiBpKXt2YXIgbjshKGU9PW51bGx8fChuPWUuaGFzT3duUHJvcGVydHkpPT09bnVsbHx8bj09PXZvaWQgMCkmJm4uY2FsbChlLGEpfHwoZVthXT1pW2FdKX1mb3IobGV0IGEgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhpKSl7dmFyIHI7IShlPT1udWxsfHwocj1lLmhhc093blByb3BlcnR5KT09PW51bGx8fHI9PT12b2lkIDApJiZyLmNhbGwoZSxhKXx8KGVbYV09aVthXSl9fXJldHVybiBlfX0pO3ZhciBVbz1SKHduPT57XCJ1c2Ugc3RyaWN0XCI7YygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3bixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkod24sXCJ0b1BhdGhcIix7ZW51bWVyYWJsZTohMCxnZXQ6KCk9PmhsfSk7ZnVuY3Rpb24gaGwoZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZTtsZXQgdD1lLnNwbGl0KFwiW1wiKS5sZW5ndGgtMSxuPWUuc3BsaXQoXCJdXCIpLmxlbmd0aC0xO2lmKHQhPT1uKXRocm93IG5ldyBFcnJvcihgUGF0aCBpcyBpbnZhbGlkLiBIYXMgdW5iYWxhbmNlZCBicmFja2V0czogJHtlfWApO3JldHVybiBlLnNwbGl0KC9cXC4oPyFbXlxcW10qXFxdKXxbXFxbXFxdXS9nKS5maWx0ZXIoQm9vbGVhbil9fSk7dmFyIEdvPVIoX249PntcInVzZSBzdHJpY3RcIjtjKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KF9uLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShfbixcIm5vcm1hbGl6ZUNvbmZpZ1wiLHtlbnVtZXJhYmxlOiEwLGdldDooKT0+Z2x9KTt2YXIgeXQ9bWwoKGJyKCksYXIodnIpKSk7ZnVuY3Rpb24gem8oZSl7aWYodHlwZW9mIFdlYWtNYXAhPVwiZnVuY3Rpb25cIilyZXR1cm4gbnVsbDt2YXIgdD1uZXcgV2Vha01hcCxuPW5ldyBXZWFrTWFwO3JldHVybih6bz1mdW5jdGlvbihyKXtyZXR1cm4gcj9uOnR9KShlKX1mdW5jdGlvbiBtbChlLHQpe2lmKCF0JiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7aWYoZT09PW51bGx8fHR5cGVvZiBlIT1cIm9iamVjdFwiJiZ0eXBlb2YgZSE9XCJmdW5jdGlvblwiKXJldHVybntkZWZhdWx0OmV9O3ZhciBuPXpvKHQpO2lmKG4mJm4uaGFzKGUpKXJldHVybiBuLmdldChlKTt2YXIgcj17fSxpPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIGEgaW4gZSlpZihhIT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGEpKXt2YXIgbz1pP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxhKTpudWxsO28mJihvLmdldHx8by5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLGEsbyk6clthXT1lW2FdfXJldHVybiByLmRlZmF1bHQ9ZSxuJiZuLnNldChlLHIpLHJ9ZnVuY3Rpb24gZ2woZSl7aWYoKCgpPT57aWYoZS5wdXJnZXx8IWUuY29udGVudHx8IUFycmF5LmlzQXJyYXkoZS5jb250ZW50KSYmISh0eXBlb2YgZS5jb250ZW50PT1cIm9iamVjdFwiJiZlLmNvbnRlbnQhPT1udWxsKSlyZXR1cm4hMTtpZihBcnJheS5pc0FycmF5KGUuY29udGVudCkpcmV0dXJuIGUuY29udGVudC5ldmVyeShyPT50eXBlb2Ygcj09XCJzdHJpbmdcIj8hMDohKHR5cGVvZihyPT1udWxsP3ZvaWQgMDpyLnJhdykhPVwic3RyaW5nXCJ8fChyPT1udWxsP3ZvaWQgMDpyLmV4dGVuc2lvbikmJnR5cGVvZihyPT1udWxsP3ZvaWQgMDpyLmV4dGVuc2lvbikhPVwic3RyaW5nXCIpKTtpZih0eXBlb2YgZS5jb250ZW50PT1cIm9iamVjdFwiJiZlLmNvbnRlbnQhPT1udWxsKXtpZihPYmplY3Qua2V5cyhlLmNvbnRlbnQpLnNvbWUocj0+IVtcImZpbGVzXCIsXCJleHRyYWN0XCIsXCJ0cmFuc2Zvcm1cIl0uaW5jbHVkZXMocikpKXJldHVybiExO2lmKEFycmF5LmlzQXJyYXkoZS5jb250ZW50LmZpbGVzKSl7aWYoIWUuY29udGVudC5maWxlcy5ldmVyeShyPT50eXBlb2Ygcj09XCJzdHJpbmdcIj8hMDohKHR5cGVvZihyPT1udWxsP3ZvaWQgMDpyLnJhdykhPVwic3RyaW5nXCJ8fChyPT1udWxsP3ZvaWQgMDpyLmV4dGVuc2lvbikmJnR5cGVvZihyPT1udWxsP3ZvaWQgMDpyLmV4dGVuc2lvbikhPVwic3RyaW5nXCIpKSlyZXR1cm4hMTtpZih0eXBlb2YgZS5jb250ZW50LmV4dHJhY3Q9PVwib2JqZWN0XCIpe2ZvcihsZXQgciBvZiBPYmplY3QudmFsdWVzKGUuY29udGVudC5leHRyYWN0KSlpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiKXJldHVybiExfWVsc2UgaWYoIShlLmNvbnRlbnQuZXh0cmFjdD09PXZvaWQgMHx8dHlwZW9mIGUuY29udGVudC5leHRyYWN0PT1cImZ1bmN0aW9uXCIpKXJldHVybiExO2lmKHR5cGVvZiBlLmNvbnRlbnQudHJhbnNmb3JtPT1cIm9iamVjdFwiKXtmb3IobGV0IHIgb2YgT2JqZWN0LnZhbHVlcyhlLmNvbnRlbnQudHJhbnNmb3JtKSlpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiKXJldHVybiExfWVsc2UgaWYoIShlLmNvbnRlbnQudHJhbnNmb3JtPT09dm9pZCAwfHx0eXBlb2YgZS5jb250ZW50LnRyYW5zZm9ybT09XCJmdW5jdGlvblwiKSlyZXR1cm4hMX1yZXR1cm4hMH1yZXR1cm4hMX0pKCl8fHl0LmRlZmF1bHQud2FybihcInB1cmdlLWRlcHJlY2F0aW9uXCIsW1wiVGhlIGBwdXJnZWAvYGNvbnRlbnRgIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkIGluIFRhaWx3aW5kIENTUyB2My4wLlwiLFwiVXBkYXRlIHlvdXIgY29uZmlndXJhdGlvbiBmaWxlIHRvIGVsaW1pbmF0ZSB0aGlzIHdhcm5pbmcuXCIsXCJodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3VwZ3JhZGUtZ3VpZGUjY29uZmlndXJlLWNvbnRlbnQtc291cmNlc1wiXSksZS5zYWZlbGlzdD0oKCk9Pnt2YXIgcjtsZXR7Y29udGVudDppLHB1cmdlOmEsc2FmZWxpc3Q6b309ZTtyZXR1cm4gQXJyYXkuaXNBcnJheShvKT9vOkFycmF5LmlzQXJyYXkoaT09bnVsbD92b2lkIDA6aS5zYWZlbGlzdCk/aS5zYWZlbGlzdDpBcnJheS5pc0FycmF5KGE9PW51bGw/dm9pZCAwOmEuc2FmZWxpc3QpP2Euc2FmZWxpc3Q6QXJyYXkuaXNBcnJheShhPT1udWxsfHwocj1hLm9wdGlvbnMpPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6ci5zYWZlbGlzdCk/YS5vcHRpb25zLnNhZmVsaXN0OltdfSkoKSx0eXBlb2YgZS5wcmVmaXg9PVwiZnVuY3Rpb25cIil5dC5kZWZhdWx0Lndhcm4oXCJwcmVmaXgtZnVuY3Rpb25cIixbXCJBcyBvZiBUYWlsd2luZCBDU1MgdjMuMCwgYHByZWZpeGAgY2Fubm90IGJlIGEgZnVuY3Rpb24uXCIsXCJVcGRhdGUgYHByZWZpeGAgaW4geW91ciBjb25maWd1cmF0aW9uIHRvIGJlIGEgc3RyaW5nIHRvIGVsaW1pbmF0ZSB0aGlzIHdhcm5pbmcuXCIsXCJodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3VwZ3JhZGUtZ3VpZGUjcHJlZml4LWNhbm5vdC1iZS1hLWZ1bmN0aW9uXCJdKSxlLnByZWZpeD1cIlwiO2Vsc2V7dmFyIG47ZS5wcmVmaXg9KG49ZS5wcmVmaXgpIT09bnVsbCYmbiE9PXZvaWQgMD9uOlwiXCJ9ZS5jb250ZW50PXtmaWxlczooKCk9PntsZXR7Y29udGVudDpyLHB1cmdlOml9PWU7cmV0dXJuIEFycmF5LmlzQXJyYXkoaSk/aTpBcnJheS5pc0FycmF5KGk9PW51bGw/dm9pZCAwOmkuY29udGVudCk/aS5jb250ZW50OkFycmF5LmlzQXJyYXkocik/cjpBcnJheS5pc0FycmF5KHI9PW51bGw/dm9pZCAwOnIuY29udGVudCk/ci5jb250ZW50OkFycmF5LmlzQXJyYXkocj09bnVsbD92b2lkIDA6ci5maWxlcyk/ci5maWxlczpbXX0pKCksZXh0cmFjdDooKCk9PntsZXQgcj0oKCk9Pnt2YXIgbyxzLHUsbCxmLHAsZyxtLGQsaDtyZXR1cm4hKChvPWUucHVyZ2UpPT09bnVsbHx8bz09PXZvaWQgMCkmJm8uZXh0cmFjdD9lLnB1cmdlLmV4dHJhY3Q6ISgocz1lLmNvbnRlbnQpPT09bnVsbHx8cz09PXZvaWQgMCkmJnMuZXh0cmFjdD9lLmNvbnRlbnQuZXh0cmFjdDohKCh1PWUucHVyZ2UpPT09bnVsbHx8dT09PXZvaWQgMHx8KGw9dS5leHRyYWN0KT09PW51bGx8fGw9PT12b2lkIDApJiZsLkRFRkFVTFQ/ZS5wdXJnZS5leHRyYWN0LkRFRkFVTFQ6ISgoZj1lLmNvbnRlbnQpPT09bnVsbHx8Zj09PXZvaWQgMHx8KHA9Zi5leHRyYWN0KT09PW51bGx8fHA9PT12b2lkIDApJiZwLkRFRkFVTFQ/ZS5jb250ZW50LmV4dHJhY3QuREVGQVVMVDohKChnPWUucHVyZ2UpPT09bnVsbHx8Zz09PXZvaWQgMHx8KG09Zy5vcHRpb25zKT09PW51bGx8fG09PT12b2lkIDApJiZtLmV4dHJhY3RvcnM/ZS5wdXJnZS5vcHRpb25zLmV4dHJhY3RvcnM6ISgoZD1lLmNvbnRlbnQpPT09bnVsbHx8ZD09PXZvaWQgMHx8KGg9ZC5vcHRpb25zKT09PW51bGx8fGg9PT12b2lkIDApJiZoLmV4dHJhY3RvcnM/ZS5jb250ZW50Lm9wdGlvbnMuZXh0cmFjdG9yczp7fX0pKCksaT17fSxhPSgoKT0+e3ZhciBvLHMsdSxsO2lmKCEoKG89ZS5wdXJnZSk9PT1udWxsfHxvPT09dm9pZCAwfHwocz1vLm9wdGlvbnMpPT09bnVsbHx8cz09PXZvaWQgMCkmJnMuZGVmYXVsdEV4dHJhY3RvcilyZXR1cm4gZS5wdXJnZS5vcHRpb25zLmRlZmF1bHRFeHRyYWN0b3I7aWYoISgodT1lLmNvbnRlbnQpPT09bnVsbHx8dT09PXZvaWQgMHx8KGw9dS5vcHRpb25zKT09PW51bGx8fGw9PT12b2lkIDApJiZsLmRlZmF1bHRFeHRyYWN0b3IpcmV0dXJuIGUuY29udGVudC5vcHRpb25zLmRlZmF1bHRFeHRyYWN0b3J9KSgpO2lmKGEhPT12b2lkIDAmJihpLkRFRkFVTFQ9YSksdHlwZW9mIHI9PVwiZnVuY3Rpb25cIilpLkRFRkFVTFQ9cjtlbHNlIGlmKEFycmF5LmlzQXJyYXkocikpZm9yKGxldHtleHRlbnNpb25zOm8sZXh0cmFjdG9yOnN9b2YgciE9bnVsbD9yOltdKWZvcihsZXQgdSBvZiBvKWlbdV09cztlbHNlIHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbCYmT2JqZWN0LmFzc2lnbihpLHIpO3JldHVybiBpfSkoKSx0cmFuc2Zvcm06KCgpPT57bGV0IHI9KCgpPT57dmFyIGEsbyxzLHUsbCxmO3JldHVybiEoKGE9ZS5wdXJnZSk9PT1udWxsfHxhPT09dm9pZCAwKSYmYS50cmFuc2Zvcm0/ZS5wdXJnZS50cmFuc2Zvcm06ISgobz1lLmNvbnRlbnQpPT09bnVsbHx8bz09PXZvaWQgMCkmJm8udHJhbnNmb3JtP2UuY29udGVudC50cmFuc2Zvcm06ISgocz1lLnB1cmdlKT09PW51bGx8fHM9PT12b2lkIDB8fCh1PXMudHJhbnNmb3JtKT09PW51bGx8fHU9PT12b2lkIDApJiZ1LkRFRkFVTFQ/ZS5wdXJnZS50cmFuc2Zvcm0uREVGQVVMVDohKChsPWUuY29udGVudCk9PT1udWxsfHxsPT09dm9pZCAwfHwoZj1sLnRyYW5zZm9ybSk9PT1udWxsfHxmPT09dm9pZCAwKSYmZi5ERUZBVUxUP2UuY29udGVudC50cmFuc2Zvcm0uREVGQVVMVDp7fX0pKCksaT17fTtyZXR1cm4gdHlwZW9mIHI9PVwiZnVuY3Rpb25cIiYmKGkuREVGQVVMVD1yKSx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwmJk9iamVjdC5hc3NpZ24oaSxyKSxpfSkoKX07Zm9yKGxldCByIG9mIGUuY29udGVudC5maWxlcylpZih0eXBlb2Ygcj09XCJzdHJpbmdcIiYmL3soW14sXSo/KX0vZy50ZXN0KHIpKXt5dC5kZWZhdWx0Lndhcm4oXCJpbnZhbGlkLWdsb2ItYnJhY2VzXCIsW2BUaGUgZ2xvYiBwYXR0ZXJuICR7KDAseXQuZGltKShyKX0gaW4geW91ciBUYWlsd2luZCBDU1MgY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLmAsYFVwZGF0ZSBpdCB0byAkeygwLHl0LmRpbSkoci5yZXBsYWNlKC97KFteLF0qPyl9L2csXCIkMVwiKSl9IHRvIHNpbGVuY2UgdGhpcyB3YXJuaW5nLmBdKTticmVha31yZXR1cm4gZX19KTt2YXIgam89UihTbj0+e1widXNlIHN0cmljdFwiO2MoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoU24sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFNuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLGdldDooKT0+dmx9KTtmdW5jdGlvbiB2bChlKXtpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkhPT1cIltvYmplY3QgT2JqZWN0XVwiKXJldHVybiExO2xldCB0PU9iamVjdC5nZXRQcm90b3R5cGVPZihlKTtyZXR1cm4gdD09PW51bGx8fHQ9PT1PYmplY3QucHJvdG90eXBlfX0pO3ZhciBWbz1SKFRuPT57XCJ1c2Ugc3RyaWN0XCI7YygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShUbixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoVG4sXCJjbG9uZURlZXBcIix7ZW51bWVyYWJsZTohMCxnZXQ6KCk9PmtufSk7ZnVuY3Rpb24ga24oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5tYXAodD0+a24odCkpOnR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbD9PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZSkubWFwKChbdCxuXSk9Plt0LGtuKG4pXSkpOmV9fSk7dmFyIEVuPVIoKHlyLEhvKT0+e1widXNlIHN0cmljdFwiO2MoKTt5ci5fX2VzTW9kdWxlPSEwO3lyLmRlZmF1bHQ9eGw7ZnVuY3Rpb24gYmwoZSl7Zm9yKHZhciB0PWUudG9Mb3dlckNhc2UoKSxuPVwiXCIscj0hMSxpPTA7aTw2JiZ0W2ldIT09dm9pZCAwO2krKyl7dmFyIGE9dC5jaGFyQ29kZUF0KGkpLG89YT49OTcmJmE8PTEwMnx8YT49NDgmJmE8PTU3O2lmKHI9YT09PTMyLCFvKWJyZWFrO24rPXRbaV19aWYobi5sZW5ndGghPT0wKXt2YXIgcz1wYXJzZUludChuLDE2KSx1PXM+PTU1Mjk2JiZzPD01NzM0MztyZXR1cm4gdXx8cz09PTB8fHM+MTExNDExMT9bXCJcXHVGRkZEXCIsbi5sZW5ndGgrKHI/MTowKV06W1N0cmluZy5mcm9tQ29kZVBvaW50KHMpLG4ubGVuZ3RoKyhyPzE6MCldfX12YXIgeWw9L1xcXFwvO2Z1bmN0aW9uIHhsKGUpe3ZhciB0PXlsLnRlc3QoZSk7aWYoIXQpcmV0dXJuIGU7Zm9yKHZhciBuPVwiXCIscj0wO3I8ZS5sZW5ndGg7cisrKXtpZihlW3JdPT09XCJcXFxcXCIpe3ZhciBpPWJsKGUuc2xpY2UocisxLHIrNykpO2lmKGkhPT12b2lkIDApe24rPWlbMF0scis9aVsxXTtjb250aW51ZX1pZihlW3IrMV09PT1cIlxcXFxcIil7bis9XCJcXFxcXCIscisrO2NvbnRpbnVlfWUubGVuZ3RoPT09cisxJiYobis9ZVtyXSk7Y29udGludWV9bis9ZVtyXX1yZXR1cm4gbn1Iby5leHBvcnRzPXlyLmRlZmF1bHR9KTt2YXIgWG89UigoeHIsWW8pPT57XCJ1c2Ugc3RyaWN0XCI7YygpO3hyLl9fZXNNb2R1bGU9ITA7eHIuZGVmYXVsdD13bDtmdW5jdGlvbiB3bChlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLHI9MTtyPHQ7cisrKW5bci0xXT1hcmd1bWVudHNbcl07Zm9yKDtuLmxlbmd0aD4wOyl7dmFyIGk9bi5zaGlmdCgpO2lmKCFlW2ldKXJldHVybjtlPWVbaV19cmV0dXJuIGV9WW8uZXhwb3J0cz14ci5kZWZhdWx0fSk7dmFyIEpvPVIoKHdyLFFvKT0+e1widXNlIHN0cmljdFwiO2MoKTt3ci5fX2VzTW9kdWxlPSEwO3dyLmRlZmF1bHQ9X2w7ZnVuY3Rpb24gX2woZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkodD4xP3QtMTowKSxyPTE7cjx0O3IrKyluW3ItMV09YXJndW1lbnRzW3JdO2Zvcig7bi5sZW5ndGg+MDspe3ZhciBpPW4uc2hpZnQoKTtlW2ldfHwoZVtpXT17fSksZT1lW2ldfX1Rby5leHBvcnRzPXdyLmRlZmF1bHR9KTt2YXIgWm89UigoX3IsS28pPT57XCJ1c2Ugc3RyaWN0XCI7YygpO19yLl9fZXNNb2R1bGU9ITA7X3IuZGVmYXVsdD1TbDtmdW5jdGlvbiBTbChlKXtmb3IodmFyIHQ9XCJcIixuPWUuaW5kZXhPZihcIi8qXCIpLHI9MDtuPj0wOyl7dD10K2Uuc2xpY2UocixuKTt2YXIgaT1lLmluZGV4T2YoXCIqL1wiLG4rMik7aWYoaTwwKXJldHVybiB0O3I9aSsyLG49ZS5pbmRleE9mKFwiLypcIixyKX1yZXR1cm4gdD10K2Uuc2xpY2UociksdH1Lby5leHBvcnRzPV9yLmRlZmF1bHR9KTt2YXIgeHQ9UihUZT0+e1widXNlIHN0cmljdFwiO2MoKTtUZS5fX2VzTW9kdWxlPSEwO1RlLnN0cmlwQ29tbWVudHM9VGUuZW5zdXJlT2JqZWN0PVRlLmdldFByb3A9VGUudW5lc2M9dm9pZCAwO3ZhciBrbD1TcihFbigpKTtUZS51bmVzYz1rbC5kZWZhdWx0O3ZhciBUbD1TcihYbygpKTtUZS5nZXRQcm9wPVRsLmRlZmF1bHQ7dmFyIEVsPVNyKEpvKCkpO1RlLmVuc3VyZU9iamVjdD1FbC5kZWZhdWx0O3ZhciBPbD1TcihabygpKTtUZS5zdHJpcENvbW1lbnRzPU9sLmRlZmF1bHQ7ZnVuY3Rpb24gU3IoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0pO3ZhciBJZT1SKCh3dCxyYSk9PntcInVzZSBzdHJpY3RcIjtjKCk7d3QuX19lc01vZHVsZT0hMDt3dC5kZWZhdWx0PXZvaWQgMDt2YXIgZWE9eHQoKTtmdW5jdGlvbiB0YShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gUGwoZSx0LG4pe3JldHVybiB0JiZ0YShlLnByb3RvdHlwZSx0KSxuJiZ0YShlLG4pLGV9dmFyIEFsPWZ1bmN0aW9uIGUodCxuKXtpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8dD09PW51bGwpcmV0dXJuIHQ7dmFyIHI9bmV3IHQuY29uc3RydWN0b3I7Zm9yKHZhciBpIGluIHQpaWYoISF0Lmhhc093blByb3BlcnR5KGkpKXt2YXIgYT10W2ldLG89dHlwZW9mIGE7aT09PVwicGFyZW50XCImJm89PT1cIm9iamVjdFwiP24mJihyW2ldPW4pOmEgaW5zdGFuY2VvZiBBcnJheT9yW2ldPWEubWFwKGZ1bmN0aW9uKHMpe3JldHVybiBlKHMscil9KTpyW2ldPWUoYSxyKX1yZXR1cm4gcn0sSWw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4pe249PT12b2lkIDAmJihuPXt9KSxPYmplY3QuYXNzaWduKHRoaXMsbiksdGhpcy5zcGFjZXM9dGhpcy5zcGFjZXN8fHt9LHRoaXMuc3BhY2VzLmJlZm9yZT10aGlzLnNwYWNlcy5iZWZvcmV8fFwiXCIsdGhpcy5zcGFjZXMuYWZ0ZXI9dGhpcy5zcGFjZXMuYWZ0ZXJ8fFwiXCJ9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQucmVtb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKSx0aGlzLnBhcmVudD12b2lkIDAsdGhpc30sdC5yZXBsYWNlV2l0aD1mdW5jdGlvbigpe2lmKHRoaXMucGFyZW50KXtmb3IodmFyIHIgaW4gYXJndW1lbnRzKXRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLGFyZ3VtZW50c1tyXSk7dGhpcy5yZW1vdmUoKX1yZXR1cm4gdGhpc30sdC5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50LmF0KHRoaXMucGFyZW50LmluZGV4KHRoaXMpKzEpfSx0LnByZXY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnQuYXQodGhpcy5wYXJlbnQuaW5kZXgodGhpcyktMSl9LHQuY2xvbmU9ZnVuY3Rpb24ocil7cj09PXZvaWQgMCYmKHI9e30pO3ZhciBpPUFsKHRoaXMpO2Zvcih2YXIgYSBpbiByKWlbYV09clthXTtyZXR1cm4gaX0sdC5hcHBlbmRUb1Byb3BlcnR5QW5kRXNjYXBlPWZ1bmN0aW9uKHIsaSxhKXt0aGlzLnJhd3N8fCh0aGlzLnJhd3M9e30pO3ZhciBvPXRoaXNbcl0scz10aGlzLnJhd3Nbcl07dGhpc1tyXT1vK2ksc3x8YSE9PWk/dGhpcy5yYXdzW3JdPShzfHxvKSthOmRlbGV0ZSB0aGlzLnJhd3Nbcl19LHQuc2V0UHJvcGVydHlBbmRFc2NhcGU9ZnVuY3Rpb24ocixpLGEpe3RoaXMucmF3c3x8KHRoaXMucmF3cz17fSksdGhpc1tyXT1pLHRoaXMucmF3c1tyXT1hfSx0LnNldFByb3BlcnR5V2l0aG91dEVzY2FwZT1mdW5jdGlvbihyLGkpe3RoaXNbcl09aSx0aGlzLnJhd3MmJmRlbGV0ZSB0aGlzLnJhd3Nbcl19LHQuaXNBdFBvc2l0aW9uPWZ1bmN0aW9uKHIsaSl7aWYodGhpcy5zb3VyY2UmJnRoaXMuc291cmNlLnN0YXJ0JiZ0aGlzLnNvdXJjZS5lbmQpcmV0dXJuISh0aGlzLnNvdXJjZS5zdGFydC5saW5lPnJ8fHRoaXMuc291cmNlLmVuZC5saW5lPHJ8fHRoaXMuc291cmNlLnN0YXJ0LmxpbmU9PT1yJiZ0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4+aXx8dGhpcy5zb3VyY2UuZW5kLmxpbmU9PT1yJiZ0aGlzLnNvdXJjZS5lbmQuY29sdW1uPGkpfSx0LnN0cmluZ2lmeVByb3BlcnR5PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnJhd3MmJnRoaXMucmF3c1tyXXx8dGhpc1tyXX0sdC52YWx1ZVRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIFN0cmluZyh0aGlzLnN0cmluZ2lmeVByb3BlcnR5KFwidmFsdWVcIikpfSx0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuW3RoaXMucmF3U3BhY2VCZWZvcmUsdGhpcy52YWx1ZVRvU3RyaW5nKCksdGhpcy5yYXdTcGFjZUFmdGVyXS5qb2luKFwiXCIpfSxQbChlLFt7a2V5OlwicmF3U3BhY2VCZWZvcmVcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgcj10aGlzLnJhd3MmJnRoaXMucmF3cy5zcGFjZXMmJnRoaXMucmF3cy5zcGFjZXMuYmVmb3JlO3JldHVybiByPT09dm9pZCAwJiYocj10aGlzLnNwYWNlcyYmdGhpcy5zcGFjZXMuYmVmb3JlKSxyfHxcIlwifSxzZXQ6ZnVuY3Rpb24ocil7KDAsZWEuZW5zdXJlT2JqZWN0KSh0aGlzLFwicmF3c1wiLFwic3BhY2VzXCIpLHRoaXMucmF3cy5zcGFjZXMuYmVmb3JlPXJ9fSx7a2V5OlwicmF3U3BhY2VBZnRlclwiLGdldDpmdW5jdGlvbigpe3ZhciByPXRoaXMucmF3cyYmdGhpcy5yYXdzLnNwYWNlcyYmdGhpcy5yYXdzLnNwYWNlcy5hZnRlcjtyZXR1cm4gcj09PXZvaWQgMCYmKHI9dGhpcy5zcGFjZXMuYWZ0ZXIpLHJ8fFwiXCJ9LHNldDpmdW5jdGlvbihyKXsoMCxlYS5lbnN1cmVPYmplY3QpKHRoaXMsXCJyYXdzXCIsXCJzcGFjZXNcIiksdGhpcy5yYXdzLnNwYWNlcy5hZnRlcj1yfX1dKSxlfSgpO3d0LmRlZmF1bHQ9SWw7cmEuZXhwb3J0cz13dC5kZWZhdWx0fSk7dmFyIG5lPVIoaj0+e1widXNlIHN0cmljdFwiO2MoKTtqLl9fZXNNb2R1bGU9ITA7ai5VTklWRVJTQUw9ai5BVFRSSUJVVEU9ai5DTEFTUz1qLkNPTUJJTkFUT1I9ai5DT01NRU5UPWouSUQ9ai5ORVNUSU5HPWouUFNFVURPPWouUk9PVD1qLlNFTEVDVE9SPWouU1RSSU5HPWouVEFHPXZvaWQgMDt2YXIgUmw9XCJ0YWdcIjtqLlRBRz1SbDt2YXIgTGw9XCJzdHJpbmdcIjtqLlNUUklORz1MbDt2YXIgQ2w9XCJzZWxlY3RvclwiO2ouU0VMRUNUT1I9Q2w7dmFyIERsPVwicm9vdFwiO2ouUk9PVD1EbDt2YXIgRmw9XCJwc2V1ZG9cIjtqLlBTRVVETz1GbDt2YXIgTWw9XCJuZXN0aW5nXCI7ai5ORVNUSU5HPU1sO3ZhciBObD1cImlkXCI7ai5JRD1ObDt2YXIgV2w9XCJjb21tZW50XCI7ai5DT01NRU5UPVdsO3ZhciAkbD1cImNvbWJpbmF0b3JcIjtqLkNPTUJJTkFUT1I9JGw7dmFyIHFsPVwiY2xhc3NcIjtqLkNMQVNTPXFsO3ZhciBCbD1cImF0dHJpYnV0ZVwiO2ouQVRUUklCVVRFPUJsO3ZhciBVbD1cInVuaXZlcnNhbFwiO2ouVU5JVkVSU0FMPVVsfSk7dmFyIGtyPVIoKF90LGFhKT0+e1widXNlIHN0cmljdFwiO2MoKTtfdC5fX2VzTW9kdWxlPSEwO190LmRlZmF1bHQ9dm9pZCAwO3ZhciB6bD1qbChJZSgpKSxSZT1HbChuZSgpKTtmdW5jdGlvbiBvYSgpe2lmKHR5cGVvZiBXZWFrTWFwIT1cImZ1bmN0aW9uXCIpcmV0dXJuIG51bGw7dmFyIGU9bmV3IFdlYWtNYXA7cmV0dXJuIG9hPWZ1bmN0aW9uKCl7cmV0dXJuIGV9LGV9ZnVuY3Rpb24gR2woZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO2lmKGU9PT1udWxsfHx0eXBlb2YgZSE9XCJvYmplY3RcIiYmdHlwZW9mIGUhPVwiZnVuY3Rpb25cIilyZXR1cm57ZGVmYXVsdDplfTt2YXIgdD1vYSgpO2lmKHQmJnQuaGFzKGUpKXJldHVybiB0LmdldChlKTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIGkgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxpKSl7dmFyIGE9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsaSk6bnVsbDthJiYoYS5nZXR8fGEuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixpLGEpOm5baV09ZVtpXX1yZXR1cm4gbi5kZWZhdWx0PWUsdCYmdC5zZXQoZSxuKSxufWZ1bmN0aW9uIGpsKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBWbChlLHQpe3ZhciBuO2lmKHR5cGVvZiBTeW1ib2w+XCJ1XCJ8fGVbU3ltYm9sLml0ZXJhdG9yXT09bnVsbCl7aWYoQXJyYXkuaXNBcnJheShlKXx8KG49SGwoZSkpfHx0JiZlJiZ0eXBlb2YgZS5sZW5ndGg9PVwibnVtYmVyXCIpe24mJihlPW4pO3ZhciByPTA7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHI+PWUubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTplW3IrK119fX10aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuYCl9cmV0dXJuIG49ZVtTeW1ib2wuaXRlcmF0b3JdKCksbi5uZXh0LmJpbmQobil9ZnVuY3Rpb24gSGwoZSx0KXtpZighIWUpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXJldHVybiBuYShlLHQpO3ZhciBuPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKTtpZihuPT09XCJPYmplY3RcIiYmZS5jb25zdHJ1Y3RvciYmKG49ZS5jb25zdHJ1Y3Rvci5uYW1lKSxuPT09XCJNYXBcInx8bj09PVwiU2V0XCIpcmV0dXJuIEFycmF5LmZyb20oZSk7aWYobj09PVwiQXJndW1lbnRzXCJ8fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBuYShlLHQpfX1mdW5jdGlvbiBuYShlLHQpeyh0PT1udWxsfHx0PmUubGVuZ3RoKSYmKHQ9ZS5sZW5ndGgpO2Zvcih2YXIgbj0wLHI9bmV3IEFycmF5KHQpO248dDtuKyspcltuXT1lW25dO3JldHVybiByfWZ1bmN0aW9uIGlhKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBZbChlLHQsbil7cmV0dXJuIHQmJmlhKGUucHJvdG90eXBlLHQpLG4mJmlhKGUsbiksZX1mdW5jdGlvbiBYbChlLHQpe2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsT24oZSx0KX1mdW5jdGlvbiBPbihlLHQpe3JldHVybiBPbj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHIsaSl7cmV0dXJuIHIuX19wcm90b19fPWkscn0sT24oZSx0KX12YXIgUWw9ZnVuY3Rpb24oZSl7WGwodCxlKTtmdW5jdGlvbiB0KHIpe3ZhciBpO3JldHVybiBpPWUuY2FsbCh0aGlzLHIpfHx0aGlzLGkubm9kZXN8fChpLm5vZGVzPVtdKSxpfXZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLmFwcGVuZD1mdW5jdGlvbihpKXtyZXR1cm4gaS5wYXJlbnQ9dGhpcyx0aGlzLm5vZGVzLnB1c2goaSksdGhpc30sbi5wcmVwZW5kPWZ1bmN0aW9uKGkpe3JldHVybiBpLnBhcmVudD10aGlzLHRoaXMubm9kZXMudW5zaGlmdChpKSx0aGlzfSxuLmF0PWZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLm5vZGVzW2ldfSxuLmluZGV4PWZ1bmN0aW9uKGkpe3JldHVybiB0eXBlb2YgaT09XCJudW1iZXJcIj9pOnRoaXMubm9kZXMuaW5kZXhPZihpKX0sbi5yZW1vdmVDaGlsZD1mdW5jdGlvbihpKXtpPXRoaXMuaW5kZXgoaSksdGhpcy5hdChpKS5wYXJlbnQ9dm9pZCAwLHRoaXMubm9kZXMuc3BsaWNlKGksMSk7dmFyIGE7Zm9yKHZhciBvIGluIHRoaXMuaW5kZXhlcylhPXRoaXMuaW5kZXhlc1tvXSxhPj1pJiYodGhpcy5pbmRleGVzW29dPWEtMSk7cmV0dXJuIHRoaXN9LG4ucmVtb3ZlQWxsPWZ1bmN0aW9uKCl7Zm9yKHZhciBpPVZsKHRoaXMubm9kZXMpLGE7IShhPWkoKSkuZG9uZTspe3ZhciBvPWEudmFsdWU7by5wYXJlbnQ9dm9pZCAwfXJldHVybiB0aGlzLm5vZGVzPVtdLHRoaXN9LG4uZW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZW1vdmVBbGwoKX0sbi5pbnNlcnRBZnRlcj1mdW5jdGlvbihpLGEpe2EucGFyZW50PXRoaXM7dmFyIG89dGhpcy5pbmRleChpKTt0aGlzLm5vZGVzLnNwbGljZShvKzEsMCxhKSxhLnBhcmVudD10aGlzO3ZhciBzO2Zvcih2YXIgdSBpbiB0aGlzLmluZGV4ZXMpcz10aGlzLmluZGV4ZXNbdV0sbzw9cyYmKHRoaXMuaW5kZXhlc1t1XT1zKzEpO3JldHVybiB0aGlzfSxuLmluc2VydEJlZm9yZT1mdW5jdGlvbihpLGEpe2EucGFyZW50PXRoaXM7dmFyIG89dGhpcy5pbmRleChpKTt0aGlzLm5vZGVzLnNwbGljZShvLDAsYSksYS5wYXJlbnQ9dGhpczt2YXIgcztmb3IodmFyIHUgaW4gdGhpcy5pbmRleGVzKXM9dGhpcy5pbmRleGVzW3VdLHM8PW8mJih0aGlzLmluZGV4ZXNbdV09cysxKTtyZXR1cm4gdGhpc30sbi5fZmluZENoaWxkQXRQb3NpdGlvbj1mdW5jdGlvbihpLGEpe3ZhciBvPXZvaWQgMDtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKHMpe2lmKHMuYXRQb3NpdGlvbil7dmFyIHU9cy5hdFBvc2l0aW9uKGksYSk7aWYodSlyZXR1cm4gbz11LCExfWVsc2UgaWYocy5pc0F0UG9zaXRpb24oaSxhKSlyZXR1cm4gbz1zLCExfSksb30sbi5hdFBvc2l0aW9uPWZ1bmN0aW9uKGksYSl7aWYodGhpcy5pc0F0UG9zaXRpb24oaSxhKSlyZXR1cm4gdGhpcy5fZmluZENoaWxkQXRQb3NpdGlvbihpLGEpfHx0aGlzfSxuLl9pbmZlckVuZFBvc2l0aW9uPWZ1bmN0aW9uKCl7dGhpcy5sYXN0JiZ0aGlzLmxhc3Quc291cmNlJiZ0aGlzLmxhc3Quc291cmNlLmVuZCYmKHRoaXMuc291cmNlPXRoaXMuc291cmNlfHx7fSx0aGlzLnNvdXJjZS5lbmQ9dGhpcy5zb3VyY2UuZW5kfHx7fSxPYmplY3QuYXNzaWduKHRoaXMuc291cmNlLmVuZCx0aGlzLmxhc3Quc291cmNlLmVuZCkpfSxuLmVhY2g9ZnVuY3Rpb24oaSl7dGhpcy5sYXN0RWFjaHx8KHRoaXMubGFzdEVhY2g9MCksdGhpcy5pbmRleGVzfHwodGhpcy5pbmRleGVzPXt9KSx0aGlzLmxhc3RFYWNoKys7dmFyIGE9dGhpcy5sYXN0RWFjaDtpZih0aGlzLmluZGV4ZXNbYV09MCwhIXRoaXMubGVuZ3RoKXtmb3IodmFyIG8sczt0aGlzLmluZGV4ZXNbYV08dGhpcy5sZW5ndGgmJihvPXRoaXMuaW5kZXhlc1thXSxzPWkodGhpcy5hdChvKSxvKSxzIT09ITEpOyl0aGlzLmluZGV4ZXNbYV0rPTE7aWYoZGVsZXRlIHRoaXMuaW5kZXhlc1thXSxzPT09ITEpcmV0dXJuITF9fSxuLndhbGs9ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihhLG8pe3ZhciBzPWkoYSxvKTtpZihzIT09ITEmJmEubGVuZ3RoJiYocz1hLndhbGsoaSkpLHM9PT0hMSlyZXR1cm4hMX0pfSxuLndhbGtBdHRyaWJ1dGVzPWZ1bmN0aW9uKGkpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihvKXtpZihvLnR5cGU9PT1SZS5BVFRSSUJVVEUpcmV0dXJuIGkuY2FsbChhLG8pfSl9LG4ud2Fsa0NsYXNzZXM9ZnVuY3Rpb24oaSl7dmFyIGE9dGhpcztyZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKG8pe2lmKG8udHlwZT09PVJlLkNMQVNTKXJldHVybiBpLmNhbGwoYSxvKX0pfSxuLndhbGtDb21iaW5hdG9ycz1mdW5jdGlvbihpKXt2YXIgYT10aGlzO3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24obyl7aWYoby50eXBlPT09UmUuQ09NQklOQVRPUilyZXR1cm4gaS5jYWxsKGEsbyl9KX0sbi53YWxrQ29tbWVudHM9ZnVuY3Rpb24oaSl7dmFyIGE9dGhpcztyZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKG8pe2lmKG8udHlwZT09PVJlLkNPTU1FTlQpcmV0dXJuIGkuY2FsbChhLG8pfSl9LG4ud2Fsa0lkcz1mdW5jdGlvbihpKXt2YXIgYT10aGlzO3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24obyl7aWYoby50eXBlPT09UmUuSUQpcmV0dXJuIGkuY2FsbChhLG8pfSl9LG4ud2Fsa05lc3Rpbmc9ZnVuY3Rpb24oaSl7dmFyIGE9dGhpcztyZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKG8pe2lmKG8udHlwZT09PVJlLk5FU1RJTkcpcmV0dXJuIGkuY2FsbChhLG8pfSl9LG4ud2Fsa1BzZXVkb3M9ZnVuY3Rpb24oaSl7dmFyIGE9dGhpcztyZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKG8pe2lmKG8udHlwZT09PVJlLlBTRVVETylyZXR1cm4gaS5jYWxsKGEsbyl9KX0sbi53YWxrVGFncz1mdW5jdGlvbihpKXt2YXIgYT10aGlzO3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24obyl7aWYoby50eXBlPT09UmUuVEFHKXJldHVybiBpLmNhbGwoYSxvKX0pfSxuLndhbGtVbml2ZXJzYWxzPWZ1bmN0aW9uKGkpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihvKXtpZihvLnR5cGU9PT1SZS5VTklWRVJTQUwpcmV0dXJuIGkuY2FsbChhLG8pfSl9LG4uc3BsaXQ9ZnVuY3Rpb24oaSl7dmFyIGE9dGhpcyxvPVtdO3JldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbihzLHUsbCl7dmFyIGY9aS5jYWxsKGEsdSk7cmV0dXJuIG8ucHVzaCh1KSxmPyhzLnB1c2gobyksbz1bXSk6bD09PWEubGVuZ3RoLTEmJnMucHVzaChvKSxzfSxbXSl9LG4ubWFwPWZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLm5vZGVzLm1hcChpKX0sbi5yZWR1Y2U9ZnVuY3Rpb24oaSxhKXtyZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoaSxhKX0sbi5ldmVyeT1mdW5jdGlvbihpKXtyZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShpKX0sbi5zb21lPWZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLm5vZGVzLnNvbWUoaSl9LG4uZmlsdGVyPWZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLm5vZGVzLmZpbHRlcihpKX0sbi5zb3J0PWZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLm5vZGVzLnNvcnQoaSl9LG4udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoU3RyaW5nKS5qb2luKFwiXCIpfSxZbCh0LFt7a2V5OlwiZmlyc3RcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdCgwKX19LHtrZXk6XCJsYXN0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXQodGhpcy5sZW5ndGgtMSl9fSx7a2V5OlwibGVuZ3RoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXMubGVuZ3RofX1dKSx0fSh6bC5kZWZhdWx0KTtfdC5kZWZhdWx0PVFsO2FhLmV4cG9ydHM9X3QuZGVmYXVsdH0pO3ZhciBBbj1SKChTdCx1YSk9PntcInVzZSBzdHJpY3RcIjtjKCk7U3QuX19lc01vZHVsZT0hMDtTdC5kZWZhdWx0PXZvaWQgMDt2YXIgSmw9Wmwoa3IoKSksS2w9bmUoKTtmdW5jdGlvbiBabChlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gc2EoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIGVmKGUsdCxuKXtyZXR1cm4gdCYmc2EoZS5wcm90b3R5cGUsdCksbiYmc2EoZSxuKSxlfWZ1bmN0aW9uIHRmKGUsdCl7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxQbihlLHQpfWZ1bmN0aW9uIFBuKGUsdCl7cmV0dXJuIFBuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocixpKXtyZXR1cm4gci5fX3Byb3RvX189aSxyfSxQbihlLHQpfXZhciByZj1mdW5jdGlvbihlKXt0Zih0LGUpO2Z1bmN0aW9uIHQocil7dmFyIGk7cmV0dXJuIGk9ZS5jYWxsKHRoaXMscil8fHRoaXMsaS50eXBlPUtsLlJPT1QsaX12YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBpPXRoaXMucmVkdWNlKGZ1bmN0aW9uKGEsbyl7cmV0dXJuIGEucHVzaChTdHJpbmcobykpLGF9LFtdKS5qb2luKFwiLFwiKTtyZXR1cm4gdGhpcy50cmFpbGluZ0NvbW1hP2krXCIsXCI6aX0sbi5lcnJvcj1mdW5jdGlvbihpLGEpe3JldHVybiB0aGlzLl9lcnJvcj90aGlzLl9lcnJvcihpLGEpOm5ldyBFcnJvcihpKX0sZWYodCxbe2tleTpcImVycm9yR2VuZXJhdG9yXCIsc2V0OmZ1bmN0aW9uKGkpe3RoaXMuX2Vycm9yPWl9fV0pLHR9KEpsLmRlZmF1bHQpO1N0LmRlZmF1bHQ9cmY7dWEuZXhwb3J0cz1TdC5kZWZhdWx0fSk7dmFyIFJuPVIoKGt0LGxhKT0+e1widXNlIHN0cmljdFwiO2MoKTtrdC5fX2VzTW9kdWxlPSEwO2t0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuZj1hZihrcigpKSxvZj1uZSgpO2Z1bmN0aW9uIGFmKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBzZihlLHQpe2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsSW4oZSx0KX1mdW5jdGlvbiBJbihlLHQpe3JldHVybiBJbj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHIsaSl7cmV0dXJuIHIuX19wcm90b19fPWkscn0sSW4oZSx0KX12YXIgdWY9ZnVuY3Rpb24oZSl7c2YodCxlKTtmdW5jdGlvbiB0KG4pe3ZhciByO3JldHVybiByPWUuY2FsbCh0aGlzLG4pfHx0aGlzLHIudHlwZT1vZi5TRUxFQ1RPUixyfXJldHVybiB0fShuZi5kZWZhdWx0KTtrdC5kZWZhdWx0PXVmO2xhLmV4cG9ydHM9a3QuZGVmYXVsdH0pO3ZhciBUcj1SKChyZyxmYSk9PntcInVzZSBzdHJpY3RcIjtjKCk7dmFyIGxmPXt9LGZmPWxmLmhhc093blByb3BlcnR5LGNmPWZ1bmN0aW9uKHQsbil7aWYoIXQpcmV0dXJuIG47dmFyIHI9e307Zm9yKHZhciBpIGluIG4pcltpXT1mZi5jYWxsKHQsaSk/dFtpXTpuW2ldO3JldHVybiByfSxkZj0vWyAtLFxcLlxcLzotQFxcWy1cXF5gXFx7LX5dLyxwZj0vWyAtLFxcLlxcLzotQFxcW1xcXVxcXmBcXHstfl0vLGhmPS8oXnxcXFxcKyk/KFxcXFxbQS1GMC05XXsxLDZ9KVxceDIwKD8hW2EtZkEtRjAtOVxceDIwXSkvZyxMbj1mdW5jdGlvbiBlKHQsbil7bj1jZihuLGUub3B0aW9ucyksbi5xdW90ZXMhPVwic2luZ2xlXCImJm4ucXVvdGVzIT1cImRvdWJsZVwiJiYobi5xdW90ZXM9XCJzaW5nbGVcIik7Zm9yKHZhciByPW4ucXVvdGVzPT1cImRvdWJsZVwiPydcIic6XCInXCIsaT1uLmlzSWRlbnRpZmllcixhPXQuY2hhckF0KDApLG89XCJcIixzPTAsdT10Lmxlbmd0aDtzPHU7KXt2YXIgbD10LmNoYXJBdChzKyspLGY9bC5jaGFyQ29kZUF0KCkscD12b2lkIDA7aWYoZjwzMnx8Zj4xMjYpe2lmKGY+PTU1Mjk2JiZmPD01NjMxOSYmczx1KXt2YXIgZz10LmNoYXJDb2RlQXQocysrKTsoZyY2NDUxMik9PTU2MzIwP2Y9KChmJjEwMjMpPDwxMCkrKGcmMTAyMykrNjU1MzY6cy0tfXA9XCJcXFxcXCIrZi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKStcIiBcIn1lbHNlIG4uZXNjYXBlRXZlcnl0aGluZz9kZi50ZXN0KGwpP3A9XCJcXFxcXCIrbDpwPVwiXFxcXFwiK2YudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkrXCIgXCI6L1tcXHRcXG5cXGZcXHJcXHgwQl0vLnRlc3QobCk/cD1cIlxcXFxcIitmLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpK1wiIFwiOmw9PVwiXFxcXFwifHwhaSYmKGw9PSdcIicmJnI9PWx8fGw9PVwiJ1wiJiZyPT1sKXx8aSYmcGYudGVzdChsKT9wPVwiXFxcXFwiK2w6cD1sO28rPXB9cmV0dXJuIGkmJigvXi1bLVxcZF0vLnRlc3Qobyk/bz1cIlxcXFwtXCIrby5zbGljZSgxKTovXFxkLy50ZXN0KGEpJiYobz1cIlxcXFwzXCIrYStcIiBcIitvLnNsaWNlKDEpKSksbz1vLnJlcGxhY2UoaGYsZnVuY3Rpb24obSxkLGgpe3JldHVybiBkJiZkLmxlbmd0aCUyP206KGR8fFwiXCIpK2h9KSwhaSYmbi53cmFwP3IrbytyOm99O0xuLm9wdGlvbnM9e2VzY2FwZUV2ZXJ5dGhpbmc6ITEsaXNJZGVudGlmaWVyOiExLHF1b3RlczpcInNpbmdsZVwiLHdyYXA6ITF9O0xuLnZlcnNpb249XCIzLjAuMFwiO2ZhLmV4cG9ydHM9TG59KTt2YXIgRG49UigoVHQscGEpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO1R0Ll9fZXNNb2R1bGU9ITA7VHQuZGVmYXVsdD12b2lkIDA7dmFyIG1mPWRhKFRyKCkpLGdmPXh0KCksdmY9ZGEoSWUoKSksYmY9bmUoKTtmdW5jdGlvbiBkYShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gY2EoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIHlmKGUsdCxuKXtyZXR1cm4gdCYmY2EoZS5wcm90b3R5cGUsdCksbiYmY2EoZSxuKSxlfWZ1bmN0aW9uIHhmKGUsdCl7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxDbihlLHQpfWZ1bmN0aW9uIENuKGUsdCl7cmV0dXJuIENuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocixpKXtyZXR1cm4gci5fX3Byb3RvX189aSxyfSxDbihlLHQpfXZhciB3Zj1mdW5jdGlvbihlKXt4Zih0LGUpO2Z1bmN0aW9uIHQocil7dmFyIGk7cmV0dXJuIGk9ZS5jYWxsKHRoaXMscil8fHRoaXMsaS50eXBlPWJmLkNMQVNTLGkuX2NvbnN0cnVjdGVkPSEwLGl9dmFyIG49dC5wcm90b3R5cGU7cmV0dXJuIG4udmFsdWVUb1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLlwiK2UucHJvdG90eXBlLnZhbHVlVG9TdHJpbmcuY2FsbCh0aGlzKX0seWYodCxbe2tleTpcInZhbHVlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ZhbHVlfSxzZXQ6ZnVuY3Rpb24oaSl7aWYodGhpcy5fY29uc3RydWN0ZWQpe3ZhciBhPSgwLG1mLmRlZmF1bHQpKGkse2lzSWRlbnRpZmllcjohMH0pO2EhPT1pPygoMCxnZi5lbnN1cmVPYmplY3QpKHRoaXMsXCJyYXdzXCIpLHRoaXMucmF3cy52YWx1ZT1hKTp0aGlzLnJhd3MmJmRlbGV0ZSB0aGlzLnJhd3MudmFsdWV9dGhpcy5fdmFsdWU9aX19XSksdH0odmYuZGVmYXVsdCk7VHQuZGVmYXVsdD13ZjtwYS5leHBvcnRzPVR0LmRlZmF1bHR9KTt2YXIgTW49UigoRXQsaGEpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO0V0Ll9fZXNNb2R1bGU9ITA7RXQuZGVmYXVsdD12b2lkIDA7dmFyIF9mPWtmKEllKCkpLFNmPW5lKCk7ZnVuY3Rpb24ga2YoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIFRmKGUsdCl7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxGbihlLHQpfWZ1bmN0aW9uIEZuKGUsdCl7cmV0dXJuIEZuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocixpKXtyZXR1cm4gci5fX3Byb3RvX189aSxyfSxGbihlLHQpfXZhciBFZj1mdW5jdGlvbihlKXtUZih0LGUpO2Z1bmN0aW9uIHQobil7dmFyIHI7cmV0dXJuIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXMsci50eXBlPVNmLkNPTU1FTlQscn1yZXR1cm4gdH0oX2YuZGVmYXVsdCk7RXQuZGVmYXVsdD1FZjtoYS5leHBvcnRzPUV0LmRlZmF1bHR9KTt2YXIgV249UigoT3QsbWEpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO090Ll9fZXNNb2R1bGU9ITA7T3QuZGVmYXVsdD12b2lkIDA7dmFyIE9mPUFmKEllKCkpLFBmPW5lKCk7ZnVuY3Rpb24gQWYoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIElmKGUsdCl7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxObihlLHQpfWZ1bmN0aW9uIE5uKGUsdCl7cmV0dXJuIE5uPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocixpKXtyZXR1cm4gci5fX3Byb3RvX189aSxyfSxObihlLHQpfXZhciBSZj1mdW5jdGlvbihlKXtJZih0LGUpO2Z1bmN0aW9uIHQocil7dmFyIGk7cmV0dXJuIGk9ZS5jYWxsKHRoaXMscil8fHRoaXMsaS50eXBlPVBmLklELGl9dmFyIG49dC5wcm90b3R5cGU7cmV0dXJuIG4udmFsdWVUb1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiI1wiK2UucHJvdG90eXBlLnZhbHVlVG9TdHJpbmcuY2FsbCh0aGlzKX0sdH0oT2YuZGVmYXVsdCk7T3QuZGVmYXVsdD1SZjttYS5leHBvcnRzPU90LmRlZmF1bHR9KTt2YXIgRXI9UigoUHQsYmEpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO1B0Ll9fZXNNb2R1bGU9ITA7UHQuZGVmYXVsdD12b2lkIDA7dmFyIExmPXZhKFRyKCkpLENmPXh0KCksRGY9dmEoSWUoKSk7ZnVuY3Rpb24gdmEoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGdhKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBGZihlLHQsbil7cmV0dXJuIHQmJmdhKGUucHJvdG90eXBlLHQpLG4mJmdhKGUsbiksZX1mdW5jdGlvbiBNZihlLHQpe2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsJG4oZSx0KX1mdW5jdGlvbiAkbihlLHQpe3JldHVybiAkbj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHIsaSl7cmV0dXJuIHIuX19wcm90b19fPWkscn0sJG4oZSx0KX12YXIgTmY9ZnVuY3Rpb24oZSl7TWYodCxlKTtmdW5jdGlvbiB0KCl7cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLnF1YWxpZmllZE5hbWU9ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXMubmFtZXNwYWNlP3RoaXMubmFtZXNwYWNlU3RyaW5nK1wifFwiK2k6aX0sbi52YWx1ZVRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucXVhbGlmaWVkTmFtZShlLnByb3RvdHlwZS52YWx1ZVRvU3RyaW5nLmNhbGwodGhpcykpfSxGZih0LFt7a2V5OlwibmFtZXNwYWNlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25hbWVzcGFjZX0sc2V0OmZ1bmN0aW9uKGkpe2lmKGk9PT0hMHx8aT09PVwiKlwifHxpPT09XCImXCIpe3RoaXMuX25hbWVzcGFjZT1pLHRoaXMucmF3cyYmZGVsZXRlIHRoaXMucmF3cy5uYW1lc3BhY2U7cmV0dXJufXZhciBhPSgwLExmLmRlZmF1bHQpKGkse2lzSWRlbnRpZmllcjohMH0pO3RoaXMuX25hbWVzcGFjZT1pLGEhPT1pPygoMCxDZi5lbnN1cmVPYmplY3QpKHRoaXMsXCJyYXdzXCIpLHRoaXMucmF3cy5uYW1lc3BhY2U9YSk6dGhpcy5yYXdzJiZkZWxldGUgdGhpcy5yYXdzLm5hbWVzcGFjZX19LHtrZXk6XCJuc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9uYW1lc3BhY2V9LHNldDpmdW5jdGlvbihpKXt0aGlzLm5hbWVzcGFjZT1pfX0se2tleTpcIm5hbWVzcGFjZVN0cmluZ1wiLGdldDpmdW5jdGlvbigpe2lmKHRoaXMubmFtZXNwYWNlKXt2YXIgaT10aGlzLnN0cmluZ2lmeVByb3BlcnR5KFwibmFtZXNwYWNlXCIpO3JldHVybiBpPT09ITA/XCJcIjppfWVsc2UgcmV0dXJuXCJcIn19XSksdH0oRGYuZGVmYXVsdCk7UHQuZGVmYXVsdD1OZjtiYS5leHBvcnRzPVB0LmRlZmF1bHR9KTt2YXIgQm49UigoQXQseWEpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO0F0Ll9fZXNNb2R1bGU9ITA7QXQuZGVmYXVsdD12b2lkIDA7dmFyIFdmPXFmKEVyKCkpLCRmPW5lKCk7ZnVuY3Rpb24gcWYoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIEJmKGUsdCl7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxxbihlLHQpfWZ1bmN0aW9uIHFuKGUsdCl7cmV0dXJuIHFuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocixpKXtyZXR1cm4gci5fX3Byb3RvX189aSxyfSxxbihlLHQpfXZhciBVZj1mdW5jdGlvbihlKXtCZih0LGUpO2Z1bmN0aW9uIHQobil7dmFyIHI7cmV0dXJuIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXMsci50eXBlPSRmLlRBRyxyfXJldHVybiB0fShXZi5kZWZhdWx0KTtBdC5kZWZhdWx0PVVmO3lhLmV4cG9ydHM9QXQuZGVmYXVsdH0pO3ZhciB6bj1SKChJdCx4YSk9PntcInVzZSBzdHJpY3RcIjtjKCk7SXQuX19lc01vZHVsZT0hMDtJdC5kZWZhdWx0PXZvaWQgMDt2YXIgemY9amYoSWUoKSksR2Y9bmUoKTtmdW5jdGlvbiBqZihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gVmYoZSx0KXtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLFVuKGUsdCl9ZnVuY3Rpb24gVW4oZSx0KXtyZXR1cm4gVW49T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihyLGkpe3JldHVybiByLl9fcHJvdG9fXz1pLHJ9LFVuKGUsdCl9dmFyIEhmPWZ1bmN0aW9uKGUpe1ZmKHQsZSk7ZnVuY3Rpb24gdChuKXt2YXIgcjtyZXR1cm4gcj1lLmNhbGwodGhpcyxuKXx8dGhpcyxyLnR5cGU9R2YuU1RSSU5HLHJ9cmV0dXJuIHR9KHpmLmRlZmF1bHQpO0l0LmRlZmF1bHQ9SGY7eGEuZXhwb3J0cz1JdC5kZWZhdWx0fSk7dmFyIGpuPVIoKFJ0LHdhKT0+e1widXNlIHN0cmljdFwiO2MoKTtSdC5fX2VzTW9kdWxlPSEwO1J0LmRlZmF1bHQ9dm9pZCAwO3ZhciBZZj1RZihrcigpKSxYZj1uZSgpO2Z1bmN0aW9uIFFmKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBKZihlLHQpe2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsR24oZSx0KX1mdW5jdGlvbiBHbihlLHQpe3JldHVybiBHbj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHIsaSl7cmV0dXJuIHIuX19wcm90b19fPWkscn0sR24oZSx0KX12YXIgS2Y9ZnVuY3Rpb24oZSl7SmYodCxlKTtmdW5jdGlvbiB0KHIpe3ZhciBpO3JldHVybiBpPWUuY2FsbCh0aGlzLHIpfHx0aGlzLGkudHlwZT1YZi5QU0VVRE8saX12YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBpPXRoaXMubGVuZ3RoP1wiKFwiK3RoaXMubWFwKFN0cmluZykuam9pbihcIixcIikrXCIpXCI6XCJcIjtyZXR1cm5bdGhpcy5yYXdTcGFjZUJlZm9yZSx0aGlzLnN0cmluZ2lmeVByb3BlcnR5KFwidmFsdWVcIiksaSx0aGlzLnJhd1NwYWNlQWZ0ZXJdLmpvaW4oXCJcIil9LHR9KFlmLmRlZmF1bHQpO1J0LmRlZmF1bHQ9S2Y7d2EuZXhwb3J0cz1SdC5kZWZhdWx0fSk7dmFyIFNhPVIoKG5nLF9hKT0+e2MoKTtfYS5leHBvcnRzPWZ1bmN0aW9uKHQsbil7cmV0dXJuIGZ1bmN0aW9uKC4uLnIpe3JldHVybiBjb25zb2xlLndhcm4obiksdCguLi5yKX19fSk7dmFyIEpuPVIoRHQ9PntcInVzZSBzdHJpY3RcIjtjKCk7RHQuX19lc01vZHVsZT0hMDtEdC51bmVzY2FwZVZhbHVlPVFuO0R0LmRlZmF1bHQ9dm9pZCAwO3ZhciBMdD1YbihUcigpKSxaZj1YbihFbigpKSxlYz1YbihFcigpKSx0Yz1uZSgpLFZuO2Z1bmN0aW9uIFhuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBrYShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gcmMoZSx0LG4pe3JldHVybiB0JiZrYShlLnByb3RvdHlwZSx0KSxuJiZrYShlLG4pLGV9ZnVuY3Rpb24gbmMoZSx0KXtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLFluKGUsdCl9ZnVuY3Rpb24gWW4oZSx0KXtyZXR1cm4gWW49T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihyLGkpe3JldHVybiByLl9fcHJvdG9fXz1pLHJ9LFluKGUsdCl9dmFyIEN0PVNhKCksaWM9L14oJ3xcIikoW15dKilcXDEkLyxvYz1DdChmdW5jdGlvbigpe30sXCJBc3NpZ25pbmcgYW4gYXR0cmlidXRlIGEgdmFsdWUgY29udGFpbmluZyBjaGFyYWN0ZXJzIHRoYXQgbWlnaHQgbmVlZCB0byBiZSBlc2NhcGVkIGlzIGRlcHJlY2F0ZWQuIENhbGwgYXR0cmlidXRlLnNldFZhbHVlKCkgaW5zdGVhZC5cIiksYWM9Q3QoZnVuY3Rpb24oKXt9LFwiQXNzaWduaW5nIGF0dHIucXVvdGVkIGlzIGRlcHJlY2F0ZWQgYW5kIGhhcyBubyBlZmZlY3QuIEFzc2lnbiB0byBhdHRyLnF1b3RlTWFyayBpbnN0ZWFkLlwiKSxzYz1DdChmdW5jdGlvbigpe30sXCJDb25zdHJ1Y3RpbmcgYW4gQXR0cmlidXRlIHNlbGVjdG9yIHdpdGggYSB2YWx1ZSB3aXRob3V0IHNwZWNpZnlpbmcgcXVvdGVNYXJrIGlzIGRlcHJlY2F0ZWQuIE5vdGU6IFRoZSB2YWx1ZSBzaG91bGQgYmUgdW5lc2NhcGVkIG5vdy5cIik7ZnVuY3Rpb24gUW4oZSl7dmFyIHQ9ITEsbj1udWxsLHI9ZSxpPXIubWF0Y2goaWMpO3JldHVybiBpJiYobj1pWzFdLHI9aVsyXSkscj0oMCxaZi5kZWZhdWx0KShyKSxyIT09ZSYmKHQ9ITApLHtkZXByZWNhdGVkVXNhZ2U6dCx1bmVzY2FwZWQ6cixxdW90ZU1hcms6bn19ZnVuY3Rpb24gdWMoZSl7aWYoZS5xdW90ZU1hcmshPT12b2lkIDB8fGUudmFsdWU9PT12b2lkIDApcmV0dXJuIGU7c2MoKTt2YXIgdD1RbihlLnZhbHVlKSxuPXQucXVvdGVNYXJrLHI9dC51bmVzY2FwZWQ7cmV0dXJuIGUucmF3c3x8KGUucmF3cz17fSksZS5yYXdzLnZhbHVlPT09dm9pZCAwJiYoZS5yYXdzLnZhbHVlPWUudmFsdWUpLGUudmFsdWU9cixlLnF1b3RlTWFyaz1uLGV9dmFyIE9yPWZ1bmN0aW9uKGUpe25jKHQsZSk7ZnVuY3Rpb24gdChyKXt2YXIgaTtyZXR1cm4gcj09PXZvaWQgMCYmKHI9e30pLGk9ZS5jYWxsKHRoaXMsdWMocikpfHx0aGlzLGkudHlwZT10Yy5BVFRSSUJVVEUsaS5yYXdzPWkucmF3c3x8e30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGkucmF3cyxcInVucXVvdGVkXCIse2dldDpDdChmdW5jdGlvbigpe3JldHVybiBpLnZhbHVlfSxcImF0dHIucmF3cy51bnF1b3RlZCBpcyBkZXByZWNhdGVkLiBDYWxsIGF0dHIudmFsdWUgaW5zdGVhZC5cIiksc2V0OkN0KGZ1bmN0aW9uKCl7cmV0dXJuIGkudmFsdWV9LFwiU2V0dGluZyBhdHRyLnJhd3MudW5xdW90ZWQgaXMgZGVwcmVjYXRlZCBhbmQgaGFzIG5vIGVmZmVjdC4gYXR0ci52YWx1ZSBpcyB1bmVzY2FwZWQgYnkgZGVmYXVsdCBub3cuXCIpfSksaS5fY29uc3RydWN0ZWQ9ITAsaX12YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi5nZXRRdW90ZWRWYWx1ZT1mdW5jdGlvbihpKXtpPT09dm9pZCAwJiYoaT17fSk7dmFyIGE9dGhpcy5fZGV0ZXJtaW5lUXVvdGVNYXJrKGkpLG89SG5bYV0scz0oMCxMdC5kZWZhdWx0KSh0aGlzLl92YWx1ZSxvKTtyZXR1cm4gc30sbi5fZGV0ZXJtaW5lUXVvdGVNYXJrPWZ1bmN0aW9uKGkpe3JldHVybiBpLnNtYXJ0P3RoaXMuc21hcnRRdW90ZU1hcmsoaSk6dGhpcy5wcmVmZXJyZWRRdW90ZU1hcmsoaSl9LG4uc2V0VmFsdWU9ZnVuY3Rpb24oaSxhKXthPT09dm9pZCAwJiYoYT17fSksdGhpcy5fdmFsdWU9aSx0aGlzLl9xdW90ZU1hcms9dGhpcy5fZGV0ZXJtaW5lUXVvdGVNYXJrKGEpLHRoaXMuX3N5bmNSYXdWYWx1ZSgpfSxuLnNtYXJ0UXVvdGVNYXJrPWZ1bmN0aW9uKGkpe3ZhciBhPXRoaXMudmFsdWUsbz1hLnJlcGxhY2UoL1teJ10vZyxcIlwiKS5sZW5ndGgscz1hLnJlcGxhY2UoL1teXCJdL2csXCJcIikubGVuZ3RoO2lmKG8rcz09PTApe3ZhciB1PSgwLEx0LmRlZmF1bHQpKGEse2lzSWRlbnRpZmllcjohMH0pO2lmKHU9PT1hKXJldHVybiB0Lk5PX1FVT1RFO3ZhciBsPXRoaXMucHJlZmVycmVkUXVvdGVNYXJrKGkpO2lmKGw9PT10Lk5PX1FVT1RFKXt2YXIgZj10aGlzLnF1b3RlTWFya3x8aS5xdW90ZU1hcmt8fHQuRE9VQkxFX1FVT1RFLHA9SG5bZl0sZz0oMCxMdC5kZWZhdWx0KShhLHApO2lmKGcubGVuZ3RoPHUubGVuZ3RoKXJldHVybiBmfXJldHVybiBsfWVsc2UgcmV0dXJuIHM9PT1vP3RoaXMucHJlZmVycmVkUXVvdGVNYXJrKGkpOnM8bz90LkRPVUJMRV9RVU9URTp0LlNJTkdMRV9RVU9URX0sbi5wcmVmZXJyZWRRdW90ZU1hcms9ZnVuY3Rpb24oaSl7dmFyIGE9aS5wcmVmZXJDdXJyZW50UXVvdGVNYXJrP3RoaXMucXVvdGVNYXJrOmkucXVvdGVNYXJrO3JldHVybiBhPT09dm9pZCAwJiYoYT1pLnByZWZlckN1cnJlbnRRdW90ZU1hcms/aS5xdW90ZU1hcms6dGhpcy5xdW90ZU1hcmspLGE9PT12b2lkIDAmJihhPXQuRE9VQkxFX1FVT1RFKSxhfSxuLl9zeW5jUmF3VmFsdWU9ZnVuY3Rpb24oKXt2YXIgaT0oMCxMdC5kZWZhdWx0KSh0aGlzLl92YWx1ZSxIblt0aGlzLnF1b3RlTWFya10pO2k9PT10aGlzLl92YWx1ZT90aGlzLnJhd3MmJmRlbGV0ZSB0aGlzLnJhd3MudmFsdWU6dGhpcy5yYXdzLnZhbHVlPWl9LG4uX2hhbmRsZUVzY2FwZXM9ZnVuY3Rpb24oaSxhKXtpZih0aGlzLl9jb25zdHJ1Y3RlZCl7dmFyIG89KDAsTHQuZGVmYXVsdCkoYSx7aXNJZGVudGlmaWVyOiEwfSk7byE9PWE/dGhpcy5yYXdzW2ldPW86ZGVsZXRlIHRoaXMucmF3c1tpXX19LG4uX3NwYWNlc0Zvcj1mdW5jdGlvbihpKXt2YXIgYT17YmVmb3JlOlwiXCIsYWZ0ZXI6XCJcIn0sbz10aGlzLnNwYWNlc1tpXXx8e30scz10aGlzLnJhd3Muc3BhY2VzJiZ0aGlzLnJhd3Muc3BhY2VzW2ldfHx7fTtyZXR1cm4gT2JqZWN0LmFzc2lnbihhLG8scyl9LG4uX3N0cmluZ0Zvcj1mdW5jdGlvbihpLGEsbyl7YT09PXZvaWQgMCYmKGE9aSksbz09PXZvaWQgMCYmKG89VGEpO3ZhciBzPXRoaXMuX3NwYWNlc0ZvcihhKTtyZXR1cm4gbyh0aGlzLnN0cmluZ2lmeVByb3BlcnR5KGkpLHMpfSxuLm9mZnNldE9mPWZ1bmN0aW9uKGkpe3ZhciBhPTEsbz10aGlzLl9zcGFjZXNGb3IoXCJhdHRyaWJ1dGVcIik7aWYoYSs9by5iZWZvcmUubGVuZ3RoLGk9PT1cIm5hbWVzcGFjZVwifHxpPT09XCJuc1wiKXJldHVybiB0aGlzLm5hbWVzcGFjZT9hOi0xO2lmKGk9PT1cImF0dHJpYnV0ZU5TXCJ8fChhKz10aGlzLm5hbWVzcGFjZVN0cmluZy5sZW5ndGgsdGhpcy5uYW1lc3BhY2UmJihhKz0xKSxpPT09XCJhdHRyaWJ1dGVcIikpcmV0dXJuIGE7YSs9dGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcImF0dHJpYnV0ZVwiKS5sZW5ndGgsYSs9by5hZnRlci5sZW5ndGg7dmFyIHM9dGhpcy5fc3BhY2VzRm9yKFwib3BlcmF0b3JcIik7YSs9cy5iZWZvcmUubGVuZ3RoO3ZhciB1PXRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJvcGVyYXRvclwiKTtpZihpPT09XCJvcGVyYXRvclwiKXJldHVybiB1P2E6LTE7YSs9dS5sZW5ndGgsYSs9cy5hZnRlci5sZW5ndGg7dmFyIGw9dGhpcy5fc3BhY2VzRm9yKFwidmFsdWVcIik7YSs9bC5iZWZvcmUubGVuZ3RoO3ZhciBmPXRoaXMuc3RyaW5naWZ5UHJvcGVydHkoXCJ2YWx1ZVwiKTtpZihpPT09XCJ2YWx1ZVwiKXJldHVybiBmP2E6LTE7YSs9Zi5sZW5ndGgsYSs9bC5hZnRlci5sZW5ndGg7dmFyIHA9dGhpcy5fc3BhY2VzRm9yKFwiaW5zZW5zaXRpdmVcIik7cmV0dXJuIGErPXAuYmVmb3JlLmxlbmd0aCxpPT09XCJpbnNlbnNpdGl2ZVwiJiZ0aGlzLmluc2Vuc2l0aXZlP2E6LTF9LG4udG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgaT10aGlzLGE9W3RoaXMucmF3U3BhY2VCZWZvcmUsXCJbXCJdO3JldHVybiBhLnB1c2godGhpcy5fc3RyaW5nRm9yKFwicXVhbGlmaWVkQXR0cmlidXRlXCIsXCJhdHRyaWJ1dGVcIikpLHRoaXMub3BlcmF0b3ImJih0aGlzLnZhbHVlfHx0aGlzLnZhbHVlPT09XCJcIikmJihhLnB1c2godGhpcy5fc3RyaW5nRm9yKFwib3BlcmF0b3JcIikpLGEucHVzaCh0aGlzLl9zdHJpbmdGb3IoXCJ2YWx1ZVwiKSksYS5wdXNoKHRoaXMuX3N0cmluZ0ZvcihcImluc2Vuc2l0aXZlRmxhZ1wiLFwiaW5zZW5zaXRpdmVcIixmdW5jdGlvbihvLHMpe3JldHVybiBvLmxlbmd0aD4wJiYhaS5xdW90ZWQmJnMuYmVmb3JlLmxlbmd0aD09PTAmJiEoaS5zcGFjZXMudmFsdWUmJmkuc3BhY2VzLnZhbHVlLmFmdGVyKSYmKHMuYmVmb3JlPVwiIFwiKSxUYShvLHMpfSkpKSxhLnB1c2goXCJdXCIpLGEucHVzaCh0aGlzLnJhd1NwYWNlQWZ0ZXIpLGEuam9pbihcIlwiKX0scmModCxbe2tleTpcInF1b3RlZFwiLGdldDpmdW5jdGlvbigpe3ZhciBpPXRoaXMucXVvdGVNYXJrO3JldHVybiBpPT09XCInXCJ8fGk9PT0nXCInfSxzZXQ6ZnVuY3Rpb24oaSl7YWMoKX19LHtrZXk6XCJxdW90ZU1hcmtcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcXVvdGVNYXJrfSxzZXQ6ZnVuY3Rpb24oaSl7aWYoIXRoaXMuX2NvbnN0cnVjdGVkKXt0aGlzLl9xdW90ZU1hcms9aTtyZXR1cm59dGhpcy5fcXVvdGVNYXJrIT09aSYmKHRoaXMuX3F1b3RlTWFyaz1pLHRoaXMuX3N5bmNSYXdWYWx1ZSgpKX19LHtrZXk6XCJxdWFsaWZpZWRBdHRyaWJ1dGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5xdWFsaWZpZWROYW1lKHRoaXMucmF3cy5hdHRyaWJ1dGV8fHRoaXMuYXR0cmlidXRlKX19LHtrZXk6XCJpbnNlbnNpdGl2ZUZsYWdcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnNlbnNpdGl2ZT9cImlcIjpcIlwifX0se2tleTpcInZhbHVlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ZhbHVlfSxzZXQ6ZnVuY3Rpb24oaSl7aWYodGhpcy5fY29uc3RydWN0ZWQpe3ZhciBhPVFuKGkpLG89YS5kZXByZWNhdGVkVXNhZ2Uscz1hLnVuZXNjYXBlZCx1PWEucXVvdGVNYXJrO2lmKG8mJm9jKCkscz09PXRoaXMuX3ZhbHVlJiZ1PT09dGhpcy5fcXVvdGVNYXJrKXJldHVybjt0aGlzLl92YWx1ZT1zLHRoaXMuX3F1b3RlTWFyaz11LHRoaXMuX3N5bmNSYXdWYWx1ZSgpfWVsc2UgdGhpcy5fdmFsdWU9aX19LHtrZXk6XCJhdHRyaWJ1dGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYXR0cmlidXRlfSxzZXQ6ZnVuY3Rpb24oaSl7dGhpcy5faGFuZGxlRXNjYXBlcyhcImF0dHJpYnV0ZVwiLGkpLHRoaXMuX2F0dHJpYnV0ZT1pfX1dKSx0fShlYy5kZWZhdWx0KTtEdC5kZWZhdWx0PU9yO09yLk5PX1FVT1RFPW51bGw7T3IuU0lOR0xFX1FVT1RFPVwiJ1wiO09yLkRPVUJMRV9RVU9URT0nXCInO3ZhciBIbj0oVm49e1wiJ1wiOntxdW90ZXM6XCJzaW5nbGVcIix3cmFwOiEwfSwnXCInOntxdW90ZXM6XCJkb3VibGVcIix3cmFwOiEwfX0sVm5bbnVsbF09e2lzSWRlbnRpZmllcjohMH0sVm4pO2Z1bmN0aW9uIFRhKGUsdCl7cmV0dXJuXCJcIit0LmJlZm9yZStlK3QuYWZ0ZXJ9fSk7dmFyIFpuPVIoKEZ0LEVhKT0+e1widXNlIHN0cmljdFwiO2MoKTtGdC5fX2VzTW9kdWxlPSEwO0Z0LmRlZmF1bHQ9dm9pZCAwO3ZhciBsYz1jYyhFcigpKSxmYz1uZSgpO2Z1bmN0aW9uIGNjKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBkYyhlLHQpe2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsS24oZSx0KX1mdW5jdGlvbiBLbihlLHQpe3JldHVybiBLbj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHIsaSl7cmV0dXJuIHIuX19wcm90b19fPWkscn0sS24oZSx0KX12YXIgcGM9ZnVuY3Rpb24oZSl7ZGModCxlKTtmdW5jdGlvbiB0KG4pe3ZhciByO3JldHVybiByPWUuY2FsbCh0aGlzLG4pfHx0aGlzLHIudHlwZT1mYy5VTklWRVJTQUwsci52YWx1ZT1cIipcIixyfXJldHVybiB0fShsYy5kZWZhdWx0KTtGdC5kZWZhdWx0PXBjO0VhLmV4cG9ydHM9RnQuZGVmYXVsdH0pO3ZhciB0aT1SKChNdCxPYSk9PntcInVzZSBzdHJpY3RcIjtjKCk7TXQuX19lc01vZHVsZT0hMDtNdC5kZWZhdWx0PXZvaWQgMDt2YXIgaGM9Z2MoSWUoKSksbWM9bmUoKTtmdW5jdGlvbiBnYyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gdmMoZSx0KXtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLGVpKGUsdCl9ZnVuY3Rpb24gZWkoZSx0KXtyZXR1cm4gZWk9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihyLGkpe3JldHVybiByLl9fcHJvdG9fXz1pLHJ9LGVpKGUsdCl9dmFyIGJjPWZ1bmN0aW9uKGUpe3ZjKHQsZSk7ZnVuY3Rpb24gdChuKXt2YXIgcjtyZXR1cm4gcj1lLmNhbGwodGhpcyxuKXx8dGhpcyxyLnR5cGU9bWMuQ09NQklOQVRPUixyfXJldHVybiB0fShoYy5kZWZhdWx0KTtNdC5kZWZhdWx0PWJjO09hLmV4cG9ydHM9TXQuZGVmYXVsdH0pO3ZhciBuaT1SKChOdCxQYSk9PntcInVzZSBzdHJpY3RcIjtjKCk7TnQuX19lc01vZHVsZT0hMDtOdC5kZWZhdWx0PXZvaWQgMDt2YXIgeWM9d2MoSWUoKSkseGM9bmUoKTtmdW5jdGlvbiB3YyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gX2MoZSx0KXtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLHJpKGUsdCl9ZnVuY3Rpb24gcmkoZSx0KXtyZXR1cm4gcmk9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihyLGkpe3JldHVybiByLl9fcHJvdG9fXz1pLHJ9LHJpKGUsdCl9dmFyIFNjPWZ1bmN0aW9uKGUpe19jKHQsZSk7ZnVuY3Rpb24gdChuKXt2YXIgcjtyZXR1cm4gcj1lLmNhbGwodGhpcyxuKXx8dGhpcyxyLnR5cGU9eGMuTkVTVElORyxyLnZhbHVlPVwiJlwiLHJ9cmV0dXJuIHR9KHljLmRlZmF1bHQpO050LmRlZmF1bHQ9U2M7UGEuZXhwb3J0cz1OdC5kZWZhdWx0fSk7dmFyIElhPVIoKFByLEFhKT0+e1widXNlIHN0cmljdFwiO2MoKTtQci5fX2VzTW9kdWxlPSEwO1ByLmRlZmF1bHQ9a2M7ZnVuY3Rpb24ga2MoZSl7cmV0dXJuIGUuc29ydChmdW5jdGlvbih0LG4pe3JldHVybiB0LW59KX1BYS5leHBvcnRzPVByLmRlZmF1bHR9KTt2YXIgaWk9UihPPT57XCJ1c2Ugc3RyaWN0XCI7YygpO08uX19lc01vZHVsZT0hMDtPLmNvbWJpbmF0b3I9Ty53b3JkPU8uY29tbWVudD1PLnN0cj1PLnRhYj1PLm5ld2xpbmU9Ty5mZWVkPU8uY3I9Ty5iYWNrc2xhc2g9Ty5iYW5nPU8uc2xhc2g9Ty5kb3VibGVRdW90ZT1PLnNpbmdsZVF1b3RlPU8uc3BhY2U9Ty5ncmVhdGVyVGhhbj1PLnBpcGU9Ty5lcXVhbHM9Ty5wbHVzPU8uY2FyZXQ9Ty50aWxkZT1PLmRvbGxhcj1PLmNsb3NlU3F1YXJlPU8ub3BlblNxdWFyZT1PLmNsb3NlUGFyZW50aGVzaXM9Ty5vcGVuUGFyZW50aGVzaXM9Ty5zZW1pY29sb249Ty5jb2xvbj1PLmNvbW1hPU8uYXQ9Ty5hc3Rlcmlzaz1PLmFtcGVyc2FuZD12b2lkIDA7dmFyIFRjPTM4O08uYW1wZXJzYW5kPVRjO3ZhciBFYz00MjtPLmFzdGVyaXNrPUVjO3ZhciBPYz02NDtPLmF0PU9jO3ZhciBQYz00NDtPLmNvbW1hPVBjO3ZhciBBYz01ODtPLmNvbG9uPUFjO3ZhciBJYz01OTtPLnNlbWljb2xvbj1JYzt2YXIgUmM9NDA7Ty5vcGVuUGFyZW50aGVzaXM9UmM7dmFyIExjPTQxO08uY2xvc2VQYXJlbnRoZXNpcz1MYzt2YXIgQ2M9OTE7Ty5vcGVuU3F1YXJlPUNjO3ZhciBEYz05MztPLmNsb3NlU3F1YXJlPURjO3ZhciBGYz0zNjtPLmRvbGxhcj1GYzt2YXIgTWM9MTI2O08udGlsZGU9TWM7dmFyIE5jPTk0O08uY2FyZXQ9TmM7dmFyIFdjPTQzO08ucGx1cz1XYzt2YXIgJGM9NjE7Ty5lcXVhbHM9JGM7dmFyIHFjPTEyNDtPLnBpcGU9cWM7dmFyIEJjPTYyO08uZ3JlYXRlclRoYW49QmM7dmFyIFVjPTMyO08uc3BhY2U9VWM7dmFyIFJhPTM5O08uc2luZ2xlUXVvdGU9UmE7dmFyIHpjPTM0O08uZG91YmxlUXVvdGU9emM7dmFyIEdjPTQ3O08uc2xhc2g9R2M7dmFyIGpjPTMzO08uYmFuZz1qYzt2YXIgVmM9OTI7Ty5iYWNrc2xhc2g9VmM7dmFyIEhjPTEzO08uY3I9SGM7dmFyIFljPTEyO08uZmVlZD1ZYzt2YXIgWGM9MTA7Ty5uZXdsaW5lPVhjO3ZhciBRYz05O08udGFiPVFjO3ZhciBKYz1SYTtPLnN0cj1KYzt2YXIgS2M9LTE7Ty5jb21tZW50PUtjO3ZhciBaYz0tMjtPLndvcmQ9WmM7dmFyIGVkPS0zO08uY29tYmluYXRvcj1lZH0pO3ZhciBEYT1SKFd0PT57XCJ1c2Ugc3RyaWN0XCI7YygpO1d0Ll9fZXNNb2R1bGU9ITA7V3QuZGVmYXVsdD1zZDtXdC5GSUVMRFM9dm9pZCAwO3ZhciBrPXRkKGlpKCkpLGl0LEc7ZnVuY3Rpb24gQ2EoKXtpZih0eXBlb2YgV2Vha01hcCE9XCJmdW5jdGlvblwiKXJldHVybiBudWxsO3ZhciBlPW5ldyBXZWFrTWFwO3JldHVybiBDYT1mdW5jdGlvbigpe3JldHVybiBlfSxlfWZ1bmN0aW9uIHRkKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTtpZihlPT09bnVsbHx8dHlwZW9mIGUhPVwib2JqZWN0XCImJnR5cGVvZiBlIT1cImZ1bmN0aW9uXCIpcmV0dXJue2RlZmF1bHQ6ZX07dmFyIHQ9Q2EoKTtpZih0JiZ0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBpIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsaSkpe3ZhciBhPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLGkpOm51bGw7YSYmKGEuZ2V0fHxhLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4saSxhKTpuW2ldPWVbaV19cmV0dXJuIG4uZGVmYXVsdD1lLHQmJnQuc2V0KGUsbiksbn12YXIgcmQ9KGl0PXt9LGl0W2sudGFiXT0hMCxpdFtrLm5ld2xpbmVdPSEwLGl0W2suY3JdPSEwLGl0W2suZmVlZF09ITAsaXQpLG5kPShHPXt9LEdbay5zcGFjZV09ITAsR1trLnRhYl09ITAsR1trLm5ld2xpbmVdPSEwLEdbay5jcl09ITAsR1trLmZlZWRdPSEwLEdbay5hbXBlcnNhbmRdPSEwLEdbay5hc3Rlcmlza109ITAsR1trLmJhbmddPSEwLEdbay5jb21tYV09ITAsR1trLmNvbG9uXT0hMCxHW2suc2VtaWNvbG9uXT0hMCxHW2sub3BlblBhcmVudGhlc2lzXT0hMCxHW2suY2xvc2VQYXJlbnRoZXNpc109ITAsR1trLm9wZW5TcXVhcmVdPSEwLEdbay5jbG9zZVNxdWFyZV09ITAsR1trLnNpbmdsZVF1b3RlXT0hMCxHW2suZG91YmxlUXVvdGVdPSEwLEdbay5wbHVzXT0hMCxHW2sucGlwZV09ITAsR1trLnRpbGRlXT0hMCxHW2suZ3JlYXRlclRoYW5dPSEwLEdbay5lcXVhbHNdPSEwLEdbay5kb2xsYXJdPSEwLEdbay5jYXJldF09ITAsR1trLnNsYXNoXT0hMCxHKSxvaT17fSxMYT1cIjAxMjM0NTY3ODlhYmNkZWZBQkNERUZcIjtmb3IoQXI9MDtBcjxMYS5sZW5ndGg7QXIrKylvaVtMYS5jaGFyQ29kZUF0KEFyKV09ITA7dmFyIEFyO2Z1bmN0aW9uIGlkKGUsdCl7dmFyIG49dCxyO2Rve2lmKHI9ZS5jaGFyQ29kZUF0KG4pLG5kW3JdKXJldHVybiBuLTE7cj09PWsuYmFja3NsYXNoP249b2QoZSxuKSsxOm4rK313aGlsZShuPGUubGVuZ3RoKTtyZXR1cm4gbi0xfWZ1bmN0aW9uIG9kKGUsdCl7dmFyIG49dCxyPWUuY2hhckNvZGVBdChuKzEpO2lmKCFyZFtyXSlpZihvaVtyXSl7dmFyIGk9MDtkbyBuKyssaSsrLHI9ZS5jaGFyQ29kZUF0KG4rMSk7d2hpbGUob2lbcl0mJmk8Nik7aTw2JiZyPT09ay5zcGFjZSYmbisrfWVsc2UgbisrO3JldHVybiBufXZhciBhZD17VFlQRTowLFNUQVJUX0xJTkU6MSxTVEFSVF9DT0w6MixFTkRfTElORTozLEVORF9DT0w6NCxTVEFSVF9QT1M6NSxFTkRfUE9TOjZ9O1d0LkZJRUxEUz1hZDtmdW5jdGlvbiBzZChlKXt2YXIgdD1bXSxuPWUuY3NzLnZhbHVlT2YoKSxyPW4saT1yLmxlbmd0aCxhPS0xLG89MSxzPTAsdT0wLGwsZixwLGcsbSxkLGgsdyxiLF8sRSxBLEQ7ZnVuY3Rpb24gTShMLEYpe2lmKGUuc2FmZSluKz1GLGI9bi5sZW5ndGgtMTtlbHNlIHRocm93IGUuZXJyb3IoXCJVbmNsb3NlZCBcIitMLG8scy1hLHMpfWZvcig7czxpOyl7c3dpdGNoKGw9bi5jaGFyQ29kZUF0KHMpLGw9PT1rLm5ld2xpbmUmJihhPXMsbys9MSksbCl7Y2FzZSBrLnNwYWNlOmNhc2Ugay50YWI6Y2FzZSBrLm5ld2xpbmU6Y2FzZSBrLmNyOmNhc2Ugay5mZWVkOmI9cztkbyBiKz0xLGw9bi5jaGFyQ29kZUF0KGIpLGw9PT1rLm5ld2xpbmUmJihhPWIsbys9MSk7d2hpbGUobD09PWsuc3BhY2V8fGw9PT1rLm5ld2xpbmV8fGw9PT1rLnRhYnx8bD09PWsuY3J8fGw9PT1rLmZlZWQpO0Q9ay5zcGFjZSxnPW8scD1iLWEtMSx1PWI7YnJlYWs7Y2FzZSBrLnBsdXM6Y2FzZSBrLmdyZWF0ZXJUaGFuOmNhc2Ugay50aWxkZTpjYXNlIGsucGlwZTpiPXM7ZG8gYis9MSxsPW4uY2hhckNvZGVBdChiKTt3aGlsZShsPT09ay5wbHVzfHxsPT09ay5ncmVhdGVyVGhhbnx8bD09PWsudGlsZGV8fGw9PT1rLnBpcGUpO0Q9ay5jb21iaW5hdG9yLGc9byxwPXMtYSx1PWI7YnJlYWs7Y2FzZSBrLmFzdGVyaXNrOmNhc2Ugay5hbXBlcnNhbmQ6Y2FzZSBrLmJhbmc6Y2FzZSBrLmNvbW1hOmNhc2Ugay5lcXVhbHM6Y2FzZSBrLmRvbGxhcjpjYXNlIGsuY2FyZXQ6Y2FzZSBrLm9wZW5TcXVhcmU6Y2FzZSBrLmNsb3NlU3F1YXJlOmNhc2Ugay5jb2xvbjpjYXNlIGsuc2VtaWNvbG9uOmNhc2Ugay5vcGVuUGFyZW50aGVzaXM6Y2FzZSBrLmNsb3NlUGFyZW50aGVzaXM6Yj1zLEQ9bCxnPW8scD1zLWEsdT1iKzE7YnJlYWs7Y2FzZSBrLnNpbmdsZVF1b3RlOmNhc2Ugay5kb3VibGVRdW90ZTpBPWw9PT1rLnNpbmdsZVF1b3RlP1wiJ1wiOidcIicsYj1zO2RvIGZvcihtPSExLGI9bi5pbmRleE9mKEEsYisxKSxiPT09LTEmJk0oXCJxdW90ZVwiLEEpLGQ9YjtuLmNoYXJDb2RlQXQoZC0xKT09PWsuYmFja3NsYXNoOylkLT0xLG09IW07d2hpbGUobSk7RD1rLnN0cixnPW8scD1zLWEsdT1iKzE7YnJlYWs7ZGVmYXVsdDpsPT09ay5zbGFzaCYmbi5jaGFyQ29kZUF0KHMrMSk9PT1rLmFzdGVyaXNrPyhiPW4uaW5kZXhPZihcIiovXCIscysyKSsxLGI9PT0wJiZNKFwiY29tbWVudFwiLFwiKi9cIiksZj1uLnNsaWNlKHMsYisxKSx3PWYuc3BsaXQoYFxuYCksaD13Lmxlbmd0aC0xLGg+MD8oXz1vK2gsRT1iLXdbaF0ubGVuZ3RoKTooXz1vLEU9YSksRD1rLmNvbW1lbnQsbz1fLGc9XyxwPWItRSk6bD09PWsuc2xhc2g/KGI9cyxEPWwsZz1vLHA9cy1hLHU9YisxKTooYj1pZChuLHMpLEQ9ay53b3JkLGc9byxwPWItYSksdT1iKzE7YnJlYWt9dC5wdXNoKFtELG8scy1hLGcscCxzLHVdKSxFJiYoYT1FLEU9bnVsbCkscz11fXJldHVybiB0fX0pO3ZhciBVYT1SKCgkdCxCYSk9PntcInVzZSBzdHJpY3RcIjtjKCk7JHQuX19lc01vZHVsZT0hMDskdC5kZWZhdWx0PXZvaWQgMDt2YXIgdWQ9YmUoQW4oKSksYWk9YmUoUm4oKSksbGQ9YmUoRG4oKSksRmE9YmUoTW4oKSksZmQ9YmUoV24oKSksY2Q9YmUoQm4oKSksc2k9YmUoem4oKSksZGQ9YmUoam4oKSksTWE9SXIoSm4oKSkscGQ9YmUoWm4oKSksdWk9YmUodGkoKSksaGQ9YmUobmkoKSksbWQ9YmUoSWEoKSksUz1JcihEYSgpKSxUPUlyKGlpKCkpLGdkPUlyKG5lKCkpLFE9eHQoKSxYZSxsaTtmdW5jdGlvbiBxYSgpe2lmKHR5cGVvZiBXZWFrTWFwIT1cImZ1bmN0aW9uXCIpcmV0dXJuIG51bGw7dmFyIGU9bmV3IFdlYWtNYXA7cmV0dXJuIHFhPWZ1bmN0aW9uKCl7cmV0dXJuIGV9LGV9ZnVuY3Rpb24gSXIoZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO2lmKGU9PT1udWxsfHx0eXBlb2YgZSE9XCJvYmplY3RcIiYmdHlwZW9mIGUhPVwiZnVuY3Rpb25cIilyZXR1cm57ZGVmYXVsdDplfTt2YXIgdD1xYSgpO2lmKHQmJnQuaGFzKGUpKXJldHVybiB0LmdldChlKTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIGkgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxpKSl7dmFyIGE9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsaSk6bnVsbDthJiYoYS5nZXR8fGEuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixpLGEpOm5baV09ZVtpXX1yZXR1cm4gbi5kZWZhdWx0PWUsdCYmdC5zZXQoZSxuKSxufWZ1bmN0aW9uIGJlKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBOYShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gdmQoZSx0LG4pe3JldHVybiB0JiZOYShlLnByb3RvdHlwZSx0KSxuJiZOYShlLG4pLGV9dmFyIGRpPShYZT17fSxYZVtULnNwYWNlXT0hMCxYZVtULmNyXT0hMCxYZVtULmZlZWRdPSEwLFhlW1QubmV3bGluZV09ITAsWGVbVC50YWJdPSEwLFhlKSxiZD1PYmplY3QuYXNzaWduKHt9LGRpLChsaT17fSxsaVtULmNvbW1lbnRdPSEwLGxpKSk7ZnVuY3Rpb24gV2EoZSl7cmV0dXJue2xpbmU6ZVtTLkZJRUxEUy5TVEFSVF9MSU5FXSxjb2x1bW46ZVtTLkZJRUxEUy5TVEFSVF9DT0xdfX1mdW5jdGlvbiAkYShlKXtyZXR1cm57bGluZTplW1MuRklFTERTLkVORF9MSU5FXSxjb2x1bW46ZVtTLkZJRUxEUy5FTkRfQ09MXX19ZnVuY3Rpb24gUWUoZSx0LG4scil7cmV0dXJue3N0YXJ0OntsaW5lOmUsY29sdW1uOnR9LGVuZDp7bGluZTpuLGNvbHVtbjpyfX19ZnVuY3Rpb24gb3QoZSl7cmV0dXJuIFFlKGVbUy5GSUVMRFMuU1RBUlRfTElORV0sZVtTLkZJRUxEUy5TVEFSVF9DT0xdLGVbUy5GSUVMRFMuRU5EX0xJTkVdLGVbUy5GSUVMRFMuRU5EX0NPTF0pfWZ1bmN0aW9uIGZpKGUsdCl7aWYoISFlKXJldHVybiBRZShlW1MuRklFTERTLlNUQVJUX0xJTkVdLGVbUy5GSUVMRFMuU1RBUlRfQ09MXSx0W1MuRklFTERTLkVORF9MSU5FXSx0W1MuRklFTERTLkVORF9DT0xdKX1mdW5jdGlvbiBhdChlLHQpe3ZhciBuPWVbdF07aWYodHlwZW9mIG49PVwic3RyaW5nXCIpcmV0dXJuIG4uaW5kZXhPZihcIlxcXFxcIikhPT0tMSYmKCgwLFEuZW5zdXJlT2JqZWN0KShlLFwicmF3c1wiKSxlW3RdPSgwLFEudW5lc2MpKG4pLGUucmF3c1t0XT09PXZvaWQgMCYmKGUucmF3c1t0XT1uKSksZX1mdW5jdGlvbiBjaShlLHQpe2Zvcih2YXIgbj0tMSxyPVtdOyhuPWUuaW5kZXhPZih0LG4rMSkpIT09LTE7KXIucHVzaChuKTtyZXR1cm4gcn1mdW5jdGlvbiB5ZCgpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sYXJndW1lbnRzKTtyZXR1cm4gZS5maWx0ZXIoZnVuY3Rpb24odCxuKXtyZXR1cm4gbj09PWUuaW5kZXhPZih0KX0pfXZhciB4ZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobixyKXtyPT09dm9pZCAwJiYocj17fSksdGhpcy5ydWxlPW4sdGhpcy5vcHRpb25zPU9iamVjdC5hc3NpZ24oe2xvc3N5OiExLHNhZmU6ITF9LHIpLHRoaXMucG9zaXRpb249MCx0aGlzLmNzcz10eXBlb2YgdGhpcy5ydWxlPT1cInN0cmluZ1wiP3RoaXMucnVsZTp0aGlzLnJ1bGUuc2VsZWN0b3IsdGhpcy50b2tlbnM9KDAsUy5kZWZhdWx0KSh7Y3NzOnRoaXMuY3NzLGVycm9yOnRoaXMuX2Vycm9yR2VuZXJhdG9yKCksc2FmZTp0aGlzLm9wdGlvbnMuc2FmZX0pO3ZhciBpPWZpKHRoaXMudG9rZW5zWzBdLHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aC0xXSk7dGhpcy5yb290PW5ldyB1ZC5kZWZhdWx0KHtzb3VyY2U6aX0pLHRoaXMucm9vdC5lcnJvckdlbmVyYXRvcj10aGlzLl9lcnJvckdlbmVyYXRvcigpO3ZhciBhPW5ldyBhaS5kZWZhdWx0KHtzb3VyY2U6e3N0YXJ0OntsaW5lOjEsY29sdW1uOjF9fX0pO3RoaXMucm9vdC5hcHBlbmQoYSksdGhpcy5jdXJyZW50PWEsdGhpcy5sb29wKCl9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQuX2Vycm9yR2VuZXJhdG9yPWZ1bmN0aW9uKCl7dmFyIHI9dGhpcztyZXR1cm4gZnVuY3Rpb24oaSxhKXtyZXR1cm4gdHlwZW9mIHIucnVsZT09XCJzdHJpbmdcIj9uZXcgRXJyb3IoaSk6ci5ydWxlLmVycm9yKGksYSl9fSx0LmF0dHJpYnV0ZT1mdW5jdGlvbigpe3ZhciByPVtdLGk9dGhpcy5jdXJyVG9rZW47Zm9yKHRoaXMucG9zaXRpb24rKzt0aGlzLnBvc2l0aW9uPHRoaXMudG9rZW5zLmxlbmd0aCYmdGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuVFlQRV0hPT1ULmNsb3NlU3F1YXJlOylyLnB1c2godGhpcy5jdXJyVG9rZW4pLHRoaXMucG9zaXRpb24rKztpZih0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5UWVBFXSE9PVQuY2xvc2VTcXVhcmUpcmV0dXJuIHRoaXMuZXhwZWN0ZWQoXCJjbG9zaW5nIHNxdWFyZSBicmFja2V0XCIsdGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuU1RBUlRfUE9TXSk7dmFyIGE9ci5sZW5ndGgsbz17c291cmNlOlFlKGlbMV0saVsyXSx0aGlzLmN1cnJUb2tlblszXSx0aGlzLmN1cnJUb2tlbls0XSksc291cmNlSW5kZXg6aVtTLkZJRUxEUy5TVEFSVF9QT1NdfTtpZihhPT09MSYmIX5bVC53b3JkXS5pbmRleE9mKHJbMF1bUy5GSUVMRFMuVFlQRV0pKXJldHVybiB0aGlzLmV4cGVjdGVkKFwiYXR0cmlidXRlXCIsclswXVtTLkZJRUxEUy5TVEFSVF9QT1NdKTtmb3IodmFyIHM9MCx1PVwiXCIsbD1cIlwiLGY9bnVsbCxwPSExO3M8YTspe3ZhciBnPXJbc10sbT10aGlzLmNvbnRlbnQoZyksZD1yW3MrMV07c3dpdGNoKGdbUy5GSUVMRFMuVFlQRV0pe2Nhc2UgVC5zcGFjZTppZihwPSEwLHRoaXMub3B0aW9ucy5sb3NzeSlicmVhaztpZihmKXsoMCxRLmVuc3VyZU9iamVjdCkobyxcInNwYWNlc1wiLGYpO3ZhciBoPW8uc3BhY2VzW2ZdLmFmdGVyfHxcIlwiO28uc3BhY2VzW2ZdLmFmdGVyPWgrbTt2YXIgdz0oMCxRLmdldFByb3ApKG8sXCJyYXdzXCIsXCJzcGFjZXNcIixmLFwiYWZ0ZXJcIil8fG51bGw7dyYmKG8ucmF3cy5zcGFjZXNbZl0uYWZ0ZXI9dyttKX1lbHNlIHU9dSttLGw9bCttO2JyZWFrO2Nhc2UgVC5hc3RlcmlzazppZihkW1MuRklFTERTLlRZUEVdPT09VC5lcXVhbHMpby5vcGVyYXRvcj1tLGY9XCJvcGVyYXRvclwiO2Vsc2UgaWYoKCFvLm5hbWVzcGFjZXx8Zj09PVwibmFtZXNwYWNlXCImJiFwKSYmZCl7dSYmKCgwLFEuZW5zdXJlT2JqZWN0KShvLFwic3BhY2VzXCIsXCJhdHRyaWJ1dGVcIiksby5zcGFjZXMuYXR0cmlidXRlLmJlZm9yZT11LHU9XCJcIiksbCYmKCgwLFEuZW5zdXJlT2JqZWN0KShvLFwicmF3c1wiLFwic3BhY2VzXCIsXCJhdHRyaWJ1dGVcIiksby5yYXdzLnNwYWNlcy5hdHRyaWJ1dGUuYmVmb3JlPXUsbD1cIlwiKSxvLm5hbWVzcGFjZT0oby5uYW1lc3BhY2V8fFwiXCIpK207dmFyIGI9KDAsUS5nZXRQcm9wKShvLFwicmF3c1wiLFwibmFtZXNwYWNlXCIpfHxudWxsO2ImJihvLnJhd3MubmFtZXNwYWNlKz1tKSxmPVwibmFtZXNwYWNlXCJ9cD0hMTticmVhaztjYXNlIFQuZG9sbGFyOmlmKGY9PT1cInZhbHVlXCIpe3ZhciBfPSgwLFEuZ2V0UHJvcCkobyxcInJhd3NcIixcInZhbHVlXCIpO28udmFsdWUrPVwiJFwiLF8mJihvLnJhd3MudmFsdWU9XytcIiRcIik7YnJlYWt9Y2FzZSBULmNhcmV0OmRbUy5GSUVMRFMuVFlQRV09PT1ULmVxdWFscyYmKG8ub3BlcmF0b3I9bSxmPVwib3BlcmF0b3JcIikscD0hMTticmVhaztjYXNlIFQuY29tYmluYXRvcjppZihtPT09XCJ+XCImJmRbUy5GSUVMRFMuVFlQRV09PT1ULmVxdWFscyYmKG8ub3BlcmF0b3I9bSxmPVwib3BlcmF0b3JcIiksbSE9PVwifFwiKXtwPSExO2JyZWFrfWRbUy5GSUVMRFMuVFlQRV09PT1ULmVxdWFscz8oby5vcGVyYXRvcj1tLGY9XCJvcGVyYXRvclwiKTohby5uYW1lc3BhY2UmJiFvLmF0dHJpYnV0ZSYmKG8ubmFtZXNwYWNlPSEwKSxwPSExO2JyZWFrO2Nhc2UgVC53b3JkOmlmKGQmJnRoaXMuY29udGVudChkKT09PVwifFwiJiZyW3MrMl0mJnJbcysyXVtTLkZJRUxEUy5UWVBFXSE9PVQuZXF1YWxzJiYhby5vcGVyYXRvciYmIW8ubmFtZXNwYWNlKW8ubmFtZXNwYWNlPW0sZj1cIm5hbWVzcGFjZVwiO2Vsc2UgaWYoIW8uYXR0cmlidXRlfHxmPT09XCJhdHRyaWJ1dGVcIiYmIXApe3UmJigoMCxRLmVuc3VyZU9iamVjdCkobyxcInNwYWNlc1wiLFwiYXR0cmlidXRlXCIpLG8uc3BhY2VzLmF0dHJpYnV0ZS5iZWZvcmU9dSx1PVwiXCIpLGwmJigoMCxRLmVuc3VyZU9iamVjdCkobyxcInJhd3NcIixcInNwYWNlc1wiLFwiYXR0cmlidXRlXCIpLG8ucmF3cy5zcGFjZXMuYXR0cmlidXRlLmJlZm9yZT1sLGw9XCJcIiksby5hdHRyaWJ1dGU9KG8uYXR0cmlidXRlfHxcIlwiKSttO3ZhciBFPSgwLFEuZ2V0UHJvcCkobyxcInJhd3NcIixcImF0dHJpYnV0ZVwiKXx8bnVsbDtFJiYoby5yYXdzLmF0dHJpYnV0ZSs9bSksZj1cImF0dHJpYnV0ZVwifWVsc2UgaWYoIW8udmFsdWUmJm8udmFsdWUhPT1cIlwifHxmPT09XCJ2YWx1ZVwiJiYhcCl7dmFyIEE9KDAsUS51bmVzYykobSksRD0oMCxRLmdldFByb3ApKG8sXCJyYXdzXCIsXCJ2YWx1ZVwiKXx8XCJcIixNPW8udmFsdWV8fFwiXCI7by52YWx1ZT1NK0Esby5xdW90ZU1hcms9bnVsbCwoQSE9PW18fEQpJiYoKDAsUS5lbnN1cmVPYmplY3QpKG8sXCJyYXdzXCIpLG8ucmF3cy52YWx1ZT0oRHx8TSkrbSksZj1cInZhbHVlXCJ9ZWxzZXt2YXIgTD1tPT09XCJpXCJ8fG09PT1cIklcIjsoby52YWx1ZXx8by52YWx1ZT09PVwiXCIpJiYoby5xdW90ZU1hcmt8fHApPyhvLmluc2Vuc2l0aXZlPUwsKCFMfHxtPT09XCJJXCIpJiYoKDAsUS5lbnN1cmVPYmplY3QpKG8sXCJyYXdzXCIpLG8ucmF3cy5pbnNlbnNpdGl2ZUZsYWc9bSksZj1cImluc2Vuc2l0aXZlXCIsdSYmKCgwLFEuZW5zdXJlT2JqZWN0KShvLFwic3BhY2VzXCIsXCJpbnNlbnNpdGl2ZVwiKSxvLnNwYWNlcy5pbnNlbnNpdGl2ZS5iZWZvcmU9dSx1PVwiXCIpLGwmJigoMCxRLmVuc3VyZU9iamVjdCkobyxcInJhd3NcIixcInNwYWNlc1wiLFwiaW5zZW5zaXRpdmVcIiksby5yYXdzLnNwYWNlcy5pbnNlbnNpdGl2ZS5iZWZvcmU9bCxsPVwiXCIpKTooby52YWx1ZXx8by52YWx1ZT09PVwiXCIpJiYoZj1cInZhbHVlXCIsby52YWx1ZSs9bSxvLnJhd3MudmFsdWUmJihvLnJhd3MudmFsdWUrPW0pKX1wPSExO2JyZWFrO2Nhc2UgVC5zdHI6aWYoIW8uYXR0cmlidXRlfHwhby5vcGVyYXRvcilyZXR1cm4gdGhpcy5lcnJvcihcIkV4cGVjdGVkIGFuIGF0dHJpYnV0ZSBmb2xsb3dlZCBieSBhbiBvcGVyYXRvciBwcmVjZWRpbmcgdGhlIHN0cmluZy5cIix7aW5kZXg6Z1tTLkZJRUxEUy5TVEFSVF9QT1NdfSk7dmFyIEY9KDAsTWEudW5lc2NhcGVWYWx1ZSkobSksTj1GLnVuZXNjYXBlZCxVPUYucXVvdGVNYXJrO28udmFsdWU9TixvLnF1b3RlTWFyaz1VLGY9XCJ2YWx1ZVwiLCgwLFEuZW5zdXJlT2JqZWN0KShvLFwicmF3c1wiKSxvLnJhd3MudmFsdWU9bSxwPSExO2JyZWFrO2Nhc2UgVC5lcXVhbHM6aWYoIW8uYXR0cmlidXRlKXJldHVybiB0aGlzLmV4cGVjdGVkKFwiYXR0cmlidXRlXCIsZ1tTLkZJRUxEUy5TVEFSVF9QT1NdLG0pO2lmKG8udmFsdWUpcmV0dXJuIHRoaXMuZXJyb3IoJ1VuZXhwZWN0ZWQgXCI9XCIgZm91bmQ7IGFuIG9wZXJhdG9yIHdhcyBhbHJlYWR5IGRlZmluZWQuJyx7aW5kZXg6Z1tTLkZJRUxEUy5TVEFSVF9QT1NdfSk7by5vcGVyYXRvcj1vLm9wZXJhdG9yP28ub3BlcmF0b3IrbTptLGY9XCJvcGVyYXRvclwiLHA9ITE7YnJlYWs7Y2FzZSBULmNvbW1lbnQ6aWYoZilpZihwfHxkJiZkW1MuRklFTERTLlRZUEVdPT09VC5zcGFjZXx8Zj09PVwiaW5zZW5zaXRpdmVcIil7dmFyIHE9KDAsUS5nZXRQcm9wKShvLFwic3BhY2VzXCIsZixcImFmdGVyXCIpfHxcIlwiLEs9KDAsUS5nZXRQcm9wKShvLFwicmF3c1wiLFwic3BhY2VzXCIsZixcImFmdGVyXCIpfHxxOygwLFEuZW5zdXJlT2JqZWN0KShvLFwicmF3c1wiLFwic3BhY2VzXCIsZiksby5yYXdzLnNwYWNlc1tmXS5hZnRlcj1LK219ZWxzZXt2YXIgZWU9b1tmXXx8XCJcIix6PSgwLFEuZ2V0UHJvcCkobyxcInJhd3NcIixmKXx8ZWU7KDAsUS5lbnN1cmVPYmplY3QpKG8sXCJyYXdzXCIpLG8ucmF3c1tmXT16K219ZWxzZSBsPWwrbTticmVhaztkZWZhdWx0OnJldHVybiB0aGlzLmVycm9yKCdVbmV4cGVjdGVkIFwiJyttKydcIiBmb3VuZC4nLHtpbmRleDpnW1MuRklFTERTLlNUQVJUX1BPU119KX1zKyt9YXQobyxcImF0dHJpYnV0ZVwiKSxhdChvLFwibmFtZXNwYWNlXCIpLHRoaXMubmV3Tm9kZShuZXcgTWEuZGVmYXVsdChvKSksdGhpcy5wb3NpdGlvbisrfSx0LnBhcnNlV2hpdGVzcGFjZUVxdWl2YWxlbnRUb2tlbnM9ZnVuY3Rpb24ocil7cjwwJiYocj10aGlzLnRva2Vucy5sZW5ndGgpO3ZhciBpPXRoaXMucG9zaXRpb24sYT1bXSxvPVwiXCIscz12b2lkIDA7ZG8gaWYoZGlbdGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuVFlQRV1dKXRoaXMub3B0aW9ucy5sb3NzeXx8KG8rPXRoaXMuY29udGVudCgpKTtlbHNlIGlmKHRoaXMuY3VyclRva2VuW1MuRklFTERTLlRZUEVdPT09VC5jb21tZW50KXt2YXIgdT17fTtvJiYodS5iZWZvcmU9byxvPVwiXCIpLHM9bmV3IEZhLmRlZmF1bHQoe3ZhbHVlOnRoaXMuY29udGVudCgpLHNvdXJjZTpvdCh0aGlzLmN1cnJUb2tlbiksc291cmNlSW5kZXg6dGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuU1RBUlRfUE9TXSxzcGFjZXM6dX0pLGEucHVzaChzKX13aGlsZSgrK3RoaXMucG9zaXRpb248cik7aWYobyl7aWYocylzLnNwYWNlcy5hZnRlcj1vO2Vsc2UgaWYoIXRoaXMub3B0aW9ucy5sb3NzeSl7dmFyIGw9dGhpcy50b2tlbnNbaV0sZj10aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uLTFdO2EucHVzaChuZXcgc2kuZGVmYXVsdCh7dmFsdWU6XCJcIixzb3VyY2U6UWUobFtTLkZJRUxEUy5TVEFSVF9MSU5FXSxsW1MuRklFTERTLlNUQVJUX0NPTF0sZltTLkZJRUxEUy5FTkRfTElORV0sZltTLkZJRUxEUy5FTkRfQ09MXSksc291cmNlSW5kZXg6bFtTLkZJRUxEUy5TVEFSVF9QT1NdLHNwYWNlczp7YmVmb3JlOm8sYWZ0ZXI6XCJcIn19KSl9fXJldHVybiBhfSx0LmNvbnZlcnRXaGl0ZXNwYWNlTm9kZXNUb1NwYWNlPWZ1bmN0aW9uKHIsaSl7dmFyIGE9dGhpcztpPT09dm9pZCAwJiYoaT0hMSk7dmFyIG89XCJcIixzPVwiXCI7ci5mb3JFYWNoKGZ1bmN0aW9uKGwpe3ZhciBmPWEubG9zc3lTcGFjZShsLnNwYWNlcy5iZWZvcmUsaSkscD1hLmxvc3N5U3BhY2UobC5yYXdTcGFjZUJlZm9yZSxpKTtvKz1mK2EubG9zc3lTcGFjZShsLnNwYWNlcy5hZnRlcixpJiZmLmxlbmd0aD09PTApLHMrPWYrbC52YWx1ZSthLmxvc3N5U3BhY2UobC5yYXdTcGFjZUFmdGVyLGkmJnAubGVuZ3RoPT09MCl9KSxzPT09byYmKHM9dm9pZCAwKTt2YXIgdT17c3BhY2U6byxyYXdTcGFjZTpzfTtyZXR1cm4gdX0sdC5pc05hbWVkQ29tYmluYXRvcj1mdW5jdGlvbihyKXtyZXR1cm4gcj09PXZvaWQgMCYmKHI9dGhpcy5wb3NpdGlvbiksdGhpcy50b2tlbnNbciswXSYmdGhpcy50b2tlbnNbciswXVtTLkZJRUxEUy5UWVBFXT09PVQuc2xhc2gmJnRoaXMudG9rZW5zW3IrMV0mJnRoaXMudG9rZW5zW3IrMV1bUy5GSUVMRFMuVFlQRV09PT1ULndvcmQmJnRoaXMudG9rZW5zW3IrMl0mJnRoaXMudG9rZW5zW3IrMl1bUy5GSUVMRFMuVFlQRV09PT1ULnNsYXNofSx0Lm5hbWVkQ29tYmluYXRvcj1mdW5jdGlvbigpe2lmKHRoaXMuaXNOYW1lZENvbWJpbmF0b3IoKSl7dmFyIHI9dGhpcy5jb250ZW50KHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24rMV0pLGk9KDAsUS51bmVzYykocikudG9Mb3dlckNhc2UoKSxhPXt9O2khPT1yJiYoYS52YWx1ZT1cIi9cIityK1wiL1wiKTt2YXIgbz1uZXcgdWkuZGVmYXVsdCh7dmFsdWU6XCIvXCIraStcIi9cIixzb3VyY2U6UWUodGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuU1RBUlRfTElORV0sdGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuU1RBUlRfQ09MXSx0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uKzJdW1MuRklFTERTLkVORF9MSU5FXSx0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uKzJdW1MuRklFTERTLkVORF9DT0xdKSxzb3VyY2VJbmRleDp0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5TVEFSVF9QT1NdLHJhd3M6YX0pO3JldHVybiB0aGlzLnBvc2l0aW9uPXRoaXMucG9zaXRpb24rMyxvfWVsc2UgdGhpcy51bmV4cGVjdGVkKCl9LHQuY29tYmluYXRvcj1mdW5jdGlvbigpe3ZhciByPXRoaXM7aWYodGhpcy5jb250ZW50KCk9PT1cInxcIilyZXR1cm4gdGhpcy5uYW1lc3BhY2UoKTt2YXIgaT10aGlzLmxvY2F0ZU5leHRNZWFuaW5nZnVsVG9rZW4odGhpcy5wb3NpdGlvbik7aWYoaTwwfHx0aGlzLnRva2Vuc1tpXVtTLkZJRUxEUy5UWVBFXT09PVQuY29tbWEpe3ZhciBhPXRoaXMucGFyc2VXaGl0ZXNwYWNlRXF1aXZhbGVudFRva2VucyhpKTtpZihhLmxlbmd0aD4wKXt2YXIgbz10aGlzLmN1cnJlbnQubGFzdDtpZihvKXt2YXIgcz10aGlzLmNvbnZlcnRXaGl0ZXNwYWNlTm9kZXNUb1NwYWNlKGEpLHU9cy5zcGFjZSxsPXMucmF3U3BhY2U7bCE9PXZvaWQgMCYmKG8ucmF3U3BhY2VBZnRlcis9bCksby5zcGFjZXMuYWZ0ZXIrPXV9ZWxzZSBhLmZvckVhY2goZnVuY3Rpb24oRCl7cmV0dXJuIHIubmV3Tm9kZShEKX0pfXJldHVybn12YXIgZj10aGlzLmN1cnJUb2tlbixwPXZvaWQgMDtpPnRoaXMucG9zaXRpb24mJihwPXRoaXMucGFyc2VXaGl0ZXNwYWNlRXF1aXZhbGVudFRva2VucyhpKSk7dmFyIGc7aWYodGhpcy5pc05hbWVkQ29tYmluYXRvcigpP2c9dGhpcy5uYW1lZENvbWJpbmF0b3IoKTp0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5UWVBFXT09PVQuY29tYmluYXRvcj8oZz1uZXcgdWkuZGVmYXVsdCh7dmFsdWU6dGhpcy5jb250ZW50KCksc291cmNlOm90KHRoaXMuY3VyclRva2VuKSxzb3VyY2VJbmRleDp0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5TVEFSVF9QT1NdfSksdGhpcy5wb3NpdGlvbisrKTpkaVt0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5UWVBFXV18fHB8fHRoaXMudW5leHBlY3RlZCgpLGcpe2lmKHApe3ZhciBtPXRoaXMuY29udmVydFdoaXRlc3BhY2VOb2Rlc1RvU3BhY2UocCksZD1tLnNwYWNlLGg9bS5yYXdTcGFjZTtnLnNwYWNlcy5iZWZvcmU9ZCxnLnJhd1NwYWNlQmVmb3JlPWh9fWVsc2V7dmFyIHc9dGhpcy5jb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZShwLCEwKSxiPXcuc3BhY2UsXz13LnJhd1NwYWNlO198fChfPWIpO3ZhciBFPXt9LEE9e3NwYWNlczp7fX07Yi5lbmRzV2l0aChcIiBcIikmJl8uZW5kc1dpdGgoXCIgXCIpPyhFLmJlZm9yZT1iLnNsaWNlKDAsYi5sZW5ndGgtMSksQS5zcGFjZXMuYmVmb3JlPV8uc2xpY2UoMCxfLmxlbmd0aC0xKSk6Yi5zdGFydHNXaXRoKFwiIFwiKSYmXy5zdGFydHNXaXRoKFwiIFwiKT8oRS5hZnRlcj1iLnNsaWNlKDEpLEEuc3BhY2VzLmFmdGVyPV8uc2xpY2UoMSkpOkEudmFsdWU9XyxnPW5ldyB1aS5kZWZhdWx0KHt2YWx1ZTpcIiBcIixzb3VyY2U6ZmkoZix0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uLTFdKSxzb3VyY2VJbmRleDpmW1MuRklFTERTLlNUQVJUX1BPU10sc3BhY2VzOkUscmF3czpBfSl9cmV0dXJuIHRoaXMuY3VyclRva2VuJiZ0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5UWVBFXT09PVQuc3BhY2UmJihnLnNwYWNlcy5hZnRlcj10aGlzLm9wdGlvbmFsU3BhY2UodGhpcy5jb250ZW50KCkpLHRoaXMucG9zaXRpb24rKyksdGhpcy5uZXdOb2RlKGcpfSx0LmNvbW1hPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbj09PXRoaXMudG9rZW5zLmxlbmd0aC0xKXt0aGlzLnJvb3QudHJhaWxpbmdDb21tYT0hMCx0aGlzLnBvc2l0aW9uKys7cmV0dXJufXRoaXMuY3VycmVudC5faW5mZXJFbmRQb3NpdGlvbigpO3ZhciByPW5ldyBhaS5kZWZhdWx0KHtzb3VyY2U6e3N0YXJ0OldhKHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24rMV0pfX0pO3RoaXMuY3VycmVudC5wYXJlbnQuYXBwZW5kKHIpLHRoaXMuY3VycmVudD1yLHRoaXMucG9zaXRpb24rK30sdC5jb21tZW50PWZ1bmN0aW9uKCl7dmFyIHI9dGhpcy5jdXJyVG9rZW47dGhpcy5uZXdOb2RlKG5ldyBGYS5kZWZhdWx0KHt2YWx1ZTp0aGlzLmNvbnRlbnQoKSxzb3VyY2U6b3Qociksc291cmNlSW5kZXg6cltTLkZJRUxEUy5TVEFSVF9QT1NdfSkpLHRoaXMucG9zaXRpb24rK30sdC5lcnJvcj1mdW5jdGlvbihyLGkpe3Rocm93IHRoaXMucm9vdC5lcnJvcihyLGkpfSx0Lm1pc3NpbmdCYWNrc2xhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcnJvcihcIkV4cGVjdGVkIGEgYmFja3NsYXNoIHByZWNlZGluZyB0aGUgc2VtaWNvbG9uLlwiLHtpbmRleDp0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5TVEFSVF9QT1NdfSl9LHQubWlzc2luZ1BhcmVudGhlc2lzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhwZWN0ZWQoXCJvcGVuaW5nIHBhcmVudGhlc2lzXCIsdGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuU1RBUlRfUE9TXSl9LHQubWlzc2luZ1NxdWFyZUJyYWNrZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leHBlY3RlZChcIm9wZW5pbmcgc3F1YXJlIGJyYWNrZXRcIix0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5TVEFSVF9QT1NdKX0sdC51bmV4cGVjdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkICdcIit0aGlzLmNvbnRlbnQoKStcIicuIEVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyB3aXRoIFxcXFwgbWF5IGhlbHAuXCIsdGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuU1RBUlRfUE9TXSl9LHQubmFtZXNwYWNlPWZ1bmN0aW9uKCl7dmFyIHI9dGhpcy5wcmV2VG9rZW4mJnRoaXMuY29udGVudCh0aGlzLnByZXZUb2tlbil8fCEwO2lmKHRoaXMubmV4dFRva2VuW1MuRklFTERTLlRZUEVdPT09VC53b3JkKXJldHVybiB0aGlzLnBvc2l0aW9uKyssdGhpcy53b3JkKHIpO2lmKHRoaXMubmV4dFRva2VuW1MuRklFTERTLlRZUEVdPT09VC5hc3RlcmlzaylyZXR1cm4gdGhpcy5wb3NpdGlvbisrLHRoaXMudW5pdmVyc2FsKHIpfSx0Lm5lc3Rpbmc9ZnVuY3Rpb24oKXtpZih0aGlzLm5leHRUb2tlbil7dmFyIHI9dGhpcy5jb250ZW50KHRoaXMubmV4dFRva2VuKTtpZihyPT09XCJ8XCIpe3RoaXMucG9zaXRpb24rKztyZXR1cm59fXZhciBpPXRoaXMuY3VyclRva2VuO3RoaXMubmV3Tm9kZShuZXcgaGQuZGVmYXVsdCh7dmFsdWU6dGhpcy5jb250ZW50KCksc291cmNlOm90KGkpLHNvdXJjZUluZGV4OmlbUy5GSUVMRFMuU1RBUlRfUE9TXX0pKSx0aGlzLnBvc2l0aW9uKyt9LHQucGFyZW50aGVzZXM9ZnVuY3Rpb24oKXt2YXIgcj10aGlzLmN1cnJlbnQubGFzdCxpPTE7aWYodGhpcy5wb3NpdGlvbisrLHImJnIudHlwZT09PWdkLlBTRVVETyl7dmFyIGE9bmV3IGFpLmRlZmF1bHQoe3NvdXJjZTp7c3RhcnQ6V2EodGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbi0xXSl9fSksbz10aGlzLmN1cnJlbnQ7Zm9yKHIuYXBwZW5kKGEpLHRoaXMuY3VycmVudD1hO3RoaXMucG9zaXRpb248dGhpcy50b2tlbnMubGVuZ3RoJiZpOyl0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5UWVBFXT09PVQub3BlblBhcmVudGhlc2lzJiZpKyssdGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuVFlQRV09PT1ULmNsb3NlUGFyZW50aGVzaXMmJmktLSxpP3RoaXMucGFyc2UoKToodGhpcy5jdXJyZW50LnNvdXJjZS5lbmQ9JGEodGhpcy5jdXJyVG9rZW4pLHRoaXMuY3VycmVudC5wYXJlbnQuc291cmNlLmVuZD0kYSh0aGlzLmN1cnJUb2tlbiksdGhpcy5wb3NpdGlvbisrKTt0aGlzLmN1cnJlbnQ9b31lbHNle2Zvcih2YXIgcz10aGlzLmN1cnJUb2tlbix1PVwiKFwiLGw7dGhpcy5wb3NpdGlvbjx0aGlzLnRva2Vucy5sZW5ndGgmJmk7KXRoaXMuY3VyclRva2VuW1MuRklFTERTLlRZUEVdPT09VC5vcGVuUGFyZW50aGVzaXMmJmkrKyx0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5UWVBFXT09PVQuY2xvc2VQYXJlbnRoZXNpcyYmaS0tLGw9dGhpcy5jdXJyVG9rZW4sdSs9dGhpcy5wYXJzZVBhcmVudGhlc2lzVG9rZW4odGhpcy5jdXJyVG9rZW4pLHRoaXMucG9zaXRpb24rKztyP3IuYXBwZW5kVG9Qcm9wZXJ0eUFuZEVzY2FwZShcInZhbHVlXCIsdSx1KTp0aGlzLm5ld05vZGUobmV3IHNpLmRlZmF1bHQoe3ZhbHVlOnUsc291cmNlOlFlKHNbUy5GSUVMRFMuU1RBUlRfTElORV0sc1tTLkZJRUxEUy5TVEFSVF9DT0xdLGxbUy5GSUVMRFMuRU5EX0xJTkVdLGxbUy5GSUVMRFMuRU5EX0NPTF0pLHNvdXJjZUluZGV4OnNbUy5GSUVMRFMuU1RBUlRfUE9TXX0pKX1pZihpKXJldHVybiB0aGlzLmV4cGVjdGVkKFwiY2xvc2luZyBwYXJlbnRoZXNpc1wiLHRoaXMuY3VyclRva2VuW1MuRklFTERTLlNUQVJUX1BPU10pfSx0LnBzZXVkbz1mdW5jdGlvbigpe2Zvcih2YXIgcj10aGlzLGk9XCJcIixhPXRoaXMuY3VyclRva2VuO3RoaXMuY3VyclRva2VuJiZ0aGlzLmN1cnJUb2tlbltTLkZJRUxEUy5UWVBFXT09PVQuY29sb247KWkrPXRoaXMuY29udGVudCgpLHRoaXMucG9zaXRpb24rKztpZighdGhpcy5jdXJyVG9rZW4pcmV0dXJuIHRoaXMuZXhwZWN0ZWQoW1wicHNldWRvLWNsYXNzXCIsXCJwc2V1ZG8tZWxlbWVudFwiXSx0aGlzLnBvc2l0aW9uLTEpO2lmKHRoaXMuY3VyclRva2VuW1MuRklFTERTLlRZUEVdPT09VC53b3JkKXRoaXMuc3BsaXRXb3JkKCExLGZ1bmN0aW9uKG8scyl7aSs9byxyLm5ld05vZGUobmV3IGRkLmRlZmF1bHQoe3ZhbHVlOmksc291cmNlOmZpKGEsci5jdXJyVG9rZW4pLHNvdXJjZUluZGV4OmFbUy5GSUVMRFMuU1RBUlRfUE9TXX0pKSxzPjEmJnIubmV4dFRva2VuJiZyLm5leHRUb2tlbltTLkZJRUxEUy5UWVBFXT09PVQub3BlblBhcmVudGhlc2lzJiZyLmVycm9yKFwiTWlzcGxhY2VkIHBhcmVudGhlc2lzLlwiLHtpbmRleDpyLm5leHRUb2tlbltTLkZJRUxEUy5TVEFSVF9QT1NdfSl9KTtlbHNlIHJldHVybiB0aGlzLmV4cGVjdGVkKFtcInBzZXVkby1jbGFzc1wiLFwicHNldWRvLWVsZW1lbnRcIl0sdGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuU1RBUlRfUE9TXSl9LHQuc3BhY2U9ZnVuY3Rpb24oKXt2YXIgcj10aGlzLmNvbnRlbnQoKTt0aGlzLnBvc2l0aW9uPT09MHx8dGhpcy5wcmV2VG9rZW5bUy5GSUVMRFMuVFlQRV09PT1ULmNvbW1hfHx0aGlzLnByZXZUb2tlbltTLkZJRUxEUy5UWVBFXT09PVQub3BlblBhcmVudGhlc2lzfHx0aGlzLmN1cnJlbnQubm9kZXMuZXZlcnkoZnVuY3Rpb24oaSl7cmV0dXJuIGkudHlwZT09PVwiY29tbWVudFwifSk/KHRoaXMuc3BhY2VzPXRoaXMub3B0aW9uYWxTcGFjZShyKSx0aGlzLnBvc2l0aW9uKyspOnRoaXMucG9zaXRpb249PT10aGlzLnRva2Vucy5sZW5ndGgtMXx8dGhpcy5uZXh0VG9rZW5bUy5GSUVMRFMuVFlQRV09PT1ULmNvbW1hfHx0aGlzLm5leHRUb2tlbltTLkZJRUxEUy5UWVBFXT09PVQuY2xvc2VQYXJlbnRoZXNpcz8odGhpcy5jdXJyZW50Lmxhc3Quc3BhY2VzLmFmdGVyPXRoaXMub3B0aW9uYWxTcGFjZShyKSx0aGlzLnBvc2l0aW9uKyspOnRoaXMuY29tYmluYXRvcigpfSx0LnN0cmluZz1mdW5jdGlvbigpe3ZhciByPXRoaXMuY3VyclRva2VuO3RoaXMubmV3Tm9kZShuZXcgc2kuZGVmYXVsdCh7dmFsdWU6dGhpcy5jb250ZW50KCksc291cmNlOm90KHIpLHNvdXJjZUluZGV4OnJbUy5GSUVMRFMuU1RBUlRfUE9TXX0pKSx0aGlzLnBvc2l0aW9uKyt9LHQudW5pdmVyc2FsPWZ1bmN0aW9uKHIpe3ZhciBpPXRoaXMubmV4dFRva2VuO2lmKGkmJnRoaXMuY29udGVudChpKT09PVwifFwiKXJldHVybiB0aGlzLnBvc2l0aW9uKyssdGhpcy5uYW1lc3BhY2UoKTt2YXIgYT10aGlzLmN1cnJUb2tlbjt0aGlzLm5ld05vZGUobmV3IHBkLmRlZmF1bHQoe3ZhbHVlOnRoaXMuY29udGVudCgpLHNvdXJjZTpvdChhKSxzb3VyY2VJbmRleDphW1MuRklFTERTLlNUQVJUX1BPU119KSxyKSx0aGlzLnBvc2l0aW9uKyt9LHQuc3BsaXRXb3JkPWZ1bmN0aW9uKHIsaSl7Zm9yKHZhciBhPXRoaXMsbz10aGlzLm5leHRUb2tlbixzPXRoaXMuY29udGVudCgpO28mJn5bVC5kb2xsYXIsVC5jYXJldCxULmVxdWFscyxULndvcmRdLmluZGV4T2Yob1tTLkZJRUxEUy5UWVBFXSk7KXt0aGlzLnBvc2l0aW9uKys7dmFyIHU9dGhpcy5jb250ZW50KCk7aWYocys9dSx1Lmxhc3RJbmRleE9mKFwiXFxcXFwiKT09PXUubGVuZ3RoLTEpe3ZhciBsPXRoaXMubmV4dFRva2VuO2wmJmxbUy5GSUVMRFMuVFlQRV09PT1ULnNwYWNlJiYocys9dGhpcy5yZXF1aXJlZFNwYWNlKHRoaXMuY29udGVudChsKSksdGhpcy5wb3NpdGlvbisrKX1vPXRoaXMubmV4dFRva2VufXZhciBmPWNpKHMsXCIuXCIpLmZpbHRlcihmdW5jdGlvbihkKXt2YXIgaD1zW2QtMV09PT1cIlxcXFxcIix3PS9eXFxkK1xcLlxcZCslJC8udGVzdChzKTtyZXR1cm4haCYmIXd9KSxwPWNpKHMsXCIjXCIpLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gc1tkLTFdIT09XCJcXFxcXCJ9KSxnPWNpKHMsXCIje1wiKTtnLmxlbmd0aCYmKHA9cC5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuIX5nLmluZGV4T2YoZCl9KSk7dmFyIG09KDAsbWQuZGVmYXVsdCkoeWQoWzBdLmNvbmNhdChmLHApKSk7bS5mb3JFYWNoKGZ1bmN0aW9uKGQsaCl7dmFyIHc9bVtoKzFdfHxzLmxlbmd0aCxiPXMuc2xpY2UoZCx3KTtpZihoPT09MCYmaSlyZXR1cm4gaS5jYWxsKGEsYixtLmxlbmd0aCk7dmFyIF8sRT1hLmN1cnJUb2tlbixBPUVbUy5GSUVMRFMuU1RBUlRfUE9TXSttW2hdLEQ9UWUoRVsxXSxFWzJdK2QsRVszXSxFWzJdKyh3LTEpKTtpZih+Zi5pbmRleE9mKGQpKXt2YXIgTT17dmFsdWU6Yi5zbGljZSgxKSxzb3VyY2U6RCxzb3VyY2VJbmRleDpBfTtfPW5ldyBsZC5kZWZhdWx0KGF0KE0sXCJ2YWx1ZVwiKSl9ZWxzZSBpZih+cC5pbmRleE9mKGQpKXt2YXIgTD17dmFsdWU6Yi5zbGljZSgxKSxzb3VyY2U6RCxzb3VyY2VJbmRleDpBfTtfPW5ldyBmZC5kZWZhdWx0KGF0KEwsXCJ2YWx1ZVwiKSl9ZWxzZXt2YXIgRj17dmFsdWU6Yixzb3VyY2U6RCxzb3VyY2VJbmRleDpBfTthdChGLFwidmFsdWVcIiksXz1uZXcgY2QuZGVmYXVsdChGKX1hLm5ld05vZGUoXyxyKSxyPW51bGx9KSx0aGlzLnBvc2l0aW9uKyt9LHQud29yZD1mdW5jdGlvbihyKXt2YXIgaT10aGlzLm5leHRUb2tlbjtyZXR1cm4gaSYmdGhpcy5jb250ZW50KGkpPT09XCJ8XCI/KHRoaXMucG9zaXRpb24rKyx0aGlzLm5hbWVzcGFjZSgpKTp0aGlzLnNwbGl0V29yZChyKX0sdC5sb29wPWZ1bmN0aW9uKCl7Zm9yKDt0aGlzLnBvc2l0aW9uPHRoaXMudG9rZW5zLmxlbmd0aDspdGhpcy5wYXJzZSghMCk7cmV0dXJuIHRoaXMuY3VycmVudC5faW5mZXJFbmRQb3NpdGlvbigpLHRoaXMucm9vdH0sdC5wYXJzZT1mdW5jdGlvbihyKXtzd2l0Y2godGhpcy5jdXJyVG9rZW5bUy5GSUVMRFMuVFlQRV0pe2Nhc2UgVC5zcGFjZTp0aGlzLnNwYWNlKCk7YnJlYWs7Y2FzZSBULmNvbW1lbnQ6dGhpcy5jb21tZW50KCk7YnJlYWs7Y2FzZSBULm9wZW5QYXJlbnRoZXNpczp0aGlzLnBhcmVudGhlc2VzKCk7YnJlYWs7Y2FzZSBULmNsb3NlUGFyZW50aGVzaXM6ciYmdGhpcy5taXNzaW5nUGFyZW50aGVzaXMoKTticmVhaztjYXNlIFQub3BlblNxdWFyZTp0aGlzLmF0dHJpYnV0ZSgpO2JyZWFrO2Nhc2UgVC5kb2xsYXI6Y2FzZSBULmNhcmV0OmNhc2UgVC5lcXVhbHM6Y2FzZSBULndvcmQ6dGhpcy53b3JkKCk7YnJlYWs7Y2FzZSBULmNvbG9uOnRoaXMucHNldWRvKCk7YnJlYWs7Y2FzZSBULmNvbW1hOnRoaXMuY29tbWEoKTticmVhaztjYXNlIFQuYXN0ZXJpc2s6dGhpcy51bml2ZXJzYWwoKTticmVhaztjYXNlIFQuYW1wZXJzYW5kOnRoaXMubmVzdGluZygpO2JyZWFrO2Nhc2UgVC5zbGFzaDpjYXNlIFQuY29tYmluYXRvcjp0aGlzLmNvbWJpbmF0b3IoKTticmVhaztjYXNlIFQuc3RyOnRoaXMuc3RyaW5nKCk7YnJlYWs7Y2FzZSBULmNsb3NlU3F1YXJlOnRoaXMubWlzc2luZ1NxdWFyZUJyYWNrZXQoKTtjYXNlIFQuc2VtaWNvbG9uOnRoaXMubWlzc2luZ0JhY2tzbGFzaCgpO2RlZmF1bHQ6dGhpcy51bmV4cGVjdGVkKCl9fSx0LmV4cGVjdGVkPWZ1bmN0aW9uKHIsaSxhKXtpZihBcnJheS5pc0FycmF5KHIpKXt2YXIgbz1yLnBvcCgpO3I9ci5qb2luKFwiLCBcIikrXCIgb3IgXCIrb312YXIgcz0vXlthZWlvdV0vLnRlc3QoclswXSk/XCJhblwiOlwiYVwiO3JldHVybiBhP3RoaXMuZXJyb3IoXCJFeHBlY3RlZCBcIitzK1wiIFwiK3IrJywgZm91bmQgXCInK2ErJ1wiIGluc3RlYWQuJyx7aW5kZXg6aX0pOnRoaXMuZXJyb3IoXCJFeHBlY3RlZCBcIitzK1wiIFwiK3IrXCIuXCIse2luZGV4Oml9KX0sdC5yZXF1aXJlZFNwYWNlPWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLm9wdGlvbnMubG9zc3k/XCIgXCI6cn0sdC5vcHRpb25hbFNwYWNlPWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLm9wdGlvbnMubG9zc3k/XCJcIjpyfSx0Lmxvc3N5U3BhY2U9ZnVuY3Rpb24ocixpKXtyZXR1cm4gdGhpcy5vcHRpb25zLmxvc3N5P2k/XCIgXCI6XCJcIjpyfSx0LnBhcnNlUGFyZW50aGVzaXNUb2tlbj1mdW5jdGlvbihyKXt2YXIgaT10aGlzLmNvbnRlbnQocik7cmV0dXJuIHJbUy5GSUVMRFMuVFlQRV09PT1ULnNwYWNlP3RoaXMucmVxdWlyZWRTcGFjZShpKTppfSx0Lm5ld05vZGU9ZnVuY3Rpb24ocixpKXtyZXR1cm4gaSYmKC9eICskLy50ZXN0KGkpJiYodGhpcy5vcHRpb25zLmxvc3N5fHwodGhpcy5zcGFjZXM9KHRoaXMuc3BhY2VzfHxcIlwiKStpKSxpPSEwKSxyLm5hbWVzcGFjZT1pLGF0KHIsXCJuYW1lc3BhY2VcIikpLHRoaXMuc3BhY2VzJiYoci5zcGFjZXMuYmVmb3JlPXRoaXMuc3BhY2VzLHRoaXMuc3BhY2VzPVwiXCIpLHRoaXMuY3VycmVudC5hcHBlbmQocil9LHQuY29udGVudD1mdW5jdGlvbihyKXtyZXR1cm4gcj09PXZvaWQgMCYmKHI9dGhpcy5jdXJyVG9rZW4pLHRoaXMuY3NzLnNsaWNlKHJbUy5GSUVMRFMuU1RBUlRfUE9TXSxyW1MuRklFTERTLkVORF9QT1NdKX0sdC5sb2NhdGVOZXh0TWVhbmluZ2Z1bFRva2VuPWZ1bmN0aW9uKHIpe3I9PT12b2lkIDAmJihyPXRoaXMucG9zaXRpb24rMSk7Zm9yKHZhciBpPXI7aTx0aGlzLnRva2Vucy5sZW5ndGg7KWlmKGJkW3RoaXMudG9rZW5zW2ldW1MuRklFTERTLlRZUEVdXSl7aSsrO2NvbnRpbnVlfWVsc2UgcmV0dXJuIGk7cmV0dXJuLTF9LHZkKGUsW3trZXk6XCJjdXJyVG9rZW5cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbl19fSx7a2V5OlwibmV4dFRva2VuXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24rMV19fSx7a2V5OlwicHJldlRva2VuXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24tMV19fV0pLGV9KCk7JHQuZGVmYXVsdD14ZDtCYS5leHBvcnRzPSR0LmRlZmF1bHR9KTt2YXIgR2E9UigocXQsemEpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO3F0Ll9fZXNNb2R1bGU9ITA7cXQuZGVmYXVsdD12b2lkIDA7dmFyIHdkPV9kKFVhKCkpO2Z1bmN0aW9uIF9kKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX12YXIgU2Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4scil7dGhpcy5mdW5jPW58fGZ1bmN0aW9uKCl7fSx0aGlzLmZ1bmNSZXM9bnVsbCx0aGlzLm9wdGlvbnM9cn12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5fc2hvdWxkVXBkYXRlU2VsZWN0b3I9ZnVuY3Rpb24ocixpKXtpPT09dm9pZCAwJiYoaT17fSk7dmFyIGE9T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMsaSk7cmV0dXJuIGEudXBkYXRlU2VsZWN0b3I9PT0hMT8hMTp0eXBlb2YgciE9XCJzdHJpbmdcIn0sdC5faXNMb3NzeT1mdW5jdGlvbihyKXtyPT09dm9pZCAwJiYocj17fSk7dmFyIGk9T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMscik7cmV0dXJuIGkubG9zc2xlc3M9PT0hMX0sdC5fcm9vdD1mdW5jdGlvbihyLGkpe2k9PT12b2lkIDAmJihpPXt9KTt2YXIgYT1uZXcgd2QuZGVmYXVsdChyLHRoaXMuX3BhcnNlT3B0aW9ucyhpKSk7cmV0dXJuIGEucm9vdH0sdC5fcGFyc2VPcHRpb25zPWZ1bmN0aW9uKHIpe3JldHVybntsb3NzeTp0aGlzLl9pc0xvc3N5KHIpfX0sdC5fcnVuPWZ1bmN0aW9uKHIsaSl7dmFyIGE9dGhpcztyZXR1cm4gaT09PXZvaWQgMCYmKGk9e30pLG5ldyBQcm9taXNlKGZ1bmN0aW9uKG8scyl7dHJ5e3ZhciB1PWEuX3Jvb3QocixpKTtQcm9taXNlLnJlc29sdmUoYS5mdW5jKHUpKS50aGVuKGZ1bmN0aW9uKGwpe3ZhciBmPXZvaWQgMDtyZXR1cm4gYS5fc2hvdWxkVXBkYXRlU2VsZWN0b3IocixpKSYmKGY9dS50b1N0cmluZygpLHIuc2VsZWN0b3I9Zikse3RyYW5zZm9ybTpsLHJvb3Q6dSxzdHJpbmc6Zn19KS50aGVuKG8scyl9Y2F0Y2gobCl7cyhsKTtyZXR1cm59fSl9LHQuX3J1blN5bmM9ZnVuY3Rpb24ocixpKXtpPT09dm9pZCAwJiYoaT17fSk7dmFyIGE9dGhpcy5fcm9vdChyLGkpLG89dGhpcy5mdW5jKGEpO2lmKG8mJnR5cGVvZiBvLnRoZW49PVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvciBwcm9jZXNzb3IgcmV0dXJuZWQgYSBwcm9taXNlIHRvIGEgc3luY2hyb25vdXMgY2FsbC5cIik7dmFyIHM9dm9pZCAwO3JldHVybiBpLnVwZGF0ZVNlbGVjdG9yJiZ0eXBlb2YgciE9XCJzdHJpbmdcIiYmKHM9YS50b1N0cmluZygpLHIuc2VsZWN0b3I9cykse3RyYW5zZm9ybTpvLHJvb3Q6YSxzdHJpbmc6c319LHQuYXN0PWZ1bmN0aW9uKHIsaSl7cmV0dXJuIHRoaXMuX3J1bihyLGkpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEucm9vdH0pfSx0LmFzdFN5bmM9ZnVuY3Rpb24ocixpKXtyZXR1cm4gdGhpcy5fcnVuU3luYyhyLGkpLnJvb3R9LHQudHJhbnNmb3JtPWZ1bmN0aW9uKHIsaSl7cmV0dXJuIHRoaXMuX3J1bihyLGkpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEudHJhbnNmb3JtfSl9LHQudHJhbnNmb3JtU3luYz1mdW5jdGlvbihyLGkpe3JldHVybiB0aGlzLl9ydW5TeW5jKHIsaSkudHJhbnNmb3JtfSx0LnByb2Nlc3M9ZnVuY3Rpb24ocixpKXtyZXR1cm4gdGhpcy5fcnVuKHIsaSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS5zdHJpbmd8fGEucm9vdC50b1N0cmluZygpfSl9LHQucHJvY2Vzc1N5bmM9ZnVuY3Rpb24ocixpKXt2YXIgYT10aGlzLl9ydW5TeW5jKHIsaSk7cmV0dXJuIGEuc3RyaW5nfHxhLnJvb3QudG9TdHJpbmcoKX0sZX0oKTtxdC5kZWZhdWx0PVNkO3phLmV4cG9ydHM9cXQuZGVmYXVsdH0pO3ZhciBqYT1SKFY9PntcInVzZSBzdHJpY3RcIjtjKCk7Vi5fX2VzTW9kdWxlPSEwO1YudW5pdmVyc2FsPVYudGFnPVYuc3RyaW5nPVYuc2VsZWN0b3I9Vi5yb290PVYucHNldWRvPVYubmVzdGluZz1WLmlkPVYuY29tbWVudD1WLmNvbWJpbmF0b3I9Vi5jbGFzc05hbWU9Vi5hdHRyaWJ1dGU9dm9pZCAwO3ZhciBrZD15ZShKbigpKSxUZD15ZShEbigpKSxFZD15ZSh0aSgpKSxPZD15ZShNbigpKSxQZD15ZShXbigpKSxBZD15ZShuaSgpKSxJZD15ZShqbigpKSxSZD15ZShBbigpKSxMZD15ZShSbigpKSxDZD15ZSh6bigpKSxEZD15ZShCbigpKSxGZD15ZShabigpKTtmdW5jdGlvbiB5ZShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIE1kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcga2QuZGVmYXVsdCh0KX07Vi5hdHRyaWJ1dGU9TWQ7dmFyIE5kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVGQuZGVmYXVsdCh0KX07Vi5jbGFzc05hbWU9TmQ7dmFyIFdkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgRWQuZGVmYXVsdCh0KX07Vi5jb21iaW5hdG9yPVdkO3ZhciAkZD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IE9kLmRlZmF1bHQodCl9O1YuY29tbWVudD0kZDt2YXIgcWQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBQZC5kZWZhdWx0KHQpfTtWLmlkPXFkO3ZhciBCZD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IEFkLmRlZmF1bHQodCl9O1YubmVzdGluZz1CZDt2YXIgVWQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBJZC5kZWZhdWx0KHQpfTtWLnBzZXVkbz1VZDt2YXIgemQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBSZC5kZWZhdWx0KHQpfTtWLnJvb3Q9emQ7dmFyIEdkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTGQuZGVmYXVsdCh0KX07Vi5zZWxlY3Rvcj1HZDt2YXIgamQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBDZC5kZWZhdWx0KHQpfTtWLnN0cmluZz1qZDt2YXIgVmQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBEZC5kZWZhdWx0KHQpfTtWLnRhZz1WZDt2YXIgSGQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBGZC5kZWZhdWx0KHQpfTtWLnVuaXZlcnNhbD1IZH0pO3ZhciBYYT1SKFc9PntcInVzZSBzdHJpY3RcIjtjKCk7Vy5fX2VzTW9kdWxlPSEwO1cuaXNOb2RlPXBpO1cuaXNQc2V1ZG9FbGVtZW50PVlhO1cuaXNQc2V1ZG9DbGFzcz1pcDtXLmlzQ29udGFpbmVyPW9wO1cuaXNOYW1lc3BhY2U9YXA7Vy5pc1VuaXZlcnNhbD1XLmlzVGFnPVcuaXNTdHJpbmc9Vy5pc1NlbGVjdG9yPVcuaXNSb290PVcuaXNQc2V1ZG89Vy5pc05lc3Rpbmc9Vy5pc0lkZW50aWZpZXI9Vy5pc0NvbW1lbnQ9Vy5pc0NvbWJpbmF0b3I9Vy5pc0NsYXNzTmFtZT1XLmlzQXR0cmlidXRlPXZvaWQgMDt2YXIgSj1uZSgpLGxlLFlkPShsZT17fSxsZVtKLkFUVFJJQlVURV09ITAsbGVbSi5DTEFTU109ITAsbGVbSi5DT01CSU5BVE9SXT0hMCxsZVtKLkNPTU1FTlRdPSEwLGxlW0ouSURdPSEwLGxlW0ouTkVTVElOR109ITAsbGVbSi5QU0VVRE9dPSEwLGxlW0ouUk9PVF09ITAsbGVbSi5TRUxFQ1RPUl09ITAsbGVbSi5TVFJJTkddPSEwLGxlW0ouVEFHXT0hMCxsZVtKLlVOSVZFUlNBTF09ITAsbGUpO2Z1bmN0aW9uIHBpKGUpe3JldHVybiB0eXBlb2YgZT09XCJvYmplY3RcIiYmWWRbZS50eXBlXX1mdW5jdGlvbiB4ZShlLHQpe3JldHVybiBwaSh0KSYmdC50eXBlPT09ZX12YXIgVmE9eGUuYmluZChudWxsLEouQVRUUklCVVRFKTtXLmlzQXR0cmlidXRlPVZhO3ZhciBYZD14ZS5iaW5kKG51bGwsSi5DTEFTUyk7Vy5pc0NsYXNzTmFtZT1YZDt2YXIgUWQ9eGUuYmluZChudWxsLEouQ09NQklOQVRPUik7Vy5pc0NvbWJpbmF0b3I9UWQ7dmFyIEpkPXhlLmJpbmQobnVsbCxKLkNPTU1FTlQpO1cuaXNDb21tZW50PUpkO3ZhciBLZD14ZS5iaW5kKG51bGwsSi5JRCk7Vy5pc0lkZW50aWZpZXI9S2Q7dmFyIFpkPXhlLmJpbmQobnVsbCxKLk5FU1RJTkcpO1cuaXNOZXN0aW5nPVpkO3ZhciBoaT14ZS5iaW5kKG51bGwsSi5QU0VVRE8pO1cuaXNQc2V1ZG89aGk7dmFyIGVwPXhlLmJpbmQobnVsbCxKLlJPT1QpO1cuaXNSb290PWVwO3ZhciB0cD14ZS5iaW5kKG51bGwsSi5TRUxFQ1RPUik7Vy5pc1NlbGVjdG9yPXRwO3ZhciBycD14ZS5iaW5kKG51bGwsSi5TVFJJTkcpO1cuaXNTdHJpbmc9cnA7dmFyIEhhPXhlLmJpbmQobnVsbCxKLlRBRyk7Vy5pc1RhZz1IYTt2YXIgbnA9eGUuYmluZChudWxsLEouVU5JVkVSU0FMKTtXLmlzVW5pdmVyc2FsPW5wO2Z1bmN0aW9uIFlhKGUpe3JldHVybiBoaShlKSYmZS52YWx1ZSYmKGUudmFsdWUuc3RhcnRzV2l0aChcIjo6XCIpfHxlLnZhbHVlLnRvTG93ZXJDYXNlKCk9PT1cIjpiZWZvcmVcInx8ZS52YWx1ZS50b0xvd2VyQ2FzZSgpPT09XCI6YWZ0ZXJcInx8ZS52YWx1ZS50b0xvd2VyQ2FzZSgpPT09XCI6Zmlyc3QtbGV0dGVyXCJ8fGUudmFsdWUudG9Mb3dlckNhc2UoKT09PVwiOmZpcnN0LWxpbmVcIil9ZnVuY3Rpb24gaXAoZSl7cmV0dXJuIGhpKGUpJiYhWWEoZSl9ZnVuY3Rpb24gb3AoZSl7cmV0dXJuISEocGkoZSkmJmUud2Fsayl9ZnVuY3Rpb24gYXAoZSl7cmV0dXJuIFZhKGUpfHxIYShlKX19KTt2YXIgUWE9UihrZT0+e1widXNlIHN0cmljdFwiO2MoKTtrZS5fX2VzTW9kdWxlPSEwO3ZhciBtaT1uZSgpO09iamVjdC5rZXlzKG1pKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2U9PT1cImRlZmF1bHRcInx8ZT09PVwiX19lc01vZHVsZVwifHxlIGluIGtlJiZrZVtlXT09PW1pW2VdfHwoa2VbZV09bWlbZV0pfSk7dmFyIGdpPWphKCk7T2JqZWN0LmtleXMoZ2kpLmZvckVhY2goZnVuY3Rpb24oZSl7ZT09PVwiZGVmYXVsdFwifHxlPT09XCJfX2VzTW9kdWxlXCJ8fGUgaW4ga2UmJmtlW2VdPT09Z2lbZV18fChrZVtlXT1naVtlXSl9KTt2YXIgdmk9WGEoKTtPYmplY3Qua2V5cyh2aSkuZm9yRWFjaChmdW5jdGlvbihlKXtlPT09XCJkZWZhdWx0XCJ8fGU9PT1cIl9fZXNNb2R1bGVcInx8ZSBpbiBrZSYma2VbZV09PT12aVtlXXx8KGtlW2VdPXZpW2VdKX0pfSk7dmFyIFphPVIoKEJ0LEthKT0+e1widXNlIHN0cmljdFwiO2MoKTtCdC5fX2VzTW9kdWxlPSEwO0J0LmRlZmF1bHQ9dm9pZCAwO3ZhciBzcD1mcChHYSgpKSx1cD1scChRYSgpKTtmdW5jdGlvbiBKYSgpe2lmKHR5cGVvZiBXZWFrTWFwIT1cImZ1bmN0aW9uXCIpcmV0dXJuIG51bGw7dmFyIGU9bmV3IFdlYWtNYXA7cmV0dXJuIEphPWZ1bmN0aW9uKCl7cmV0dXJuIGV9LGV9ZnVuY3Rpb24gbHAoZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO2lmKGU9PT1udWxsfHx0eXBlb2YgZSE9XCJvYmplY3RcIiYmdHlwZW9mIGUhPVwiZnVuY3Rpb25cIilyZXR1cm57ZGVmYXVsdDplfTt2YXIgdD1KYSgpO2lmKHQmJnQuaGFzKGUpKXJldHVybiB0LmdldChlKTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIGkgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxpKSl7dmFyIGE9cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsaSk6bnVsbDthJiYoYS5nZXR8fGEuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixpLGEpOm5baV09ZVtpXX1yZXR1cm4gbi5kZWZhdWx0PWUsdCYmdC5zZXQoZSxuKSxufWZ1bmN0aW9uIGZwKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX12YXIgYmk9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBzcC5kZWZhdWx0KHQpfTtPYmplY3QuYXNzaWduKGJpLHVwKTtkZWxldGUgYmkuX19lc01vZHVsZTt2YXIgY3A9Ymk7QnQuZGVmYXVsdD1jcDtLYS5leHBvcnRzPUJ0LmRlZmF1bHR9KTt2YXIgZXM9Uih5aT0+e1widXNlIHN0cmljdFwiO2MoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeWksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHlpLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLGdldDooKT0+ZHB9KTtmdW5jdGlvbiBkcChlKXtyZXR1cm4gZS5yZXBsYWNlKC9cXFxcLC9nLFwiXFxcXDJjIFwiKX19KTt2YXIgcnM9UigoY2csdHMpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO3RzLmV4cG9ydHM9e2FsaWNlYmx1ZTpbMjQwLDI0OCwyNTVdLGFudGlxdWV3aGl0ZTpbMjUwLDIzNSwyMTVdLGFxdWE6WzAsMjU1LDI1NV0sYXF1YW1hcmluZTpbMTI3LDI1NSwyMTJdLGF6dXJlOlsyNDAsMjU1LDI1NV0sYmVpZ2U6WzI0NSwyNDUsMjIwXSxiaXNxdWU6WzI1NSwyMjgsMTk2XSxibGFjazpbMCwwLDBdLGJsYW5jaGVkYWxtb25kOlsyNTUsMjM1LDIwNV0sYmx1ZTpbMCwwLDI1NV0sYmx1ZXZpb2xldDpbMTM4LDQzLDIyNl0sYnJvd246WzE2NSw0Miw0Ml0sYnVybHl3b29kOlsyMjIsMTg0LDEzNV0sY2FkZXRibHVlOls5NSwxNTgsMTYwXSxjaGFydHJldXNlOlsxMjcsMjU1LDBdLGNob2NvbGF0ZTpbMjEwLDEwNSwzMF0sY29yYWw6WzI1NSwxMjcsODBdLGNvcm5mbG93ZXJibHVlOlsxMDAsMTQ5LDIzN10sY29ybnNpbGs6WzI1NSwyNDgsMjIwXSxjcmltc29uOlsyMjAsMjAsNjBdLGN5YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRhcmtnb2xkZW5yb2Q6WzE4NCwxMzQsMTFdLGRhcmtncmF5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJrZ3JleTpbMTY5LDE2OSwxNjldLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmtzZWFncmVlbjpbMTQzLDE4OCwxNDNdLGRhcmtzbGF0ZWJsdWU6WzcyLDYxLDEzOV0sZGFya3NsYXRlZ3JheTpbNDcsNzksNzldLGRhcmtzbGF0ZWdyZXk6WzQ3LDc5LDc5XSxkYXJrdHVycXVvaXNlOlswLDIwNiwyMDldLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZGVlcHBpbms6WzI1NSwyMCwxNDddLGRlZXBza3libHVlOlswLDE5MSwyNTVdLGRpbWdyYXk6WzEwNSwxMDUsMTA1XSxkaW1ncmV5OlsxMDUsMTA1LDEwNV0sZG9kZ2VyYmx1ZTpbMzAsMTQ0LDI1NV0sZmlyZWJyaWNrOlsxNzgsMzQsMzRdLGZsb3JhbHdoaXRlOlsyNTUsMjUwLDI0MF0sZm9yZXN0Z3JlZW46WzM0LDEzOSwzNF0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnYWluc2Jvcm86WzIyMCwyMjAsMjIwXSxnaG9zdHdoaXRlOlsyNDgsMjQ4LDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxnb2xkZW5yb2Q6WzIxOCwxNjUsMzJdLGdyYXk6WzEyOCwxMjgsMTI4XSxncmVlbjpbMCwxMjgsMF0sZ3JlZW55ZWxsb3c6WzE3MywyNTUsNDddLGdyZXk6WzEyOCwxMjgsMTI4XSxob25leWRldzpbMjQwLDI1NSwyNDBdLGhvdHBpbms6WzI1NSwxMDUsMTgwXSxpbmRpYW5yZWQ6WzIwNSw5Miw5Ml0saW5kaWdvOls3NSwwLDEzMF0saXZvcnk6WzI1NSwyNTUsMjQwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxhdmVuZGVyOlsyMzAsMjMwLDI1MF0sbGF2ZW5kZXJibHVzaDpbMjU1LDI0MCwyNDVdLGxhd25ncmVlbjpbMTI0LDI1MiwwXSxsZW1vbmNoaWZmb246WzI1NSwyNTAsMjA1XSxsaWdodGJsdWU6WzE3MywyMTYsMjMwXSxsaWdodGNvcmFsOlsyNDAsMTI4LDEyOF0sbGlnaHRjeWFuOlsyMjQsMjU1LDI1NV0sbGlnaHRnb2xkZW5yb2R5ZWxsb3c6WzI1MCwyNTAsMjEwXSxsaWdodGdyYXk6WzIxMSwyMTEsMjExXSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRncmV5OlsyMTEsMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHRzYWxtb246WzI1NSwxNjAsMTIyXSxsaWdodHNlYWdyZWVuOlszMiwxNzgsMTcwXSxsaWdodHNreWJsdWU6WzEzNSwyMDYsMjUwXSxsaWdodHNsYXRlZ3JheTpbMTE5LDEzNiwxNTNdLGxpZ2h0c2xhdGVncmV5OlsxMTksMTM2LDE1M10sbGlnaHRzdGVlbGJsdWU6WzE3NiwxOTYsMjIyXSxsaWdodHllbGxvdzpbMjU1LDI1NSwyMjRdLGxpbWU6WzAsMjU1LDBdLGxpbWVncmVlbjpbNTAsMjA1LDUwXSxsaW5lbjpbMjUwLDI0MCwyMzBdLG1hZ2VudGE6WzI1NSwwLDI1NV0sbWFyb29uOlsxMjgsMCwwXSxtZWRpdW1hcXVhbWFyaW5lOlsxMDIsMjA1LDE3MF0sbWVkaXVtYmx1ZTpbMCwwLDIwNV0sbWVkaXVtb3JjaGlkOlsxODYsODUsMjExXSxtZWRpdW1wdXJwbGU6WzE0NywxMTIsMjE5XSxtZWRpdW1zZWFncmVlbjpbNjAsMTc5LDExM10sbWVkaXVtc2xhdGVibHVlOlsxMjMsMTA0LDIzOF0sbWVkaXVtc3ByaW5nZ3JlZW46WzAsMjUwLDE1NF0sbWVkaXVtdHVycXVvaXNlOls3MiwyMDksMjA0XSxtZWRpdW12aW9sZXRyZWQ6WzE5OSwyMSwxMzNdLG1pZG5pZ2h0Ymx1ZTpbMjUsMjUsMTEyXSxtaW50Y3JlYW06WzI0NSwyNTUsMjUwXSxtaXN0eXJvc2U6WzI1NSwyMjgsMjI1XSxtb2NjYXNpbjpbMjU1LDIyOCwxODFdLG5hdmFqb3doaXRlOlsyNTUsMjIyLDE3M10sbmF2eTpbMCwwLDEyOF0sb2xkbGFjZTpbMjUzLDI0NSwyMzBdLG9saXZlOlsxMjgsMTI4LDBdLG9saXZlZHJhYjpbMTA3LDE0MiwzNV0sb3JhbmdlOlsyNTUsMTY1LDBdLG9yYW5nZXJlZDpbMjU1LDY5LDBdLG9yY2hpZDpbMjE4LDExMiwyMTRdLHBhbGVnb2xkZW5yb2Q6WzIzOCwyMzIsMTcwXSxwYWxlZ3JlZW46WzE1MiwyNTEsMTUyXSxwYWxldHVycXVvaXNlOlsxNzUsMjM4LDIzOF0scGFsZXZpb2xldHJlZDpbMjE5LDExMiwxNDddLHBhcGF5YXdoaXA6WzI1NSwyMzksMjEzXSxwZWFjaHB1ZmY6WzI1NSwyMTgsMTg1XSxwZXJ1OlsyMDUsMTMzLDYzXSxwaW5rOlsyNTUsMTkyLDIwM10scGx1bTpbMjIxLDE2MCwyMjFdLHBvd2RlcmJsdWU6WzE3NiwyMjQsMjMwXSxwdXJwbGU6WzEyOCwwLDEyOF0scmViZWNjYXB1cnBsZTpbMTAyLDUxLDE1M10scmVkOlsyNTUsMCwwXSxyb3N5YnJvd246WzE4OCwxNDMsMTQzXSxyb3lhbGJsdWU6WzY1LDEwNSwyMjVdLHNhZGRsZWJyb3duOlsxMzksNjksMTldLHNhbG1vbjpbMjUwLDEyOCwxMTRdLHNhbmR5YnJvd246WzI0NCwxNjQsOTZdLHNlYWdyZWVuOls0NiwxMzksODddLHNlYXNoZWxsOlsyNTUsMjQ1LDIzOF0sc2llbm5hOlsxNjAsODIsNDVdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHNreWJsdWU6WzEzNSwyMDYsMjM1XSxzbGF0ZWJsdWU6WzEwNiw5MCwyMDVdLHNsYXRlZ3JheTpbMTEyLDEyOCwxNDRdLHNsYXRlZ3JleTpbMTEyLDEyOCwxNDRdLHNub3c6WzI1NSwyNTAsMjUwXSxzcHJpbmdncmVlbjpbMCwyNTUsMTI3XSxzdGVlbGJsdWU6WzcwLDEzMCwxODBdLHRhbjpbMjEwLDE4MCwxNDBdLHRlYWw6WzAsMTI4LDEyOF0sdGhpc3RsZTpbMjE2LDE5MSwyMTZdLHRvbWF0bzpbMjU1LDk5LDcxXSx0dXJxdW9pc2U6WzY0LDIyNCwyMDhdLHZpb2xldDpbMjM4LDEzMCwyMzhdLHdoZWF0OlsyNDUsMjIyLDE3OV0sd2hpdGU6WzI1NSwyNTUsMjU1XSx3aGl0ZXNtb2tlOlsyNDUsMjQ1LDI0NV0seWVsbG93OlsyNTUsMjU1LDBdLHllbGxvd2dyZWVuOlsxNTQsMjA1LDUwXX19KTt2YXIgd2k9Uih4aT0+e1widXNlIHN0cmljdFwiO2MoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeGksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gcHAoZSx0KXtmb3IodmFyIG4gaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOiEwLGdldDp0W25dfSl9cHAoeGkse3BhcnNlQ29sb3I6KCk9PnlwLGZvcm1hdENvbG9yOigpPT54cH0pO3ZhciBucz1ocChycygpKTtmdW5jdGlvbiBocChlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIG1wPS9eIyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSk/JC9pLGdwPS9eIyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSk/JC9pLE5lPS8oPzpcXGQrfFxcZCpcXC5cXGQrKSU/LyxScj0vKD86XFxzKixcXHMqfFxccyspLyxpcz0vXFxzKlssL11cXHMqLyxXZT0vdmFyXFwoLS0oPzpbXiApXSo/KVxcKS8sdnA9bmV3IFJlZ0V4cChgXihyZ2IpYT9cXFxcKFxcXFxzKigke05lLnNvdXJjZX18JHtXZS5zb3VyY2V9KSg/OiR7UnIuc291cmNlfSgke05lLnNvdXJjZX18JHtXZS5zb3VyY2V9KSk/KD86JHtSci5zb3VyY2V9KCR7TmUuc291cmNlfXwke1dlLnNvdXJjZX0pKT8oPzoke2lzLnNvdXJjZX0oJHtOZS5zb3VyY2V9fCR7V2Uuc291cmNlfSkpP1xcXFxzKlxcXFwpJGApLGJwPW5ldyBSZWdFeHAoYF4oaHNsKWE/XFxcXChcXFxccyooKD86JHtOZS5zb3VyY2V9KSg/OmRlZ3xyYWR8Z3JhZHx0dXJuKT98JHtXZS5zb3VyY2V9KSg/OiR7UnIuc291cmNlfSgke05lLnNvdXJjZX18JHtXZS5zb3VyY2V9KSk/KD86JHtSci5zb3VyY2V9KCR7TmUuc291cmNlfXwke1dlLnNvdXJjZX0pKT8oPzoke2lzLnNvdXJjZX0oJHtOZS5zb3VyY2V9fCR7V2Uuc291cmNlfSkpP1xcXFxzKlxcXFwpJGApO2Z1bmN0aW9uIHlwKGUse2xvb3NlOnQ9ITF9PXt9KXt2YXIgbixyO2lmKHR5cGVvZiBlIT1cInN0cmluZ1wiKXJldHVybiBudWxsO2lmKGU9ZS50cmltKCksZT09PVwidHJhbnNwYXJlbnRcIilyZXR1cm57bW9kZTpcInJnYlwiLGNvbG9yOltcIjBcIixcIjBcIixcIjBcIl0sYWxwaGE6XCIwXCJ9O2lmKGUgaW4gbnMuZGVmYXVsdClyZXR1cm57bW9kZTpcInJnYlwiLGNvbG9yOm5zLmRlZmF1bHRbZV0ubWFwKHU9PnUudG9TdHJpbmcoKSl9O2xldCBpPWUucmVwbGFjZShncCwodSxsLGYscCxnKT0+W1wiI1wiLGwsbCxmLGYscCxwLGc/ZytnOlwiXCJdLmpvaW4oXCJcIikpLm1hdGNoKG1wKTtpZihpIT09bnVsbClyZXR1cm57bW9kZTpcInJnYlwiLGNvbG9yOltwYXJzZUludChpWzFdLDE2KSxwYXJzZUludChpWzJdLDE2KSxwYXJzZUludChpWzNdLDE2KV0ubWFwKHU9PnUudG9TdHJpbmcoKSksYWxwaGE6aVs0XT8ocGFyc2VJbnQoaVs0XSwxNikvMjU1KS50b1N0cmluZygpOnZvaWQgMH07dmFyIGE7bGV0IG89KGE9ZS5tYXRjaCh2cCkpIT09bnVsbCYmYSE9PXZvaWQgMD9hOmUubWF0Y2goYnApO2lmKG89PT1udWxsKXJldHVybiBudWxsO2xldCBzPVtvWzJdLG9bM10sb1s0XV0uZmlsdGVyKEJvb2xlYW4pLm1hcCh1PT51LnRvU3RyaW5nKCkpO3JldHVybiF0JiZzLmxlbmd0aCE9PTN8fHMubGVuZ3RoPDMmJiFzLnNvbWUodT0+L152YXJcXCguKj9cXCkkLy50ZXN0KHUpKT9udWxsOnttb2RlOm9bMV0sY29sb3I6cyxhbHBoYToobj1vWzVdKT09PW51bGx8fG49PT12b2lkIDB8fChyPW4udG9TdHJpbmcpPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6ci5jYWxsKG4pfX1mdW5jdGlvbiB4cCh7bW9kZTplLGNvbG9yOnQsYWxwaGE6bn0pe2xldCByPW4hPT12b2lkIDA7cmV0dXJuYCR7ZX0oJHt0LmpvaW4oXCIgXCIpfSR7cj9gIC8gJHtufWA6XCJcIn0pYH19KTt2YXIgU2k9UihfaT0+e1widXNlIHN0cmljdFwiO2MoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoX2ksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gd3AoZSx0KXtmb3IodmFyIG4gaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOiEwLGdldDp0W25dfSl9d3AoX2kse3dpdGhBbHBoYVZhbHVlOigpPT5fcCxkZWZhdWx0OigpPT5TcH0pO3ZhciBMcj13aSgpO2Z1bmN0aW9uIF9wKGUsdCxuKXtpZih0eXBlb2YgZT09XCJmdW5jdGlvblwiKXJldHVybiBlKHtvcGFjaXR5VmFsdWU6dH0pO2xldCByPSgwLExyLnBhcnNlQ29sb3IpKGUse2xvb3NlOiEwfSk7cmV0dXJuIHI9PT1udWxsP246KDAsTHIuZm9ybWF0Q29sb3IpKHsuLi5yLGFscGhhOnR9KX1mdW5jdGlvbiBTcCh7Y29sb3I6ZSxwcm9wZXJ0eTp0LHZhcmlhYmxlOm59KXtsZXQgcj1bXS5jb25jYXQodCk7aWYodHlwZW9mIGU9PVwiZnVuY3Rpb25cIilyZXR1cm57W25dOlwiMVwiLC4uLk9iamVjdC5mcm9tRW50cmllcyhyLm1hcChhPT5bYSxlKHtvcGFjaXR5VmFyaWFibGU6bixvcGFjaXR5VmFsdWU6YHZhcigke259KWB9KV0pKX07bGV0IGk9KDAsTHIucGFyc2VDb2xvcikoZSk7cmV0dXJuIGk9PT1udWxsP09iamVjdC5mcm9tRW50cmllcyhyLm1hcChhPT5bYSxlXSkpOmkuYWxwaGEhPT12b2lkIDA/T2JqZWN0LmZyb21FbnRyaWVzKHIubWFwKGE9PlthLGVdKSk6e1tuXTpcIjFcIiwuLi5PYmplY3QuZnJvbUVudHJpZXMoci5tYXAoYT0+W2EsKDAsTHIuZm9ybWF0Q29sb3IpKHsuLi5pLGFscGhhOmB2YXIoJHtufSlgfSldKSl9fX0pO3ZhciBscz1SKGtpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShraSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtmdW5jdGlvbiBrcChlLHQpe2Zvcih2YXIgbiBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6ITAsZ2V0OnRbbl19KX1rcChraSx7cGF0dGVybjooKT0+RXAsd2l0aG91dENhcHR1cmluZzooKT0+YXMsYW55OigpPT5zcyxvcHRpb25hbDooKT0+T3AsemVyb09yTW9yZTooKT0+UHAsbmVzdGVkQnJhY2tldHM6KCk9PnVzLGVzY2FwZTooKT0+SmV9KTt2YXIgb3M9L1tcXFxcXiQuKis/KClbXFxde318XS9nLFRwPVJlZ0V4cChvcy5zb3VyY2UpO2Z1bmN0aW9uIFV0KGUpe3JldHVybiBlPUFycmF5LmlzQXJyYXkoZSk/ZTpbZV0sZT1lLm1hcCh0PT50IGluc3RhbmNlb2YgUmVnRXhwP3Quc291cmNlOnQpLGUuam9pbihcIlwiKX1mdW5jdGlvbiBFcChlKXtyZXR1cm4gbmV3IFJlZ0V4cChVdChlKSxcImdcIil9ZnVuY3Rpb24gYXMoZSl7cmV0dXJuIG5ldyBSZWdFeHAoYCg/OiR7VXQoZSl9KWAsXCJnXCIpfWZ1bmN0aW9uIHNzKGUpe3JldHVybmAoPzoke2UubWFwKFV0KS5qb2luKFwifFwiKX0pYH1mdW5jdGlvbiBPcChlKXtyZXR1cm5gKD86JHtVdChlKX0pP2B9ZnVuY3Rpb24gUHAoZSl7cmV0dXJuYCg/OiR7VXQoZSl9KSpgfWZ1bmN0aW9uIHVzKGUsdCxuPTEpe3JldHVybiBhcyhbSmUoZSksL1teXFxzXSovLG49PT0xP2BbXiR7SmUoZSl9JHtKZSh0KX1zXSpgOnNzKFtgW14ke0plKGUpfSR7SmUodCl9c10qYCx1cyhlLHQsbi0xKV0pLC9bXlxcc10qLyxKZSh0KV0pfWZ1bmN0aW9uIEplKGUpe3JldHVybiBlJiZUcC50ZXN0KGUpP2UucmVwbGFjZShvcyxcIlxcXFwkJlwiKTplfHxcIlwifX0pO3ZhciBjcz1SKFRpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShUaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoVGksXCJzcGxpdEF0VG9wTGV2ZWxPbmx5XCIse2VudW1lcmFibGU6ITAsZ2V0OigpPT5ScH0pO3ZhciBBcD1JcChscygpKTtmdW5jdGlvbiBmcyhlKXtpZih0eXBlb2YgV2Vha01hcCE9XCJmdW5jdGlvblwiKXJldHVybiBudWxsO3ZhciB0PW5ldyBXZWFrTWFwLG49bmV3IFdlYWtNYXA7cmV0dXJuKGZzPWZ1bmN0aW9uKHIpe3JldHVybiByP246dH0pKGUpfWZ1bmN0aW9uIElwKGUsdCl7aWYoIXQmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTtpZihlPT09bnVsbHx8dHlwZW9mIGUhPVwib2JqZWN0XCImJnR5cGVvZiBlIT1cImZ1bmN0aW9uXCIpcmV0dXJue2RlZmF1bHQ6ZX07dmFyIG49ZnModCk7aWYobiYmbi5oYXMoZSkpcmV0dXJuIG4uZ2V0KGUpO3ZhciByPXt9LGk9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIgYSBpbiBlKWlmKGEhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYSkpe3ZhciBvPWk/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLGEpOm51bGw7byYmKG8uZ2V0fHxvLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsYSxvKTpyW2FdPWVbYV19cmV0dXJuIHIuZGVmYXVsdD1lLG4mJm4uc2V0KGUscikscn1mdW5jdGlvbipScChlLHQpe2xldCBuPW5ldyBSZWdFeHAoYFsoKXt9XFxcXFtcXFxcXSR7QXAuZXNjYXBlKHQpfV1gLFwiZ1wiKSxyPTAsaT0wLGE9ITEsbz0wLHM9MCx1PXQubGVuZ3RoO2ZvcihsZXQgbCBvZiBlLm1hdGNoQWxsKG4pKXtsZXQgZj1sWzBdPT09dFtvXSxwPW89PT11LTEsZz1mJiZwO2xbMF09PT1cIihcIiYmcisrLGxbMF09PT1cIilcIiYmci0tLGxbMF09PT1cIltcIiYmcisrLGxbMF09PT1cIl1cIiYmci0tLGxbMF09PT1cIntcIiYmcisrLGxbMF09PT1cIn1cIiYmci0tLGYmJnI9PT0wJiYocz09PTAmJihzPWwuaW5kZXgpLG8rKyksZyYmcj09PTAmJihhPSEwLHlpZWxkIGUuc3Vic3RyaW5nKGkscyksaT1zK3UpLG89PT11JiYobz0wLHM9MCl9YT95aWVsZCBlLnN1YnN0cmluZyhpKTp5aWVsZCBlfX0pO3ZhciBwcz1SKEVpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtmdW5jdGlvbiBMcChlLHQpe2Zvcih2YXIgbiBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6ITAsZ2V0OnRbbl19KX1McChFaSx7cGFyc2VCb3hTaGFkb3dWYWx1ZTooKT0+TXAsZm9ybWF0Qm94U2hhZG93VmFsdWU6KCk9Pk5wfSk7dmFyIENwPWNzKCksRHA9bmV3IFNldChbXCJpbnNldFwiLFwiaW5oZXJpdFwiLFwiaW5pdGlhbFwiLFwicmV2ZXJ0XCIsXCJ1bnNldFwiXSksRnA9L1xcICsoPyFbXihdKlxcKSkvZyxkcz0vXi0/KFxcZCt8XFwuXFxkKykoLio/KSQvZztmdW5jdGlvbiBNcChlKXtyZXR1cm4gQXJyYXkuZnJvbSgoMCxDcC5zcGxpdEF0VG9wTGV2ZWxPbmx5KShlLFwiLFwiKSkubWFwKG49PntsZXQgcj1uLnRyaW0oKSxpPXtyYXc6cn0sYT1yLnNwbGl0KEZwKSxvPW5ldyBTZXQ7Zm9yKGxldCBzIG9mIGEpZHMubGFzdEluZGV4PTAsIW8uaGFzKFwiS0VZV09SRFwiKSYmRHAuaGFzKHMpPyhpLmtleXdvcmQ9cyxvLmFkZChcIktFWVdPUkRcIikpOmRzLnRlc3Qocyk/by5oYXMoXCJYXCIpP28uaGFzKFwiWVwiKT9vLmhhcyhcIkJMVVJcIik/by5oYXMoXCJTUFJFQURcIil8fChpLnNwcmVhZD1zLG8uYWRkKFwiU1BSRUFEXCIpKTooaS5ibHVyPXMsby5hZGQoXCJCTFVSXCIpKTooaS55PXMsby5hZGQoXCJZXCIpKTooaS54PXMsby5hZGQoXCJYXCIpKTppLmNvbG9yPyhpLnVua25vd258fChpLnVua25vd249W10pLGkudW5rbm93bi5wdXNoKHMpKTppLmNvbG9yPXM7cmV0dXJuIGkudmFsaWQ9aS54IT09dm9pZCAwJiZpLnkhPT12b2lkIDAsaX0pfWZ1bmN0aW9uIE5wKGUpe3JldHVybiBlLm1hcCh0PT50LnZhbGlkP1t0LmtleXdvcmQsdC54LHQueSx0LmJsdXIsdC5zcHJlYWQsdC5jb2xvcl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpOnQucmF3KS5qb2luKFwiLCBcIil9fSk7dmFyIHhzPVIoUGk9PntcInVzZSBzdHJpY3RcIjtjKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFBpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2Z1bmN0aW9uIFdwKGUsdCl7Zm9yKHZhciBuIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6dFtuXX0pfVdwKFBpLHtub3JtYWxpemU6KCk9PiRlLHVybDooKT0+Z3MsbnVtYmVyOigpPT5CcCxwZXJjZW50YWdlOigpPT52cyxsZW5ndGg6KCk9PmJzLGxpbmVXaWR0aDooKT0+R3Asc2hhZG93OigpPT5qcCxjb2xvcjooKT0+VnAsaW1hZ2U6KCk9PkhwLGdyYWRpZW50OigpPT55cyxwb3NpdGlvbjooKT0+UXAsZmFtaWx5TmFtZTooKT0+SnAsZ2VuZXJpY05hbWU6KCk9PlpwLGFic29sdXRlU2l6ZTooKT0+dGgscmVsYXRpdmVTaXplOigpPT5uaH0pO3ZhciAkcD13aSgpLHFwPXBzKCksT2k9W1wibWluXCIsXCJtYXhcIixcImNsYW1wXCIsXCJjYWxjXCJdLG1zPS8sKD8hW14oXSpcXCkpL2csQ3I9L18oPyFbXihdKlxcKSkvZztmdW5jdGlvbiAkZShlLHQ9ITApe3JldHVybiBlLmluY2x1ZGVzKFwidXJsKFwiKT9lLnNwbGl0KC8odXJsXFwoLio/XFwpKS9nKS5maWx0ZXIoQm9vbGVhbikubWFwKG49Pi9edXJsXFwoLio/XFwpJC8udGVzdChuKT9uOiRlKG4sITEpKS5qb2luKFwiXCIpOihlPWUucmVwbGFjZSgvKFteXFxcXF0pXysvZywobixyKT0+citcIiBcIi5yZXBlYXQobi5sZW5ndGgtMSkpLnJlcGxhY2UoL15fL2csXCIgXCIpLnJlcGxhY2UoL1xcXFxfL2csXCJfXCIpLHQmJihlPWUudHJpbSgpKSxlPWUucmVwbGFjZSgvKGNhbGN8bWlufG1heHxjbGFtcClcXCguK1xcKS9nLG49Pm4ucmVwbGFjZSgvKC0/XFxkKlxcLj9cXGQoPyFcXGItLitbLCldKD8hW14rXFwtLypdKVxcRCkoPzolfFthLXpdKyk/fFxcKSkoWytcXC0vKl0pL2csXCIkMSAkMiBcIikpLGUpfWZ1bmN0aW9uIGdzKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgoXCJ1cmwoXCIpfWZ1bmN0aW9uIEJwKGUpe3JldHVybiFpc05hTihOdW1iZXIoZSkpfHxPaS5zb21lKHQ9Pm5ldyBSZWdFeHAoYF4ke3R9XFxcXCguKz9gKS50ZXN0KGUpKX1mdW5jdGlvbiB2cyhlKXtyZXR1cm4gZS5zcGxpdChDcikuZXZlcnkodD0+LyUkL2cudGVzdCh0KXx8T2kuc29tZShuPT5uZXcgUmVnRXhwKGBeJHtufVxcXFwoLis/JWApLnRlc3QodCkpKX12YXIgVXA9W1wiY21cIixcIm1tXCIsXCJRXCIsXCJpblwiLFwicGNcIixcInB0XCIsXCJweFwiLFwiZW1cIixcImV4XCIsXCJjaFwiLFwicmVtXCIsXCJsaFwiLFwidndcIixcInZoXCIsXCJ2bWluXCIsXCJ2bWF4XCJdLGhzPWAoPzoke1VwLmpvaW4oXCJ8XCIpfSlgO2Z1bmN0aW9uIGJzKGUpe3JldHVybiBlLnNwbGl0KENyKS5ldmVyeSh0PT50PT09XCIwXCJ8fG5ldyBSZWdFeHAoYCR7aHN9JGApLnRlc3QodCl8fE9pLnNvbWUobj0+bmV3IFJlZ0V4cChgXiR7bn1cXFxcKC4rPyR7aHN9YCkudGVzdCh0KSkpfXZhciB6cD1uZXcgU2V0KFtcInRoaW5cIixcIm1lZGl1bVwiLFwidGhpY2tcIl0pO2Z1bmN0aW9uIEdwKGUpe3JldHVybiB6cC5oYXMoZSl9ZnVuY3Rpb24ganAoZSl7bGV0IHQ9KDAscXAucGFyc2VCb3hTaGFkb3dWYWx1ZSkoJGUoZSkpO2ZvcihsZXQgbiBvZiB0KWlmKCFuLnZhbGlkKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIFZwKGUpe2xldCB0PTA7cmV0dXJuIGUuc3BsaXQoQ3IpLmV2ZXJ5KHI9PihyPSRlKHIpLHIuc3RhcnRzV2l0aChcInZhcihcIik/ITA6KDAsJHAucGFyc2VDb2xvcikocix7bG9vc2U6ITB9KSE9PW51bGw/KHQrKywhMCk6ITEpKT90PjA6ITF9ZnVuY3Rpb24gSHAoZSl7bGV0IHQ9MDtyZXR1cm4gZS5zcGxpdChtcykuZXZlcnkocj0+KHI9JGUociksci5zdGFydHNXaXRoKFwidmFyKFwiKT8hMDpncyhyKXx8eXMocil8fFtcImVsZW1lbnQoXCIsXCJpbWFnZShcIixcImNyb3NzLWZhZGUoXCIsXCJpbWFnZS1zZXQoXCJdLnNvbWUoaT0+ci5zdGFydHNXaXRoKGkpKT8odCsrLCEwKTohMSkpP3Q+MDohMX12YXIgWXA9bmV3IFNldChbXCJsaW5lYXItZ3JhZGllbnRcIixcInJhZGlhbC1ncmFkaWVudFwiLFwicmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudFwiLFwicmVwZWF0aW5nLXJhZGlhbC1ncmFkaWVudFwiLFwiY29uaWMtZ3JhZGllbnRcIl0pO2Z1bmN0aW9uIHlzKGUpe2U9JGUoZSk7Zm9yKGxldCB0IG9mIFlwKWlmKGUuc3RhcnRzV2l0aChgJHt0fShgKSlyZXR1cm4hMDtyZXR1cm4hMX12YXIgWHA9bmV3IFNldChbXCJjZW50ZXJcIixcInRvcFwiLFwicmlnaHRcIixcImJvdHRvbVwiLFwibGVmdFwiXSk7ZnVuY3Rpb24gUXAoZSl7bGV0IHQ9MDtyZXR1cm4gZS5zcGxpdChDcikuZXZlcnkocj0+KHI9JGUociksci5zdGFydHNXaXRoKFwidmFyKFwiKT8hMDpYcC5oYXMocil8fGJzKHIpfHx2cyhyKT8odCsrLCEwKTohMSkpP3Q+MDohMX1mdW5jdGlvbiBKcChlKXtsZXQgdD0wO3JldHVybiBlLnNwbGl0KG1zKS5ldmVyeShyPT4ocj0kZShyKSxyLnN0YXJ0c1dpdGgoXCJ2YXIoXCIpPyEwOnIuaW5jbHVkZXMoXCIgXCIpJiYhLyhbJ1wiXSkoW15cIiddKylcXDEvZy50ZXN0KHIpfHwvXlxcZC9nLnRlc3Qocik/ITE6KHQrKywhMCkpKT90PjA6ITF9dmFyIEtwPW5ldyBTZXQoW1wic2VyaWZcIixcInNhbnMtc2VyaWZcIixcIm1vbm9zcGFjZVwiLFwiY3Vyc2l2ZVwiLFwiZmFudGFzeVwiLFwic3lzdGVtLXVpXCIsXCJ1aS1zZXJpZlwiLFwidWktc2Fucy1zZXJpZlwiLFwidWktbW9ub3NwYWNlXCIsXCJ1aS1yb3VuZGVkXCIsXCJtYXRoXCIsXCJlbW9qaVwiLFwiZmFuZ3NvbmdcIl0pO2Z1bmN0aW9uIFpwKGUpe3JldHVybiBLcC5oYXMoZSl9dmFyIGVoPW5ldyBTZXQoW1wieHgtc21hbGxcIixcIngtc21hbGxcIixcInNtYWxsXCIsXCJtZWRpdW1cIixcImxhcmdlXCIsXCJ4LWxhcmdlXCIsXCJ4LWxhcmdlXCIsXCJ4eHgtbGFyZ2VcIl0pO2Z1bmN0aW9uIHRoKGUpe3JldHVybiBlaC5oYXMoZSl9dmFyIHJoPW5ldyBTZXQoW1wibGFyZ2VyXCIsXCJzbWFsbGVyXCJdKTtmdW5jdGlvbiBuaChlKXtyZXR1cm4gcmguaGFzKGUpfX0pO3ZhciBQcz1SKFJpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShSaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtmdW5jdGlvbiBpaChlLHQpe2Zvcih2YXIgbiBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6ITAsZ2V0OnRbbl19KX1paChSaSx7dXBkYXRlQWxsQ2xhc3NlczooKT0+c2gsYXNWYWx1ZTooKT0+R3QscGFyc2VDb2xvckZvcm1hdDooKT0+QWksYXNDb2xvcjooKT0+VHMsYXNMb29rdXBWYWx1ZTooKT0+RXMsY29lcmNlVmFsdWU6KCk9PmNofSk7dmFyIG9oPUlpKFphKCkpLGFoPUlpKGVzKCkpLHdzPVNpKCksZmU9eHMoKSxfcz1JaShtbigpKTtmdW5jdGlvbiBJaShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gc2goZSx0KXtyZXR1cm4oMCxvaC5kZWZhdWx0KShpPT57aS53YWxrQ2xhc3NlcyhhPT57bGV0IG89dChhLnZhbHVlKTthLnZhbHVlPW8sYS5yYXdzJiZhLnJhd3MudmFsdWUmJihhLnJhd3MudmFsdWU9KDAsYWguZGVmYXVsdCkoYS5yYXdzLnZhbHVlKSl9KX0pLnByb2Nlc3NTeW5jKGUpfWZ1bmN0aW9uIGtzKGUsdCl7aWYoIXp0KGUpKXJldHVybjtsZXQgbj1lLnNsaWNlKDEsLTEpO2lmKCEhdChuKSlyZXR1cm4oMCxmZS5ub3JtYWxpemUpKG4pfWZ1bmN0aW9uIHVoKGUsdD17fSxuKXtsZXQgcj10W2VdO2lmKHIhPT12b2lkIDApcmV0dXJuKDAsX3MuZGVmYXVsdCkocik7aWYoenQoZSkpe2xldCBpPWtzKGUsbik7cmV0dXJuIGk9PT12b2lkIDA/dm9pZCAwOigwLF9zLmRlZmF1bHQpKGkpfX1mdW5jdGlvbiBHdChlLHQ9e30se3ZhbGlkYXRlOm49KCk9PiEwfT17fSl7dmFyIHI7bGV0IGk9KHI9dC52YWx1ZXMpPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6cltlXTtyZXR1cm4gaSE9PXZvaWQgMD9pOnQuc3VwcG9ydHNOZWdhdGl2ZVZhbHVlcyYmZS5zdGFydHNXaXRoKFwiLVwiKT91aChlLnNsaWNlKDEpLHQudmFsdWVzLG4pOmtzKGUsbil9ZnVuY3Rpb24genQoZSl7cmV0dXJuIGUuc3RhcnRzV2l0aChcIltcIikmJmUuZW5kc1dpdGgoXCJdXCIpfWZ1bmN0aW9uIGxoKGUpe2xldCB0PWUubGFzdEluZGV4T2YoXCIvXCIpO3JldHVybiB0PT09LTF8fHQ9PT1lLmxlbmd0aC0xP1tlXTpbZS5zbGljZSgwLHQpLGUuc2xpY2UodCsxKV19ZnVuY3Rpb24gQWkoZSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCImJmUuaW5jbHVkZXMoXCI8YWxwaGEtdmFsdWU+XCIpKXtsZXQgdD1lO3JldHVybih7b3BhY2l0eVZhbHVlOm49MX0pPT50LnJlcGxhY2UoXCI8YWxwaGEtdmFsdWU+XCIsbil9cmV0dXJuIGV9ZnVuY3Rpb24gVHMoZSx0PXt9LHt0YWlsd2luZENvbmZpZzpuPXt9fT17fSl7dmFyIHI7aWYoKChyPXQudmFsdWVzKT09PW51bGx8fHI9PT12b2lkIDA/dm9pZCAwOnJbZV0pIT09dm9pZCAwKXt2YXIgaTtyZXR1cm4gQWkoKGk9dC52YWx1ZXMpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aVtlXSl9bGV0W2Esb109bGgoZSk7aWYobyE9PXZvaWQgMCl7dmFyIHMsdSxsLGY7bGV0IHA9KGY9KHM9dC52YWx1ZXMpPT09bnVsbHx8cz09PXZvaWQgMD92b2lkIDA6c1thXSkhPT1udWxsJiZmIT09dm9pZCAwP2Y6enQoYSk/YS5zbGljZSgxLC0xKTp2b2lkIDA7cmV0dXJuIHA9PT12b2lkIDA/dm9pZCAwOihwPUFpKHApLHp0KG8pPygwLHdzLndpdGhBbHBoYVZhbHVlKShwLG8uc2xpY2UoMSwtMSkpOigodT1uLnRoZW1lKT09PW51bGx8fHU9PT12b2lkIDB8fChsPXUub3BhY2l0eSk9PT1udWxsfHxsPT09dm9pZCAwP3ZvaWQgMDpsW29dKT09PXZvaWQgMD92b2lkIDA6KDAsd3Mud2l0aEFscGhhVmFsdWUpKHAsbi50aGVtZS5vcGFjaXR5W29dKSl9cmV0dXJuIEd0KGUsdCx7dmFsaWRhdGU6ZmUuY29sb3J9KX1mdW5jdGlvbiBFcyhlLHQ9e30pe3ZhciBuO3JldHVybihuPXQudmFsdWVzKT09PW51bGx8fG49PT12b2lkIDA/dm9pZCAwOm5bZV19ZnVuY3Rpb24gd2UoZSl7cmV0dXJuKHQsbik9Pkd0KHQsbix7dmFsaWRhdGU6ZX0pfXZhciBPcz17YW55Okd0LGNvbG9yOlRzLHVybDp3ZShmZS51cmwpLGltYWdlOndlKGZlLmltYWdlKSxsZW5ndGg6d2UoZmUubGVuZ3RoKSxwZXJjZW50YWdlOndlKGZlLnBlcmNlbnRhZ2UpLHBvc2l0aW9uOndlKGZlLnBvc2l0aW9uKSxsb29rdXA6RXMsXCJnZW5lcmljLW5hbWVcIjp3ZShmZS5nZW5lcmljTmFtZSksXCJmYW1pbHktbmFtZVwiOndlKGZlLmZhbWlseU5hbWUpLG51bWJlcjp3ZShmZS5udW1iZXIpLFwibGluZS13aWR0aFwiOndlKGZlLmxpbmVXaWR0aCksXCJhYnNvbHV0ZS1zaXplXCI6d2UoZmUuYWJzb2x1dGVTaXplKSxcInJlbGF0aXZlLXNpemVcIjp3ZShmZS5yZWxhdGl2ZVNpemUpLHNoYWRvdzp3ZShmZS5zaGFkb3cpfSxTcz1PYmplY3Qua2V5cyhPcyk7ZnVuY3Rpb24gZmgoZSx0KXtsZXQgbj1lLmluZGV4T2YodCk7cmV0dXJuIG49PT0tMT9bdm9pZCAwLGVdOltlLnNsaWNlKDAsbiksZS5zbGljZShuKzEpXX1mdW5jdGlvbiBjaChlLHQsbixyKXtpZih6dCh0KSl7bGV0IGk9dC5zbGljZSgxLC0xKSxbYSxvXT1maChpLFwiOlwiKTtpZighL15bXFx3LV9dKyQvZy50ZXN0KGEpKW89aTtlbHNlIGlmKGEhPT12b2lkIDAmJiFTcy5pbmNsdWRlcyhhKSlyZXR1cm5bXTtpZihvLmxlbmd0aD4wJiZTcy5pbmNsdWRlcyhhKSlyZXR1cm5bR3QoYFske299XWAsbiksYV19Zm9yKGxldCBpIG9mW10uY29uY2F0KGUpKXtsZXQgYT1Pc1tpXSh0LG4se3RhaWx3aW5kQ29uZmlnOnJ9KTtpZihhIT09dm9pZCAwKXJldHVyblthLGldfXJldHVybltdfX0pO3ZhciBBcz1SKExpPT57XCJ1c2Ugc3RyaWN0XCI7YygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShMaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTGksXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsZ2V0OigpPT5kaH0pO2Z1bmN0aW9uIGRoKGUpe3JldHVybiB0eXBlb2YgZT09XCJmdW5jdGlvblwiP2Uoe30pOmV9fSk7dmFyIERzPVIoRGk9PntcInVzZSBzdHJpY3RcIjtjKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KERpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShEaSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCxnZXQ6KCk9PkxofSk7dmFyIHBoPUtlKG1uKCkpLGhoPUtlKE5vKCkpLG1oPUtlKFdvKCkpLGdoPUtlKGJuKCkpLHZoPUtlKHFvKCkpLExzPUJvKCksSXM9VW8oKSxiaD1HbygpLHloPUtlKGpvKCkpLHhoPVZvKCksd2g9UHMoKSxfaD1TaSgpLFNoPUtlKEFzKCkpO2Z1bmN0aW9uIEtlKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBzdChlKXtyZXR1cm4gdHlwZW9mIGU9PVwiZnVuY3Rpb25cIn1mdW5jdGlvbiBqdChlKXtyZXR1cm4gdHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsfWZ1bmN0aW9uIFZ0KGUsLi4udCl7bGV0IG49dC5wb3AoKTtmb3IobGV0IHIgb2YgdClmb3IobGV0IGkgaW4gcil7bGV0IGE9bihlW2ldLHJbaV0pO2E9PT12b2lkIDA/anQoZVtpXSkmJmp0KHJbaV0pP2VbaV09VnQoZVtpXSxyW2ldLG4pOmVbaV09cltpXTplW2ldPWF9cmV0dXJuIGV9dmFyIENpPXtjb2xvcnM6dmguZGVmYXVsdCxuZWdhdGl2ZShlKXtyZXR1cm4gT2JqZWN0LmtleXMoZSkuZmlsdGVyKHQ9PmVbdF0hPT1cIjBcIikucmVkdWNlKCh0LG4pPT57bGV0IHI9KDAscGguZGVmYXVsdCkoZVtuXSk7cmV0dXJuIHIhPT12b2lkIDAmJih0W2AtJHtufWBdPXIpLHR9LHt9KX0sYnJlYWtwb2ludHMoZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLmZpbHRlcih0PT50eXBlb2YgZVt0XT09XCJzdHJpbmdcIikucmVkdWNlKCh0LG4pPT4oey4uLnQsW2BzY3JlZW4tJHtufWBdOmVbbl19KSx7fSl9fTtmdW5jdGlvbiBraChlLC4uLnQpe3JldHVybiBzdChlKT9lKC4uLnQpOmV9ZnVuY3Rpb24gVGgoZSl7cmV0dXJuIGUucmVkdWNlKCh0LHtleHRlbmQ6bn0pPT5WdCh0LG4sKHIsaSk9PnI9PT12b2lkIDA/W2ldOkFycmF5LmlzQXJyYXkocik/W2ksLi4ucl06W2kscl0pLHt9KX1mdW5jdGlvbiBFaChlKXtyZXR1cm57Li4uZS5yZWR1Y2UoKHQsbik9PigwLExzLmRlZmF1bHRzKSh0LG4pLHt9KSxleHRlbmQ6VGgoZSl9fWZ1bmN0aW9uIFJzKGUsdCl7aWYoQXJyYXkuaXNBcnJheShlKSYmanQoZVswXSkpcmV0dXJuIGUuY29uY2F0KHQpO2lmKEFycmF5LmlzQXJyYXkodCkmJmp0KHRbMF0pJiZqdChlKSlyZXR1cm5bZSwuLi50XTtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0fWZ1bmN0aW9uIE9oKHtleHRlbmQ6ZSwuLi50fSl7cmV0dXJuIFZ0KHQsZSwobixyKT0+IXN0KG4pJiYhci5zb21lKHN0KT9WdCh7fSxuLC4uLnIsUnMpOihpLGEpPT5WdCh7fSwuLi5bbiwuLi5yXS5tYXAobz0+a2gobyxpLGEpKSxScykpfWZ1bmN0aW9uKlBoKGUpe2xldCB0PSgwLElzLnRvUGF0aCkoZSk7aWYodC5sZW5ndGg9PT0wfHwoeWllbGQgdCxBcnJheS5pc0FycmF5KGUpKSlyZXR1cm47bGV0IG49L14oLio/KVxccypcXC9cXHMqKFteL10rKSQvLHI9ZS5tYXRjaChuKTtpZihyIT09bnVsbCl7bGV0WyxpLGFdPXIsbz0oMCxJcy50b1BhdGgpKGkpO28uYWxwaGE9YSx5aWVsZCBvfX1mdW5jdGlvbiBBaChlKXtsZXQgdD0obixyKT0+e2ZvcihsZXQgaSBvZiBQaChuKSl7bGV0IGE9MCxvPWU7Zm9yKDtvIT1udWxsJiZhPGkubGVuZ3RoOylvPW9baVthKytdXSxvPXN0KG8pJiYoaS5hbHBoYT09PXZvaWQgMHx8YTw9aS5sZW5ndGgtMSk/byh0LENpKTpvO2lmKG8hPT12b2lkIDApe2lmKGkuYWxwaGEhPT12b2lkIDApe2xldCBzPSgwLHdoLnBhcnNlQ29sb3JGb3JtYXQpKG8pO3JldHVybigwLF9oLndpdGhBbHBoYVZhbHVlKShzLGkuYWxwaGEsKDAsU2guZGVmYXVsdCkocykpfXJldHVybigwLHloLmRlZmF1bHQpKG8pPygwLHhoLmNsb25lRGVlcCkobyk6b319cmV0dXJuIHJ9O3JldHVybiBPYmplY3QuYXNzaWduKHQse3RoZW1lOnQsLi4uQ2l9KSxPYmplY3Qua2V5cyhlKS5yZWR1Y2UoKG4scik9PihuW3JdPXN0KGVbcl0pP2Vbcl0odCxDaSk6ZVtyXSxuKSx7fSl9ZnVuY3Rpb24gQ3MoZSl7bGV0IHQ9W107cmV0dXJuIGUuZm9yRWFjaChuPT57dD1bLi4udCxuXTt2YXIgcjtsZXQgaT0ocj1uPT1udWxsP3ZvaWQgMDpuLnBsdWdpbnMpIT09bnVsbCYmciE9PXZvaWQgMD9yOltdO2kubGVuZ3RoIT09MCYmaS5mb3JFYWNoKGE9PnthLl9faXNPcHRpb25zRnVuY3Rpb24mJihhPWEoKSk7dmFyIG87dD1bLi4udCwuLi5DcyhbKG89YT09bnVsbD92b2lkIDA6YS5jb25maWcpIT09bnVsbCYmbyE9PXZvaWQgMD9vOnt9XSldfSl9KSx0fWZ1bmN0aW9uIEloKGUpe3JldHVyblsuLi5lXS5yZWR1Y2VSaWdodCgobixyKT0+c3Qocik/cih7Y29yZVBsdWdpbnM6bn0pOigwLG1oLmRlZmF1bHQpKHIsbiksaGguZGVmYXVsdCl9ZnVuY3Rpb24gUmgoZSl7cmV0dXJuWy4uLmVdLnJlZHVjZVJpZ2h0KChuLHIpPT5bLi4ubiwuLi5yXSxbXSl9ZnVuY3Rpb24gTGgoZSl7bGV0IHQ9Wy4uLkNzKGUpLHtwcmVmaXg6XCJcIixpbXBvcnRhbnQ6ITEsc2VwYXJhdG9yOlwiOlwiLHZhcmlhbnRPcmRlcjpnaC5kZWZhdWx0LnZhcmlhbnRPcmRlcn1dO3ZhciBuLHI7cmV0dXJuKDAsYmgubm9ybWFsaXplQ29uZmlnKSgoMCxMcy5kZWZhdWx0cykoe3RoZW1lOkFoKE9oKEVoKHQubWFwKGk9PihuPWk9PW51bGw/dm9pZCAwOmkudGhlbWUpIT09bnVsbCYmbiE9PXZvaWQgMD9uOnt9KSkpKSxjb3JlUGx1Z2luczpJaCh0Lm1hcChpPT5pLmNvcmVQbHVnaW5zKSkscGx1Z2luczpSaChlLm1hcChpPT4ocj1pPT1udWxsP3ZvaWQgMDppLnBsdWdpbnMpIT09bnVsbCYmciE9PXZvaWQgMD9yOltdKSl9LC4uLnQpKX19KTt2YXIgRnM9e307Y28oRnMse2RlZmF1bHQ6KCk9PkNofSk7dmFyIENoLE1zPUJyKCgpPT57YygpO0NoPXt5ZWxsb3c6ZT0+ZX19KTt2YXIgcXM9UihGaT0+e1widXNlIHN0cmljdFwiO2MoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRmksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gRGgoZSx0KXtmb3IodmFyIG4gaW4gdClPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOiEwLGdldDp0W25dfSl9RGgoRmkse2ZsYWdFbmFibGVkOigpPT5OaCxpc3N1ZUZsYWdOb3RpY2VzOigpPT5XaCxkZWZhdWx0OigpPT4kaH0pO3ZhciBGaD0kcygoTXMoKSxhcihGcykpKSxNaD0kcygoYnIoKSxhcih2cikpKTtmdW5jdGlvbiAkcyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIE5zPXtvcHRpbWl6ZVVuaXZlcnNhbERlZmF1bHRzOiExfSxIdD17ZnV0dXJlOltcImhvdmVyT25seVdoZW5TdXBwb3J0ZWRcIixcInJlc3BlY3REZWZhdWx0UmluZ0NvbG9yT3BhY2l0eVwiXSxleHBlcmltZW50YWw6W1wib3B0aW1pemVVbml2ZXJzYWxEZWZhdWx0c1wiLFwibWF0Y2hWYXJpYW50XCJdfTtmdW5jdGlvbiBOaChlLHQpe2lmKEh0LmZ1dHVyZS5pbmNsdWRlcyh0KSl7dmFyIG4scixpO3JldHVybiBlLmZ1dHVyZT09PVwiYWxsXCJ8fCgoaT0ocj1lPT1udWxsfHwobj1lLmZ1dHVyZSk9PT1udWxsfHxuPT09dm9pZCAwP3ZvaWQgMDpuW3RdKSE9PW51bGwmJnIhPT12b2lkIDA/cjpOc1t0XSkhPT1udWxsJiZpIT09dm9pZCAwP2k6ITEpfWlmKEh0LmV4cGVyaW1lbnRhbC5pbmNsdWRlcyh0KSl7dmFyIGEsbyxzO3JldHVybiBlLmV4cGVyaW1lbnRhbD09PVwiYWxsXCJ8fCgocz0obz1lPT1udWxsfHwoYT1lLmV4cGVyaW1lbnRhbCk9PT1udWxsfHxhPT09dm9pZCAwP3ZvaWQgMDphW3RdKSE9PW51bGwmJm8hPT12b2lkIDA/bzpOc1t0XSkhPT1udWxsJiZzIT09dm9pZCAwP3M6ITEpfXJldHVybiExfWZ1bmN0aW9uIFdzKGUpe2lmKGUuZXhwZXJpbWVudGFsPT09XCJhbGxcIilyZXR1cm4gSHQuZXhwZXJpbWVudGFsO3ZhciB0O3JldHVybiBPYmplY3Qua2V5cygodD1lPT1udWxsP3ZvaWQgMDplLmV4cGVyaW1lbnRhbCkhPT1udWxsJiZ0IT09dm9pZCAwP3Q6e30pLmZpbHRlcihuPT5IdC5leHBlcmltZW50YWwuaW5jbHVkZXMobikmJmUuZXhwZXJpbWVudGFsW25dKX1mdW5jdGlvbiBXaChlKXtpZihwcm9jZXNzLmVudi5KRVNUX1dPUktFUl9JRD09PXZvaWQgMCYmV3MoZSkubGVuZ3RoPjApe2xldCB0PVdzKGUpLm1hcChuPT5GaC5kZWZhdWx0LnllbGxvdyhuKSkuam9pbihcIiwgXCIpO01oLmRlZmF1bHQud2FybihcImV4cGVyaW1lbnRhbC1mbGFncy1lbmFibGVkXCIsW2BZb3UgaGF2ZSBlbmFibGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlczogJHt0fWAsXCJFeHBlcmltZW50YWwgZmVhdHVyZXMgaW4gVGFpbHdpbmQgQ1NTIGFyZSBub3QgY292ZXJlZCBieSBzZW12ZXIsIG1heSBpbnRyb2R1Y2UgYnJlYWtpbmcgY2hhbmdlcywgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHRpbWUuXCJdKX19dmFyICRoPUh0fSk7dmFyIFVzPVIoTWk9PntcInVzZSBzdHJpY3RcIjtjKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE1pLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShNaSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCxnZXQ6KCk9PkJzfSk7dmFyIHFoPVVoKGJuKCkpLEJoPXFzKCk7ZnVuY3Rpb24gVWgoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIEJzKGUpe3ZhciB0O2xldCBuPSgodD1lPT1udWxsP3ZvaWQgMDplLnByZXNldHMpIT09bnVsbCYmdCE9PXZvaWQgMD90OltxaC5kZWZhdWx0XSkuc2xpY2UoKS5yZXZlcnNlKCkuZmxhdE1hcChhPT5Ccyh0eXBlb2YgYT09XCJmdW5jdGlvblwiP2EoKTphKSkscj17cmVzcGVjdERlZmF1bHRSaW5nQ29sb3JPcGFjaXR5Ont0aGVtZTp7cmluZ0NvbG9yOntERUZBVUxUOlwiIzNiODJmNjdmXCJ9fX19LGk9T2JqZWN0LmtleXMocikuZmlsdGVyKGE9PigwLEJoLmZsYWdFbmFibGVkKShlLGEpKS5tYXAoYT0+clthXSk7cmV0dXJuW2UsLi4uaSwuLi5uXX19KTt2YXIgR3M9UihOaT0+e1widXNlIHN0cmljdFwiO2MoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTmksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE5pLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLGdldDooKT0+amh9KTt2YXIgemg9enMoRHMoKSksR2g9enMoVXMoKSk7ZnVuY3Rpb24genMoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGpoKC4uLmUpe2xldFssLi4udF09KDAsR2guZGVmYXVsdCkoZVswXSk7cmV0dXJuKDAsemguZGVmYXVsdCkoWy4uLmUsLi4udF0pfX0pO3ZhciBWcz1SKChrZyxqcyk9PntjKCk7dmFyIFdpPUdzKCk7anMuZXhwb3J0cz0oV2kuX19lc01vZHVsZT9XaTp7ZGVmYXVsdDpXaX0pLmRlZmF1bHR9KTtjKCk7YygpO2MoKTtjKCk7dmFyIGhvPXt9O3ZhciBVcjtVcj1oby5kZWZhdWx0O2Z1bmN0aW9uIEV1KGUpe1VyPWV9ZnVuY3Rpb24gQWUoKXtyZXR1cm4gVXJ9YygpO2MoKTtjKCk7dmFyIGR0PShlLHQpPT4oKT0+KHR8fGUoKHQ9e2V4cG9ydHM6e319KS5leHBvcnRzLHQpLHQuZXhwb3J0cyksT3U9ZHQoKGUsdCk9Pnt0LmV4cG9ydHM9W1wiZW1cIixcImV4XCIsXCJjaFwiLFwicmVtXCIsXCJ2aFwiLFwidndcIixcInZtaW5cIixcInZtYXhcIixcInB4XCIsXCJtbVwiLFwiY21cIixcImluXCIsXCJwdFwiLFwicGNcIixcIm1vem1tXCJdfSksUHU9ZHQoKGUsdCk9Pnt0LmV4cG9ydHM9W1wiZGVnXCIsXCJncmFkXCIsXCJyYWRcIixcInR1cm5cIl19KSxBdT1kdCgoZSx0KT0+e3QuZXhwb3J0cz1bXCJkcGlcIixcImRwY21cIixcImRwcHhcIl19KSxJdT1kdCgoZSx0KT0+e3QuZXhwb3J0cz1bXCJIelwiLFwia0h6XCJdfSksUnU9ZHQoKGUsdCk9Pnt0LmV4cG9ydHM9W1wic1wiLFwibXNcIl19KSxMdT1PdSgpLG1vPVB1KCksZ289QXUoKSx2bz1JdSgpLGJvPVJ1KCk7ZnVuY3Rpb24gR3IoZSl7aWYoL1xcLlxcRD8kLy50ZXN0KGUpKXRocm93IG5ldyBFcnJvcihcIlRoZSBkb3Qgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IGEgbnVtYmVyXCIpO2lmKC9eWystXXsyfS8udGVzdChlKSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBsZWFkaW5nICsvLSBpcyBhbGxvd2VkXCIpO2lmKEN1KGUpPjEpdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgZG90IGlzIGFsbG93ZWRcIik7aWYoLyUkLy50ZXN0KGUpKXt0aGlzLnR5cGU9XCJwZXJjZW50YWdlXCIsdGhpcy52YWx1ZT16cihlKSx0aGlzLnVuaXQ9XCIlXCI7cmV0dXJufXZhciB0PUZ1KGUpO2lmKCF0KXt0aGlzLnR5cGU9XCJudW1iZXJcIix0aGlzLnZhbHVlPXpyKGUpO3JldHVybn10aGlzLnR5cGU9TnUodCksdGhpcy52YWx1ZT16cihlLnN1YnN0cigwLGUubGVuZ3RoLXQubGVuZ3RoKSksdGhpcy51bml0PXR9R3IucHJvdG90eXBlLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX07R3IucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWUrKHRoaXMudW5pdHx8XCJcIil9O2Z1bmN0aW9uIEZlKGUpe3JldHVybiBuZXcgR3IoZSl9ZnVuY3Rpb24gQ3UoZSl7dmFyIHQ9ZS5tYXRjaCgvXFwuL2cpO3JldHVybiB0P3QubGVuZ3RoOjB9ZnVuY3Rpb24genIoZSl7dmFyIHQ9cGFyc2VGbG9hdChlKTtpZihpc05hTih0KSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlcjogXCIrZSk7cmV0dXJuIHR9dmFyIER1PVtdLmNvbmNhdChtbyx2byxMdSxnbyxibyk7ZnVuY3Rpb24gRnUoZSl7dmFyIHQ9ZS5tYXRjaCgvXFxEKyQvKSxuPXQmJnRbMF07aWYobiYmRHUuaW5kZXhPZihuKT09PS0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdW5pdDogXCIrbik7cmV0dXJuIG59dmFyIE11PU9iamVjdC5hc3NpZ24oc3IobW8sXCJhbmdsZVwiKSxzcih2byxcImZyZXF1ZW5jeVwiKSxzcihnbyxcInJlc29sdXRpb25cIiksc3IoYm8sXCJ0aW1lXCIpKTtmdW5jdGlvbiBzcihlLHQpe3JldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZS5tYXAobj0+W24sdF0pKX1mdW5jdGlvbiBOdShlKXtyZXR1cm4gTXVbZV18fFwibGVuZ3RoXCJ9ZnVuY3Rpb24gWXIoZSl7bGV0IHQ9dHlwZW9mIGU7cmV0dXJuISh0PT09XCJudW1iZXJcInx8dD09PVwiYmlnaW50XCJ8fHQ9PT1cInN0cmluZ1wifHx0PT09XCJib29sZWFuXCIpfWZ1bmN0aW9uIHhvKGUpe3JldHVybi9eY2xhc3NcXHMvLnRlc3QoZS50b1N0cmluZygpKX1mdW5jdGlvbiB3byhlKXtsZXQgdD10eXBlb2YgZT5cInVcIj9bXTpbXS5jb25jYXQoZSkuZmxhdCgxLzApLG49W107Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2xldCBpPXRbcl07dHlwZW9mIGk+XCJ1XCJ8fHR5cGVvZiBpPT1cImJvb2xlYW5cInx8aT09PW51bGx8fCh0eXBlb2YgaT09XCJudW1iZXJcIiYmKGk9U3RyaW5nKGkpKSx0eXBlb2YgaT09XCJzdHJpbmdcIiYmbi5sZW5ndGgmJnR5cGVvZiBuW24ubGVuZ3RoLTFdPT1cInN0cmluZ1wiP25bbi5sZW5ndGgtMV0rPWk6bi5wdXNoKGkpKX1yZXR1cm4gbn1mdW5jdGlvbiBHZShlLHQsbixyLGk9ITEpe2lmKHR5cGVvZiBlPT1cIm51bWJlclwiKXJldHVybiBlO3RyeXtpZihlPWUudHJpbSgpLC9bIC9cXCgsXS8udGVzdChlKSlyZXR1cm47bGV0IGE9bmV3IEZlKGUpO2lmKGEudHlwZT09PVwibGVuZ3RoXCIpc3dpdGNoKGEudW5pdCl7Y2FzZVwiZW1cIjpyZXR1cm4gYS52YWx1ZSp0O2Nhc2VcInJlbVwiOnJldHVybiBhLnZhbHVlKjE2O2Nhc2VcInZ3XCI6cmV0dXJufn4oYS52YWx1ZSpyLl92aWV3cG9ydFdpZHRoLzEwMCk7Y2FzZVwidmhcIjpyZXR1cm5+fihhLnZhbHVlKnIuX3ZpZXdwb3J0SGVpZ2h0LzEwMCk7ZGVmYXVsdDpyZXR1cm4gYS52YWx1ZX1lbHNlIGlmKGEudHlwZT09PVwiYW5nbGVcIilzd2l0Y2goYS51bml0KXtjYXNlXCJkZWdcIjpyZXR1cm4gYS52YWx1ZTtjYXNlXCJyYWRcIjpyZXR1cm4gYS52YWx1ZSoxODAvTWF0aC5QSTtkZWZhdWx0OnJldHVybiBhLnZhbHVlfWVsc2UgaWYoYS50eXBlPT09XCJwZXJjZW50YWdlXCImJmkpcmV0dXJuIGEudmFsdWUvMTAwKm59Y2F0Y2h7fX1mdW5jdGlvbiBwdChlLHQpe3JldHVybltlWzBdKnRbMF0rZVsyXSp0WzFdLGVbMV0qdFswXStlWzNdKnRbMV0sZVswXSp0WzJdK2VbMl0qdFszXSxlWzFdKnRbMl0rZVszXSp0WzNdLGVbMF0qdFs0XStlWzJdKnRbNV0rZVs0XSxlWzFdKnRbNF0rZVszXSp0WzVdK2VbNV1dfWZ1bmN0aW9uIGFlKGUsdCxuLHIpe2xldCBpPXRbZV07aWYodHlwZW9mIGk+XCJ1XCIpe2lmKHImJnR5cGVvZiBlPFwidVwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgQ1NTIHByb3BlcnR5IFwiJHtyfVwiLiBBbGxvd2VkIHZhbHVlczogJHtPYmplY3Qua2V5cyh0KS5tYXAoYT0+YFwiJHthfVwiYCkuam9pbihcIiB8IFwiKX0uIFJlY2VpdmVkOiBcIiR7ZX1cIi5gKTtpPW59cmV0dXJuIGl9dmFyIHlvPXZvaWQgMCxqcixWcix1cj1bMzIsMTYwLDQ5NjEsNjU3OTIsNjU3OTMsNDE1Myw0MjQxLDEwXS5tYXAoZT0+U3RyaW5nLmZyb21Db2RlUG9pbnQoZSkpO2Z1bmN0aW9uIGplKGUsdCl7aWYoIWpyfHwhVnIpe2lmKCEodHlwZW9mIEludGw8XCJ1XCImJlwiU2VnbWVudGVyXCJpbiBJbnRsKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnRsLlNlZ21lbnRlciBkb2VzIG5vdCBleGlzdCwgcGxlYXNlIHVzZSBpbXBvcnQgYSBwb2x5ZmlsbC5cIik7anI9bmV3IEludGwuU2VnbWVudGVyKHlvLHtncmFudWxhcml0eTpcIndvcmRcIn0pLFZyPW5ldyBJbnRsLlNlZ21lbnRlcih5byx7Z3JhbnVsYXJpdHk6XCJncmFwaGVtZVwifSl9cmV0dXJuIHQ9PT1cIndvcmRcIj9bLi4uanIuc2VnbWVudChlKV0ubWFwKG49Pm4uc2VnbWVudCk6Wy4uLlZyLnNlZ21lbnQoZSldLm1hcChuPT5uLnNlZ21lbnQpfWZ1bmN0aW9uIFAoZSx0LG4pe2xldCByPVwiXCI7Zm9yKGxldFtpLGFdb2YgT2JqZWN0LmVudHJpZXModCkpdHlwZW9mIGE8XCJ1XCImJihyKz1gICR7aX09XCIke2F9XCJgKTtyZXR1cm4gbj9gPCR7ZX0ke3J9PiR7bn08LyR7ZX0+YDpgPCR7ZX0ke3J9Lz5gfWZ1bmN0aW9uIF9vKGU9MjApe2xldCB0PW5ldyBNYXA7ZnVuY3Rpb24gbihpLGEpe2lmKHQuc2l6ZT49ZSl7bGV0IG89dC5rZXlzKCkubmV4dCgpLnZhbHVlO3QuZGVsZXRlKG8pfXQuc2V0KGksYSl9ZnVuY3Rpb24gcihpKXtpZighdC5oYXMoaSkpcmV0dXJuO2xldCBvPXQuZ2V0KGkpO3JldHVybiB0LmRlbGV0ZShpKSx0LnNldChpLG8pLG99cmV0dXJue3NldDpuLGdldDpyfX12YXIgU289e2FjY2VudEhlaWdodDpcImFjY2VudC1oZWlnaHRcIixhbGlnbm1lbnRCYXNlbGluZTpcImFsaWdubWVudC1iYXNlbGluZVwiLGFyYWJpY0Zvcm06XCJhcmFiaWMtZm9ybVwiLGJhc2VsaW5lU2hpZnQ6XCJiYXNlbGluZS1zaGlmdFwiLGNhcEhlaWdodDpcImNhcC1oZWlnaHRcIixjbGlwUGF0aDpcImNsaXAtcGF0aFwiLGNsaXBSdWxlOlwiY2xpcC1ydWxlXCIsY29sb3JJbnRlcnBvbGF0aW9uOlwiY29sb3ItaW50ZXJwb2xhdGlvblwiLGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnM6XCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIixjb2xvclByb2ZpbGU6XCJjb2xvci1wcm9maWxlXCIsY29sb3JSZW5kZXJpbmc6XCJjb2xvci1yZW5kZXJpbmdcIixkb21pbmFudEJhc2VsaW5lOlwiZG9taW5hbnQtYmFzZWxpbmVcIixlbmFibGVCYWNrZ3JvdW5kOlwiZW5hYmxlLWJhY2tncm91bmRcIixmaWxsT3BhY2l0eTpcImZpbGwtb3BhY2l0eVwiLGZpbGxSdWxlOlwiZmlsbC1ydWxlXCIsZmxvb2RDb2xvcjpcImZsb29kLWNvbG9yXCIsZmxvb2RPcGFjaXR5OlwiZmxvb2Qtb3BhY2l0eVwiLGZvbnRGYW1pbHk6XCJmb250LWZhbWlseVwiLGZvbnRTaXplOlwiZm9udC1zaXplXCIsZm9udFNpemVBZGp1c3Q6XCJmb250LXNpemUtYWRqdXN0XCIsZm9udFN0cmV0Y2g6XCJmb250LXN0cmV0Y2hcIixmb250U3R5bGU6XCJmb250LXN0eWxlXCIsZm9udFZhcmlhbnQ6XCJmb250LXZhcmlhbnRcIixmb250V2VpZ2h0OlwiZm9udC13ZWlnaHRcIixnbHlwaE5hbWU6XCJnbHlwaC1uYW1lXCIsZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6XCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCIsZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOlwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIixob3JpekFkdlg6XCJob3Jpei1hZHYteFwiLGhvcml6T3JpZ2luWDpcImhvcml6LW9yaWdpbi14XCIsaW1hZ2VSZW5kZXJpbmc6XCJpbWFnZS1yZW5kZXJpbmdcIixsZXR0ZXJTcGFjaW5nOlwibGV0dGVyLXNwYWNpbmdcIixsaWdodGluZ0NvbG9yOlwibGlnaHRpbmctY29sb3JcIixtYXJrZXJFbmQ6XCJtYXJrZXItZW5kXCIsbWFya2VyTWlkOlwibWFya2VyLW1pZFwiLG1hcmtlclN0YXJ0OlwibWFya2VyLXN0YXJ0XCIsb3ZlcmxpbmVQb3NpdGlvbjpcIm92ZXJsaW5lLXBvc2l0aW9uXCIsb3ZlcmxpbmVUaGlja25lc3M6XCJvdmVybGluZS10aGlja25lc3NcIixwYWludE9yZGVyOlwicGFpbnQtb3JkZXJcIixwYW5vc2UxOlwicGFub3NlLTFcIixwb2ludGVyRXZlbnRzOlwicG9pbnRlci1ldmVudHNcIixyZW5kZXJpbmdJbnRlbnQ6XCJyZW5kZXJpbmctaW50ZW50XCIsc2hhcGVSZW5kZXJpbmc6XCJzaGFwZS1yZW5kZXJpbmdcIixzdG9wQ29sb3I6XCJzdG9wLWNvbG9yXCIsc3RvcE9wYWNpdHk6XCJzdG9wLW9wYWNpdHlcIixzdHJpa2V0aHJvdWdoUG9zaXRpb246XCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCIsc3RyaWtldGhyb3VnaFRoaWNrbmVzczpcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCIsc3Ryb2tlRGFzaGFycmF5Olwic3Ryb2tlLWRhc2hhcnJheVwiLHN0cm9rZURhc2hvZmZzZXQ6XCJzdHJva2UtZGFzaG9mZnNldFwiLHN0cm9rZUxpbmVjYXA6XCJzdHJva2UtbGluZWNhcFwiLHN0cm9rZUxpbmVqb2luOlwic3Ryb2tlLWxpbmVqb2luXCIsc3Ryb2tlTWl0ZXJsaW1pdDpcInN0cm9rZS1taXRlcmxpbWl0XCIsc3Ryb2tlT3BhY2l0eTpcInN0cm9rZS1vcGFjaXR5XCIsc3Ryb2tlV2lkdGg6XCJzdHJva2Utd2lkdGhcIix0ZXh0QW5jaG9yOlwidGV4dC1hbmNob3JcIix0ZXh0RGVjb3JhdGlvbjpcInRleHQtZGVjb3JhdGlvblwiLHRleHRSZW5kZXJpbmc6XCJ0ZXh0LXJlbmRlcmluZ1wiLHVuZGVybGluZVBvc2l0aW9uOlwidW5kZXJsaW5lLXBvc2l0aW9uXCIsdW5kZXJsaW5lVGhpY2tuZXNzOlwidW5kZXJsaW5lLXRoaWNrbmVzc1wiLHVuaWNvZGVCaWRpOlwidW5pY29kZS1iaWRpXCIsdW5pY29kZVJhbmdlOlwidW5pY29kZS1yYW5nZVwiLHVuaXRzUGVyRW06XCJ1bml0cy1wZXItZW1cIix2QWxwaGFiZXRpYzpcInYtYWxwaGFiZXRpY1wiLHZIYW5naW5nOlwidi1oYW5naW5nXCIsdklkZW9ncmFwaGljOlwidi1pZGVvZ3JhcGhpY1wiLHZNYXRoZW1hdGljYWw6XCJ2LW1hdGhlbWF0aWNhbFwiLHZlY3RvckVmZmVjdDpcInZlY3Rvci1lZmZlY3RcIix2ZXJ0QWR2WTpcInZlcnQtYWR2LXlcIix2ZXJ0T3JpZ2luWDpcInZlcnQtb3JpZ2luLXhcIix2ZXJ0T3JpZ2luWTpcInZlcnQtb3JpZ2luLXlcIix3b3JkU3BhY2luZzpcIndvcmQtc3BhY2luZ1wiLHdyaXRpbmdNb2RlOlwid3JpdGluZy1tb2RlXCIseEhlaWdodDpcIngtaGVpZ2h0XCIseGxpbmtBY3R1YXRlOlwieGxpbms6YWN0dWF0ZVwiLHhsaW5rQXJjcm9sZTpcInhsaW5rOmFyY3JvbGVcIix4bGlua0hyZWY6XCJ4bGluazpocmVmXCIseGxpbmtSb2xlOlwieGxpbms6cm9sZVwiLHhsaW5rU2hvdzpcInhsaW5rOnNob3dcIix4bGlua1RpdGxlOlwieGxpbms6dGl0bGVcIix4bGlua1R5cGU6XCJ4bGluazp0eXBlXCIseG1sQmFzZTpcInhtbDpiYXNlXCIseG1sTGFuZzpcInhtbDpsYW5nXCIseG1sU3BhY2U6XCJ4bWw6c3BhY2VcIix4bWxuc1hsaW5rOlwieG1sbnM6eGxpbmtcIn0sV3U9L1tcXHJcXG4lIygpPD4/W1xcXFxcXF1eYHt8fVwiJ10vZztmdW5jdGlvbiBIcihlKXtpZighZSlyZXR1cm5cIlwiO2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGUubWFwKEhyKS5qb2luKFwiXCIpO2lmKHR5cGVvZiBlIT1cIm9iamVjdFwiKXJldHVybiBTdHJpbmcoZSk7bGV0IHQ9ZS50eXBlO2lmKHQ9PT1cInRleHRcIil0aHJvdyBuZXcgRXJyb3IoXCI8dGV4dD4gbm9kZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLCBwbGVhc2UgY29udmVydCB0aGVtIHRvIDxwYXRoPlwiKTtsZXR7Y2hpbGRyZW46biwuLi5yfT1lLnByb3BzfHx7fTtyZXR1cm5gPCR7dH0ke09iamVjdC5lbnRyaWVzKHIpLm1hcCgoW2ksYV0pPT5gICR7U29baV18fGl9PVwiJHthfVwiYCkuam9pbihcIlwiKX0+JHtIcihuKX08LyR7dH0+YH1mdW5jdGlvbiBrbyhlKXtsZXR7dmlld0JveDp0LHZpZXdib3g6bix3aWR0aDpyLGhlaWdodDppLGNsYXNzTmFtZTphLHN0eWxlOm8sY2hpbGRyZW46cywuLi51fT1lLnByb3BzfHx7fTt0fHwodD1uKTtsZXQgbD10LnNwbGl0KFwiIFwiKS5tYXAoZj0+cGFyc2VJbnQoZiwxMCkpO3JldHVybiB1LnhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix1LnZpZXdCb3g9dCx1LndpZHRoPWxbMl0sdS5oZWlnaHQ9bFszXSxgZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsJHtgPHN2ZyR7T2JqZWN0LmVudHJpZXModSkubWFwKChbZixwXSk9PmAgJHtTb1tmXXx8Zn09XCIke3B9XCJgKS5qb2luKFwiXCIpfT4ke0hyKHMpfTwvc3ZnPmAucmVwbGFjZShXdSxlbmNvZGVVUklDb21wb25lbnQpfWB9YygpO2MoKTt2YXIgdmU9XCJmbGV4XCIsVG89e3A6e2Rpc3BsYXk6dmUsbWFyZ2luVG9wOlwiMWVtXCIsbWFyZ2luQm90dG9tOlwiMWVtXCJ9LGRpdjp7ZGlzcGxheTp2ZX0sYmxvY2txdW90ZTp7ZGlzcGxheTp2ZSxtYXJnaW5Ub3A6XCIxZW1cIixtYXJnaW5Cb3R0b206XCIxZW1cIixtYXJnaW5MZWZ0OjQwLG1hcmdpblJpZ2h0OjQwfSxjZW50ZXI6e2Rpc3BsYXk6dmUsdGV4dEFsaWduOlwiY2VudGVyXCJ9LGhyOntkaXNwbGF5OnZlLG1hcmdpblRvcDpcIjAuNWVtXCIsbWFyZ2luQm90dG9tOlwiMC41ZW1cIixtYXJnaW5MZWZ0OlwiYXV0b1wiLG1hcmdpblJpZ2h0OlwiYXV0b1wiLGJvcmRlcldpZHRoOjEsYm9yZGVyU3R5bGU6XCJzb2xpZFwifSxoMTp7ZGlzcGxheTp2ZSxmb250U2l6ZTpcIjJlbVwiLG1hcmdpblRvcDpcIjAuNjdlbVwiLG1hcmdpbkJvdHRvbTpcIjAuNjdlbVwiLG1hcmdpbkxlZnQ6MCxtYXJnaW5SaWdodDowLGZvbnRXZWlnaHQ6XCJib2xkXCJ9LGgyOntkaXNwbGF5OnZlLGZvbnRTaXplOlwiMS41ZW1cIixtYXJnaW5Ub3A6XCIwLjgzZW1cIixtYXJnaW5Cb3R0b206XCIwLjgzZW1cIixtYXJnaW5MZWZ0OjAsbWFyZ2luUmlnaHQ6MCxmb250V2VpZ2h0OlwiYm9sZFwifSxoMzp7ZGlzcGxheTp2ZSxmb250U2l6ZTpcIjEuMTdlbVwiLG1hcmdpblRvcDpcIjFlbVwiLG1hcmdpbkJvdHRvbTpcIjFlbVwiLG1hcmdpbkxlZnQ6MCxtYXJnaW5SaWdodDowLGZvbnRXZWlnaHQ6XCJib2xkXCJ9LGg0OntkaXNwbGF5OnZlLG1hcmdpblRvcDpcIjEuMzNlbVwiLG1hcmdpbkJvdHRvbTpcIjEuMzNlbVwiLG1hcmdpbkxlZnQ6MCxtYXJnaW5SaWdodDowLGZvbnRXZWlnaHQ6XCJib2xkXCJ9LGg1OntkaXNwbGF5OnZlLGZvbnRTaXplOlwiMC44M2VtXCIsbWFyZ2luVG9wOlwiMS42N2VtXCIsbWFyZ2luQm90dG9tOlwiMS42N2VtXCIsbWFyZ2luTGVmdDowLG1hcmdpblJpZ2h0OjAsZm9udFdlaWdodDpcImJvbGRcIn0saDY6e2Rpc3BsYXk6dmUsZm9udFNpemU6XCIwLjY3ZW1cIixtYXJnaW5Ub3A6XCIyLjMzZW1cIixtYXJnaW5Cb3R0b206XCIyLjMzZW1cIixtYXJnaW5MZWZ0OjAsbWFyZ2luUmlnaHQ6MCxmb250V2VpZ2h0OlwiYm9sZFwifSx1Ont0ZXh0RGVjb3JhdGlvbjpcInVuZGVybGluZVwifSxzdHJvbmc6e2ZvbnRXZWlnaHQ6XCJib2xkXCJ9LGI6e2ZvbnRXZWlnaHQ6XCJib2xkXCJ9LGk6e2ZvbnRTdHlsZTpcIml0YWxpY1wifSxlbTp7Zm9udFN0eWxlOlwiaXRhbGljXCJ9LGNvZGU6e2ZvbnRGYW1pbHk6XCJtb25vc3BhY2VcIn0sa2JkOntmb250RmFtaWx5OlwibW9ub3NwYWNlXCJ9LHByZTp7ZGlzcGxheTp2ZSxmb250RmFtaWx5OlwibW9ub3NwYWNlXCIsd2hpdGVTcGFjZTpcInByZVwiLG1hcmdpblRvcDpcIjFlbVwiLG1hcmdpbkJvdHRvbTpcIjFlbVwifSxtYXJrOntiYWNrZ3JvdW5kQ29sb3I6XCJ5ZWxsb3dcIixjb2xvcjpcImJsYWNrXCJ9LGJpZzp7Zm9udFNpemU6XCJsYXJnZXJcIn0sc21hbGw6e2ZvbnRTaXplOlwic21hbGxlclwifSxzOnt0ZXh0RGVjb3JhdGlvbjpcImxpbmUtdGhyb3VnaFwifX07YygpO3ZhciAkdT1uZXcgU2V0KFtcImNvbG9yXCIsXCJmb250XCIsXCJmb250RmFtaWx5XCIsXCJmb250U2l6ZVwiLFwiZm9udFN0eWxlXCIsXCJmb250V2VpZ2h0XCIsXCJsZXR0ZXJTcGFjaW5nXCIsXCJsaW5lSGVpZ2h0XCIsXCJ0ZXh0QWxpZ25cIixcInRleHRUcmFuc2Zvcm1cIixcInRleHRTaGFkb3dPZmZzZXRcIixcInRleHRTaGFkb3dDb2xvclwiLFwidGV4dFNoYWRvd1JhZGl1c1wiLFwidGV4dERlY29yYXRpb25MaW5lXCIsXCJ0ZXh0RGVjb3JhdGlvblN0eWxlXCIsXCJ0ZXh0RGVjb3JhdGlvbkNvbG9yXCIsXCJ3aGl0ZVNwYWNlXCIsXCJ0cmFuc2Zvcm1cIixcIndvcmRCcmVha1wiLFwib3BhY2l0eVwiLFwiZmlsdGVyXCIsXCJfdmlld3BvcnRXaWR0aFwiLFwiX3ZpZXdwb3J0SGVpZ2h0XCIsXCJfaW5oZXJpdGVkQ2xpcFBhdGhJZFwiLFwiX2luaGVyaXRlZE1hc2tJZFwiLFwiX2luaGVyaXRlZEJhY2tncm91bmRDbGlwVGV4dFBhdGhcIl0pO2Z1bmN0aW9uIFhyKGUpe2xldCB0PXt9O2ZvcihsZXQgbiBpbiBlKSR1LmhhcyhuKSYmKHRbbl09ZVtuXSk7cmV0dXJuIHR9YygpO2ltcG9ydHtnZXRQcm9wZXJ0eU5hbWUgYXMgVXUsZ2V0U3R5bGVzRm9yUHJvcGVydHkgYXMgVmV9ZnJvbVwiY3NzLXRvLXJlYWN0LW5hdGl2ZVwiO2ltcG9ydHtwYXJzZUVsZW1lbnRTdHlsZSBhcyB6dX1mcm9tXCJjc3MtYmFja2dyb3VuZC1wYXJzZXJcIjtpbXBvcnR7cGFyc2UgYXMgR3V9ZnJvbVwiY3NzLWJveC1zaGFkb3dcIjtjKCk7aW1wb3J0IHF1IGZyb21cInBvc3Rjc3MtdmFsdWUtcGFyc2VyXCI7ZnVuY3Rpb24gQnUoZSx0KXt0cnl7bGV0IG49bmV3IEZlKGUpO3N3aXRjaChuLnVuaXQpe2Nhc2VcInB4XCI6cmV0dXJue2Fic29sdXRlOm4udmFsdWV9O2Nhc2VcImVtXCI6cmV0dXJue2Fic29sdXRlOm4udmFsdWUqdH07Y2FzZVwicmVtXCI6cmV0dXJue2Fic29sdXRlOm4udmFsdWUqMTZ9O2Nhc2VcIiVcIjpyZXR1cm57cmVsYXRpdmU6bi52YWx1ZX07ZGVmYXVsdDpyZXR1cm57fX19Y2F0Y2h7cmV0dXJue319fWZ1bmN0aW9uIFFyKGUsdCxuKXtzd2l0Y2goZSl7Y2FzZVwidG9wXCI6cmV0dXJue3lSZWxhdGl2ZTowfTtjYXNlXCJsZWZ0XCI6cmV0dXJue3hSZWxhdGl2ZTowfTtjYXNlXCJyaWdodFwiOnJldHVybnt4UmVsYXRpdmU6MTAwfTtjYXNlXCJib3R0b21cIjpyZXR1cm57eVJlbGF0aXZlOjEwMH07Y2FzZVwiY2VudGVyXCI6cmV0dXJue307ZGVmYXVsdDpsZXQgcj1CdShlLHQpO3JldHVybiByLmFic29sdXRlP3tbbj9cInhBYnNvbHV0ZVwiOlwieUFic29sdXRlXCJdOnIuYWJzb2x1dGV9OnIucmVsYXRpdmU/e1tuP1wieFJlbGF0aXZlXCI6XCJ5UmVsYXRpdmVcIl06ci5yZWxhdGl2ZX06e319fWZ1bmN0aW9uIEpyKGUsdCl7aWYodHlwZW9mIGU9PVwibnVtYmVyXCIpcmV0dXJue3hBYnNvbHV0ZTplfTtsZXQgbjt0cnl7bj1xdShlKS5ub2Rlcy5maWx0ZXIocj0+ci50eXBlPT09XCJ3b3JkXCIpLm1hcChyPT5yLnZhbHVlKX1jYXRjaHtyZXR1cm57fX1yZXR1cm4gbi5sZW5ndGg9PT0xP1FyKG5bMF0sdCwhMCk6bi5sZW5ndGg9PT0yPygoblswXT09PVwidG9wXCJ8fG5bMF09PT1cImJvdHRvbVwifHxuWzFdPT09XCJsZWZ0XCJ8fG5bMV09PT1cInJpZ2h0XCIpJiZuLnJldmVyc2UoKSx7Li4uUXIoblswXSx0LCEwKSwuLi5RcihuWzFdLHQsITEpfSk6e319dmFyIGp1PW5ldyBTZXQoW1wiZmxleFwiLFwiZmxleEdyb3dcIixcImZsZXhTaHJpbmtcIixcImZsZXhCYXNpc1wiLFwiZm9udFdlaWdodFwiLFwibGluZUhlaWdodFwiLFwib3BhY2l0eVwiLFwic2NhbGVcIixcInNjYWxlWFwiLFwic2NhbGVZXCJdKSxWdT1uZXcgU2V0KFtcImxpbmVIZWlnaHRcIl0pO2Z1bmN0aW9uIEh1KGUsdCxuLHIpe3JldHVybiBlPT09XCJ0ZXh0RGVjb3JhdGlvblwiJiYhbi5pbmNsdWRlcyh0LnRleHREZWNvcmF0aW9uQ29sb3IpJiYodC50ZXh0RGVjb3JhdGlvbkNvbG9yPXIpLHR9ZnVuY3Rpb24gaHQoZSx0KXtyZXR1cm4gdHlwZW9mIHQ9PVwibnVtYmVyXCI/anUuaGFzKGUpP1Z1LmhhcyhlKT90OlN0cmluZyh0KTp0K1wicHhcIjp0fWZ1bmN0aW9uIFl1KGUsdCxuKXtpZihlPT09XCJsaW5lSGVpZ2h0XCIpcmV0dXJue2xpbmVIZWlnaHQ6aHQoZSx0KX07aWYoZT09PVwiZm9udEZhbWlseVwiKXJldHVybntmb250RmFtaWx5OnQuc3BsaXQoXCIsXCIpLm1hcChyPT5yLnRyaW0oKS5yZXBsYWNlKC8oXlsnXCJdKXwoWydcIl0kKS9nLFwiXCIpLnRvTG9jYWxlTG93ZXJDYXNlKCkpfTtpZihlPT09XCJib3JkZXJSYWRpdXNcIil7aWYodHlwZW9mIHQhPVwic3RyaW5nXCJ8fCF0LmluY2x1ZGVzKFwiL1wiKSlyZXR1cm47bGV0W3IsaV09dC5zcGxpdChcIi9cIiksYT1WZShlLHIsITApLG89VmUoZSxpLCEwKTtmb3IobGV0IHMgaW4gYSlvW3NdPWh0KGUsYVtzXSkrXCIgXCIraHQoZSxvW3NdKTtyZXR1cm4gb31pZigvXmJvcmRlcihUb3B8UmlnaHR8Qm90dG9tfExlZnQpPyQvLnRlc3QoZSkpe2xldCByPVZlKFwiYm9yZGVyXCIsdCwhMCk7ci5ib3JkZXJXaWR0aD09PTEmJiFTdHJpbmcodCkuaW5jbHVkZXMoXCIxcHhcIikmJihyLmJvcmRlcldpZHRoPTMpLHIuYm9yZGVyQ29sb3I9PT1cImJsYWNrXCImJiFTdHJpbmcodCkuaW5jbHVkZXMoXCJibGFja1wiKSYmKHIuYm9yZGVyQ29sb3I9bik7bGV0IGk9e1dpZHRoOmh0KGUrXCJXaWR0aFwiLHIuYm9yZGVyV2lkdGgpLFN0eWxlOmFlKHIuYm9yZGVyU3R5bGUse3NvbGlkOlwic29saWRcIixkYXNoZWQ6XCJkYXNoZWRcIn0sXCJzb2xpZFwiLGUrXCJTdHlsZVwiKSxDb2xvcjpyLmJvcmRlckNvbG9yfSxhPXt9O2ZvcihsZXQgbyBvZiBlPT09XCJib3JkZXJcIj9bXCJUb3BcIixcIlJpZ2h0XCIsXCJCb3R0b21cIixcIkxlZnRcIl06W2Uuc2xpY2UoNildKWZvcihsZXQgcyBpbiBpKWFbXCJib3JkZXJcIitvK3NdPWlbc107cmV0dXJuIGF9aWYoZT09PVwiYm94U2hhZG93XCIpe2lmKCF0KXRocm93IG5ldyBFcnJvcignSW52YWxpZCBgYm94U2hhZG93YCB2YWx1ZTogXCInK3QrJ1wiLicpO3JldHVybntbZV06dHlwZW9mIHQ9PVwic3RyaW5nXCI/R3UodCk6dH19aWYoZT09PVwidHJhbnNmb3JtXCIpe2lmKHR5cGVvZiB0IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYHRyYW5zZm9ybWAgdmFsdWUuXCIpO2xldCByPXt9LGk9dC5yZXBsYWNlKC8oLT9bXFxkLl0rJSkvZywobyxzKT0+e2xldCB1PX5+KE1hdGgucmFuZG9tKCkqMWU5KTtyZXR1cm4gclt1XT1zLHUrXCJweFwifSksYT1WZShcInRyYW5zZm9ybVwiLGksITApO2ZvcihsZXQgbyBvZiBhLnRyYW5zZm9ybSlmb3IobGV0IHMgaW4gbylyW29bc11dJiYob1tzXT1yW29bc11dKTtyZXR1cm4gYX1pZihlPT09XCJiYWNrZ3JvdW5kXCIpcmV0dXJuIHQ9dC50b1N0cmluZygpLnRyaW0oKSwvXihsaW5lYXItZ3JhZGllbnR8cmFkaWFsLWdyYWRpZW50fHVybClcXCgvLnRlc3QodCk/VmUoXCJiYWNrZ3JvdW5kSW1hZ2VcIix0LCEwKTpWZShcImJhY2tncm91bmRcIix0LCEwKX1mdW5jdGlvbiBFbyhlKXtyZXR1cm4gZT09PVwidHJhbnNmb3JtXCI/XCIgT25seSBhYnNvbHV0ZSBsZW5ndGhzIHN1Y2ggYXMgYDEwcHhgIGFyZSBzdXBwb3J0ZWQuXCI6XCJcIn12YXIgT289L3JnYlxcKChcXGQrKVxccysoXFxkKylcXHMrKFxcZCspXFxzKlxcL1xccyooW1xcLlxcZF0rKVxcKS87ZnVuY3Rpb24gUG8oZSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCImJk9vLnRlc3QoZS50cmltKCkpKXJldHVybiBlLnRyaW0oKS5yZXBsYWNlKE9vLCh0LG4scixpLGEpPT5gcmdiYSgke259LCAke3J9LCAke2l9LCAke2F9KWApO2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7Zm9yKGxldCB0IGluIGUpZVt0XT1QbyhlW3RdKTtyZXR1cm4gZX1yZXR1cm4gZX1mdW5jdGlvbiBscihlLHQpe3ZhciBpO2xldCBuPXt9O2ZvcihsZXQgYSBpbiBlKXtpZihhLnN0YXJ0c1dpdGgoXCJfXCIpKXtuW2FdPWVbYV07Y29udGludWV9bGV0IG89VXUoYSkscz1lLmNvbG9yfHx0LmNvbG9yO3RyeXtsZXQgdT1ZdShvLGVbYV0scyl8fEh1KG8sVmUobyxodChvLGVbYV0pLCEwKSxlW2FdLHMpO09iamVjdC5hc3NpZ24obix1KX1jYXRjaCh1KXt0aHJvdyBuZXcgRXJyb3IodS5tZXNzYWdlKyh1Lm1lc3NhZ2UuaW5jbHVkZXMoZVthXSk/YFxuICBgK0VvKG8pOmBcbiAgaW4gQ1NTIHJ1bGUgXFxgJHtvfTogJHtlW2FdfVxcYC4ke0VvKG8pfWApKX19aWYobi5iYWNrZ3JvdW5kSW1hZ2Upe2xldHtiYWNrZ3JvdW5kczphfT16dShuKTtuLmJhY2tncm91bmRJbWFnZT1hfWxldCByPXR5cGVvZiBuLmZvbnRTaXplPT1cIm51bWJlclwiP24uZm9udFNpemU6dC5mb250U2l6ZTtpZih0eXBlb2Ygcj09XCJzdHJpbmdcIil0cnl7bGV0IGE9bmV3IEZlKHIpO3N3aXRjaChhLnVuaXQpe2Nhc2VcImVtXCI6cj1hLnZhbHVlKnQuZm9udFNpemU7YnJlYWs7Y2FzZVwicmVtXCI6cj1hLnZhbHVlKjE2O2JyZWFrfX1jYXRjaHtyPTE2fXR5cGVvZiBuLmZvbnRTaXplPFwidVwiJiYobi5mb250U2l6ZT1yKSxuLnRyYW5zZm9ybU9yaWdpbiYmKG4udHJhbnNmb3JtT3JpZ2luPUpyKG4udHJhbnNmb3JtT3JpZ2luLHIpKTtmb3IobGV0IGEgaW4gbil7bGV0IG89blthXTtpZihhPT09XCJsaW5lSGVpZ2h0XCIpdHlwZW9mIG89PVwic3RyaW5nXCImJihvPW5bYV09R2UobyxyLHIsdCwhMCkvcik7ZWxzZXtpZih0eXBlb2Ygbz09XCJzdHJpbmdcIil7bGV0IHM9R2UobyxyLHIsdCk7dHlwZW9mIHM8XCJ1XCImJihuW2FdPXMpLG89blthXX1pZih0eXBlb2Ygbz09XCJzdHJpbmdcInx8dHlwZW9mIG89PVwib2JqZWN0XCIpe2xldCBzPVBvKG8pO3MmJihuW2FdPXMpLG89blthXX19aWYoYT09PVwib3BhY2l0eVwiJiYobz1uW2FdPW8qdC5vcGFjaXR5KSxhPT09XCJ0cmFuc2Zvcm1cIil7bGV0IHM9bztmb3IobGV0IHUgb2Ygcyl7bGV0IGw9T2JqZWN0LmtleXModSlbMF0sZj11W2xdLHA9dHlwZW9mIGY9PVwic3RyaW5nXCImJihpPUdlKGYscixyLHQpKSE9bnVsbD9pOmY7dVtsXT1wfX19cmV0dXJuIG59YygpO2Z1bmN0aW9uIFh1KGUpe2xldCB0PW5ldyBEYXRhVmlldyhlKSxuPTQscj10LmJ5dGVMZW5ndGg7Zm9yKDtuPHI7KXtsZXQgaT10LmdldFVpbnQxNihuLCExKTtpZihpPnIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgSlBFR1wiKTtsZXQgYT10LmdldFVpbnQ4KGkrMStuKTtpZihhPT09MTkyfHxhPT09MTkzfHxhPT09MTk0KXJldHVyblt0LmdldFVpbnQxNihpKzcrbiwhMSksdC5nZXRVaW50MTYoaSs1K24sITEpXTtuKz1pKzJ9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgSlBFR1wiKX1mdW5jdGlvbiBRdShlKXtsZXQgdD1uZXcgVWludDhBcnJheShlLnNsaWNlKDYsMTApKTtyZXR1cm5bdFswXXx0WzFdPDw4LHRbMl18dFszXTw8OF19ZnVuY3Rpb24gSnUoZSl7bGV0IHQ9bmV3IERhdGFWaWV3KGUpO3JldHVyblt0LmdldFVpbnQxNigxOCwhMSksdC5nZXRVaW50MTYoMjIsITEpXX12YXIgS3I9X28oMTAwKSxacj1uZXcgTWFwLEt1PVtcImltYWdlL3BuZ1wiLFwiaW1hZ2UvanBlZ1wiLFwiaW1hZ2UvZ2lmXCIsXCJpbWFnZS9zdmcreG1sXCJdO2Z1bmN0aW9uIFp1KGUpe2xldCB0PVwiXCIsbj1uZXcgVWludDhBcnJheShlKTtmb3IobGV0IHI9MDtyPG4uYnl0ZUxlbmd0aDtyKyspdCs9U3RyaW5nLmZyb21DaGFyQ29kZShuW3JdKTtyZXR1cm4gYnRvYSh0KX1hc3luYyBmdW5jdGlvbiBmcihlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBzb3VyY2UgaXMgbm90IHByb3ZpZGVkLlwiKTtpZihlLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSlyZXR1cm5bZV07aWYoIWdsb2JhbFRoaXMuZmV0Y2gpdGhyb3cgbmV3IEVycm9yKFwiYGZldGNoYCBpcyByZXF1aXJlZCB0byBiZSBwb2x5ZmlsbGVkIHRvIGxvYWQgaW1hZ2VzLlwiKTtpZihaci5oYXMoZSkpcmV0dXJuIFpyLmdldChlKTtsZXQgdD1Lci5nZXQoZSk7aWYodClyZXR1cm4gdDtsZXQgbj1uZXcgUHJvbWlzZSgocixpKT0+e2ZldGNoKGUpLnRoZW4oYT0+e2xldCBvPWEuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7cmV0dXJuIG89PT1cImltYWdlL3N2Zyt4bWxcInx8bz09PVwiYXBwbGljYXRpb24vc3ZnK3htbFwiP2EudGV4dCgpOmEuYXJyYXlCdWZmZXIoKX0pLnRoZW4oYT0+e2lmKHR5cGVvZiBhPT1cInN0cmluZ1wiKXRyeXtsZXQgcD1gZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2J0b2EoYSl9YCxnPWEubWF0Y2goLzxzdmdbXj5dKj4vKVswXSxtPWcubWF0Y2goL3ZpZXdCb3g9XCIwIDAgKFxcZCspIChcXGQrKVwiLyksZD1nLm1hdGNoKC93aWR0aD1cIihcXGQrKVwiLyksaD1nLm1hdGNoKC9oZWlnaHQ9XCIoXFxkKylcIi8pOyFtJiZkJiZoJiYobT1bbnVsbCxkWzFdLGhbMV1dKTtsZXQgdz0rbVsxXS8rbVsyXSxiPWQmJmg/WytkWzFdLCtoWzFdXTpkP1srZFsxXSwrZFsxXS93XTpoP1sraFsxXSp3LCtoWzFdXTpbK21bMV0sK21bMl1dO0tyLnNldChlLFtwLC4uLmJdKSxyKFtwLC4uLmJdKTtyZXR1cm59Y2F0Y2gocCl7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgU1ZHIGltYWdlOiAke3AubWVzc2FnZX1gKX1sZXQgbyxzO3N3aXRjaChbLi4ubmV3IFVpbnQ4QXJyYXkoYS5zbGljZSgwLDQpKV0ubWFwKHA9PnAudG9TdHJpbmcoMTYpKS5qb2luKFwiXCIpKXtjYXNlXCI4OTUwNGU0N1wiOm89XCJpbWFnZS9wbmdcIixzPUp1KGEpO2JyZWFrO2Nhc2VcIjQ3NDk0NjM4XCI6bz1cImltYWdlL2dpZlwiLHM9UXUoYSk7YnJlYWs7Y2FzZVwiZmZkOGZmZTBcIjpjYXNlXCJmZmQ4ZmZlMVwiOmNhc2VcImZmZDhmZmUyXCI6Y2FzZVwiZmZkOGZmZTNcIjpjYXNlXCJmZmQ4ZmZlOFwiOmNhc2VcImZmZDhmZmVkXCI6Y2FzZVwiZmZkOGZmZGJcIjpvPVwiaW1hZ2UvanBlZ1wiLHM9WHUoYSk7YnJlYWt9aWYoIUt1LmluY2x1ZGVzKG8pKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgaW1hZ2UgdHlwZTogJHtvfHxcInVua25vd25cIn1gKTtsZXQgZj1gZGF0YToke299O2Jhc2U2NCwke1p1KGEpfWA7S3Iuc2V0KGUsW2YsLi4uc10pLHIoW2YsLi4uc10pfSkuY2F0Y2goYT0+e2kobmV3IEVycm9yKGBDYW4ndCBsb2FkIGltYWdlICR7ZX06IGArYS5tZXNzYWdlKSl9KX0pO3JldHVybiBaci5zZXQoZSxuKSxufWFzeW5jIGZ1bmN0aW9uIGVuKGUsdCxuLHIsaSl7bGV0IGE9QWUoKSxvPXsuLi5uLC4uLmxyKFRvW3RdLG4pLC4uLmxyKHIsbil9O2lmKHQ9PT1cImltZ1wiKXtsZXRbcyx1LGxdPWF3YWl0IGZyKGkuc3JjKTtpZih1PT09dm9pZCAwJiZsPT09dm9pZCAwKXtpZihpLndpZHRoPT09dm9pZCAwfHxpLmhlaWdodD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBzaXplIGNhbm5vdCBiZSBkZXRlcm1pbmVkLiBQbGVhc2UgcHJvdmlkZSB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgaW1hZ2UuXCIpO3U9cGFyc2VJbnQoaS53aWR0aCksbD1wYXJzZUludChpLmhlaWdodCl9bGV0IGY9bC91LHA9KG8uYm9yZGVyTGVmdFdpZHRofHwwKSsoby5ib3JkZXJSaWdodFdpZHRofHwwKSsoby5wYWRkaW5nTGVmdHx8MCkrKG8ucGFkZGluZ1JpZ2h0fHwwKSxnPShvLmJvcmRlclRvcFdpZHRofHwwKSsoby5ib3JkZXJCb3R0b21XaWR0aHx8MCkrKG8ucGFkZGluZ1RvcHx8MCkrKG8ucGFkZGluZ0JvdHRvbXx8MCksbT1vLndpZHRofHxpLndpZHRoLGQ9by5oZWlnaHR8fGkuaGVpZ2h0LGg9dHlwZW9mIG0hPVwic3RyaW5nXCImJnR5cGVvZiBkIT1cInN0cmluZ1wiO20hPT12b2lkIDAmJmgmJihtLT1wKSxkIT09dm9pZCAwJiZoJiYoZC09ZyksbT09PXZvaWQgMCYmZD09PXZvaWQgMCYmKG09dSxkPWwpLG09PT12b2lkIDAmJmUuc2V0QXNwZWN0UmF0aW8oMS9mKSxkPT09dm9pZCAwJiZlLnNldEFzcGVjdFJhdGlvKDEvZiksby53aWR0aD1oP20rcDptLG8uaGVpZ2h0PWg/ZCtnOmQsby5fX3NyYz1zfWlmKHQ9PT1cInN2Z1wiKXtsZXQgdT0oaS52aWV3Qm94fHxpLnZpZXdib3gpLnNwbGl0KFwiIFwiKS5tYXAoZz0+cGFyc2VJbnQoZywxMCkpLGw9dVszXS91WzJdLHt3aWR0aDpmLGhlaWdodDpwfT1pO3R5cGVvZiBmPlwidVwiJiZwP3R5cGVvZiBwPT1cInN0cmluZ1wiJiZwLmVuZHNXaXRoKFwiJVwiKT9mPXBhcnNlSW50KHApL2wrXCIlXCI6Zj1wYXJzZUludChwKS9sOnR5cGVvZiBwPlwidVwiJiZmP3R5cGVvZiBmPT1cInN0cmluZ1wiJiZmLmVuZHNXaXRoKFwiJVwiKT9wPXBhcnNlSW50KGYpKmwrXCIlXCI6cD1wYXJzZUludChmKSpsOihmfHwoZj11WzJdKSxwfHwocD11WzNdKSksby53aWR0aHx8KG8ud2lkdGg9Ziksby5oZWlnaHR8fChvLmhlaWdodD1wKX1yZXR1cm4gZS5zZXREaXNwbGF5KGFlKG8uZGlzcGxheSx7ZmxleDphLkRJU1BMQVlfRkxFWCxub25lOmEuRElTUExBWV9OT05FfSxhLkRJU1BMQVlfRkxFWCxcImRpc3BsYXlcIikpLGUuc2V0QWxpZ25Db250ZW50KGFlKG8uYWxpZ25Db250ZW50LHtzdHJldGNoOmEuQUxJR05fU1RSRVRDSCxjZW50ZXI6YS5BTElHTl9DRU5URVIsXCJmbGV4LXN0YXJ0XCI6YS5BTElHTl9GTEVYX1NUQVJULFwiZmxleC1lbmRcIjphLkFMSUdOX0ZMRVhfRU5ELFwic3BhY2UtYmV0d2VlblwiOmEuQUxJR05fU1BBQ0VfQkVUV0VFTixcInNwYWNlLWFyb3VuZFwiOmEuQUxJR05fU1BBQ0VfQVJPVU5ELGJhc2VsaW5lOmEuQUxJR05fQkFTRUxJTkUsbm9ybWFsOmEuQUxJR05fQVVUT30sYS5BTElHTl9BVVRPLFwiYWxpZ25Db250ZW50XCIpKSxlLnNldEFsaWduSXRlbXMoYWUoby5hbGlnbkl0ZW1zLHtzdHJldGNoOmEuQUxJR05fU1RSRVRDSCxjZW50ZXI6YS5BTElHTl9DRU5URVIsXCJmbGV4LXN0YXJ0XCI6YS5BTElHTl9GTEVYX1NUQVJULFwiZmxleC1lbmRcIjphLkFMSUdOX0ZMRVhfRU5ELGJhc2VsaW5lOmEuQUxJR05fQkFTRUxJTkUsbm9ybWFsOmEuQUxJR05fQVVUT30sYS5BTElHTl9GTEVYX1NUQVJULFwiYWxpZ25JdGVtc1wiKSksZS5zZXRBbGlnblNlbGYoYWUoby5hbGlnblNlbGYse3N0cmV0Y2g6YS5BTElHTl9TVFJFVENILGNlbnRlcjphLkFMSUdOX0NFTlRFUixcImZsZXgtc3RhcnRcIjphLkFMSUdOX0ZMRVhfU1RBUlQsXCJmbGV4LWVuZFwiOmEuQUxJR05fRkxFWF9FTkQsYmFzZWxpbmU6YS5BTElHTl9CQVNFTElORSxub3JtYWw6YS5BTElHTl9BVVRPfSxhLkFMSUdOX0FVVE8sXCJhbGlnblNlbGZcIikpLGUuc2V0SnVzdGlmeUNvbnRlbnQoYWUoby5qdXN0aWZ5Q29udGVudCx7Y2VudGVyOmEuSlVTVElGWV9DRU5URVIsXCJmbGV4LXN0YXJ0XCI6YS5KVVNUSUZZX0ZMRVhfU1RBUlQsXCJmbGV4LWVuZFwiOmEuSlVTVElGWV9GTEVYX0VORCxcInNwYWNlLWJldHdlZW5cIjphLkpVU1RJRllfU1BBQ0VfQkVUV0VFTixcInNwYWNlLWFyb3VuZFwiOmEuSlVTVElGWV9TUEFDRV9BUk9VTkR9LGEuSlVTVElGWV9GTEVYX1NUQVJULFwianVzdGlmeUNvbnRlbnRcIikpLGUuc2V0RmxleERpcmVjdGlvbihhZShvLmZsZXhEaXJlY3Rpb24se3JvdzphLkZMRVhfRElSRUNUSU9OX1JPVyxjb2x1bW46YS5GTEVYX0RJUkVDVElPTl9DT0xVTU4sXCJyb3ctcmV2ZXJzZVwiOmEuRkxFWF9ESVJFQ1RJT05fUk9XX1JFVkVSU0UsXCJjb2x1bW4tcmV2ZXJzZVwiOmEuRkxFWF9ESVJFQ1RJT05fQ09MVU1OX1JFVkVSU0V9LGEuRkxFWF9ESVJFQ1RJT05fUk9XLFwiZmxleERpcmVjdGlvblwiKSksZS5zZXRGbGV4V3JhcChhZShvLmZsZXhXcmFwLHt3cmFwOmEuV1JBUF9XUkFQLG5vd3JhcDphLldSQVBfTk9fV1JBUCxcIndyYXAtcmV2ZXJzZVwiOmEuV1JBUF9XUkFQX1JFVkVSU0V9LGEuV1JBUF9OT19XUkFQLFwiZmxleFdyYXBcIikpLHR5cGVvZiBvLmZsZXhCYXNpczxcInVcIiYmZS5zZXRGbGV4QmFzaXMoby5mbGV4QmFzaXMpLGUuc2V0RmxleEdyb3codHlwZW9mIG8uZmxleEdyb3c+XCJ1XCI/MDpvLmZsZXhHcm93KSxlLnNldEZsZXhTaHJpbmsodHlwZW9mIG8uZmxleFNocmluaz5cInVcIj8wOm8uZmxleFNocmluayksdHlwZW9mIG8ubWF4SGVpZ2h0PFwidVwiJiZlLnNldE1heEhlaWdodChvLm1heEhlaWdodCksdHlwZW9mIG8ubWF4V2lkdGg8XCJ1XCImJmUuc2V0TWF4V2lkdGgoby5tYXhXaWR0aCksdHlwZW9mIG8ubWluSGVpZ2h0PFwidVwiJiZlLnNldE1pbkhlaWdodChvLm1pbkhlaWdodCksdHlwZW9mIG8ubWluV2lkdGg8XCJ1XCImJmUuc2V0TWluV2lkdGgoby5taW5XaWR0aCksZS5zZXRPdmVyZmxvdyhhZShvLm92ZXJmbG93LHt2aXNpYmxlOmEuT1ZFUkZMT1dfVklTSUJMRSxoaWRkZW46YS5PVkVSRkxPV19ISURERU59LGEuT1ZFUkZMT1dfVklTSUJMRSxcIm92ZXJmbG93XCIpKSxlLnNldE1hcmdpbihhLkVER0VfVE9QLG8ubWFyZ2luVG9wfHwwKSxlLnNldE1hcmdpbihhLkVER0VfQk9UVE9NLG8ubWFyZ2luQm90dG9tfHwwKSxlLnNldE1hcmdpbihhLkVER0VfTEVGVCxvLm1hcmdpbkxlZnR8fDApLGUuc2V0TWFyZ2luKGEuRURHRV9SSUdIVCxvLm1hcmdpblJpZ2h0fHwwKSxlLnNldEJvcmRlcihhLkVER0VfVE9QLG8uYm9yZGVyVG9wV2lkdGh8fDApLGUuc2V0Qm9yZGVyKGEuRURHRV9CT1RUT00sby5ib3JkZXJCb3R0b21XaWR0aHx8MCksZS5zZXRCb3JkZXIoYS5FREdFX0xFRlQsby5ib3JkZXJMZWZ0V2lkdGh8fDApLGUuc2V0Qm9yZGVyKGEuRURHRV9SSUdIVCxvLmJvcmRlclJpZ2h0V2lkdGh8fDApLGUuc2V0UGFkZGluZyhhLkVER0VfVE9QLG8ucGFkZGluZ1RvcHx8MCksZS5zZXRQYWRkaW5nKGEuRURHRV9CT1RUT00sby5wYWRkaW5nQm90dG9tfHwwKSxlLnNldFBhZGRpbmcoYS5FREdFX0xFRlQsby5wYWRkaW5nTGVmdHx8MCksZS5zZXRQYWRkaW5nKGEuRURHRV9SSUdIVCxvLnBhZGRpbmdSaWdodHx8MCksZS5zZXRQb3NpdGlvblR5cGUoYWUoby5wb3NpdGlvbix7YWJzb2x1dGU6YS5QT1NJVElPTl9UWVBFX0FCU09MVVRFLHJlbGF0aXZlOmEuUE9TSVRJT05fVFlQRV9SRUxBVElWRX0sYS5QT1NJVElPTl9UWVBFX1JFTEFUSVZFLFwicG9zaXRpb25cIikpLHR5cGVvZiBvLnRvcDxcInVcIiYmZS5zZXRQb3NpdGlvbihhLkVER0VfVE9QLG8udG9wKSx0eXBlb2Ygby5ib3R0b208XCJ1XCImJmUuc2V0UG9zaXRpb24oYS5FREdFX0JPVFRPTSxvLmJvdHRvbSksdHlwZW9mIG8ubGVmdDxcInVcIiYmZS5zZXRQb3NpdGlvbihhLkVER0VfTEVGVCxvLmxlZnQpLHR5cGVvZiBvLnJpZ2h0PFwidVwiJiZlLnNldFBvc2l0aW9uKGEuRURHRV9SSUdIVCxvLnJpZ2h0KSx0eXBlb2Ygby5oZWlnaHQ8XCJ1XCI/ZS5zZXRIZWlnaHQoby5oZWlnaHQpOmUuc2V0SGVpZ2h0QXV0bygpLHR5cGVvZiBvLndpZHRoPFwidVwiP2Uuc2V0V2lkdGgoby53aWR0aCk6ZS5zZXRXaWR0aEF1dG8oKSxbbyxYcihvKV19YygpO2MoKTtjKCk7dmFyIEFvPVsxLDAsMCwxLDAsMF07ZnVuY3Rpb24gZWwoZSx0LG4pe2xldCByPVsuLi5Bb107Zm9yKGxldCBpIG9mIGUpe2xldCBhPU9iamVjdC5rZXlzKGkpWzBdLG89aVthXTtpZih0eXBlb2Ygbz09XCJzdHJpbmdcIilpZihhPT09XCJ0cmFuc2xhdGVYXCIpbz1wYXJzZUZsb2F0KG8pLzEwMCp0LGlbYV09bztlbHNlIGlmKGE9PT1cInRyYW5zbGF0ZVlcIilvPXBhcnNlRmxvYXQobykvMTAwKm4saVthXT1vO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRyYW5zZm9ybTogXCIke2F9OiAke299XCIuYCk7bGV0IHM9byx1PVsuLi5Bb107c3dpdGNoKGEpe2Nhc2VcInRyYW5zbGF0ZVhcIjp1WzRdPXM7YnJlYWs7Y2FzZVwidHJhbnNsYXRlWVwiOnVbNV09czticmVhaztjYXNlXCJzY2FsZVwiOnVbMF09cyx1WzNdPXM7YnJlYWs7Y2FzZVwic2NhbGVYXCI6dVswXT1zO2JyZWFrO2Nhc2VcInNjYWxlWVwiOnVbM109czticmVhaztjYXNlXCJyb3RhdGVcIjpsZXQgbD1zKk1hdGguUEkvMTgwLGY9TWF0aC5jb3MobCkscD1NYXRoLnNpbihsKTt1WzBdPWYsdVsxXT1wLHVbMl09LXAsdVszXT1mO2JyZWFrO2Nhc2VcInNrZXdYXCI6dVsyXT1NYXRoLnRhbihzKk1hdGguUEkvMTgwKTticmVhaztjYXNlXCJza2V3WVwiOnVbMV09TWF0aC50YW4ocypNYXRoLlBJLzE4MCk7YnJlYWt9cj1wdCh1LHIpfWUuc3BsaWNlKDAsZS5sZW5ndGgpLGUucHVzaCguLi5yKSxlLl9fcmVzb2x2ZWQ9ITB9ZnVuY3Rpb24gSGUoe2xlZnQ6ZSx0b3A6dCx3aWR0aDpuLGhlaWdodDpyfSxpLGEsbyl7dmFyIGwsZixwLGc7bGV0IHM7aS5fX3Jlc29sdmVkfHxlbChpLG4scik7bGV0IHU9aTtpZihhKXM9dTtlbHNle2xldCBtPShmPW89PW51bGw/dm9pZCAwOm8ueEFic29sdXRlKSE9bnVsbD9mOigobD1vPT1udWxsP3ZvaWQgMDpvLnhSZWxhdGl2ZSkhPW51bGw/bDo1MCkqbi8xMDAsZD0oZz1vPT1udWxsP3ZvaWQgMDpvLnlBYnNvbHV0ZSkhPW51bGw/ZzooKHA9bz09bnVsbD92b2lkIDA6by55UmVsYXRpdmUpIT1udWxsP3A6NTApKnIvMTAwLGg9ZSttLHc9dCtkO3M9cHQoWzEsMCwwLDEsaCx3XSxwdCh1LFsxLDAsMCwxLC1oLC13XSkpLHUuX19wYXJlbnQmJihzPXB0KHUuX19wYXJlbnQscykpLHUuc3BsaWNlKDAsNiwuLi5zKX1yZXR1cm5gbWF0cml4KCR7cy5tYXAobT0+bS50b0ZpeGVkKDIpKS5qb2luKFwiLFwiKX0pYH1mdW5jdGlvbiBJbyh7bGVmdDplLHRvcDp0LHdpZHRoOm4saGVpZ2h0OnIsaXNJbmhlcml0aW5nVHJhbnNmb3JtOml9LGEpe2xldCBvPVwiXCIscz0xO3JldHVybiBhLnRyYW5zZm9ybSYmKG89SGUoe2xlZnQ6ZSx0b3A6dCx3aWR0aDpuLGhlaWdodDpyfSxhLnRyYW5zZm9ybSxpLGEudHJhbnNmb3JtT3JpZ2luKSksYS5vcGFjaXR5IT09dm9pZCAwJiYocz0rYS5vcGFjaXR5KSx7bWF0cml4Om8sb3BhY2l0eTpzfX1mdW5jdGlvbiB0bih7aWQ6ZSxjb250ZW50OnQsZmlsdGVyOm4sbGVmdDpyLHRvcDppLHdpZHRoOmEsaGVpZ2h0Om8sbWF0cml4OnMsb3BhY2l0eTp1LGltYWdlOmwsY2xpcFBhdGhJZDpmLGRlYnVnOnAsc2hhcGU6ZyxkZWNvcmF0aW9uU2hhcGU6bX0sZCl7bGV0IGg9XCJcIjtpZihwJiYoaD1QKFwicmVjdFwiLHt4OnIseTppLW8sd2lkdGg6YSxoZWlnaHQ6byxmaWxsOlwidHJhbnNwYXJlbnRcIixzdHJva2U6XCIjNTc1ZWZmXCIsXCJzdHJva2Utd2lkdGhcIjoxLHRyYW5zZm9ybTpzfHx2b2lkIDAsXCJjbGlwLXBhdGhcIjpmP2B1cmwoIyR7Zn0pYDp2b2lkIDB9KSksbCl7bGV0IGI9e2hyZWY6bCx4OnIseTppLHdpZHRoOmEsaGVpZ2h0Om8sdHJhbnNmb3JtOnN8fHZvaWQgMCxcImNsaXAtcGF0aFwiOmY/YHVybCgjJHtmfSlgOnZvaWQgMCxzdHlsZTpkLmZpbHRlcj9gZmlsdGVyOiR7ZC5maWx0ZXJ9YDp2b2lkIDB9O3JldHVyblsobj9gJHtufTxnIGZpbHRlcj1cInVybCgjc2F0b3JpX3MtJHtlfSlcIj5gOlwiXCIpK1AoXCJpbWFnZVwiLHsuLi5iLG9wYWNpdHk6dSE9PTE/dTp2b2lkIDB9KSsobXx8XCJcIikrKG4/XCI8L2c+XCI6XCJcIikraCxcIlwiXX1sZXQgdz17eDpyLHk6aSx3aWR0aDphLGhlaWdodDpvLFwiZm9udC13ZWlnaHRcIjpkLmZvbnRXZWlnaHQsXCJmb250LXN0eWxlXCI6ZC5mb250U3R5bGUsXCJmb250LXNpemVcIjpkLmZvbnRTaXplLFwiZm9udC1mYW1pbHlcIjpkLmZvbnRGYW1pbHksXCJsZXR0ZXItc3BhY2luZ1wiOmQubGV0dGVyU3BhY2luZ3x8dm9pZCAwLHRyYW5zZm9ybTpzfHx2b2lkIDAsXCJjbGlwLXBhdGhcIjpmP2B1cmwoIyR7Zn0pYDp2b2lkIDAsc3R5bGU6ZC5maWx0ZXI/YGZpbHRlcjoke2QuZmlsdGVyfWA6dm9pZCAwfTtyZXR1cm5bKG4/YCR7bn08ZyBmaWx0ZXI9XCJ1cmwoI3NhdG9yaV9zLSR7ZX0pXCI+YDpcIlwiKStQKFwidGV4dFwiLHsuLi53LGZpbGw6ZC5jb2xvcixvcGFjaXR5OnUhPT0xP3U6dm9pZCAwfSx0KSsobXx8XCJcIikrKG4/XCI8L2c+XCI6XCJcIikraCxnP1AoXCJ0ZXh0XCIsdyx0KTpcIlwiXX1jKCk7ZnVuY3Rpb24gdGwoZSx0LG4pe3JldHVybiBlLnJlcGxhY2UoLyhbTUFdKShbMC05Li1dKyksKFswLTkuLV0rKS9nLGZ1bmN0aW9uKHIsaSxhLG8pe3JldHVybiBpKyhwYXJzZUZsb2F0KGEpK3QpK1wiLFwiKyhwYXJzZUZsb2F0KG8pK24pfSl9ZnVuY3Rpb24gUm8oe2lkOmUsd2lkdGg6dCxoZWlnaHQ6bn0scil7aWYoIXIuc2hhZG93Q29sb3J8fCFyLnNoYWRvd09mZnNldHx8dHlwZW9mIHIuc2hhZG93UmFkaXVzPlwidVwiKXJldHVyblwiXCI7bGV0IGk9ci5zaGFkb3dSYWRpdXMqci5zaGFkb3dSYWRpdXMvNCxhPU1hdGgubWluKHIuc2hhZG93T2Zmc2V0LndpZHRoLWksMCksbz1NYXRoLm1heChyLnNoYWRvd09mZnNldC53aWR0aCtpK3QsdCkscz1NYXRoLm1pbihyLnNoYWRvd09mZnNldC5oZWlnaHQtaSwwKSx1PU1hdGgubWF4KHIuc2hhZG93T2Zmc2V0LmhlaWdodCtpK24sbik7cmV0dXJuYDxkZWZzPjxmaWx0ZXIgaWQ9XCJzYXRvcmlfcy0ke2V9XCIgeD1cIiR7YS90KjEwMH0lXCIgeT1cIiR7cy9uKjEwMH0lXCIgd2lkdGg9XCIkeyhvLWEpL3QqMTAwfSVcIiBoZWlnaHQ9XCIkeyh1LXMpL24qMTAwfSVcIj48ZmVEcm9wU2hhZG93IGR4PVwiJHtyLnNoYWRvd09mZnNldC53aWR0aH1cIiBkeT1cIiR7ci5zaGFkb3dPZmZzZXQuaGVpZ2h0fVwiIHN0ZERldmlhdGlvbj1cIiR7ci5zaGFkb3dSYWRpdXMvMn1cIiBmbG9vZC1jb2xvcj1cIiR7ci5zaGFkb3dDb2xvcn1cIiBmbG9vZC1vcGFjaXR5PVwiMVwiLz48L2ZpbHRlcj48L2RlZnM+YH1mdW5jdGlvbiBjcih7d2lkdGg6ZSxoZWlnaHQ6dCxzaGFwZTpuLG9wYWNpdHk6cixpZDppfSxhKXtpZighYS5ib3hTaGFkb3cpcmV0dXJuIG51bGw7bGV0IG89XCJcIixzPVwiXCI7Zm9yKGxldCB1PWEuYm94U2hhZG93Lmxlbmd0aC0xO3U+PTA7dS0tKXtsZXQgbD1cIlwiLGY9YS5ib3hTaGFkb3dbdV07Zi5zcHJlYWRSYWRpdXMmJmYuaW5zZXQmJihmLnNwcmVhZFJhZGl1cz0tZi5zcHJlYWRSYWRpdXMpO2xldCBwPWYuYmx1clJhZGl1cypmLmJsdXJSYWRpdXMvNCsoZi5zcHJlYWRSYWRpdXN8fDApLGc9TWF0aC5taW4oLXAtKGYuaW5zZXQ/Zi5vZmZzZXRYOjApLDApLG09TWF0aC5tYXgocCtlLShmLmluc2V0P2Yub2Zmc2V0WDowKSxlKSxkPU1hdGgubWluKC1wLShmLmluc2V0P2Yub2Zmc2V0WTowKSwwKSxoPU1hdGgubWF4KHArdC0oZi5pbnNldD9mLm9mZnNldFk6MCksdCksdz1gc2F0b3JpX3MtJHtpfS0ke3V9YCxiPWBzYXRvcmlfbXMtJHtpfS0ke3V9YCxfPWYuc3ByZWFkUmFkaXVzP24ucmVwbGFjZSgnc3Ryb2tlLXdpZHRoPVwiMFwiJyxgc3Ryb2tlLXdpZHRoPVwiJHtmLnNwcmVhZFJhZGl1cyoyfVwiYCk6bjtsKz1QKFwibWFza1wiLHtpZDpiLG1hc2tVbml0czpcInVzZXJTcGFjZU9uVXNlXCJ9LFAoXCJyZWN0XCIse3g6MCx5OjAsd2lkdGg6YS5fdmlld3BvcnRXaWR0aCxoZWlnaHQ6YS5fdmlld3BvcnRIZWlnaHQsZmlsbDpmLmluc2V0P1wiIzAwMFwiOlwiI2ZmZlwifSkrXy5yZXBsYWNlKCdmaWxsPVwiI2ZmZlwiJyxmLmluc2V0PydmaWxsPVwiI2ZmZlwiJzonZmlsbD1cIiMwMDBcIicpLnJlcGxhY2UoJ3N0cm9rZT1cIiNmZmZcIicsXCJcIikpO2xldCBFPV8ucmVwbGFjZSgvZD1cIihbXlwiXSspXCIvLChBLEQpPT4nZD1cIicrdGwoRCxmLm9mZnNldFgsZi5vZmZzZXRZKSsnXCInKS5yZXBsYWNlKC94PVwiKFteXCJdKylcIi8sKEEsRCk9Pid4PVwiJysocGFyc2VGbG9hdChEKStmLm9mZnNldFgpKydcIicpLnJlcGxhY2UoL3k9XCIoW15cIl0rKVwiLywoQSxEKT0+J3k9XCInKyhwYXJzZUZsb2F0KEQpK2Yub2Zmc2V0WSkrJ1wiJyk7Zi5zcHJlYWRSYWRpdXMmJmYuc3ByZWFkUmFkaXVzPDAmJihsKz1QKFwibWFza1wiLHtpZDpiK1wiLW5lZ1wiLG1hc2tVbml0czpcInVzZXJTcGFjZU9uVXNlXCJ9LEUucmVwbGFjZSgnc3Ryb2tlPVwiI2ZmZlwiJywnc3Ryb2tlPVwiIzAwMFwiJykucmVwbGFjZSgvc3Ryb2tlLXdpZHRoPVwiW15cIl0rXCIvLGBzdHJva2Utd2lkdGg9XCIkey1mLnNwcmVhZFJhZGl1cyoyfVwiYCkpKSxmLnNwcmVhZFJhZGl1cyYmZi5zcHJlYWRSYWRpdXM8MCYmKEU9UChcImdcIix7bWFzazpgdXJsKCMke2J9LW5lZylgfSxFKSksbCs9UChcImRlZnNcIix7fSxQKFwiZmlsdGVyXCIse2lkOncseDpgJHtnL2UqMTAwfSVgLHk6YCR7ZC90KjEwMH0lYCx3aWR0aDpgJHsobS1nKS9lKjEwMH0lYCxoZWlnaHQ6YCR7KGgtZCkvdCoxMDB9JWB9LFAoXCJmZUdhdXNzaWFuQmx1clwiLHtzdGREZXZpYXRpb246Zi5ibHVyUmFkaXVzLzIscmVzdWx0OlwiYlwifSkrUChcImZlRmxvb2RcIix7XCJmbG9vZC1jb2xvclwiOmYuY29sb3IsaW46XCJTb3VyY2VHcmFwaGljXCIscmVzdWx0OlwiZlwifSkrUChcImZlQ29tcG9zaXRlXCIse2luOlwiZlwiLGluMjpcImJcIixvcGVyYXRvcjpmLmluc2V0P1wib3V0XCI6XCJpblwifSkpKStQKFwiZ1wiLHttYXNrOmB1cmwoIyR7Yn0pYCxmaWx0ZXI6YHVybCgjJHt3fSlgLG9wYWNpdHk6cn0sRSksZi5pbnNldD9zKz1sOm8rPWx9cmV0dXJuW28sc119YygpO2Z1bmN0aW9uIHJuKHt3aWR0aDplLGxlZnQ6dCx0b3A6bixhc2NlbmRlcjpyLGNsaXBQYXRoSWQ6aX0sYSl7bGV0e3RleHREZWNvcmF0aW9uQ29sb3I6byx0ZXh0RGVjb3JhdGlvblN0eWxlOnMsdGV4dERlY29yYXRpb25MaW5lOnUsZm9udFNpemU6bH09YTtpZighdXx8dT09PVwibm9uZVwiKXJldHVyblwiXCI7bGV0IGY9TWF0aC5tYXgoMSxsKi4xKSxwPXU9PT1cImxpbmUtdGhyb3VnaFwiP24rciouNTp1PT09XCJ1bmRlcmxpbmVcIj9uK3IqMS4xOm4sZz1zPT09XCJkYXNoZWRcIj9gJHtmKjEuMn0gJHtmKjJ9YDpzPT09XCJkb3R0ZWRcIj9gMCAke2YqMn1gOnZvaWQgMDtyZXR1cm4gUChcImxpbmVcIix7eDE6dCx5MTpwLHgyOnQrZSx5MjpwLHN0cm9rZTpvLFwic3Ryb2tlLXdpZHRoXCI6ZixcInN0cm9rZS1kYXNoYXJyYXlcIjpnLFwic3Ryb2tlLWxpbmVjYXBcIjpzPT09XCJkb3R0ZWRcIj9cInJvdW5kXCI6XCJzcXVhcmVcIixcImNsaXAtcGF0aFwiOmk/YHVybCgjJHtpfSlgOnZvaWQgMH0pfXZhciBubj12b2lkIDA7YXN5bmMgZnVuY3Rpb24qb24oZSx0KXt2YXIgdW87bGV0IG49QWUoKSx7cGFyZW50U3R5bGU6cixpbmhlcml0ZWRTdHlsZTppLHBhcmVudDphLGZvbnQ6byxpZDpzLGlzSW5oZXJpdGluZ1RyYW5zZm9ybTp1LGRlYnVnOmwsZW1iZWRGb250OmYsZ3JhcGhlbWVJbWFnZXM6cCxjYW5Mb2FkQWRkaXRpb25hbEFzc2V0czpnfT10O3IudGV4dFRyYW5zZm9ybT09PVwidXBwZXJjYXNlXCI/ZT1lLnRvTG9jYWxlVXBwZXJDYXNlKG5uKTpyLnRleHRUcmFuc2Zvcm09PT1cImxvd2VyY2FzZVwiP2U9ZS50b0xvY2FsZUxvd2VyQ2FzZShubik6ci50ZXh0VHJhbnNmb3JtPT09XCJjYXBpdGFsaXplXCImJihlPWplKGUsXCJ3b3JkXCIpLm1hcChIPT5qZShILFwiZ3JhcGhlbWVcIikubWFwKChZLFgpPT5YPT09MD9ZLnRvTG9jYWxlVXBwZXJDYXNlKG5uKTpZKS5qb2luKFwiXCIpKS5qb2luKFwiXCIpKTtsZXQgbT1hZShyLndvcmRCcmVhayx7bm9ybWFsOlwid29yZFwiLFwiYnJlYWstYWxsXCI6XCJncmFwaGVtZVwiLFwiYnJlYWstd29yZFwiOlwiZ3JhcGhlbWVcIixcImtlZXAtYWxsXCI6XCJ3b3JkXCJ9LFwid29yZFwiLFwid29yZEJyZWFrXCIpLGQ9amUoZSxtKSxoPW4uTm9kZS5jcmVhdGUoKTtoLnNldEFsaWduSXRlbXMobi5BTElHTl9CQVNFTElORSksaC5zZXRKdXN0aWZ5Q29udGVudChhZShyLnRleHRBbGlnbix7bGVmdDpuLkpVU1RJRllfRkxFWF9TVEFSVCxyaWdodDpuLkpVU1RJRllfRkxFWF9FTkQsY2VudGVyOm4uSlVTVElGWV9DRU5URVIsanVzdGlmeTpuLkpVU1RJRllfU1BBQ0VfQkVUV0VFTixzdGFydDpuLkpVU1RJRllfRkxFWF9TVEFSVCxlbmQ6bi5KVVNUSUZZX0ZMRVhfRU5EfSxuLkpVU1RJRllfRkxFWF9TVEFSVCxcInRleHRBbGlnblwiKSksYS5pbnNlcnRDaGlsZChoLGEuZ2V0Q2hpbGRDb3VudCgpKTtsZXR7dGV4dEFsaWduOncsdGV4dE92ZXJmbG93OmIsd2hpdGVTcGFjZTpfLGxpbmVIZWlnaHQ6RSxmaWx0ZXI6QSxfaW5oZXJpdGVkQmFja2dyb3VuZENsaXBUZXh0UGF0aDpEfT1yLE09ci5mb250U2l6ZSxMPW8uZ2V0RW5naW5lKE0sRSxyKSxGPWc/ZC5maWx0ZXIoSD0+IUwuaGFzKEgpKTpbXTt5aWVsZCBGLEYubGVuZ3RoJiYoTD1vLmdldEVuZ2luZShNLEUscikpO2xldCBOPVtdLFU9W10scT1bXSxLPVtdLGVlPW5ldyBNYXAsej1IPT57bGV0IFk9MDtmb3IobGV0IFggb2YgSCl7aWYoZWUuaGFzKFgpKXtZKz1lZS5nZXQoWCk7Y29udGludWV9bGV0IHVlPUwubWVhc3VyZShYLHIpO2VlLnNldChYLHVlKSxZKz11ZX1yZXR1cm4gWX0sWj0wLHNlPVtdLEM9MDtmb3IobGV0IEggb2YgZCl7bGV0IFk9ITEsWD1wJiZwW0hdO189PT1cInByZVwiP1k9SFswXT09PWBcbmA6XyE9PVwibm93cmFwXCImJihYfHx1ci5pbmNsdWRlcyhIWzBdKSkmJihZPSEwKSxZPyhfPT09XCJub3dyYXBcIj9DKz16KHNlKStyLmZvbnRTaXplOihaPU1hdGgubWF4KFoseihzZSkpLFgmJihaPU1hdGgubWF4KFosci5mb250U2l6ZSkpKSxzZT1bXSk6KCF1ci5pbmNsdWRlcyhIWzBdKXx8IXNlLmxlbmd0aCkmJnNlLnB1c2goSD09PWBcbmA/XCIgXCI6SCl9Wj1NYXRoLm1heChaLHooc2UpK0MpO2xldCBJPWEuZ2V0TWluV2lkdGgoKSxCPWEuZ2V0TWF4V2lkdGgoKSxTZT1hLmdldFdpZHRoKCk7aXNOYU4oU2UudmFsdWUpJiYoaXNOYU4oSS52YWx1ZSl8fEkudW5pdD09PTEmJkkudmFsdWU+WikmJihpc05hTihCLnZhbHVlKXx8Qi51bml0PT09MSYmKFo9TWF0aC5taW4oWixCLnZhbHVlKSksYS5zZXRNaW5XaWR0aChaKSksdHlwZW9mIHIuZmxleFNocmluaz5cInVcIiYmYS5zZXRGbGV4U2hyaW5rKDEpO2xldCBOcj1fPT09XCJwcmUtd3JhcFwifHxfPT09XCJwcmVcIjtoLnNldE1lYXN1cmVGdW5jKEg9PntsZXQgWT0wLFg9XCJcIix1ZT0wLGRlPTAscGU9MCxoZT0tMSxCZT0wLHRlPTAsVWU9MDtOPVtdLHE9WzBdO2ZvcihsZXQgRGU9MDtEZTxkLmxlbmd0aDtEZSsrKXtsZXQgaWU9ZFtEZV07aWYoIU5yJiZ1ci5pbmNsdWRlcyhpZVswXSkpWHx8KFg9XCIgXCIpLHVlPXooW1hdKSxLW0RlXT1udWxsO2Vsc2V7bGV0IHplPU5yJiZpZT09PWBcbmAsbWU9emU/MDpwJiZwW2llXT9yLmZvbnRTaXplOnooW2llXSk7ZGV8fChYPVwiXCIsdWU9MCk7bGV0IG9lPXVlfHxcIiwuIT86LUApPl19JSNcIi5pbmRleE9mKGllWzBdKTwwLGdlPSFkZXx8ISF1ZTtpZih6ZXx8RGUmJm9lJiZkZSt1ZSttZT5IJiZfIT09XCJub3dyYXBcIiYmXyE9PVwicHJlXCIpTi5wdXNoKGRlKSxVLnB1c2goVWUpLFkrKyxCZSs9dGUsZGU9bWUsdGU9bWU/TC5oZWlnaHQoaWUpOjAsVWU9bWU/TC5iYXNlbGluZShpZSk6MCxxLnB1c2goMSksaGU9LTEsemV8fChwZT1NYXRoLm1heChwZSxIKSk7ZWxzZXtkZSs9dWUrbWU7bGV0IG50PUwuaGVpZ2h0KGllKTtudD50ZSYmKHRlPW50LFVlPUwuYmFzZWxpbmUoaWUpKSxnZSYmcVtxLmxlbmd0aC0xXSsrfVg9XCJcIix1ZT0wLGdlJiZoZSsrLHBlPU1hdGgubWF4KHBlLGRlKSxLW0RlXT17eTpCZSx4OmRlLW1lLHdpZHRoOm1lLGxpbmU6WSxsaW5lSW5kZXg6aGV9fX1yZXR1cm4gZGUmJihZKyssTi5wdXNoKGRlKSxVLnB1c2goVWUpLEJlKz10ZSkse3dpZHRoOnBlLGhlaWdodDpCZX19KTtsZXRbZnQsYnVdPXlpZWxkLFdyPVwiXCIsWnQ9XCJcIixDZT1pLl9pbmhlcml0ZWRDbGlwUGF0aElkLHJvPWkuX2luaGVyaXRlZE1hc2tJZCx7bGVmdDpubyx0b3A6aW8sd2lkdGg6ZXIsaGVpZ2h0Om9vfT1oLmdldENvbXB1dGVkTGF5b3V0KCksJHI9YS5nZXRDb21wdXRlZFdpZHRoKCktYS5nZXRDb21wdXRlZFBhZGRpbmcobi5FREdFX0xFRlQpLWEuZ2V0Q29tcHV0ZWRQYWRkaW5nKG4uRURHRV9SSUdIVCktYS5nZXRDb21wdXRlZEJvcmRlcihuLkVER0VfTEVGVCktYS5nZXRDb21wdXRlZEJvcmRlcihuLkVER0VfUklHSFQpLHR0PWZ0K25vLHJ0PWJ1K2lvLHttYXRyaXg6UGUsb3BhY2l0eTp0cn09SW8oe2xlZnQ6bm8sdG9wOmlvLHdpZHRoOmVyLGhlaWdodDpvbyxpc0luaGVyaXRpbmdUcmFuc2Zvcm06dX0scikscnI9XCJcIjtyLnRleHRTaGFkb3dPZmZzZXQmJihycj1Sbyh7d2lkdGg6ZXIsaGVpZ2h0Om9vLGlkOnN9LHtzaGFkb3dDb2xvcjpyLnRleHRTaGFkb3dDb2xvcixzaGFkb3dPZmZzZXQ6ci50ZXh0U2hhZG93T2Zmc2V0LHNoYWRvd1JhZGl1czpyLnRleHRTaGFkb3dSYWRpdXN9KSk7bGV0IGN0PVwiXCIsbnI9XCJcIixhbz1cIlwiLHFyPS0xLHNvPWI9PT1cImVsbGlwc2lzXCI/eihbXCJcXHUyMDI2XCJdKTowLHl1PWI9PT1cImVsbGlwc2lzXCI/eihbXCIgXCJdKTowLGlyPXt9O2ZvcihsZXQgSD0wO0g8ZC5sZW5ndGg7SCsrKXtpZighS1tIXSljb250aW51ZTtsZXQgWT1LW0hdLFg9ZFtIXSx1ZT1udWxsLGRlPXA/cFtYXTpudWxsLHBlPVkueSxoZT1ZLngsQmU9WS53aWR0aCx0ZT1ZLmxpbmU7aWYodGU9PT1xciljb250aW51ZTtsZXQgVWU9ITE7aWYoTi5sZW5ndGg+MSl7bGV0IG9lPWVyLU5bdGVdO2lmKHc9PT1cInJpZ2h0XCJ8fHc9PT1cImVuZFwiKWhlKz1vZTtlbHNlIGlmKHc9PT1cImNlbnRlclwiKWhlKz1vZS8yO2Vsc2UgaWYodz09PVwianVzdGlmeVwiJiZ0ZTxOLmxlbmd0aC0xKXtsZXQgZ2U9cVt0ZV07aGUrPShnZT4xP29lLyhnZS0xKTowKSpZLmxpbmVJbmRleCxVZT0hMH19aWYoaXJbdGVdfHwoaXJbdGVdPVtoZSxVZT9lcjpOW3RlXV0pLGI9PT1cImVsbGlwc2lzXCImJk5bdGVdPiRyJiZZLngrQmUrc28reXU+JHIpe2xldCBvZT1qZShYLFwiZ3JhcGhlbWVcIiksZ2U9XCJcIixudD0wO2ZvcihsZXQgbG8gb2Ygb2Upe2xldCBmbz1ZLngreihbZ2UrbG9dKTtpZihnZSYmZm8rc28+JHIpYnJlYWs7Z2UrPWxvLG50PWZvfVg9Z2UrXCJcXHUyMDI2XCIscXI9dGUsaXJbdGVdWzFdPW50fWxldCBEZT1VW3RlXSxpZT1MLmJhc2VsaW5lKFgpLHplPUwuaGVpZ2h0KFgpLG1lPURlLWllO2lmKGRlP3BlKz0wOmY/KHVlPUwuZ2V0U1ZHKFgsey4uLnIsbGVmdDp0dCtoZSx0b3A6cnQrcGUraWUrbWUsbGV0dGVyU3BhY2luZzpyLmxldHRlclNwYWNpbmd9KSxsJiYoYW8rPVAoXCJyZWN0XCIse3g6dHQraGUseTpydCtwZSttZSx3aWR0aDpZLndpZHRoLGhlaWdodDp6ZSxmaWxsOlwidHJhbnNwYXJlbnRcIixzdHJva2U6XCIjNTc1ZWZmXCIsXCJzdHJva2Utd2lkdGhcIjoxLHRyYW5zZm9ybTpQZXx8dm9pZCAwLFwiY2xpcC1wYXRoXCI6Q2U/YHVybCgjJHtDZX0pYDp2b2lkIDB9KStQKFwibGluZVwiLHt4MTp0dCtoZSx4Mjp0dCtoZStZLndpZHRoLHkxOnJ0K3BlK21lK2llLHkyOnJ0K3BlK21lK2llLHN0cm9rZTpcIiMxNGMwMDBcIixcInN0cm9rZS13aWR0aFwiOjEsdHJhbnNmb3JtOlBlfHx2b2lkIDAsXCJjbGlwLXBhdGhcIjpDZT9gdXJsKCMke0NlfSlgOnZvaWQgMH0pKSk6cGUrPWllK21lLHIudGV4dERlY29yYXRpb25MaW5lJiYodGUhPT0oKHVvPUtbSCsxXSk9PW51bGw/dm9pZCAwOnVvLmxpbmUpfHxxcj09PXRlKSl7bGV0IG9lPWlyW3RlXTtvZSYmIW9lWzJdJiYoY3QrPXJuKHtsZWZ0OnR0K29lWzBdLHRvcDpydCt6ZSordGUsd2lkdGg6b2VbMV0sYXNjZW5kZXI6TC5iYXNlbGluZShYKSxjbGlwUGF0aElkOkNlfSxyKSxvZVsyXT0xKX1pZih1ZSE9PW51bGwpbnIrPXVlK1wiIFwiO2Vsc2V7bGV0W29lLGdlXT10bih7Y29udGVudDpYLGZpbHRlcjpycixpZDpzLGxlZnQ6dHQraGUsdG9wOnJ0K3BlLHdpZHRoOkJlLGhlaWdodDp6ZSxtYXRyaXg6UGUsb3BhY2l0eTp0cixpbWFnZTpkZSxjbGlwUGF0aElkOkNlLGRlYnVnOmwsc2hhcGU6ISFELGRlY29yYXRpb25TaGFwZTpjdH0scik7V3IrPW9lLFp0Kz1nZSxjdD1cIlwifX1pZihucil7bGV0IEg9ci5jb2xvciE9PVwidHJhbnNwYXJlbnRcIiYmdHIhPT0wP1AoXCJwYXRoXCIse2ZpbGw6ci5jb2xvcixkOm5yLHRyYW5zZm9ybTpQZXx8dm9pZCAwLG9wYWNpdHk6dHIhPT0xP3RyOnZvaWQgMCxcImNsaXAtcGF0aFwiOkNlP2B1cmwoIyR7Q2V9KWA6dm9pZCAwLG1hc2s6cm8/YHVybCgjJHtyb30pYDp2b2lkIDAsc3R5bGU6QT9gZmlsdGVyOiR7QX1gOnZvaWQgMH0pOlwiXCI7RCYmKFp0PVAoXCJwYXRoXCIse2Q6bnIsdHJhbnNmb3JtOlBlfHx2b2lkIDB9KSksV3IrPShycj9ycitQKFwiZ1wiLHtmaWx0ZXI6YHVybCgjc2F0b3JpX3MtJHtzfSlgfSxIK2N0KTpIK2N0KSthb31yZXR1cm4gWnQmJihyLl9pbmhlcml0ZWRCYWNrZ3JvdW5kQ2xpcFRleHRQYXRoLnZhbHVlKz1adCksV3J9YygpO2MoKTtjKCk7dmFyIGFuPWFufHx7fSxMbz17dHlwZTpcImRpcmVjdGlvbmFsXCIsdmFsdWU6XCJib3R0b21cIn07YW4ucGFyc2U9ZnVuY3Rpb24oKXt2YXIgZT17bGluZWFyR3JhZGllbnQ6L14oXFwtKHdlYmtpdHxvfG1zfG1veilcXC0pPyhsaW5lYXJcXC1ncmFkaWVudCkvaSxyZXBlYXRpbmdMaW5lYXJHcmFkaWVudDovXihcXC0od2Via2l0fG98bXN8bW96KVxcLSk/KHJlcGVhdGluZ1xcLWxpbmVhclxcLWdyYWRpZW50KS9pLHJhZGlhbEdyYWRpZW50Oi9eKFxcLSh3ZWJraXR8b3xtc3xtb3opXFwtKT8ocmFkaWFsXFwtZ3JhZGllbnQpL2kscmVwZWF0aW5nUmFkaWFsR3JhZGllbnQ6L14oXFwtKHdlYmtpdHxvfG1zfG1veilcXC0pPyhyZXBlYXRpbmdcXC1yYWRpYWxcXC1ncmFkaWVudCkvaSxzaWRlT3JDb3JuZXI6L150byAobGVmdCAodG9wfGJvdHRvbSl8cmlnaHQgKHRvcHxib3R0b20pfHRvcCAobGVmdHxyaWdodCl8Ym90dG9tIChsZWZ0fHJpZ2h0KXxsZWZ0fHJpZ2h0fHRvcHxib3R0b20pL2ksZXh0ZW50S2V5d29yZHM6L14oY2xvc2VzdFxcLXNpZGV8Y2xvc2VzdFxcLWNvcm5lcnxmYXJ0aGVzdFxcLXNpZGV8ZmFydGhlc3RcXC1jb3JuZXJ8Y29udGFpbnxjb3ZlcikvLHBvc2l0aW9uS2V5d29yZHM6L14obGVmdHxjZW50ZXJ8cmlnaHR8dG9wfGJvdHRvbSkvaSxwaXhlbFZhbHVlOi9eKC0/KChbMC05XSpcXC5bMC05XSspfChbMC05XStcXC4/KSkpcHgvLHBlcmNlbnRhZ2VWYWx1ZTovXigtPygoWzAtOV0qXFwuWzAtOV0rKXwoWzAtOV0rXFwuPykpKVxcJS8sZW1WYWx1ZTovXigtPygoWzAtOV0qXFwuWzAtOV0rKXwoWzAtOV0rXFwuPykpKWVtLyxhbmdsZVZhbHVlOi9eKC0/KChbMC05XSpcXC5bMC05XSspfChbMC05XStcXC4/KSkpZGVnLyxzdGFydENhbGw6L15cXCgvLGVuZENhbGw6L15cXCkvLGNvbW1hOi9eLC8saGV4Q29sb3I6L15cXCMoWzAtOWEtZkEtRl0rKS8sbGl0ZXJhbENvbG9yOi9eKFthLXpBLVpdKykvLHJnYkNvbG9yOi9ecmdiL2kscmdiYUNvbG9yOi9ecmdiYS9pLG51bWJlcjovXigoWzAtOV0qXFwuWzAtOV0rKXwoWzAtOV0rXFwuPykpL30sdD1cIlwiO2Z1bmN0aW9uIG4oQyl7dmFyIEk9bmV3IEVycm9yKHQrXCI6IFwiK0MpO3Rocm93IEkuc291cmNlPXQsSX1mdW5jdGlvbiByKCl7dmFyIEM9aSgpO3JldHVybiB0Lmxlbmd0aD4wJiZuKFwiSW52YWxpZCBpbnB1dCBub3QgRU9GXCIpLEN9ZnVuY3Rpb24gaSgpe3JldHVybiBFKGEpfWZ1bmN0aW9uIGEoKXtyZXR1cm4gbyhcImxpbmVhci1ncmFkaWVudFwiLGUubGluZWFyR3JhZGllbnQsdSxMbyl8fG8oXCJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50XCIsZS5yZXBlYXRpbmdMaW5lYXJHcmFkaWVudCx1LExvKXx8byhcInJhZGlhbC1ncmFkaWVudFwiLGUucmFkaWFsR3JhZGllbnQscCl8fG8oXCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50XCIsZS5yZXBlYXRpbmdSYWRpYWxHcmFkaWVudCxwKX1mdW5jdGlvbiBvKEMsSSxCLFNlKXtyZXR1cm4gcyhJLGZ1bmN0aW9uKE5yKXt2YXIgZnQ9QigpO3JldHVybiBmdD9aKGUuY29tbWEpfHxuKFwiTWlzc2luZyBjb21tYSBiZWZvcmUgY29sb3Igc3RvcHNcIik6ZnQ9U2Use3R5cGU6QyxvcmllbnRhdGlvbjpmdCxjb2xvclN0b3BzOkUoQSl9fSl9ZnVuY3Rpb24gcyhDLEkpe3ZhciBCPVooQyk7aWYoQil7WihlLnN0YXJ0Q2FsbCl8fG4oXCJNaXNzaW5nIChcIik7dmFyIFNlPUkoQik7cmV0dXJuIFooZS5lbmRDYWxsKXx8bihcIk1pc3NpbmcgKVwiKSxTZX19ZnVuY3Rpb24gdSgpe3JldHVybiBsKCl8fGYoKX1mdW5jdGlvbiBsKCl7cmV0dXJuIHooXCJkaXJlY3Rpb25hbFwiLGUuc2lkZU9yQ29ybmVyLDEpfWZ1bmN0aW9uIGYoKXtyZXR1cm4geihcImFuZ3VsYXJcIixlLmFuZ2xlVmFsdWUsMSl9ZnVuY3Rpb24gcCgpe3ZhciBDLEk9ZygpLEI7cmV0dXJuIEkmJihDPVtdLEMucHVzaChJKSxCPXQsWihlLmNvbW1hKSYmKEk9ZygpLEk/Qy5wdXNoKEkpOnQ9QikpLEN9ZnVuY3Rpb24gZygpe3ZhciBDPW0oKXx8ZCgpO2lmKEMpQy5hdD13KCk7ZWxzZXt2YXIgST1oKCk7aWYoSSl7Qz1JO3ZhciBCPXcoKTtCJiYoQy5hdD1CKX1lbHNle3ZhciBTZT1iKCk7U2UmJihDPXt0eXBlOlwiZGVmYXVsdC1yYWRpYWxcIixhdDpTZX0pfX1yZXR1cm4gQ31mdW5jdGlvbiBtKCl7dmFyIEM9eihcInNoYXBlXCIsL14oY2lyY2xlKS9pLDApO3JldHVybiBDJiYoQy5zdHlsZT1lZSgpfHxoKCkpLEN9ZnVuY3Rpb24gZCgpe3ZhciBDPXooXCJzaGFwZVwiLC9eKGVsbGlwc2UpL2ksMCk7cmV0dXJuIEMmJihDLnN0eWxlPXEoKXx8aCgpKSxDfWZ1bmN0aW9uIGgoKXtyZXR1cm4geihcImV4dGVudC1rZXl3b3JkXCIsZS5leHRlbnRLZXl3b3JkcywxKX1mdW5jdGlvbiB3KCl7aWYoeihcInBvc2l0aW9uXCIsL15hdC8sMCkpe3ZhciBDPWIoKTtyZXR1cm4gQ3x8bihcIk1pc3NpbmcgcG9zaXRpb25pbmcgdmFsdWVcIiksQ319ZnVuY3Rpb24gYigpe3ZhciBDPV8oKTtpZihDLnh8fEMueSlyZXR1cm57dHlwZTpcInBvc2l0aW9uXCIsdmFsdWU6Q319ZnVuY3Rpb24gXygpe3JldHVybnt4OnEoKSx5OnEoKX19ZnVuY3Rpb24gRShDKXt2YXIgST1DKCksQj1bXTtpZihJKWZvcihCLnB1c2goSSk7WihlLmNvbW1hKTspST1DKCksST9CLnB1c2goSSk6bihcIk9uZSBleHRyYSBjb21tYVwiKTtyZXR1cm4gQn1mdW5jdGlvbiBBKCl7dmFyIEM9RCgpO3JldHVybiBDfHxuKFwiRXhwZWN0ZWQgY29sb3IgZGVmaW5pdGlvblwiKSxDLmxlbmd0aD1xKCksQ31mdW5jdGlvbiBEKCl7cmV0dXJuIEwoKXx8TigpfHxGKCl8fE0oKX1mdW5jdGlvbiBNKCl7cmV0dXJuIHooXCJsaXRlcmFsXCIsZS5saXRlcmFsQ29sb3IsMCl9ZnVuY3Rpb24gTCgpe3JldHVybiB6KFwiaGV4XCIsZS5oZXhDb2xvciwxKX1mdW5jdGlvbiBGKCl7cmV0dXJuIHMoZS5yZ2JDb2xvcixmdW5jdGlvbigpe3JldHVybnt0eXBlOlwicmdiXCIsdmFsdWU6RShVKX19KX1mdW5jdGlvbiBOKCl7cmV0dXJuIHMoZS5yZ2JhQ29sb3IsZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcInJnYmFcIix2YWx1ZTpFKFUpfX0pfWZ1bmN0aW9uIFUoKXtyZXR1cm4gWihlLm51bWJlcilbMV19ZnVuY3Rpb24gcSgpe3JldHVybiB6KFwiJVwiLGUucGVyY2VudGFnZVZhbHVlLDEpfHxLKCl8fGVlKCl9ZnVuY3Rpb24gSygpe3JldHVybiB6KFwicG9zaXRpb24ta2V5d29yZFwiLGUucG9zaXRpb25LZXl3b3JkcywxKX1mdW5jdGlvbiBlZSgpe3JldHVybiB6KFwicHhcIixlLnBpeGVsVmFsdWUsMSl8fHooXCJlbVwiLGUuZW1WYWx1ZSwxKX1mdW5jdGlvbiB6KEMsSSxCKXt2YXIgU2U9WihJKTtpZihTZSlyZXR1cm57dHlwZTpDLHZhbHVlOlNlW0JdfX1mdW5jdGlvbiBaKEMpe3ZhciBJLEI7cmV0dXJuIEI9L15bXFxuXFxyXFx0XFxzXSsvLmV4ZWModCksQiYmc2UoQlswXS5sZW5ndGgpLEk9Qy5leGVjKHQpLEkmJnNlKElbMF0ubGVuZ3RoKSxJfWZ1bmN0aW9uIHNlKEMpe3Q9dC5zdWJzdHIoQyl9cmV0dXJuIGZ1bmN0aW9uKEMpe3JldHVybiB0PUMudG9TdHJpbmcoKSxyKCl9fSgpO3ZhciBzbj1hbjtmdW5jdGlvbiBybChlKXtyZXR1cm4gZS50eXBlPT09XCJsaXRlcmFsXCI/ZS52YWx1ZTplLnR5cGU9PT1cImhleFwiP2AjJHtlLnZhbHVlfWA6ZS50eXBlPT09XCJyZ2JcIj9gcmdiKCR7ZS52YWx1ZS5qb2luKFwiLFwiKX0pYDplLnR5cGU9PT1cInJnYmFcIj9gcmdiYSgke2UudmFsdWUuam9pbihcIixcIil9KWA6XCJ0cmFuc3BhcmVudFwifWZ1bmN0aW9uIG5sKGUsdCl7cmV0dXJuIHR5cGVvZiBlPT1cInN0cmluZ1wiJiZlLmVuZHNXaXRoKFwiJVwiKT90KnBhcnNlRmxvYXQoZSkvMTAwOitlfWZ1bmN0aW9uIHVuKGUse3g6dCx5Om4sZGVmYXVsdFg6cixkZWZhdWx0WTppfSl7cmV0dXJuKGU/ZS5zcGxpdChcIiBcIikubWFwKGE9Pnt0cnl7bGV0IG89bmV3IEZlKGEpO3JldHVybiBvLnR5cGU9PT1cImxlbmd0aFwifHxvLnR5cGU9PT1cIm51bWJlclwiP28udmFsdWU6by52YWx1ZStvLnVuaXR9Y2F0Y2h7cmV0dXJuIG51bGx9fSkuZmlsdGVyKGE9PmEhPT1udWxsKTpbcixpXSkubWFwKChhLG8pPT5ubChhLFt0LG5dW29dKSl9ZnVuY3Rpb24gQ28oZSx0KXtsZXQgbj1bXTtmb3IobGV0IG8gb2YgdCl7bGV0IHM9cmwobyk7aWYoIW4ubGVuZ3RoJiYobi5wdXNoKHtvZmZzZXQ6MCxjb2xvcjpzfSksdHlwZW9mIG8ubGVuZ3RoPlwidVwifHxvLmxlbmd0aC52YWx1ZT09PVwiMFwiKSljb250aW51ZTtsZXQgdT10eXBlb2Ygby5sZW5ndGg+XCJ1XCI/dm9pZCAwOm8ubGVuZ3RoLnR5cGU9PT1cIiVcIj9vLmxlbmd0aC52YWx1ZS8xMDA6by5sZW5ndGgudmFsdWUvZTtuLnB1c2goe29mZnNldDp1LGNvbG9yOnN9KX1uLmxlbmd0aHx8bi5wdXNoKHtvZmZzZXQ6MCxjb2xvcjpcInRyYW5zcGFyZW50XCJ9KTtsZXQgcj1uW24ubGVuZ3RoLTFdO3Iub2Zmc2V0IT09MSYmKHR5cGVvZiByLm9mZnNldD5cInVcIj9yLm9mZnNldD0xOm4ucHVzaCh7b2Zmc2V0OjEsY29sb3I6ci5jb2xvcn0pKTtsZXQgaT0wLGE9MTtmb3IobGV0IG89MDtvPG4ubGVuZ3RoO28rKylpZih0eXBlb2YgbltvXS5vZmZzZXQ+XCJ1XCIpe2ZvcihhPG8mJihhPW8pO3R5cGVvZiBuW2FdLm9mZnNldD5cInVcIjspYSsrO25bb10ub2Zmc2V0PShuW2FdLm9mZnNldC1uW2ldLm9mZnNldCkvKGEtaSkqKG8taSkrbltpXS5vZmZzZXR9ZWxzZSBpPW87cmV0dXJuIG59YXN5bmMgZnVuY3Rpb24gbG4oe2lkOmUsd2lkdGg6dCxoZWlnaHQ6bn0se2ltYWdlOnIsc2l6ZTppLHBvc2l0aW9uOmEscmVwZWF0Om99KXtvPW98fFwicmVwZWF0XCI7bGV0IHM9bz09PVwicmVwZWF0LXhcInx8bz09PVwicmVwZWF0XCIsdT1vPT09XCJyZXBlYXQteVwifHxvPT09XCJyZXBlYXRcIixsPXVuKGkse3g6dCx5Om4sZGVmYXVsdFg6dCxkZWZhdWx0WTpufSksZj11bihhLHt4OnQseTpuLGRlZmF1bHRYOjAsZGVmYXVsdFk6MH0pO2lmKHIuc3RhcnRzV2l0aChcImxpbmVhci1ncmFkaWVudChcIikpe2xldCBwPXNuLnBhcnNlKHIpWzBdLFtnLG1dPWwsZCxoLHcsYjtpZihwLm9yaWVudGF0aW9uLnR5cGU9PT1cImRpcmVjdGlvbmFsXCIpW2QsaCx3LGJdPXt0b3A6WzAsMSwwLDBdLGJvdHRvbTpbMCwwLDAsMV0sbGVmdDpbMSwwLDAsMF0scmlnaHQ6WzAsMCwxLDBdfVtwLm9yaWVudGF0aW9uLnZhbHVlXTtlbHNlIGlmKHAub3JpZW50YXRpb24udHlwZT09PVwiYW5ndWxhclwiKXtsZXQgTT0rcC5vcmllbnRhdGlvbi52YWx1ZS8xODAqTWF0aC5QSS1NYXRoLlBJLzIsTD1NYXRoLmNvcyhNKSxGPU1hdGguc2luKE0pO2Q9MCxoPTAsdz1MLGI9Rix3PDAmJihkLT13LHc9MCksYjwwJiYoaC09YixiPTApfWxldCBfPUNvKHQscC5jb2xvclN0b3BzKSxFPWBzYXRvcmlfYmkke2V9YCxBPWBzYXRvcmlfcGF0dGVybl8ke2V9YCxEPVAoXCJwYXR0ZXJuXCIse2lkOkEseDpmWzBdL3QseTpmWzFdL24sd2lkdGg6cz9nL3Q6XCIxXCIsaGVpZ2h0OnU/bS9uOlwiMVwiLHBhdHRlcm5Vbml0czpcIm9iamVjdEJvdW5kaW5nQm94XCJ9LFAoXCJsaW5lYXJHcmFkaWVudFwiLHtpZDpFLHgxOmQseTE6aCx4Mjp3LHkyOmJ9LF8ubWFwKE09PlAoXCJzdG9wXCIse29mZnNldDpNLm9mZnNldCoxMDArXCIlXCIsXCJzdG9wLWNvbG9yXCI6TS5jb2xvcn0pKS5qb2luKFwiXCIpKStQKFwicmVjdFwiLHt4OjAseTowLHdpZHRoOmcsaGVpZ2h0Om0sZmlsbDpgdXJsKCMke0V9KWB9KSk7cmV0dXJuW0EsRF19aWYoci5zdGFydHNXaXRoKFwicmFkaWFsLWdyYWRpZW50KFwiKSl7bGV0IHA9c24ucGFyc2UocilbMF0sZz1wLm9yaWVudGF0aW9uWzBdLFttLGRdPWwsaD1cImNpcmNsZVwiLHc9bS8yLGI9ZC8yO2lmKGcudHlwZT09PVwic2hhcGVcIil7aWYoaD1nLnZhbHVlLGcuYXQpaWYoZy5hdC50eXBlPT09XCJwb3NpdGlvblwiKXc9Zy5hdC52YWx1ZS54LnZhbHVlLGI9Zy5hdC52YWx1ZS55LnZhbHVlO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwib3JpZW50YXRpb24uYXQudHlwZSBub3QgaW1wbGVtZW50ZWQ6IFwiK2cuYXQudHlwZSl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJvcmllbnRhdGlvbi50eXBlIG5vdCBpbXBsZW1lbnRlZDogXCIrZy50eXBlKTtsZXQgXz1Dbyh0LHAuY29sb3JTdG9wcyksRT1gc2F0b3JpX3JhZGlhbF8ke2V9YCxBPWBzYXRvcmlfcGF0dGVybl8ke2V9YCxEPWBzYXRvcmlfbWFza18ke2V9YCxNPXt9LEw9TWF0aC5tYXgoTWF0aC5hYnMobS13KSxNYXRoLmFicyh3KSksRj1NYXRoLm1heChNYXRoLmFicyhkLWIpLE1hdGguYWJzKGIpKTtpZihoPT09XCJjaXJjbGVcIilNLnI9TWF0aC5zcXJ0KEwqTCtGKkYpO2Vsc2UgaWYoaD09PVwiZWxsaXBzZVwiKXtsZXQgcT1GIT09MD9ML0Y6MTtNLnJ5PU1hdGguc3FydChMKkwrRipGKnEqcSkvcSxNLnJ4PU0ucnkqcX1sZXQgTj1QKFwicGF0dGVyblwiLHtpZDpBLHg6ZlswXS90LHk6ZlsxXS9uLHdpZHRoOnM/bS90OlwiMVwiLGhlaWdodDp1P2QvbjpcIjFcIixwYXR0ZXJuVW5pdHM6XCJvYmplY3RCb3VuZGluZ0JveFwifSxQKFwicmFkaWFsR3JhZGllbnRcIix7aWQ6RX0sXy5tYXAocT0+UChcInN0b3BcIix7b2Zmc2V0OnEub2Zmc2V0LFwic3RvcC1jb2xvclwiOnEuY29sb3J9KSkuam9pbihcIlwiKSkrUChcIm1hc2tcIix7aWQ6RH0sUChcInJlY3RcIix7eDowLHk6MCx3aWR0aDptLGhlaWdodDpkLGZpbGw6XCIjZmZmXCJ9KSkrUChoLHtjeDp3LGN5OmIsd2lkdGg6bSxoZWlnaHQ6ZCwuLi5NLGZpbGw6YHVybCgjJHtFfSlgLG1hc2s6YHVybCgjJHtEfSlgfSkpO3JldHVybltBLE5dfWlmKHIuc3RhcnRzV2l0aChcInVybChcIikpe2xldCBwPXVuKGkse3g6dCx5Om4sZGVmYXVsdFg6MCxkZWZhdWx0WTowfSksW2csbSxkXT1hd2FpdCBmcihyLnNsaWNlKDQsLTEpKSxoPXBbMF18fG0sdz1wWzFdfHxkO3JldHVybltgc2F0b3JpX2JpJHtlfWAsUChcInBhdHRlcm5cIix7aWQ6YHNhdG9yaV9iaSR7ZX1gLHBhdHRlcm5Db250ZW50VW5pdHM6XCJ1c2VyU3BhY2VPblVzZVwiLHBhdHRlcm5Vbml0czpcInVzZXJTcGFjZU9uVXNlXCIseDpmWzBdLHk6ZlsxXSx3aWR0aDpzP2g6XCIxMDAlXCIsaGVpZ2h0OnU/dzpcIjEwMCVcIn0sUChcImltYWdlXCIse3g6MCx5OjAsd2lkdGg6aCxoZWlnaHQ6dyxwcmVzZXJ2ZUFzcGVjdFJhdGlvOlwibm9uZVwiLGhyZWY6Z30pKV19dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhY2tncm91bmQgaW1hZ2U6IFwiJHtyfVwiYCl9YygpO2Z1bmN0aW9uIGlsKFtlLHRdKXtyZXR1cm4gTWF0aC5yb3VuZChlKjFlMyk9PT0wJiZNYXRoLnJvdW5kKHQqMWUzKT09PTA/MDpNYXRoLnJvdW5kKGUqdC9NYXRoLnNxcnQoZSplK3QqdCkqMWUzKS8xZTN9ZnVuY3Rpb24gZHIoZSx0LG4pe3JldHVybiBuPGUrdCYmKG4vMjxlJiZuLzI8dD9lPXQ9bi8yOm4vMjxlP2U9bi10Om4vMjx0JiYodD1uLWUpKSxbZSx0XX1mdW5jdGlvbiBwcihlKXtlWzBdPWVbMV09TWF0aC5taW4oZVswXSxlWzFdKX1mdW5jdGlvbiBocihlLHQsbixyLGkpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgYT1lLnNwbGl0KFwiIFwiKS5tYXAocz0+cy50cmltKCkpLG89IWFbMV0mJiFhWzBdLmVuZHNXaXRoKFwiJVwiKTtyZXR1cm4gYVsxXT1hWzFdfHxhWzBdLFtvLFtNYXRoLm1pbihHZShhWzBdLHIsdCxpLCEwKSx0KSxNYXRoLm1pbihHZShhWzFdLHIsbixpLCEwKSxuKV1dfXJldHVybiB0eXBlb2YgZT09XCJudW1iZXJcIj9bITAsW01hdGgubWluKGUsdCksTWF0aC5taW4oZSxuKV1dOlshMCx2b2lkIDBdfWZ1bmN0aW9uIE1lKHtsZWZ0OmUsdG9wOnQsd2lkdGg6bixoZWlnaHQ6cn0saSxhKXtsZXR7Ym9yZGVyVG9wTGVmdFJhZGl1czpvLGJvcmRlclRvcFJpZ2h0UmFkaXVzOnMsYm9yZGVyQm90dG9tTGVmdFJhZGl1czp1LGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOmwsZm9udFNpemU6Zn09aSxwLGcsbSxkO2lmKFtwLG9dPWhyKG8sbixyLGYsaSksW2csc109aHIocyxuLHIsZixpKSxbbSx1XT1ocih1LG4scixmLGkpLFtkLGxdPWhyKGwsbixyLGYsaSksIWEmJiFvJiYhcyYmIXUmJiFsKXJldHVyblwiXCI7b3x8KG89WzAsMF0pLHN8fChzPVswLDBdKSx1fHwodT1bMCwwXSksbHx8KGw9WzAsMF0pLFtvWzBdLHNbMF1dPWRyKG9bMF0sc1swXSxuKSxbdVswXSxsWzBdXT1kcih1WzBdLGxbMF0sbiksW29bMV0sdVsxXV09ZHIob1sxXSx1WzFdLHIpLFtzWzFdLGxbMV1dPWRyKHNbMV0sbFsxXSxyKSxwJiZwcihvKSxnJiZwcihzKSxtJiZwcih1KSxkJiZwcihsKTtsZXQgaD1bXTtoWzBdPVtzLHNdLGhbMV09W2wsWy1sWzBdLGxbMV1dXSxoWzJdPVt1LFstdVswXSwtdVsxXV1dLGhbM109W28sW29bMF0sLW9bMV1dXTtsZXQgdz1gaCR7bi1vWzBdLXNbMF19IGEke2hbMF1bMF19IDAgMCAxICR7aFswXVsxXX1gLGI9YHYke3Itc1sxXS1sWzFdfSBhJHtoWzFdWzBdfSAwIDAgMSAke2hbMV1bMV19YCxfPWBoJHtsWzBdK3VbMF0tbn0gYSR7aFsyXVswXX0gMCAwIDEgJHtoWzJdWzFdfWAsRT1gdiR7dVsxXStvWzFdLXJ9IGEke2hbM11bMF19IDAgMCAxICR7aFszXVsxXX1gO2lmKGEpe2xldCBEPWZ1bmN0aW9uKEspe2xldCBlZT1pbChbbyxzLGwsdV1bS10pO3JldHVybiBLPT09MD9bW2Urb1swXS1lZSx0K29bMV0tZWVdLFtlK29bMF0sdF1dOks9PT0xP1tbZStuLXNbMF0rZWUsdCtzWzFdLWVlXSxbZStuLHQrc1sxXV1dOks9PT0yP1tbZStuLWxbMF0rZWUsdCtyLWxbMV0rZWVdLFtlK24tbFswXSx0K3JdXTpbW2UrdVswXS1lZSx0K3ItdVsxXStlZV0sW2UsdCtyLXVbMV1dXX0sQT1hLmluZGV4T2YoITEpO2lmKCFhLmluY2x1ZGVzKCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGBwYXJ0aWFsU2lkZXNgLlwiKTtpZihBPT09LTEpQT0wO2Vsc2UgZm9yKDshYVtBXTspQT0oQSsxKSU0O2xldCBNPVwiXCIsTD1EKEEpLEY9YE0ke0xbMF19IEEke2hbKEErMyklNF1bMF19IDAgMCAxICR7TFsxXX1gLE49MDtmb3IoO048NCYmYVsoQStOKSU0XTtOKyspTSs9RitcIiBcIixGPVt3LGIsXyxFXVsoQStOKSU0XTtsZXQgVT0oQStOKSU0O00rPUYuc3BsaXQoXCIgXCIpWzBdO2xldCBxPUQoVSk7cmV0dXJuIE0rPWAgQSR7aFsoVSszKSU0XVswXX0gMCAwIDEgJHtxWzBdfWAsTX1yZXR1cm5gTSR7ZStvWzBdfSwke3R9ICR7d30gJHtifSAke199ICR7RX1gfWMoKTtjKCk7YygpO2Z1bmN0aW9uIERvKGUsdCxuKXtyZXR1cm4gbltlK1wiV2lkdGhcIl09PT1uW3QrXCJXaWR0aFwiXSYmbltlK1wiU3R5bGVcIl09PT1uW3QrXCJTdHlsZVwiXSYmbltlK1wiQ29sb3JcIl09PT1uW3QrXCJDb2xvclwiXX1mdW5jdGlvbiBtcih7aWQ6ZSxjdXJyZW50Q2xpcFBhdGhJZDp0LGJvcmRlclBhdGg6bixib3JkZXJUeXBlOnIsbGVmdDppLHRvcDphLHdpZHRoOm8saGVpZ2h0OnN9LHUpe2lmKCEodS5ib3JkZXJUb3BXaWR0aHx8dS5ib3JkZXJSaWdodFdpZHRofHx1LmJvcmRlckJvdHRvbVdpZHRofHx1LmJvcmRlckxlZnRXaWR0aCkpcmV0dXJuIG51bGw7bGV0IGY9YHNhdG9yaV9iYy0ke2V9YDtyZXR1cm5bUChcImNsaXBQYXRoXCIse2lkOmYsXCJjbGlwLXBhdGhcIjp0P2B1cmwoIyR7dH0pYDp2b2lkIDB9LFAocix7eDppLHk6YSx3aWR0aDpvLGhlaWdodDpzLGQ6bnx8dm9pZCAwfSkpLGZdfWZ1bmN0aW9uIFllKHtsZWZ0OmUsdG9wOnQsd2lkdGg6bixoZWlnaHQ6cixwcm9wczppLGFzQ29udGVudE1hc2s6YSxtYXNrQm9yZGVyT25seTpvfSxzKXtsZXQgdT1bXCJib3JkZXJUb3BcIixcImJvcmRlclJpZ2h0XCIsXCJib3JkZXJCb3R0b21cIixcImJvcmRlckxlZnRcIl07aWYoIWEmJiF1LnNvbWUobT0+c1ttK1wiV2lkdGhcIl0pKXJldHVyblwiXCI7bGV0IGw9XCJcIixmPTA7Zm9yKDtmPjAmJkRvKHVbZl0sdVsoZiszKSU0XSxzKTspZj0oZiszKSU0O2xldCBwPVshMSwhMSwhMSwhMV0sZz1bXTtmb3IobGV0IG09MDttPDQ7bSsrKXtsZXQgZD0oZittKSU0LGg9KGYrbSsxKSU0LHc9dVtkXSxiPXVbaF07aWYocFtkXT0hMCxnPVtzW3crXCJXaWR0aFwiXSxzW3crXCJTdHlsZVwiXSxzW3crXCJDb2xvclwiXSx3XSwhRG8odyxiLHMpKXtsZXQgXz0oZ1swXXx8MCkrKGEmJiFvJiZzW3cucmVwbGFjZShcImJvcmRlclwiLFwicGFkZGluZ1wiKV18fDApO18mJihsKz1QKFwicGF0aFwiLHt3aWR0aDpuLGhlaWdodDpyLC4uLmksZmlsbDpcIm5vbmVcIixzdHJva2U6YT9cIiMwMDBcIjpnWzJdLFwic3Ryb2tlLXdpZHRoXCI6XyoyLFwic3Ryb2tlLWRhc2hhcnJheVwiOiFhJiZnWzFdPT09XCJkYXNoZWRcIj9fKjIrXCIgXCIrXzp2b2lkIDAsZDpNZSh7bGVmdDplLHRvcDp0LHdpZHRoOm4saGVpZ2h0OnJ9LHMscCl9KSkscD1bITEsITEsITEsITFdfX1pZihwLnNvbWUoQm9vbGVhbikpe2xldCBtPShnWzBdfHwwKSsoYSYmIW8mJnNbZ1szXS5yZXBsYWNlKFwiYm9yZGVyXCIsXCJwYWRkaW5nXCIpXXx8MCk7bSYmKGwrPVAoXCJwYXRoXCIse3dpZHRoOm4saGVpZ2h0OnIsLi4uaSxmaWxsOlwibm9uZVwiLHN0cm9rZTphP1wiIzAwMFwiOmdbMl0sXCJzdHJva2Utd2lkdGhcIjptKjIsXCJzdHJva2UtZGFzaGFycmF5XCI6IWEmJmdbMV09PT1cImRhc2hlZFwiP20qMitcIiBcIittOnZvaWQgMCxkOk1lKHtsZWZ0OmUsdG9wOnQsd2lkdGg6bixoZWlnaHQ6cn0scyxwKX0pKX1yZXR1cm4gbH1mdW5jdGlvbiBtdCh7aWQ6ZSxsZWZ0OnQsdG9wOm4sd2lkdGg6cixoZWlnaHQ6aSxtYXRyaXg6YSxib3JkZXJPbmx5Om99LHMpe2xldCB1PShzLmJvcmRlckxlZnRXaWR0aHx8MCkrKG8/MDpzLnBhZGRpbmdMZWZ0fHwwKSxsPShzLmJvcmRlclRvcFdpZHRofHwwKSsobz8wOnMucGFkZGluZ1RvcHx8MCksZj0ocy5ib3JkZXJSaWdodFdpZHRofHwwKSsobz8wOnMucGFkZGluZ1JpZ2h0fHwwKSxwPShzLmJvcmRlckJvdHRvbVdpZHRofHwwKSsobz8wOnMucGFkZGluZ0JvdHRvbXx8MCksZz17eDp0K3UseTpuK2wsd2lkdGg6ci11LWYsaGVpZ2h0OmktbC1wfTtyZXR1cm4gUChcIm1hc2tcIix7aWQ6ZX0sUChcInJlY3RcIix7Li4uZyxmaWxsOlwiI2ZmZlwiLG1hc2s6cy5faW5oZXJpdGVkTWFza0lkP2B1cmwoIyR7cy5faW5oZXJpdGVkTWFza0lkfSlgOnZvaWQgMH0pK1llKHtsZWZ0OnQsdG9wOm4sd2lkdGg6cixoZWlnaHQ6aSxwcm9wczp7dHJhbnNmb3JtOmF8fHZvaWQgMH0sYXNDb250ZW50TWFzazohMCxtYXNrQm9yZGVyT25seTpvfSxzKSl9ZnVuY3Rpb24gZm4oe2xlZnQ6ZSx0b3A6dCx3aWR0aDpuLGhlaWdodDpyLHBhdGg6aSxtYXRyaXg6YSxpZDpvfSxzKXtpZihzLm92ZXJmbG93IT09XCJoaWRkZW5cIilyZXR1cm5cIlwiO2xldCB1PW10KHtpZDpgc2F0b3JpX29tLSR7b31gLGxlZnQ6ZSx0b3A6dCx3aWR0aDpuLGhlaWdodDpyLG1hdHJpeDphLGJvcmRlck9ubHk6ITB9LHMpO3JldHVybiBQKFwiY2xpcFBhdGhcIix7aWQ6YHNhdG9yaV9jcC0ke299YCxcImNsaXAtcGF0aFwiOnMuX2luaGVyaXRlZENsaXBQYXRoSWQ/YHVybCgjJHtzLl9pbmhlcml0ZWRDbGlwUGF0aElkfSlgOnZvaWQgMH0sUChpP1wicGF0aFwiOlwicmVjdFwiLHt4OmUseTp0LHdpZHRoOm4saGVpZ2h0OnIsZDppfHx2b2lkIDB9KSkrdX1hc3luYyBmdW5jdGlvbiBjbih7aWQ6ZSxsZWZ0OnQsdG9wOm4sd2lkdGg6cixoZWlnaHQ6aSxpc0luaGVyaXRpbmdUcmFuc2Zvcm06YSxkZWJ1ZzpvfSxzKXtpZihzLmRpc3BsYXk9PT1cIm5vbmVcIilyZXR1cm5cIlwiO2xldCB1PVwicmVjdFwiLGw9XCJcIixmPVwiXCIscD1bXSxnPTEsbT1cIlwiO3MuYmFja2dyb3VuZENvbG9yJiZwLnB1c2gocy5iYWNrZ3JvdW5kQ29sb3IpLHMub3BhY2l0eSE9PXZvaWQgMCYmKGc9K3Mub3BhY2l0eSkscy50cmFuc2Zvcm0mJihsPUhlKHtsZWZ0OnQsdG9wOm4sd2lkdGg6cixoZWlnaHQ6aX0scy50cmFuc2Zvcm0sYSxzLnRyYW5zZm9ybU9yaWdpbikpO2xldCBkPVwiXCI7aWYocy5iYWNrZ3JvdW5kSW1hZ2Upe2xldCBOPVtdO2ZvcihsZXQgVT0wO1U8cy5iYWNrZ3JvdW5kSW1hZ2UubGVuZ3RoO1UrKyl7bGV0IHE9cy5iYWNrZ3JvdW5kSW1hZ2VbVV0sSz1hd2FpdCBsbih7aWQ6ZStcIl9cIitVLHdpZHRoOnIsaGVpZ2h0Oml9LHEpO0smJk4udW5zaGlmdChLKX1mb3IobGV0IFUgb2YgTilwLnB1c2goYHVybCgjJHtVWzBdfSlgKSxmKz1VWzFdLFVbMl0mJihkKz1VWzJdKX1sZXQgaD1NZSh7bGVmdDp0LHRvcDpuLHdpZHRoOnIsaGVpZ2h0Oml9LHMpO2gmJih1PVwicGF0aFwiKTtsZXQgdz1mbih7bGVmdDp0LHRvcDpuLHdpZHRoOnIsaGVpZ2h0OmkscGF0aDpoLGlkOmUsbWF0cml4Omx9LHMpLGI9cy5faW5oZXJpdGVkQ2xpcFBhdGhJZCxfPXMuX2luaGVyaXRlZE1hc2tJZDtvJiYobT1QKFwicmVjdFwiLHt4OnQseTpuLHdpZHRoOnIsaGVpZ2h0OmksZmlsbDpcInRyYW5zcGFyZW50XCIsc3Ryb2tlOlwiI2ZmNTc1N1wiLFwic3Ryb2tlLXdpZHRoXCI6MSx0cmFuc2Zvcm06bHx8dm9pZCAwLFwiY2xpcC1wYXRoXCI6Yj9gdXJsKCMke2J9KWA6dm9pZCAwfSkpO2xldHtiYWNrZ3JvdW5kQ2xpcDpFLGZpbHRlcjpBfT1zLEQ9RT09PVwidGV4dFwiP2B1cmwoI3NhdG9yaV9iY3QtJHtlfSlgOmI/YHVybCgjJHtifSlgOnZvaWQgMCxNPXAubWFwKE49PlAodSx7eDp0LHk6bix3aWR0aDpyLGhlaWdodDppLGZpbGw6TixkOmh8fHZvaWQgMCx0cmFuc2Zvcm06bHx8dm9pZCAwLFwiY2xpcC1wYXRoXCI6RCxzdHlsZTpBP2BmaWx0ZXI6JHtBfWA6dm9pZCAwLG1hc2s6Xz9gdXJsKCMke199KWA6dm9pZCAwfSkpLmpvaW4oXCJcIiksTD1tcih7aWQ6ZSxsZWZ0OnQsdG9wOm4sd2lkdGg6cixoZWlnaHQ6aSxjdXJyZW50Q2xpcFBhdGhJZDpiLGJvcmRlclBhdGg6aCxib3JkZXJUeXBlOnV9LHMpO2lmKEwpe2YrPUxbMF07bGV0IE49TFsxXTtNKz1ZZSh7bGVmdDp0LHRvcDpuLHdpZHRoOnIsaGVpZ2h0OmkscHJvcHM6e3RyYW5zZm9ybTpsfHx2b2lkIDAsXCJjbGlwLXBhdGhcIjpgdXJsKCMke059KWB9fSxzKX1sZXQgRj1jcih7d2lkdGg6cixoZWlnaHQ6aSxpZDplLG9wYWNpdHk6ZyxzaGFwZTpQKHUse3g6dCx5Om4sd2lkdGg6cixoZWlnaHQ6aSxmaWxsOlwiI2ZmZlwiLHN0cm9rZTpcIiNmZmZcIixcInN0cm9rZS13aWR0aFwiOjAsZDpofHx2b2lkIDAsdHJhbnNmb3JtOmx8fHZvaWQgMCxcImNsaXAtcGF0aFwiOkQsbWFzazpfP2B1cmwoIyR7X30pYDp2b2lkIDB9KX0scyk7cmV0dXJuKGY/UChcImRlZnNcIix7fSxmKTpcIlwiKSsoRj9GWzBdOlwiXCIpK3crKGchPT0xP2A8ZyBvcGFjaXR5PVwiJHtnfVwiPmA6XCJcIikrKGR8fE0pKyhnIT09MT9cIjwvZz5cIjpcIlwiKSsoRj9GWzFdOlwiXCIpK219YygpO2Z1bmN0aW9uIGdyKHtpZDplLGxlZnQ6dCx0b3A6bix3aWR0aDpyLGhlaWdodDppLHNyYzphLGRlYnVnOm8saXNJbmhlcml0aW5nVHJhbnNmb3JtOnN9LHUpe2lmKHUuZGlzcGxheT09PVwibm9uZVwiKXJldHVyblwiXCI7bGV0IGw9XCJcIixmPVwiXCIscD1cIlwiLGc9MSxtPVwiXCIsZD1cIlwiLGg9XCJcIjt1LnRyYW5zZm9ybSYmKG09SGUoe2xlZnQ6dCx0b3A6bix3aWR0aDpyLGhlaWdodDppfSx1LnRyYW5zZm9ybSxzLHUudHJhbnNmb3JtT3JpZ2luKSk7bGV0IHc9dS5vYmplY3RGaXQ9PT1cImNvbnRhaW5cIj9cInhNaWRZTWlkXCI6dS5vYmplY3RGaXQ9PT1cImNvdmVyXCI/XCJ4TWlkWU1pZCBzbGljZVwiOlwibm9uZVwiLGI9TWUoe2xlZnQ6dCx0b3A6bix3aWR0aDpyLGhlaWdodDppfSx1KSxfPXUuX2luaGVyaXRlZENsaXBQYXRoSWQsRT11Ll9pbmhlcml0ZWRNYXNrSWQ7YiYmKHA9UChcImNsaXBQYXRoXCIse2lkOmBzYXRvcmlfYy0ke2V9YCxcImNsaXAtcGF0aFwiOl8/YHVybCgjJHtffSlgOnZvaWQgMH0sUChcInBhdGhcIix7eDp0LHk6bix3aWR0aDpyLGhlaWdodDppLGQ6Yn0pKSk7bGV0IEE9bXIoe2lkOmUsbGVmdDp0LHRvcDpuLHdpZHRoOnIsaGVpZ2h0OmksY3VycmVudENsaXBQYXRoSWQ6Xyxib3JkZXJQYXRoOmIsYm9yZGVyVHlwZTpiP1wicGF0aFwiOlwicmVjdFwifSx1KTtpZihBKXtkKz1BWzBdO2xldCBVPUFbMV07aCs9WWUoe2xlZnQ6dCx0b3A6bix3aWR0aDpyLGhlaWdodDppLHByb3BzOnt0cmFuc2Zvcm06bXx8dm9pZCAwLFwiY2xpcC1wYXRoXCI6YHVybCgjJHtVfSlgLG1hc2s6RT9gdXJsKCMke0V9KWA6dm9pZCAwfX0sdSl9dS5vcGFjaXR5JiYoZz0rdS5vcGFjaXR5KTtsZXQgRD1jcih7d2lkdGg6cixoZWlnaHQ6aSxpZDplLG9wYWNpdHk6ZyxzaGFwZTpQKGI/XCJwYXRoXCI6XCJyZWN0XCIse3g6dCx5Om4sd2lkdGg6cixoZWlnaHQ6aSxmaWxsOlwiI2ZmZlwiLGQ6Ynx8dm9pZCAwLHRyYW5zZm9ybTptfHx2b2lkIDAsXCJjbGlwLXBhdGhcIjpfP2B1cmwoIyR7X30pYDp2b2lkIDAsbWFzazpFP2B1cmwoIyR7RX0pYDp2b2lkIDB9KX0sdSk7YiYmKGw9YHNhdG9yaV9jbS0ke2V9YCxmPW10KHtpZDpgc2F0b3JpX2NtLSR7ZX1gLGxlZnQ6dCx0b3A6bix3aWR0aDpyLGhlaWdodDppLG1hdHJpeDptfSx1KSk7bGV0IE09KHUuYm9yZGVyTGVmdFdpZHRofHwwKSsodS5wYWRkaW5nTGVmdHx8MCksTD0odS5ib3JkZXJUb3BXaWR0aHx8MCkrKHUucGFkZGluZ1RvcHx8MCksRj0odS5ib3JkZXJSaWdodFdpZHRofHwwKSsodS5wYWRkaW5nUmlnaHR8fDApLE49KHUuYm9yZGVyQm90dG9tV2lkdGh8fDApKyh1LnBhZGRpbmdCb3R0b218fDApO3JldHVybihkP1AoXCJkZWZzXCIse30sZCk6XCJcIikrZisoRD9EWzBdOlwiXCIpK3ArUChcImltYWdlXCIse3g6dCtNLHk6bitMLHdpZHRoOnItTS1GLGhlaWdodDppLUwtTixocmVmOmEscHJlc2VydmVBc3BlY3RSYXRpbzp3LG9wYWNpdHk6Zyx0cmFuc2Zvcm06bXx8dm9pZCAwLFwiY2xpcC1wYXRoXCI6cD9gdXJsKCNzYXRvcmlfYy0ke2V9KWA6Xz9gdXJsKCMke199KWA6dm9pZCAwLG1hc2s6bD9gdXJsKCMke2x9KWA6dm9pZCAwfSkrKEQ/RFsxXTpcIlwiKStofWFzeW5jIGZ1bmN0aW9uKmd0KGUsdCl7bGV0IG49QWUoKSx7aWQ6cixpbmhlcml0ZWRTdHlsZTppLHBhcmVudDphLGZvbnQ6byxkZWJ1ZzpzLGVtYmVkRm9udDp1PSEwLGdyYXBoZW1lSW1hZ2VzOmwsY2FuTG9hZEFkZGl0aW9uYWxBc3NldHM6ZixnZXRUd1N0eWxlczpwfT10O2lmKGU9PT1udWxsfHx0eXBlb2YgZT5cInVcIilyZXR1cm4geWllbGQseWllbGQsXCJcIjtpZighWXIoZSl8fHR5cGVvZiBlLnR5cGU9PVwiZnVuY3Rpb25cIil7bGV0IEk7aWYoIVlyKGUpKUk9b24oU3RyaW5nKGUpLHQpLHlpZWxkKGF3YWl0IEkubmV4dCgpKS52YWx1ZTtlbHNle2lmKHhvKGUudHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2xhc3MgY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuXCIpO0k9Z3QoZS50eXBlKGUucHJvcHMpLHQpLHlpZWxkKGF3YWl0IEkubmV4dCgpKS52YWx1ZX1hd2FpdCBJLm5leHQoKTtsZXQgQj15aWVsZDtyZXR1cm4oYXdhaXQgSS5uZXh0KEIpKS52YWx1ZX1sZXR7dHlwZTpnLHByb3BzOm19PWUse3N0eWxlOmQsY2hpbGRyZW46aCx0dzp3fT1tfHx7fTtpZih3KXtsZXQgST1wKHcsZCk7ZD1PYmplY3QuYXNzaWduKEksZCl9bGV0IGI9bi5Ob2RlLmNyZWF0ZSgpO2EuaW5zZXJ0Q2hpbGQoYixhLmdldENoaWxkQ291bnQoKSk7bGV0W18sRV09YXdhaXQgZW4oYixnLGksZCxtKSxBPV8udHJhbnNmb3JtPT09aS50cmFuc2Zvcm07aWYoQXx8KF8udHJhbnNmb3JtLl9fcGFyZW50PWkudHJhbnNmb3JtKSxfLm92ZXJmbG93PT09XCJoaWRkZW5cIiYmKEUuX2luaGVyaXRlZENsaXBQYXRoSWQ9YHNhdG9yaV9jcC0ke3J9YCxFLl9pbmhlcml0ZWRNYXNrSWQ9YHNhdG9yaV9vbS0ke3J9YCksXy5iYWNrZ3JvdW5kQ2xpcD09PVwidGV4dFwiKXtsZXQgST17dmFsdWU6XCJcIn07RS5faW5oZXJpdGVkQmFja2dyb3VuZENsaXBUZXh0UGF0aD1JLF8uX2luaGVyaXRlZEJhY2tncm91bmRDbGlwVGV4dFBhdGg9SX1sZXQgRD13byhoKSxNPVtdLEw9MCxGPVtdO2ZvcihsZXQgSSBvZiBEKXtsZXQgQj1ndChJLHtpZDpyK1wiLVwiK0wrKyxwYXJlbnRTdHlsZTpfLGluaGVyaXRlZFN0eWxlOkUsaXNJbmhlcml0aW5nVHJhbnNmb3JtOiEwLHBhcmVudDpiLGZvbnQ6byxlbWJlZEZvbnQ6dSxkZWJ1ZzpzLGdyYXBoZW1lSW1hZ2VzOmwsY2FuTG9hZEFkZGl0aW9uYWxBc3NldHM6ZixnZXRUd1N0eWxlczpwfSk7Zj9GLnB1c2goLi4uKGF3YWl0IEIubmV4dCgpKS52YWx1ZXx8W10pOmF3YWl0IEIubmV4dCgpLE0ucHVzaChCKX15aWVsZCBGO2ZvcihsZXQgSSBvZiBNKWF3YWl0IEkubmV4dCgpO2xldFtOLFVdPXlpZWxkLHtsZWZ0OnEsdG9wOkssd2lkdGg6ZWUsaGVpZ2h0Onp9PWIuZ2V0Q29tcHV0ZWRMYXlvdXQoKTtxKz1OLEsrPVU7bGV0IFo9XCJcIixzZT1cIlwiLEM9XCJcIjtpZihnPT09XCJpbWdcIil7bGV0IEk9Xy5fX3NyYztzZT1ncih7aWQ6cixsZWZ0OnEsdG9wOkssd2lkdGg6ZWUsaGVpZ2h0Onosc3JjOkksaXNJbmhlcml0aW5nVHJhbnNmb3JtOkEsZGVidWc6c30sXyl9ZWxzZSBpZihnPT09XCJzdmdcIil7bGV0IEk9a28oZSk7c2U9Z3Ioe2lkOnIsbGVmdDpxLHRvcDpLLHdpZHRoOmVlLGhlaWdodDp6LHNyYzpJLGlzSW5oZXJpdGluZ1RyYW5zZm9ybTpBLGRlYnVnOnN9LF8pfWVsc2V7bGV0IEk9ZD09bnVsbD92b2lkIDA6ZC5kaXNwbGF5O2lmKGc9PT1cImRpdlwiJiZoJiZ0eXBlb2YgaCE9XCJzdHJpbmdcIiYmSSE9PVwiZmxleFwiJiZJIT09XCJub25lXCIpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCA8ZGl2PiB0byBoYXZlIGV4cGxpY2l0IFwiZGlzcGxheTogZmxleFwiIG9yIFwiZGlzcGxheTogbm9uZVwiIGlmIGl0IGhhcyBtb3JlIHRoYW4gb25lIGNoaWxkIG5vZGUuJyk7c2U9YXdhaXQgY24oe2lkOnIsbGVmdDpxLHRvcDpLLHdpZHRoOmVlLGhlaWdodDp6LGlzSW5oZXJpdGluZ1RyYW5zZm9ybTpBLGRlYnVnOnN9LF8pfWZvcihsZXQgSSBvZiBNKVorPShhd2FpdCBJLm5leHQoW3EsS10pKS52YWx1ZTtyZXR1cm4gXy5faW5oZXJpdGVkQmFja2dyb3VuZENsaXBUZXh0UGF0aCYmKEMrPVAoXCJjbGlwUGF0aFwiLHtpZDpgc2F0b3JpX2JjdC0ke3J9YCxcImNsaXAtcGF0aFwiOl8uX2luaGVyaXRlZENsaXBQYXRoSWQ/YHVybCgjJHtfLl9pbmhlcml0ZWRDbGlwUGF0aElkfSlgOnZvaWQgMH0sXy5faW5oZXJpdGVkQmFja2dyb3VuZENsaXBUZXh0UGF0aC52YWx1ZSkpLEMrc2UrWn1jKCk7aW1wb3J0IGRuIGZyb21cIkBzaHVkaW5nL29wZW50eXBlLmpzXCI7ZnVuY3Rpb24gb2woZSx0LFtuLHJdLFtpLGFdKXtpZihuIT09aSlyZXR1cm4gbj8haXx8bj09PWU/LTE6aT09PWU/MTplPT09NDAwJiZuPT09NTAwfHxlPT09NTAwJiZuPT09NDAwPy0xOmU9PT00MDAmJmk9PT01MDB8fGU9PT01MDAmJmk9PT00MDA/MTplPDQwMD9uPGUmJmk8ZT9pLW46bjxlPy0xOmk8ZT8xOm4taTplPG4mJmU8aT9uLWk6ZTxuPy0xOmU8aT8xOmktbjoxO2lmKHIhPT1hKXtpZihyPT09dClyZXR1cm4tMTtpZihhPT09dClyZXR1cm4gMX1yZXR1cm4tMX12YXIgdnQ9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5mb250cz1uZXcgTWFwO3RoaXMuYWRkRm9udHModCl9Z2V0KHtuYW1lOnQsd2VpZ2h0Om4sc3R5bGU6cn0pe2lmKCF0aGlzLmZvbnRzLmhhcyh0KSlyZXR1cm4gbnVsbDtuPT09XCJub3JtYWxcIiYmKG49NDAwKSxuPT09XCJib2xkXCImJihuPTcwMCk7bGV0IGk9Wy4uLnRoaXMuZm9udHMuZ2V0KHQpXSxhPWlbMF07Zm9yKGxldCBvPTE7bzxpLmxlbmd0aDtvKyspe2xldFsscyx1XT1hLFssbCxmXT1pW29dO29sKG4scixbcyx1XSxbbCxmXSk+MCYmKGE9aVtvXSl9cmV0dXJuIGFbMF19YWRkRm9udHModCl7Zm9yKGxldCBuIG9mIHQpe2xldCByPW4uZGF0YSxpPWRuLnBhcnNlKFwiYnVmZmVyXCJpbiByP3IuYnVmZmVyLnNsaWNlKHIuYnl0ZU9mZnNldCxyLmJ5dGVPZmZzZXQrci5ieXRlTGVuZ3RoKTpyLHtsb3dNZW1vcnk6ITB9KSxhPWkuY2hhclRvR2x5cGhJbmRleDtpLmNoYXJUb0dseXBoSW5kZXg9cz0+e2xldCB1PWEuY2FsbChpLHMpO3JldHVybiB1PT09MCYmaS5fdHJhY2tCcm9rZW5DaGFycyYmaS5fdHJhY2tCcm9rZW5DaGFycy5wdXNoKHMpLHV9LHRoaXMuZGVmYXVsdEZvbnR8fCh0aGlzLmRlZmF1bHRGb250PWkpO2xldCBvPW4ubmFtZS50b0xvd2VyQ2FzZSgpO3RoaXMuZm9udHMuaGFzKG8pfHx0aGlzLmZvbnRzLnNldChvLFtdKSx0aGlzLmZvbnRzLmdldChvKS5wdXNoKFtpLG4ud2VpZ2h0LG4uc3R5bGVdKX19Z2V0RW5naW5lKHQ9MTYsbj0xLjIse2ZvbnRGYW1pbHk6cixmb250V2VpZ2h0Omk9NDAwLGZvbnRTdHlsZTphPVwibm9ybWFsXCJ9KXtpZighdGhpcy5mb250cy5zaXplKXRocm93IG5ldyBFcnJvcihcIk5vIGZvbnRzIGFyZSBsb2FkZWQuIEF0IGxlYXN0IG9uZSBmb250IGlzIHJlcXVpcmVkIHRvIGNhbGN1bGF0ZSB0aGUgbGF5b3V0LlwiKTtyPShBcnJheS5pc0FycmF5KHIpP3I6W3JdKS5tYXAoZD0+ZC50b0xvd2VyQ2FzZSgpKTtsZXQgbz1yLm1hcChkPT50aGlzLmdldCh7bmFtZTpkLHdlaWdodDppLHN0eWxlOmF9KSkuZmlsdGVyKEJvb2xlYW4pLHM9QXJyYXkuZnJvbSh0aGlzLmZvbnRzLmtleXMoKSk7Zm9yKGxldCBkIG9mIHMpci5pbmNsdWRlcyhkKXx8by5wdXNoKHRoaXMuZ2V0KHtuYW1lOmQsd2VpZ2h0Omksc3R5bGU6YX0pKTtsZXQgdT1uZXcgTWFwLGw9KGQsaD0hMCk9PntsZXQgdz1kLmNoYXJDb2RlQXQoMCk7aWYodS5oYXModykpcmV0dXJuIHUuZ2V0KHcpO2xldCBiPW8uZmluZCgoXyxFKT0+ISFfLmNoYXJUb0dseXBoSW5kZXgoZCl8fGgmJkU9PT1vLmxlbmd0aC0xKTtyZXR1cm4gYiYmdS5zZXQodyxiKSxifSxmPShkLGg9ITEpPT57dmFyIGIsXztyZXR1cm4oKGg/KF89KGI9ZC50YWJsZXMpPT1udWxsP3ZvaWQgMDpiLm9zMik9PW51bGw/dm9pZCAwOl8uc1R5cG9Bc2NlbmRlcjowKXx8ZC5hc2NlbmRlcikvZC51bml0c1BlckVtKnR9LHA9KGQsaD0hMSk9Pnt2YXIgYixfO3JldHVybigoaD8oXz0oYj1kLnRhYmxlcyk9PW51bGw/dm9pZCAwOmIub3MyKT09bnVsbD92b2lkIDA6Xy5zVHlwb0Rlc2NlbmRlcjowKXx8ZC5kZXNjZW5kZXIpL2QudW5pdHNQZXJFbSp0fSxnPWQ9PmwoZCwhMSksbT17aGFzOmQ9PntpZihkPT09YFxuYClyZXR1cm4hMDtsZXQgaD1nKGQpO3JldHVybiBoPyhoLl90cmFja0Jyb2tlbkNoYXJzPVtdLGguc3RyaW5nVG9HbHlwaHMoZCksaC5fdHJhY2tCcm9rZW5DaGFycy5sZW5ndGg/KGguX3RyYWNrQnJva2VuQ2hhcnM9dm9pZCAwLCExKTohMCk6ITF9LGJhc2VsaW5lOihkLGg9dHlwZW9mIGQ+XCJ1XCI/b1swXTpsKGQpKT0+e2xldCB3PWYoaCwhMCksYj1wKGgsITApLF89bS5oZWlnaHQoZCxoKSx7eU1heDpFLHlNaW46QX09aC50YWJsZXMuaGVhZCxEPXctYixNPShFLyhFLUEpLTEpKkQ7cmV0dXJuIF8qKCgxLjIvbisxKS8yKStNfSxoZWlnaHQ6KGQsaD10eXBlb2YgZD5cInVcIj9vWzBdOmwoZCkpPT4oZihoKS1wKGgpKSoobi8xLjIpLG1lYXN1cmU6KGQsaCk9PnRoaXMubWVhc3VyZShsLGQsaCksZ2V0U1ZHOihkLGgpPT50aGlzLmdldFNWRyhsLGQsaCl9O3JldHVybiBtfXBhdGNoRm9udEZhbGxiYWNrUmVzb2x2ZXIodCxuKXtsZXQgcj1bXTt0Ll90cmFja0Jyb2tlbkNoYXJzPXI7bGV0IGk9dC5zdHJpbmdUb0dseXBocztyZXR1cm4gdC5zdHJpbmdUb0dseXBocz0oYSwuLi5vKT0+e2xldCBzPWkuY2FsbCh0LGEsLi4ubyk7Zm9yKGxldCB1PTA7dTxzLmxlbmd0aDt1KyspaWYoc1t1XS51bmljb2RlPT09dm9pZCAwKXtsZXQgbD1yLnNoaWZ0KCksZj1uKGwpO2lmKGYhPT10KXtsZXQgcD1mLmNoYXJUb0dseXBoKGwpLGc9dC51bml0c1BlckVtL2YudW5pdHNQZXJFbSxtPW5ldyBkbi5QYXRoO20udW5pdHNQZXJFbT10LnVuaXRzUGVyRW0sbS5jb21tYW5kcz1wLnBhdGguY29tbWFuZHMubWFwKGg9PntsZXQgdz17Li4uaH07Zm9yKGxldCBiIGluIHcpdHlwZW9mIHdbYl09PVwibnVtYmVyXCImJih3W2JdKj1nKTtyZXR1cm4gd30pO2xldCBkPW5ldyBkbi5HbHlwaCh7Li4ucCxhZHZhbmNlV2lkdGg6cC5hZHZhbmNlV2lkdGgqZyx4TWluOnAueE1pbipnLHhNYXg6cC54TWF4KmcseU1pbjpwLnlNaW4qZyx5TWF4OnAueU1heCpnLHBhdGg6bX0pO3NbdV09ZH19cmV0dXJuIHN9LCgpPT57dC5zdHJpbmdUb0dseXBocz1pLHQuX3RyYWNrQnJva2VuQ2hhcnM9dm9pZCAwfX1tZWFzdXJlKHQsbix7Zm9udFNpemU6cixsZXR0ZXJTcGFjaW5nOmk9MH0pe2xldCBhPXQobiksbz10aGlzLnBhdGNoRm9udEZhbGxiYWNrUmVzb2x2ZXIoYSx0KTt0cnl7cmV0dXJuIGEuZ2V0QWR2YW5jZVdpZHRoKG4scix7bGV0dGVyU3BhY2luZzppL3J9KX1maW5hbGx5e28oKX19Z2V0U1ZHKHQsbix7Zm9udFNpemU6cix0b3A6aSxsZWZ0OmEsbGV0dGVyU3BhY2luZzpvPTB9KXtsZXQgcz10KG4pLHU9dGhpcy5wYXRjaEZvbnRGYWxsYmFja1Jlc29sdmVyKHMsdCk7dHJ5e3JldHVybiByPT09MD9cIlwiOnMuZ2V0UGF0aChuLnJlcGxhY2UoL1xcbi9nLFwiXCIpLGEsaSxyLHtsZXR0ZXJTcGFjaW5nOm8vcn0pLnRvUGF0aERhdGEoMSl9ZmluYWxseXt1KCl9fX07YygpO2Z1bmN0aW9uIHBuKHt3aWR0aDplLGhlaWdodDp0LGNvbnRlbnQ6bn0pe3JldHVybiBQKFwic3ZnXCIse3dpZHRoOmUsaGVpZ2h0OnQsdmlld0JveDpgMCAwICR7ZX0gJHt0fWAseG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifSxuKX1jKCk7dmFyIEZvPXtlbW9qaTovXFxwe1JJfVxccHtSSX18XFxwe0Vtb2ppfShcXHB7RU1vZH0rfFxcdXtGRTBGfVxcdXsyMEUzfT98W1xcdXtFMDAyMH0tXFx1e0UwMDdFfV0rXFx1e0UwMDdGfSk/KFxcdXsyMDBEfVxccHtFbW9qaX0oXFxwe0VNb2R9K3xcXHV7RkUwRn1cXHV7MjBFM30/fFtcXHV7RTAwMjB9LVxcdXtFMDA3RX1dK1xcdXtFMDA3Rn0pPykrfFxccHtFUHJlc30oXFxwe0VNb2R9K3xcXHV7RkUwRn1cXHV7MjBFM30/fFtcXHV7RTAwMjB9LVxcdXtFMDA3RX1dK1xcdXtFMDA3Rn0pP3xcXHB7RW1vaml9KFxccHtFTW9kfSt8XFx1e0ZFMEZ9XFx1ezIwRTN9P3xbXFx1e0UwMDIwfS1cXHV7RTAwN0V9XStcXHV7RTAwN0Z9KXxbXFx1e0UwMDB9LVxcdXtGOEZGfV18W1xcdXtGMDAwMH0tXFx1e0ZGRkZEfV18W1xcdXsxMDAwMDB9LVxcdXsxMEZGRkR9XS91LGphOi9cXHB7c2N4PUhpcmF9fFxccHtzY3g9S2FuYX18W++8jO+8m++8ml0vdSxrbzovXFxwe3NjeD1IYW5ndWx9L3Usemg6L1xccHtzY3g9SGFufS91LHRoOi9cXHB7c2N4PVRoYWl9L3UsYm46L1xccHtzY3g9QmVuZ2FsaX0vdSxhcjovXFxwe3NjeD1BcmFiaWN9L3UsdGE6L1xccHtzY3g9VGFtaWx9L3UsbWw6L1xccHtzY3g9TWFsYXlhbGFtfS91LGhlOi9cXHB7c2N4PUhlYnJld30vdSx0ZTovXFxwe3NjeD1UZWx1Z3V9L3UsZGV2YW5hZ2FyaTovXFxwe3NjeD1EZXZhbmFnYXJpfS91fTtmdW5jdGlvbiBNbyhlKXtmb3IobGV0IHQgaW4gRm8paWYoRm9bdF0udGVzdChlKSlyZXR1cm4gdDtyZXR1cm5cInVua25vd25cIn1jKCk7YygpO3ZhciBtdT1UdShWcygpKTtjKCk7YygpO2MoKTtjKCk7dmFyIFZoPVtcImlvc1wiLFwiYW5kcm9pZFwiLFwid2luZG93c1wiLFwibWFjb3NcIixcIndlYlwiXTtmdW5jdGlvbiBZcyhlKXtyZXR1cm4gVmguaW5jbHVkZXMoZSl9dmFyIEhoPVtcInBvcnRyYWl0XCIsXCJsYW5kc2NhcGVcIl07ZnVuY3Rpb24gWHMoZSl7cmV0dXJuIEhoLmluY2x1ZGVzKGUpfXZhciBIczsoZnVuY3Rpb24oZSl7ZS5mb250U2l6ZT1cImZvbnRTaXplXCIsZS5saW5lSGVpZ2h0PVwibGluZUhlaWdodFwifSkoSHN8fChIcz17fSkpO3ZhciAkOyhmdW5jdGlvbihlKXtlLnJlbT1cInJlbVwiLGUuZW09XCJlbVwiLGUucHg9XCJweFwiLGUucGVyY2VudD1cIiVcIixlLnZ3PVwidndcIixlLnZoPVwidmhcIixlLm5vbmU9XCI8bm8tY3NzLXVuaXQ+XCJ9KSgkfHwoJD17fSkpO2Z1bmN0aW9uICRpKGUpe3JldHVybiB0eXBlb2YgZT09XCJzdHJpbmdcIn1mdW5jdGlvbiBxaShlKXtyZXR1cm4gdHlwZW9mIGU9PVwib2JqZWN0XCJ9dmFyIEJpO2Z1bmN0aW9uIHYoZSl7cmV0dXJue2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOmV9fWZ1bmN0aW9uIHJlKGUsdD17fSl7bGV0e2ZyYWN0aW9uczpufT10O2lmKG4mJmUuaW5jbHVkZXMoXCIvXCIpKXtsZXRbYT1cIlwiLG89XCJcIl09ZS5zcGxpdChcIi9cIiwyKSxzPXJlKGEpLHU9cmUobyk7cmV0dXJuIXN8fCF1P251bGw6W3NbMF0vdVswXSx1WzFdXX1sZXQgcj1wYXJzZUZsb2F0KGUpO2lmKE51bWJlci5pc05hTihyKSlyZXR1cm4gbnVsbDtsZXQgaT1lLm1hdGNoKC8oKFthLXpdezIsfXwlKSkkLyk7aWYoIWkpcmV0dXJuW3IsJC5ub25lXTtzd2l0Y2goaT09bnVsbD92b2lkIDA6aVsxXSl7Y2FzZVwicmVtXCI6cmV0dXJuW3IsJC5yZW1dO2Nhc2VcInB4XCI6cmV0dXJuW3IsJC5weF07Y2FzZVwiZW1cIjpyZXR1cm5bciwkLmVtXTtjYXNlXCIlXCI6cmV0dXJuW3IsJC5wZXJjZW50XTtjYXNlXCJ2d1wiOnJldHVybltyLCQudnddO2Nhc2VcInZoXCI6cmV0dXJuW3IsJC52aF07ZGVmYXVsdDpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gTGUoZSx0LG49e30pe2xldCByPUVlKHQsbik7cmV0dXJuIHI9PT1udWxsP251bGw6dih7W2VdOnJ9KX1mdW5jdGlvbiBEcihlLHQsbil7bGV0IHI9RWUodCk7cmV0dXJuIHIhPT1udWxsJiYobltlXT1yKSxufWZ1bmN0aW9uIEpzKGUsdCl7bGV0IG49RWUodCk7cmV0dXJuIG49PT1udWxsP251bGw6e1tlXTpufX1mdW5jdGlvbiBFZShlLHQ9e30pe2lmKGU9PT12b2lkIDApcmV0dXJuIG51bGw7bGV0IG49cmUoU3RyaW5nKGUpLHQpO3JldHVybiBuP3FlKC4uLm4sdCk6bnVsbH1mdW5jdGlvbiBxZShlLHQsbj17fSl7bGV0e2lzTmVnYXRpdmU6cixkZXZpY2U6aX09bjtzd2l0Y2godCl7Y2FzZSAkLnJlbTpyZXR1cm4gZSoxNioocj8tMToxKTtjYXNlICQucHg6cmV0dXJuIGUqKHI/LTE6MSk7Y2FzZSAkLnBlcmNlbnQ6cmV0dXJuYCR7cj9cIi1cIjpcIlwifSR7ZX0lYDtjYXNlICQubm9uZTpyZXR1cm4gZSoocj8tMToxKTtjYXNlICQudnc6cmV0dXJuIGkhPW51bGwmJmkud2luZG93RGltZW5zaW9ucz9pLndpbmRvd0RpbWVuc2lvbnMud2lkdGgqKGUvMTAwKTooY2UoXCJgdndgIENTUyB1bml0IHJlcXVpcmVzIGNvbmZpZ3VyYXRpb24gd2l0aCBgdXNlRGV2aWNlQ29udGV4dCgpYFwiKSxudWxsKTtjYXNlICQudmg6cmV0dXJuIGkhPW51bGwmJmkud2luZG93RGltZW5zaW9ucz9pLndpbmRvd0RpbWVuc2lvbnMuaGVpZ2h0KihlLzEwMCk6KGNlKFwiYHZoYCBDU1MgdW5pdCByZXF1aXJlcyBjb25maWd1cmF0aW9uIHdpdGggYHVzZURldmljZUNvbnRleHQoKWBcIiksbnVsbCk7ZGVmYXVsdDpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gVWkoZSl7bGV0IHQ9cmUoZSk7aWYoIXQpcmV0dXJuIG51bGw7bGV0W24scl09dDtzd2l0Y2gocil7Y2FzZSAkLnJlbTpyZXR1cm4gbioxNjtjYXNlICQucHg6cmV0dXJuIG47ZGVmYXVsdDpyZXR1cm4gbnVsbH19dmFyIFloPXt0OlwiVG9wXCIsdHI6XCJUb3BSaWdodFwiLHRsOlwiVG9wTGVmdFwiLGI6XCJCb3R0b21cIixicjpcIkJvdHRvbVJpZ2h0XCIsYmw6XCJCb3R0b21MZWZ0XCIsbDpcIkxlZnRcIixyOlwiUmlnaHRcIix4OlwiSG9yaXpvbnRhbFwiLHk6XCJWZXJ0aWNhbFwifTtmdW5jdGlvbiB6aShlKXtyZXR1cm4gWWhbZSE9bnVsbD9lOlwiXCJdfHxcIkFsbFwifWZ1bmN0aW9uIEdpKGUpe2xldCB0PVwiQWxsXCI7cmV0dXJuW2UucmVwbGFjZSgvXi0odHxifHJ8bHx0cnx0bHxicnxibCkoLXwkKS8sKHIsaSk9Pih0PXppKGkpLFwiXCIpKSx0XX1mdW5jdGlvbiBaZShlLHQ9e30pe2lmKGUuaW5jbHVkZXMoXCIvXCIpKXtsZXQgbj1RcyhlLHsuLi50LGZyYWN0aW9uczohMH0pO2lmKG4pcmV0dXJuIG59cmV0dXJuIGVbMF09PT1cIltcIiYmKGU9ZS5zbGljZSgxLC0xKSksUXMoZSx0KX1mdW5jdGlvbiBfZShlLHQsbj17fSl7bGV0IHI9WmUodCxuKTtyZXR1cm4gcj09PW51bGw/bnVsbDp2KHtbZV06cn0pfWZ1bmN0aW9uIFFzKGUsdD17fSl7aWYoZT09PVwicHhcIilyZXR1cm4gMTtsZXQgbj1yZShlLHQpO2lmKCFuKXJldHVybiBudWxsO2xldFtyLGldPW47cmV0dXJuIHQuZnJhY3Rpb25zJiYoaT0kLnBlcmNlbnQscio9MTAwKSxpPT09JC5ub25lJiYocj1yLzQsaT0kLnJlbSkscWUocixpLHQpfWZ1bmN0aW9uIFhoKC4uLmUpe2NvbnNvbGUud2FybiguLi5lKX1mdW5jdGlvbiBRaCguLi5lKXt9dmFyIGNlPXR5cGVvZiBwcm9jZXNzPlwidVwifHwoKEJpPXByb2Nlc3M9PW51bGw/dm9pZCAwOnByb2Nlc3MuZW52KT09PW51bGx8fEJpPT09dm9pZCAwP3ZvaWQgMDpCaS5KRVNUX1dPUktFUl9JRCk9PT12b2lkIDA/WGg6UWg7dmFyIEpoPVtbXCJhc3BlY3Qtc3F1YXJlXCIsdih7YXNwZWN0UmF0aW86MX0pXSxbXCJhc3BlY3QtdmlkZW9cIix2KHthc3BlY3RSYXRpbzoxNi85fSldLFtcIml0ZW1zLWNlbnRlclwiLHYoe2FsaWduSXRlbXM6XCJjZW50ZXJcIn0pXSxbXCJpdGVtcy1zdGFydFwiLHYoe2FsaWduSXRlbXM6XCJmbGV4LXN0YXJ0XCJ9KV0sW1wiaXRlbXMtZW5kXCIsdih7YWxpZ25JdGVtczpcImZsZXgtZW5kXCJ9KV0sW1wiaXRlbXMtYmFzZWxpbmVcIix2KHthbGlnbkl0ZW1zOlwiYmFzZWxpbmVcIn0pXSxbXCJpdGVtcy1zdHJldGNoXCIsdih7YWxpZ25JdGVtczpcInN0cmV0Y2hcIn0pXSxbXCJqdXN0aWZ5LXN0YXJ0XCIsdih7anVzdGlmeUNvbnRlbnQ6XCJmbGV4LXN0YXJ0XCJ9KV0sW1wianVzdGlmeS1lbmRcIix2KHtqdXN0aWZ5Q29udGVudDpcImZsZXgtZW5kXCJ9KV0sW1wianVzdGlmeS1jZW50ZXJcIix2KHtqdXN0aWZ5Q29udGVudDpcImNlbnRlclwifSldLFtcImp1c3RpZnktYmV0d2VlblwiLHYoe2p1c3RpZnlDb250ZW50Olwic3BhY2UtYmV0d2VlblwifSldLFtcImp1c3RpZnktYXJvdW5kXCIsdih7anVzdGlmeUNvbnRlbnQ6XCJzcGFjZS1hcm91bmRcIn0pXSxbXCJqdXN0aWZ5LWV2ZW5seVwiLHYoe2p1c3RpZnlDb250ZW50Olwic3BhY2UtZXZlbmx5XCJ9KV0sW1wiY29udGVudC1zdGFydFwiLHYoe2FsaWduQ29udGVudDpcImZsZXgtc3RhcnRcIn0pXSxbXCJjb250ZW50LWVuZFwiLHYoe2FsaWduQ29udGVudDpcImZsZXgtZW5kXCJ9KV0sW1wiY29udGVudC1iZXR3ZWVuXCIsdih7YWxpZ25Db250ZW50Olwic3BhY2UtYmV0d2VlblwifSldLFtcImNvbnRlbnQtYXJvdW5kXCIsdih7YWxpZ25Db250ZW50Olwic3BhY2UtYXJvdW5kXCJ9KV0sW1wiY29udGVudC1zdHJldGNoXCIsdih7YWxpZ25Db250ZW50Olwic3RyZXRjaFwifSldLFtcImNvbnRlbnQtY2VudGVyXCIsdih7YWxpZ25Db250ZW50OlwiY2VudGVyXCJ9KV0sW1wic2VsZi1hdXRvXCIsdih7YWxpZ25TZWxmOlwiYXV0b1wifSldLFtcInNlbGYtc3RhcnRcIix2KHthbGlnblNlbGY6XCJmbGV4LXN0YXJ0XCJ9KV0sW1wic2VsZi1lbmRcIix2KHthbGlnblNlbGY6XCJmbGV4LWVuZFwifSldLFtcInNlbGYtY2VudGVyXCIsdih7YWxpZ25TZWxmOlwiY2VudGVyXCJ9KV0sW1wic2VsZi1zdHJldGNoXCIsdih7YWxpZ25TZWxmOlwic3RyZXRjaFwifSldLFtcInNlbGYtYmFzZWxpbmVcIix2KHthbGlnblNlbGY6XCJiYXNlbGluZVwifSldLFtcImRpcmVjdGlvbi1pbmhlcml0XCIsdih7ZGlyZWN0aW9uOlwiaW5oZXJpdFwifSldLFtcImRpcmVjdGlvbi1sdHJcIix2KHtkaXJlY3Rpb246XCJsdHJcIn0pXSxbXCJkaXJlY3Rpb24tcnRsXCIsdih7ZGlyZWN0aW9uOlwicnRsXCJ9KV0sW1wiaGlkZGVuXCIsdih7ZGlzcGxheTpcIm5vbmVcIn0pXSxbXCJmbGV4XCIsdih7ZGlzcGxheTpcImZsZXhcIn0pXSxbXCJmbGV4LXJvd1wiLHYoe2ZsZXhEaXJlY3Rpb246XCJyb3dcIn0pXSxbXCJmbGV4LXJvdy1yZXZlcnNlXCIsdih7ZmxleERpcmVjdGlvbjpcInJvdy1yZXZlcnNlXCJ9KV0sW1wiZmxleC1jb2xcIix2KHtmbGV4RGlyZWN0aW9uOlwiY29sdW1uXCJ9KV0sW1wiZmxleC1jb2wtcmV2ZXJzZVwiLHYoe2ZsZXhEaXJlY3Rpb246XCJjb2x1bW4tcmV2ZXJzZVwifSldLFtcImZsZXgtd3JhcFwiLHYoe2ZsZXhXcmFwOlwid3JhcFwifSldLFtcImZsZXgtd3JhcC1yZXZlcnNlXCIsdih7ZmxleFdyYXA6XCJ3cmFwLXJldmVyc2VcIn0pXSxbXCJmbGV4LW5vd3JhcFwiLHYoe2ZsZXhXcmFwOlwibm93cmFwXCJ9KV0sW1wiZmxleC1hdXRvXCIsdih7ZmxleEdyb3c6MSxmbGV4U2hyaW5rOjEsZmxleEJhc2lzOlwiYXV0b1wifSldLFtcImZsZXgtaW5pdGlhbFwiLHYoe2ZsZXhHcm93OjAsZmxleFNocmluazoxLGZsZXhCYXNpczpcImF1dG9cIn0pXSxbXCJmbGV4LW5vbmVcIix2KHtmbGV4R3JvdzowLGZsZXhTaHJpbms6MCxmbGV4QmFzaXM6XCJhdXRvXCJ9KV0sW1wib3ZlcmZsb3ctaGlkZGVuXCIsdih7b3ZlcmZsb3c6XCJoaWRkZW5cIn0pXSxbXCJvdmVyZmxvdy12aXNpYmxlXCIsdih7b3ZlcmZsb3c6XCJ2aXNpYmxlXCJ9KV0sW1wib3ZlcmZsb3ctc2Nyb2xsXCIsdih7b3ZlcmZsb3c6XCJzY3JvbGxcIn0pXSxbXCJhYnNvbHV0ZVwiLHYoe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIn0pXSxbXCJyZWxhdGl2ZVwiLHYoe3Bvc2l0aW9uOlwicmVsYXRpdmVcIn0pXSxbXCJpdGFsaWNcIix2KHtmb250U3R5bGU6XCJpdGFsaWNcIn0pXSxbXCJub3QtaXRhbGljXCIsdih7Zm9udFN0eWxlOlwibm9ybWFsXCJ9KV0sW1wib2xkc3R5bGUtbnVtc1wiLFl0KFwib2xkc3R5bGUtbnVtc1wiKV0sW1wic21hbGwtY2Fwc1wiLFl0KFwic21hbGwtY2Fwc1wiKV0sW1wibGluaW5nLW51bXNcIixZdChcImxpbmluZy1udW1zXCIpXSxbXCJ0YWJ1bGFyLW51bXNcIixZdChcInRhYnVsYXItbnVtc1wiKV0sW1wicHJvcG9ydGlvbmFsLW51bXNcIixZdChcInByb3BvcnRpb25hbC1udW1zXCIpXSxbXCJmb250LXRoaW5cIix2KHtmb250V2VpZ2h0OlwiMTAwXCJ9KV0sW1wiZm9udC0xMDBcIix2KHtmb250V2VpZ2h0OlwiMTAwXCJ9KV0sW1wiZm9udC1leHRyYWxpZ2h0XCIsdih7Zm9udFdlaWdodDpcIjIwMFwifSldLFtcImZvbnQtMjAwXCIsdih7Zm9udFdlaWdodDpcIjIwMFwifSldLFtcImZvbnQtbGlnaHRcIix2KHtmb250V2VpZ2h0OlwiMzAwXCJ9KV0sW1wiZm9udC0zMDBcIix2KHtmb250V2VpZ2h0OlwiMzAwXCJ9KV0sW1wiZm9udC1ub3JtYWxcIix2KHtmb250V2VpZ2h0Olwibm9ybWFsXCJ9KV0sW1wiZm9udC00MDBcIix2KHtmb250V2VpZ2h0OlwiNDAwXCJ9KV0sW1wiZm9udC1tZWRpdW1cIix2KHtmb250V2VpZ2h0OlwiNTAwXCJ9KV0sW1wiZm9udC01MDBcIix2KHtmb250V2VpZ2h0OlwiNTAwXCJ9KV0sW1wiZm9udC1zZW1pYm9sZFwiLHYoe2ZvbnRXZWlnaHQ6XCI2MDBcIn0pXSxbXCJmb250LTYwMFwiLHYoe2ZvbnRXZWlnaHQ6XCI2MDBcIn0pXSxbXCJmb250LWJvbGRcIix2KHtmb250V2VpZ2h0OlwiYm9sZFwifSldLFtcImZvbnQtNzAwXCIsdih7Zm9udFdlaWdodDpcIjcwMFwifSldLFtcImZvbnQtZXh0cmFib2xkXCIsdih7Zm9udFdlaWdodDpcIjgwMFwifSldLFtcImZvbnQtODAwXCIsdih7Zm9udFdlaWdodDpcIjgwMFwifSldLFtcImZvbnQtYmxhY2tcIix2KHtmb250V2VpZ2h0OlwiOTAwXCJ9KV0sW1wiZm9udC05MDBcIix2KHtmb250V2VpZ2h0OlwiOTAwXCJ9KV0sW1wiaW5jbHVkZS1mb250LXBhZGRpbmdcIix2KHtpbmNsdWRlRm9udFBhZGRpbmc6ITB9KV0sW1wicmVtb3ZlLWZvbnQtcGFkZGluZ1wiLHYoe2luY2x1ZGVGb250UGFkZGluZzohMX0pXSxbXCJtYXgtdy1ub25lXCIsdih7bWF4V2lkdGg6XCI5OTk5OSVcIn0pXSxbXCJ0ZXh0LWxlZnRcIix2KHt0ZXh0QWxpZ246XCJsZWZ0XCJ9KV0sW1widGV4dC1jZW50ZXJcIix2KHt0ZXh0QWxpZ246XCJjZW50ZXJcIn0pXSxbXCJ0ZXh0LXJpZ2h0XCIsdih7dGV4dEFsaWduOlwicmlnaHRcIn0pXSxbXCJ0ZXh0LWp1c3RpZnlcIix2KHt0ZXh0QWxpZ246XCJqdXN0aWZ5XCJ9KV0sW1widGV4dC1hdXRvXCIsdih7dGV4dEFsaWduOlwiYXV0b1wifSldLFtcInVuZGVybGluZVwiLHYoe3RleHREZWNvcmF0aW9uTGluZTpcInVuZGVybGluZVwifSldLFtcImxpbmUtdGhyb3VnaFwiLHYoe3RleHREZWNvcmF0aW9uTGluZTpcImxpbmUtdGhyb3VnaFwifSldLFtcIm5vLXVuZGVybGluZVwiLHYoe3RleHREZWNvcmF0aW9uTGluZTpcIm5vbmVcIn0pXSxbXCJ1cHBlcmNhc2VcIix2KHt0ZXh0VHJhbnNmb3JtOlwidXBwZXJjYXNlXCJ9KV0sW1wibG93ZXJjYXNlXCIsdih7dGV4dFRyYW5zZm9ybTpcImxvd2VyY2FzZVwifSldLFtcImNhcGl0YWxpemVcIix2KHt0ZXh0VHJhbnNmb3JtOlwiY2FwaXRhbGl6ZVwifSldLFtcIm5vcm1hbC1jYXNlXCIsdih7dGV4dFRyYW5zZm9ybTpcIm5vbmVcIn0pXSxbXCJ3LWF1dG9cIix2KHt3aWR0aDpcImF1dG9cIn0pXSxbXCJoLWF1dG9cIix2KHtoZWlnaHQ6XCJhdXRvXCJ9KV0sW1wic2hhZG93LXNtXCIsdih7c2hhZG93T2Zmc2V0Ont3aWR0aDoxLGhlaWdodDoxfSxzaGFkb3dDb2xvcjpcIiMwMDBcIixzaGFkb3dSYWRpdXM6MSxzaGFkb3dPcGFjaXR5Oi4wMjUsZWxldmF0aW9uOjF9KV0sW1wic2hhZG93XCIsdih7c2hhZG93T2Zmc2V0Ont3aWR0aDoxLGhlaWdodDoxfSxzaGFkb3dDb2xvcjpcIiMwMDBcIixzaGFkb3dSYWRpdXM6MSxzaGFkb3dPcGFjaXR5Oi4wNzUsZWxldmF0aW9uOjJ9KV0sW1wic2hhZG93LW1kXCIsdih7c2hhZG93T2Zmc2V0Ont3aWR0aDoxLGhlaWdodDoxfSxzaGFkb3dDb2xvcjpcIiMwMDBcIixzaGFkb3dSYWRpdXM6MyxzaGFkb3dPcGFjaXR5Oi4xMjUsZWxldmF0aW9uOjN9KV0sW1wic2hhZG93LWxnXCIsdih7c2hhZG93T2Zmc2V0Ont3aWR0aDoxLGhlaWdodDoxfSxzaGFkb3dDb2xvcjpcIiMwMDBcIixzaGFkb3dPcGFjaXR5Oi4xNSxzaGFkb3dSYWRpdXM6OCxlbGV2YXRpb246OH0pXSxbXCJzaGFkb3cteGxcIix2KHtzaGFkb3dPZmZzZXQ6e3dpZHRoOjEsaGVpZ2h0OjF9LHNoYWRvd0NvbG9yOlwiIzAwMFwiLHNoYWRvd09wYWNpdHk6LjE5LHNoYWRvd1JhZGl1czoyMCxlbGV2YXRpb246MTJ9KV0sW1wic2hhZG93LTJ4bFwiLHYoe3NoYWRvd09mZnNldDp7d2lkdGg6MSxoZWlnaHQ6MX0sc2hhZG93Q29sb3I6XCIjMDAwXCIsc2hhZG93T3BhY2l0eTouMjUsc2hhZG93UmFkaXVzOjMwLGVsZXZhdGlvbjoxNn0pXSxbXCJzaGFkb3ctbm9uZVwiLHYoe3NoYWRvd09mZnNldDp7d2lkdGg6MCxoZWlnaHQ6MH0sc2hhZG93Q29sb3I6XCIjMDAwXCIsc2hhZG93UmFkaXVzOjAsc2hhZG93T3BhY2l0eTowLGVsZXZhdGlvbjowfSldXSxqaT1KaDtmdW5jdGlvbiBZdChlKXtyZXR1cm57a2luZDpcImRlcGVuZGVudFwiLGNvbXBsZXRlKHQpeyghdC5mb250VmFyaWFudHx8IUFycmF5LmlzQXJyYXkodC5mb250VmFyaWFudCkpJiYodC5mb250VmFyaWFudD1bXSksdC5mb250VmFyaWFudC5wdXNoKGUpfX19dmFyIFh0PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuaXI9bmV3IE1hcChqaSksdGhpcy5zdHlsZXM9bmV3IE1hcCx0aGlzLnByZWZpeGVzPW5ldyBNYXAsdGhpcy5pcj1uZXcgTWFwKFsuLi5qaSwuLi50IT1udWxsP3Q6W11dKX1nZXRTdHlsZSh0KXtyZXR1cm4gdGhpcy5zdHlsZXMuZ2V0KHQpfXNldFN0eWxlKHQsbil7dGhpcy5zdHlsZXMuc2V0KHQsbil9Z2V0SXIodCl7cmV0dXJuIHRoaXMuaXIuZ2V0KHQpfXNldElyKHQsbil7dGhpcy5pci5zZXQodCxuKX1nZXRQcmVmaXhNYXRjaCh0KXtyZXR1cm4gdGhpcy5wcmVmaXhlcy5nZXQodCl9c2V0UHJlZml4TWF0Y2godCxuKXt0aGlzLnByZWZpeGVzLnNldCh0LG4pfX07YygpO2MoKTtmdW5jdGlvbiBWaShlLHQsbj17fSl7bGV0IHI9dD09bnVsbD92b2lkIDA6dFtlXTtpZighcilyZXR1cm4gX2UoXCJmb250U2l6ZVwiLGUsbik7aWYodHlwZW9mIHI9PVwic3RyaW5nXCIpcmV0dXJuIExlKFwiZm9udFNpemVcIixyKTtsZXQgaT17fSxbYSxvXT1yLHM9SnMoXCJmb250U2l6ZVwiLGEpO2lmKHMmJihpPXMpLHR5cGVvZiBvPT1cInN0cmluZ1wiKXJldHVybiB2KERyKFwibGluZUhlaWdodFwiLEtzKG8saSksaSkpO2xldHtsaW5lSGVpZ2h0OnUsbGV0dGVyU3BhY2luZzpsfT1vO3JldHVybiB1JiZEcihcImxpbmVIZWlnaHRcIixLcyh1LGkpLGkpLGwmJkRyKFwibGV0dGVyU3BhY2luZ1wiLGwsaSksdihpKX1mdW5jdGlvbiBLcyhlLHQpe2xldCBuPXJlKGUpO2lmKG4pe2xldFtyLGldPW47aWYoKGk9PT0kLm5vbmV8fGk9PT0kLmVtKSYmdHlwZW9mIHQuZm9udFNpemU9PVwibnVtYmVyXCIpcmV0dXJuIHQuZm9udFNpemUqcn1yZXR1cm4gZX1jKCk7ZnVuY3Rpb24gSGkoZSx0KXt2YXIgbjtsZXQgcj0obj10PT1udWxsP3ZvaWQgMDp0W2VdKSE9PW51bGwmJm4hPT12b2lkIDA/bjplLnN0YXJ0c1dpdGgoXCJbXCIpP2Uuc2xpY2UoMSwtMSk6ZSxpPXJlKHIpO2lmKCFpKXJldHVybiBudWxsO2xldFthLG9dPWk7aWYobz09PSQubm9uZSlyZXR1cm57a2luZDpcImRlcGVuZGVudFwiLGNvbXBsZXRlKHUpe2lmKHR5cGVvZiB1LmZvbnRTaXplIT1cIm51bWJlclwiKXJldHVyblwicmVsYXRpdmUgbGluZS1oZWlnaHQgdXRpbGl0aWVzIHJlcXVpcmUgdGhhdCBmb250LXNpemUgYmUgc2V0XCI7dS5saW5lSGVpZ2h0PXUuZm9udFNpemUqYX19O2xldCBzPXFlKGEsbyk7cmV0dXJuIHMhPT1udWxsP3Yoe2xpbmVIZWlnaHQ6c30pOm51bGx9YygpO2Z1bmN0aW9uIFlpKGUsdCxuLHIsaSl7bGV0IGE9XCJcIjtpZihyWzBdPT09XCJbXCIpYT1yLnNsaWNlKDEsLTEpO2Vsc2V7bGV0IGw9aT09bnVsbD92b2lkIDA6aVtyXTtpZihsKWE9bDtlbHNle2xldCBmPVplKHIpO3JldHVybiBmJiZ0eXBlb2YgZj09XCJudW1iZXJcIj9acyhmLCQucHgsdCxlKTpudWxsfX1pZihhPT09XCJhdXRvXCIpcmV0dXJuIGV1KHQsZSxcImF1dG9cIik7bGV0IG89cmUoYSk7aWYoIW8pcmV0dXJuIG51bGw7bGV0W3MsdV09bztyZXR1cm4gbiYmKHM9LXMpLFpzKHMsdSx0LGUpfWZ1bmN0aW9uIFpzKGUsdCxuLHIpe2xldCBpPXFlKGUsdCk7cmV0dXJuIGk9PT1udWxsP251bGw6ZXUobixyLGkpfWZ1bmN0aW9uIGV1KGUsdCxuKXtzd2l0Y2goZSl7Y2FzZVwiQWxsXCI6cmV0dXJue2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOntbYCR7dH1Ub3BgXTpuLFtgJHt0fVJpZ2h0YF06bixbYCR7dH1Cb3R0b21gXTpuLFtgJHt0fUxlZnRgXTpufX07Y2FzZVwiQm90dG9tXCI6Y2FzZVwiVG9wXCI6Y2FzZVwiTGVmdFwiOmNhc2VcIlJpZ2h0XCI6cmV0dXJue2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOntbYCR7dH0ke2V9YF06bn19O2Nhc2VcIlZlcnRpY2FsXCI6cmV0dXJue2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOntbYCR7dH1Ub3BgXTpuLFtgJHt0fUJvdHRvbWBdOm59fTtjYXNlXCJIb3Jpem9udGFsXCI6cmV0dXJue2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOntbYCR7dH1MZWZ0YF06bixbYCR7dH1SaWdodGBdOm59fTtkZWZhdWx0OnJldHVybiBudWxsfX1jKCk7ZnVuY3Rpb24gWGkoZSl7aWYoIWUpcmV0dXJue307bGV0IHQ9T2JqZWN0LmVudHJpZXMoZSkucmVkdWNlKChpLFthLG9dKT0+e2xldCBzPVswLDEvMCwwXSx1PXR5cGVvZiBvPT1cInN0cmluZ1wiP3ttaW46b306byxsPXUubWluP1VpKHUubWluKTowO2w9PT1udWxsP2NlKGBpbnZhbGlkIHNjcmVlbiBjb25maWcgdmFsdWU6ICR7YX0tPm1pbjogJHt1Lm1pbn1gKTpzWzBdPWw7bGV0IGY9dS5tYXg/VWkodS5tYXgpOjEvMDtyZXR1cm4gZj09PW51bGw/Y2UoYGludmFsaWQgc2NyZWVuIGNvbmZpZyB2YWx1ZTogJHthfS0+bWF4OiAke3UubWF4fWApOnNbMV09ZixpW2FdPXMsaX0se30pLG49T2JqZWN0LnZhbHVlcyh0KTtuLnNvcnQoKGksYSk9PntsZXRbbyxzXT1pLFt1LGxdPWE7cmV0dXJuIHM9PT0xLzB8fGw9PT0xLzA/by11OnMtbH0pO2xldCByPTA7cmV0dXJuIG4uZm9yRWFjaChpPT5pWzJdPXIrKyksdH1jKCk7ZnVuY3Rpb24gUWkoZSx0KXtsZXQgbj10PT1udWxsP3ZvaWQgMDp0W2VdO2lmKCFuKXJldHVybiBudWxsO2lmKHR5cGVvZiBuPT1cInN0cmluZ1wiKXJldHVybiB2KHtmb250RmFtaWx5Om59KTtsZXQgcj1uWzBdO3JldHVybiByP3Yoe2ZvbnRGYW1pbHk6cn0pOm51bGx9YygpO2Z1bmN0aW9uIGV0KGUsdCxuKXtpZighbilyZXR1cm4gbnVsbDtsZXQgcjt0LmluY2x1ZGVzKFwiL1wiKSYmKFt0PVwiXCIscl09dC5zcGxpdChcIi9cIiwyKSk7bGV0IGk9XCJcIjtpZih0LnN0YXJ0c1dpdGgoXCJbI1wiKXx8dC5zdGFydHNXaXRoKFwiW3JnYlwiKT9pPXQuc2xpY2UoMSwtMSk6aT1udSh0LG4pLCFpKXJldHVybiBudWxsO2lmKHIpe2xldCBhPU51bWJlcihyKTtpZighTnVtYmVyLmlzTmFOKGEpKXJldHVybiBpPXR1KGksYS8xMDApLHYoe1tGcltlXS5jb2xvcl06aX0pfXJldHVybntraW5kOlwiZGVwZW5kZW50XCIsY29tcGxldGUoYSl7bGV0IG89RnJbZV0ub3BhY2l0eSxzPWFbb107dHlwZW9mIHM9PVwibnVtYmVyXCImJihpPXR1KGkscykpLGFbRnJbZV0uY29sb3JdPWl9fX1mdW5jdGlvbiBRdChlLHQpe2xldCBuPXBhcnNlSW50KHQsMTApO2lmKE51bWJlci5pc05hTihuKSlyZXR1cm4gbnVsbDtsZXQgcj1uLzEwMCxpPXtbRnJbZV0ub3BhY2l0eV06cn07cmV0dXJue2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOml9fWZ1bmN0aW9uIHR1KGUsdCl7cmV0dXJuIGUuc3RhcnRzV2l0aChcIiNcIik/ZT1LaChlKTplLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpJiYoZT1lLnJlcGxhY2UoL15yZ2JcXCgvLFwicmdiYShcIikucmVwbGFjZSgvXFwpJC8sXCIsIDEpXCIpKSxlLnJlcGxhY2UoLywgP1xcZCpcXC4/KFxcZCspXFwpJC8sYCwgJHt0fSlgKX1mdW5jdGlvbiBydShlKXtmb3IobGV0IHQgaW4gZSl0LnN0YXJ0c1dpdGgoXCJfX29wYWNpdHlfXCIpJiZkZWxldGUgZVt0XX12YXIgRnI9e2JnOntvcGFjaXR5OlwiX19vcGFjaXR5X2JnXCIsY29sb3I6XCJiYWNrZ3JvdW5kQ29sb3JcIn0sdGV4dDp7b3BhY2l0eTpcIl9fb3BhY2l0eV90ZXh0XCIsY29sb3I6XCJjb2xvclwifSxib3JkZXI6e29wYWNpdHk6XCJfX29wYWNpdHlfYm9yZGVyXCIsY29sb3I6XCJib3JkZXJDb2xvclwifSxib3JkZXJUb3A6e29wYWNpdHk6XCJfX29wYWNpdHlfYm9yZGVyXCIsY29sb3I6XCJib3JkZXJUb3BDb2xvclwifSxib3JkZXJCb3R0b206e29wYWNpdHk6XCJfX29wYWNpdHlfYm9yZGVyXCIsY29sb3I6XCJib3JkZXJCb3R0b21Db2xvclwifSxib3JkZXJMZWZ0OntvcGFjaXR5OlwiX19vcGFjaXR5X2JvcmRlclwiLGNvbG9yOlwiYm9yZGVyTGVmdENvbG9yXCJ9LGJvcmRlclJpZ2h0OntvcGFjaXR5OlwiX19vcGFjaXR5X2JvcmRlclwiLGNvbG9yOlwiYm9yZGVyUmlnaHRDb2xvclwifSxzaGFkb3c6e29wYWNpdHk6XCJfX29wYWNpdHlfc2hhZG93XCIsY29sb3I6XCJzaGFkb3dDb2xvclwifSx0aW50OntvcGFjaXR5OlwiX19vcGFjaXR5X3RpbnRcIixjb2xvcjpcInRpbnRDb2xvclwifX07ZnVuY3Rpb24gS2goZSl7bGV0IHQ9ZTtlPWUucmVwbGFjZShaaCwobyxzLHUsbCk9PnMrcyt1K3UrbCtsKTtsZXQgbj1lMC5leGVjKGUpO2lmKCFuKXJldHVybiBjZShgaW52YWxpZCBjb25maWcgaGV4IGNvbG9yIHZhbHVlOiAke3R9YCksXCJyZ2JhKDAsIDAsIDAsIDEpXCI7bGV0IHI9cGFyc2VJbnQoblsxXSwxNiksaT1wYXJzZUludChuWzJdLDE2KSxhPXBhcnNlSW50KG5bM10sMTYpO3JldHVybmByZ2JhKCR7cn0sICR7aX0sICR7YX0sIDEpYH1mdW5jdGlvbiBudShlLHQpe2xldCBuPXRbZV07aWYoJGkobikpcmV0dXJuIG47aWYocWkobikmJiRpKG4uREVGQVVMVCkpcmV0dXJuIG4uREVGQVVMVDtsZXRbcj1cIlwiLC4uLmldPWUuc3BsaXQoXCItXCIpO2Zvcig7ciE9PWU7KXtsZXQgYT10W3JdO2lmKHFpKGEpKXJldHVybiBudShpLmpvaW4oXCItXCIpLGEpO2lmKGkubGVuZ3RoPT09MClyZXR1cm5cIlwiO3I9YCR7cn0tJHtpLnNoaWZ0KCl9YH1yZXR1cm5cIlwifXZhciBaaD0vXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pLGUwPS9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7YygpO2Z1bmN0aW9uIG91KGUsdCl7bGV0W24scl09R2koZSk7aWYobi5tYXRjaCgvXigtPyhcXGQpKyk/JC8pKXJldHVybiB0MChuLHIsdD09bnVsbD92b2lkIDA6dC5ib3JkZXJXaWR0aCk7aWYobj1uLnJlcGxhY2UoL14tLyxcIlwiKSxbXCJkYXNoZWRcIixcInNvbGlkXCIsXCJkb3R0ZWRcIl0uaW5jbHVkZXMobikpcmV0dXJuIHYoe2JvcmRlclN0eWxlOm59KTtsZXQgYT1cImJvcmRlclwiO3N3aXRjaChyKXtjYXNlXCJCb3R0b21cIjphPVwiYm9yZGVyQm90dG9tXCI7YnJlYWs7Y2FzZVwiVG9wXCI6YT1cImJvcmRlclRvcFwiO2JyZWFrO2Nhc2VcIkxlZnRcIjphPVwiYm9yZGVyTGVmdFwiO2JyZWFrO2Nhc2VcIlJpZ2h0XCI6YT1cImJvcmRlclJpZ2h0XCI7YnJlYWt9bGV0IG89ZXQoYSxuLHQ9PW51bGw/dm9pZCAwOnQuYm9yZGVyQ29sb3IpO2lmKG8pcmV0dXJuIG87bGV0IHM9YGJvcmRlciR7cj09PVwiQWxsXCI/XCJcIjpyfVdpZHRoYDtuPW4ucmVwbGFjZSgvXi0vLFwiXCIpO2xldCB1PW4uc2xpY2UoMSwtMSksbD1fZShzLHUpO3JldHVybiB0eXBlb2YobD09bnVsbD92b2lkIDA6bC5zdHlsZVtzXSkhPVwibnVtYmVyXCI/bnVsbDpsfWZ1bmN0aW9uIHQwKGUsdCxuKXtpZighbilyZXR1cm4gbnVsbDtlPWUucmVwbGFjZSgvXi0vLFwiXCIpO2xldCBpPW5bZT09PVwiXCI/XCJERUZBVUxUXCI6ZV07aWYoaT09PXZvaWQgMClyZXR1cm4gbnVsbDtsZXQgYT1gYm9yZGVyJHt0PT09XCJBbGxcIj9cIlwiOnR9V2lkdGhgO3JldHVybiBMZShhLGkpfWZ1bmN0aW9uIGF1KGUsdCl7aWYoIXQpcmV0dXJuIG51bGw7bGV0W24scl09R2koZSk7bj1uLnJlcGxhY2UoL14tLyxcIlwiKSxuPT09XCJcIiYmKG49XCJERUZBVUxUXCIpO2xldCBpPWBib3JkZXIke3I9PT1cIkFsbFwiP1wiXCI6cn1SYWRpdXNgLGE9dFtuXTtpZihhKXJldHVybiBpdShMZShpLGEpKTtsZXQgbz1fZShpLG4pO3JldHVybiB0eXBlb2Yobz09bnVsbD92b2lkIDA6by5zdHlsZVtpXSkhPVwibnVtYmVyXCI/bnVsbDppdShvKX1mdW5jdGlvbiBpdShlKXtpZigoZT09bnVsbD92b2lkIDA6ZS5raW5kKSE9PVwiY29tcGxldGVcIilyZXR1cm4gZTtsZXQgdD1lLnN0eWxlLmJvcmRlclRvcFJhZGl1czt0IT09dm9pZCAwJiYoZS5zdHlsZS5ib3JkZXJUb3BMZWZ0UmFkaXVzPXQsZS5zdHlsZS5ib3JkZXJUb3BSaWdodFJhZGl1cz10LGRlbGV0ZSBlLnN0eWxlLmJvcmRlclRvcFJhZGl1cyk7bGV0IG49ZS5zdHlsZS5ib3JkZXJCb3R0b21SYWRpdXM7biE9PXZvaWQgMCYmKGUuc3R5bGUuYm9yZGVyQm90dG9tTGVmdFJhZGl1cz1uLGUuc3R5bGUuYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM9bixkZWxldGUgZS5zdHlsZS5ib3JkZXJCb3R0b21SYWRpdXMpO2xldCByPWUuc3R5bGUuYm9yZGVyTGVmdFJhZGl1cztyIT09dm9pZCAwJiYoZS5zdHlsZS5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzPXIsZS5zdHlsZS5ib3JkZXJUb3BMZWZ0UmFkaXVzPXIsZGVsZXRlIGUuc3R5bGUuYm9yZGVyTGVmdFJhZGl1cyk7bGV0IGk9ZS5zdHlsZS5ib3JkZXJSaWdodFJhZGl1cztyZXR1cm4gaSE9PXZvaWQgMCYmKGUuc3R5bGUuYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM9aSxlLnN0eWxlLmJvcmRlclRvcFJpZ2h0UmFkaXVzPWksZGVsZXRlIGUuc3R5bGUuYm9yZGVyUmlnaHRSYWRpdXMpLGV9YygpO2Z1bmN0aW9uIHV0KGUsdCxuLHIpe2xldCBpPW51bGw7ZT09PVwiaW5zZXRcIiYmKHQ9dC5yZXBsYWNlKC9eKHh8eSktLywocyx1KT0+KGk9dT09PVwieFwiP1wieFwiOlwieVwiLFwiXCIpKSk7bGV0IGE9cj09bnVsbD92b2lkIDA6clt0XTtpZihhKXtsZXQgcz1FZShhLHtpc05lZ2F0aXZlOm59KTtpZihzIT09bnVsbClyZXR1cm4gc3UoZSxpLHMpfWxldCBvPVplKHQse2lzTmVnYXRpdmU6bn0pO3JldHVybiBvIT09bnVsbD9zdShlLGksbyk6bnVsbH1mdW5jdGlvbiBzdShlLHQsbil7aWYoZSE9PVwiaW5zZXRcIilyZXR1cm4gdih7W2VdOm59KTtzd2l0Y2godCl7Y2FzZSBudWxsOnJldHVybiB2KHt0b3A6bixsZWZ0Om4scmlnaHQ6bixib3R0b206bn0pO2Nhc2VcInlcIjpyZXR1cm4gdih7dG9wOm4sYm90dG9tOm59KTtjYXNlXCJ4XCI6cmV0dXJuIHYoe2xlZnQ6bixyaWdodDpufSl9fWMoKTtmdW5jdGlvbiBKdChlLHQsbil7dmFyIHI7dD10LnJlcGxhY2UoL14tLyxcIlwiKTtsZXQgaT10PT09XCJcIj9cIkRFRkFVTFRcIjp0LGE9TnVtYmVyKChyPW49PW51bGw/dm9pZCAwOm5baV0pIT09bnVsbCYmciE9PXZvaWQgMD9yOnQpO3JldHVybiBOdW1iZXIuaXNOYU4oYSk/bnVsbDp2KHtbYGZsZXgke2V9YF06YX0pfWZ1bmN0aW9uIHV1KGUsdCl7dmFyIG4scjtpZihlPSh0PT1udWxsP3ZvaWQgMDp0W2VdKXx8ZSxbXCJtaW4tY29udGVudFwiLFwicmV2ZXJ0XCIsXCJ1bnNldFwiXS5pbmNsdWRlcyhlKSlyZXR1cm4gbnVsbDtpZihlLm1hdGNoKC9eXFxkKyhcXC5cXGQrKT8kLykpcmV0dXJuIHYoe2ZsZXhHcm93Ok51bWJlcihlKSxmbGV4QmFzaXM6XCIwJVwifSk7bGV0IGk9ZS5tYXRjaCgvXihcXGQrKVxccysoXFxkKykkLyk7aWYoaSlyZXR1cm4gdih7ZmxleEdyb3c6TnVtYmVyKGlbMV0pLGZsZXhTaHJpbms6TnVtYmVyKGlbMl0pfSk7aWYoaT1lLm1hdGNoKC9eKFxcZCspXFxzKyhbXiBdKykkLyksaSl7bGV0IGE9RWUoKG49aVsyXSkhPT1udWxsJiZuIT09dm9pZCAwP246XCJcIik7cmV0dXJuIGE/dih7ZmxleEdyb3c6TnVtYmVyKGlbMV0pLGZsZXhCYXNpczphfSk6bnVsbH1pZihpPWUubWF0Y2goL14oXFxkKylcXHMrKFxcZCspXFxzKyguKykkLyksaSl7bGV0IGE9RWUoKHI9aVszXSkhPT1udWxsJiZyIT09dm9pZCAwP3I6XCJcIik7cmV0dXJuIGE/dih7ZmxleEdyb3c6TnVtYmVyKGlbMV0pLGZsZXhTaHJpbms6TnVtYmVyKGlbMl0pLGZsZXhCYXNpczphfSk6bnVsbH1yZXR1cm4gbnVsbH1jKCk7ZnVuY3Rpb24gSmkoZSx0LG49e30scil7bGV0IGk9cj09bnVsbD92b2lkIDA6clt0XTtyZXR1cm4gaSE9PXZvaWQgMD9MZShlLGksbik6X2UoZSx0LG4pfWZ1bmN0aW9uIEt0KGUsdCxuPXt9LHIpe2xldCBpPUVlKHI9PW51bGw/dm9pZCAwOnJbdF0sbik7cmV0dXJuIGk/dih7W2VdOml9KToodD09PVwic2NyZWVuXCImJih0PWUuaW5jbHVkZXMoXCJXaWR0aFwiKT9cIjEwMHZ3XCI6XCIxMDB2aFwiKSxfZShlLHQsbikpfWMoKTtmdW5jdGlvbiBsdShlLHQsbil7bGV0IHI9bj09bnVsbD92b2lkIDA6bltlXTtpZihyKXtsZXQgaT1yZShyLHtpc05lZ2F0aXZlOnR9KTtpZighaSlyZXR1cm4gbnVsbDtsZXRbYSxvXT1pO2lmKG89PT0kLmVtKXJldHVybiByMChhKTtpZihvPT09JC5wZXJjZW50KXJldHVybiBjZShcInBlcmNlbnRhZ2UtYmFzZWQgbGV0dGVyLXNwYWNpbmcgY29uZmlndXJhdGlvbiBjdXJyZW50bHkgdW5zdXBwb3J0ZWQsIHN3aXRjaCB0byBgZW1gcywgb3Igb3BlbiBhbiBpc3N1ZSBpZiB5b3UnZCBsaWtlIHRvIHNlZSBzdXBwb3J0IGFkZGVkLlwiKSxudWxsO2xldCBzPXFlKGEsbyx7aXNOZWdhdGl2ZTp0fSk7cmV0dXJuIHMhPT1udWxsP3Yoe2xldHRlclNwYWNpbmc6c30pOm51bGx9cmV0dXJuIF9lKFwibGV0dGVyU3BhY2luZ1wiLGUse2lzTmVnYXRpdmU6dH0pfWZ1bmN0aW9uIHIwKGUpe3JldHVybntraW5kOlwiZGVwZW5kZW50XCIsY29tcGxldGUodCl7bGV0IG49dC5mb250U2l6ZTtpZih0eXBlb2YgbiE9XCJudW1iZXJcInx8TnVtYmVyLmlzTmFOKG4pKXJldHVyblwidHJhY2tpbmctWCByZWxhdGl2ZSBsZXR0ZXIgc3BhY2luZyBjbGFzc2VzIHJlcXVpcmUgZm9udC1zaXplIHRvIGJlIHNldFwiO3QubGV0dGVyU3BhY2luZz1NYXRoLnJvdW5kKChlKm4rTnVtYmVyLkVQU0lMT04pKjEwMCkvMTAwfX19YygpO2Z1bmN0aW9uIGZ1KGUsdCl7bGV0IG49dD09bnVsbD92b2lkIDA6dFtlXTtpZihuKXtsZXQgaT1yZShTdHJpbmcobikpO2lmKGkpcmV0dXJuIHYoe29wYWNpdHk6aVswXX0pfWxldCByPXJlKGUpO3JldHVybiByP3Yoe29wYWNpdHk6clswXS8xMDB9KTpudWxsfWMoKTtmdW5jdGlvbiBjdShlKXtsZXQgdD1wYXJzZUludChlLDEwKTtyZXR1cm4gTnVtYmVyLmlzTmFOKHQpP251bGw6e2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOntzaGFkb3dPcGFjaXR5OnQvMTAwfX19ZnVuY3Rpb24gZHUoZSl7aWYoZS5pbmNsdWRlcyhcIi9cIikpe2xldFtuPVwiXCIscj1cIlwiXT1lLnNwbGl0KFwiL1wiLDIpLGk9S2kobiksYT1LaShyKTtyZXR1cm4gaT09PW51bGx8fGE9PT1udWxsP251bGw6e2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOntzaGFkb3dPZmZzZXQ6e3dpZHRoOmksaGVpZ2h0OmF9fX19bGV0IHQ9S2koZSk7cmV0dXJuIHQ9PT1udWxsP251bGw6e2tpbmQ6XCJjb21wbGV0ZVwiLHN0eWxlOntzaGFkb3dPZmZzZXQ6e3dpZHRoOnQsaGVpZ2h0OnR9fX19ZnVuY3Rpb24gS2koZSl7bGV0IHQ9WmUoZSk7cmV0dXJuIHR5cGVvZiB0PT1cIm51bWJlclwiP3Q6bnVsbH12YXIgbHQ9Y2xhc3N7Y29uc3RydWN0b3IodCxuPXt9LHIsaSxhKXt2YXIgbyxzLHUsbCxmLHA7dGhpcy5jb25maWc9bix0aGlzLmNhY2hlPXIsdGhpcy5wb3NpdGlvbj0wLHRoaXMuaXNOdWxsPSExLHRoaXMuaXNOZWdhdGl2ZT0hMSx0aGlzLmNvbnRleHQ9e30sdGhpcy5jb250ZXh0LmRldmljZT1pO2xldCBnPXQudHJpbSgpLnNwbGl0KFwiOlwiKSxtPVtdO2cubGVuZ3RoPT09MT90aGlzLnN0cmluZz10Oih0aGlzLnN0cmluZz0obz1nLnBvcCgpKSE9PW51bGwmJm8hPT12b2lkIDA/bzpcIlwiLG09ZyksdGhpcy5jaGFyPXRoaXMuc3RyaW5nWzBdO2xldCBkPVhpKChzPXRoaXMuY29uZmlnLnRoZW1lKT09PW51bGx8fHM9PT12b2lkIDA/dm9pZCAwOnMuc2NyZWVucyk7Zm9yKGxldCBoIG9mIG0paWYoZFtoXSl7bGV0IHc9KHU9ZFtoXSk9PT1udWxsfHx1PT09dm9pZCAwP3ZvaWQgMDp1WzJdO3chPT12b2lkIDAmJih0aGlzLm9yZGVyPSgobD10aGlzLm9yZGVyKSE9PW51bGwmJmwhPT12b2lkIDA/bDowKSt3KTtsZXQgYj0oZj1pLndpbmRvd0RpbWVuc2lvbnMpPT09bnVsbHx8Zj09PXZvaWQgMD92b2lkIDA6Zi53aWR0aDtpZihiKXtsZXRbXyxFXT0ocD1kW2hdKSE9PW51bGwmJnAhPT12b2lkIDA/cDpbMCwwXTsoYjw9X3x8Yj5FKSYmKHRoaXMuaXNOdWxsPSEwKX1lbHNlIHRoaXMuaXNOdWxsPSEwfWVsc2UgWXMoaCk/dGhpcy5pc051bGw9aCE9PWE6WHMoaCk/aS53aW5kb3dEaW1lbnNpb25zPyhpLndpbmRvd0RpbWVuc2lvbnMud2lkdGg+aS53aW5kb3dEaW1lbnNpb25zLmhlaWdodD9cImxhbmRzY2FwZVwiOlwicG9ydHJhaXRcIikhPT1oP3RoaXMuaXNOdWxsPSEwOnRoaXMuaW5jcmVtZW50T3JkZXIoKTp0aGlzLmlzTnVsbD0hMDpoPT09XCJyZXRpbmFcIj9pLnBpeGVsRGVuc2l0eT09PTI/dGhpcy5pbmNyZW1lbnRPcmRlcigpOnRoaXMuaXNOdWxsPSEwOmg9PT1cImRhcmtcIj9pLmNvbG9yU2NoZW1lIT09XCJkYXJrXCI/dGhpcy5pc051bGw9ITA6dGhpcy5pbmNyZW1lbnRPcmRlcigpOnRoaXMuaGFuZGxlUG9zc2libGVBcmJpdHJhcnlCcmVha3BvaW50UHJlZml4KGgpfHwodGhpcy5pc051bGw9ITApfXBhcnNlKCl7aWYodGhpcy5pc051bGwpcmV0dXJue2tpbmQ6XCJudWxsXCJ9O2xldCB0PXRoaXMuY2FjaGUuZ2V0SXIodGhpcy5yZXN0KTtpZih0KXJldHVybiB0O3RoaXMucGFyc2VJc05lZ2F0aXZlKCk7bGV0IG49dGhpcy5wYXJzZVV0aWxpdHkoKTtyZXR1cm4gbj90aGlzLm9yZGVyIT09dm9pZCAwP3traW5kOlwib3JkZXJlZFwiLG9yZGVyOnRoaXMub3JkZXIsc3R5bGVJcjpufTpuOntraW5kOlwibnVsbFwifX1wYXJzZVV0aWxpdHkoKXt2YXIgdCxuLHIsaSxhO2xldCBvPXRoaXMuY29uZmlnLnRoZW1lLHM9bnVsbDtzd2l0Y2godGhpcy5jaGFyKXtjYXNlXCJtXCI6Y2FzZVwicFwiOntsZXQgdT10aGlzLnBlZWtTbGljZSgxLDMpLm1hdGNoKC9eKHR8YnxyfGx8eHx5KT8tLyk7aWYodSl7bGV0IGw9dGhpcy5jaGFyPT09XCJtXCI/XCJtYXJnaW5cIjpcInBhZGRpbmdcIjt0aGlzLmFkdmFuY2UoKChuPSh0PXVbMF0pPT09bnVsbHx8dD09PXZvaWQgMD92b2lkIDA6dC5sZW5ndGgpIT09bnVsbCYmbiE9PXZvaWQgMD9uOjApKzEpO2xldCBmPXppKHVbMV0pLHA9WWkobCxmLHRoaXMuaXNOZWdhdGl2ZSx0aGlzLnJlc3QsKHI9dGhpcy5jb25maWcudGhlbWUpPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6cltsXSk7aWYocClyZXR1cm4gcH19fWlmKHRoaXMuY29uc3VtZVBlZWtlZChcImgtXCIpJiYocz1KaShcImhlaWdodFwiLHRoaXMucmVzdCx0aGlzLmNvbnRleHQsbz09bnVsbD92b2lkIDA6by5oZWlnaHQpLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJ3LVwiKSYmKHM9SmkoXCJ3aWR0aFwiLHRoaXMucmVzdCx0aGlzLmNvbnRleHQsbz09bnVsbD92b2lkIDA6by53aWR0aCkscyl8fHRoaXMuY29uc3VtZVBlZWtlZChcIm1pbi13LVwiKSYmKHM9S3QoXCJtaW5XaWR0aFwiLHRoaXMucmVzdCx0aGlzLmNvbnRleHQsbz09bnVsbD92b2lkIDA6by5taW5XaWR0aCkscyl8fHRoaXMuY29uc3VtZVBlZWtlZChcIm1pbi1oLVwiKSYmKHM9S3QoXCJtaW5IZWlnaHRcIix0aGlzLnJlc3QsdGhpcy5jb250ZXh0LG89PW51bGw/dm9pZCAwOm8ubWluSGVpZ2h0KSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwibWF4LXctXCIpJiYocz1LdChcIm1heFdpZHRoXCIsdGhpcy5yZXN0LHRoaXMuY29udGV4dCxvPT1udWxsP3ZvaWQgMDpvLm1heFdpZHRoKSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwibWF4LWgtXCIpJiYocz1LdChcIm1heEhlaWdodFwiLHRoaXMucmVzdCx0aGlzLmNvbnRleHQsbz09bnVsbD92b2lkIDA6by5tYXhIZWlnaHQpLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJsZWFkaW5nLVwiKSYmKHM9SGkodGhpcy5yZXN0LG89PW51bGw/dm9pZCAwOm8ubGluZUhlaWdodCkscyl8fHRoaXMuY29uc3VtZVBlZWtlZChcInRleHQtXCIpJiYocz1WaSh0aGlzLnJlc3Qsbz09bnVsbD92b2lkIDA6by5mb250U2l6ZSx0aGlzLmNvbnRleHQpLHN8fChzPWV0KFwidGV4dFwiLHRoaXMucmVzdCxvPT1udWxsP3ZvaWQgMDpvLnRleHRDb2xvcikscyl8fHRoaXMuY29uc3VtZVBlZWtlZChcIm9wYWNpdHktXCIpJiYocz1RdChcInRleHRcIix0aGlzLnJlc3QpLHMpKXx8dGhpcy5jb25zdW1lUGVla2VkKFwiZm9udC1cIikmJihzPVFpKHRoaXMucmVzdCxvPT1udWxsP3ZvaWQgMDpvLmZvbnRGYW1pbHkpLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJhc3BlY3QtXCIpJiYodGhpcy5jb25zdW1lUGVla2VkKFwicmF0aW8tXCIpJiZjZShcImBhc3BlY3QtcmF0aW8te3JhdGlvfWAgaXMgZGVwcmVjYXRlZCwgdXNlIGBhc3BlY3Qte3JhdGlvfWAgaW5zdGVhZFwiKSxzPUxlKFwiYXNwZWN0UmF0aW9cIix0aGlzLnJlc3Qse2ZyYWN0aW9uczohMH0pLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJ0aW50LVwiKSYmKHM9ZXQoXCJ0aW50XCIsdGhpcy5yZXN0LG89PW51bGw/dm9pZCAwOm8uY29sb3JzKSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwiYmctXCIpJiYocz1ldChcImJnXCIsdGhpcy5yZXN0LG89PW51bGw/dm9pZCAwOm8uYmFja2dyb3VuZENvbG9yKSxzfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJvcGFjaXR5LVwiKSYmKHM9UXQoXCJiZ1wiLHRoaXMucmVzdCkscykpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJib3JkZXJcIikmJihzPW91KHRoaXMucmVzdCxvKSxzfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCItb3BhY2l0eS1cIikmJihzPVF0KFwiYm9yZGVyXCIsdGhpcy5yZXN0KSxzKSl8fHRoaXMuY29uc3VtZVBlZWtlZChcInJvdW5kZWRcIikmJihzPWF1KHRoaXMucmVzdCxvPT1udWxsP3ZvaWQgMDpvLmJvcmRlclJhZGl1cykscyl8fHRoaXMuY29uc3VtZVBlZWtlZChcImJvdHRvbS1cIikmJihzPXV0KFwiYm90dG9tXCIsdGhpcy5yZXN0LHRoaXMuaXNOZWdhdGl2ZSxvPT1udWxsP3ZvaWQgMDpvLmluc2V0KSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwidG9wLVwiKSYmKHM9dXQoXCJ0b3BcIix0aGlzLnJlc3QsdGhpcy5pc05lZ2F0aXZlLG89PW51bGw/dm9pZCAwOm8uaW5zZXQpLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJsZWZ0LVwiKSYmKHM9dXQoXCJsZWZ0XCIsdGhpcy5yZXN0LHRoaXMuaXNOZWdhdGl2ZSxvPT1udWxsP3ZvaWQgMDpvLmluc2V0KSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwicmlnaHQtXCIpJiYocz11dChcInJpZ2h0XCIsdGhpcy5yZXN0LHRoaXMuaXNOZWdhdGl2ZSxvPT1udWxsP3ZvaWQgMDpvLmluc2V0KSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwiaW5zZXQtXCIpJiYocz11dChcImluc2V0XCIsdGhpcy5yZXN0LHRoaXMuaXNOZWdhdGl2ZSxvPT1udWxsP3ZvaWQgMDpvLmluc2V0KSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwiZmxleC1cIikmJih0aGlzLmNvbnN1bWVQZWVrZWQoXCJncm93XCIpP3M9SnQoXCJHcm93XCIsdGhpcy5yZXN0LG89PW51bGw/dm9pZCAwOm8uZmxleEdyb3cpOnRoaXMuY29uc3VtZVBlZWtlZChcInNocmlua1wiKT9zPUp0KFwiU2hyaW5rXCIsdGhpcy5yZXN0LG89PW51bGw/dm9pZCAwOm8uZmxleFNocmluayk6cz11dSh0aGlzLnJlc3Qsbz09bnVsbD92b2lkIDA6by5mbGV4KSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwiZ3Jvd1wiKSYmKHM9SnQoXCJHcm93XCIsdGhpcy5yZXN0LG89PW51bGw/dm9pZCAwOm8uZmxleEdyb3cpLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJzaHJpbmtcIikmJihzPUp0KFwiU2hyaW5rXCIsdGhpcy5yZXN0LG89PW51bGw/dm9pZCAwOm8uZmxleFNocmluaykscyl8fHRoaXMuY29uc3VtZVBlZWtlZChcInNoYWRvdy1jb2xvci1vcGFjaXR5LVwiKSYmKHM9UXQoXCJzaGFkb3dcIix0aGlzLnJlc3QpLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJzaGFkb3ctb3BhY2l0eS1cIikmJihzPWN1KHRoaXMucmVzdCkscyl8fHRoaXMuY29uc3VtZVBlZWtlZChcInNoYWRvdy1vZmZzZXQtXCIpJiYocz1kdSh0aGlzLnJlc3QpLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJzaGFkb3ctcmFkaXVzLVwiKSYmKHM9X2UoXCJzaGFkb3dSYWRpdXNcIix0aGlzLnJlc3QpLHMpfHx0aGlzLmNvbnN1bWVQZWVrZWQoXCJzaGFkb3ctXCIpJiYocz1ldChcInNoYWRvd1wiLHRoaXMucmVzdCxvPT1udWxsP3ZvaWQgMDpvLmNvbG9ycykscykpcmV0dXJuIHM7aWYodGhpcy5jb25zdW1lUGVla2VkKFwiZWxldmF0aW9uLVwiKSl7bGV0IHU9cGFyc2VJbnQodGhpcy5yZXN0LDEwKTtpZighTnVtYmVyLmlzTmFOKHUpKXJldHVybiB2KHtlbGV2YXRpb246dX0pfWlmKHRoaXMuY29uc3VtZVBlZWtlZChcIm9wYWNpdHktXCIpJiYocz1mdSh0aGlzLnJlc3Qsbz09bnVsbD92b2lkIDA6by5vcGFjaXR5KSxzKXx8dGhpcy5jb25zdW1lUGVla2VkKFwidHJhY2tpbmctXCIpJiYocz1sdSh0aGlzLnJlc3QsdGhpcy5pc05lZ2F0aXZlLG89PW51bGw/dm9pZCAwOm8ubGV0dGVyU3BhY2luZykscykpcmV0dXJuIHM7aWYodGhpcy5jb25zdW1lUGVla2VkKFwiei1cIikpe2xldCB1PU51bWJlcigoYT0oaT1vPT1udWxsP3ZvaWQgMDpvLnpJbmRleCk9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppW3RoaXMucmVzdF0pIT09bnVsbCYmYSE9PXZvaWQgMD9hOnRoaXMucmVzdCk7aWYoIU51bWJlci5pc05hTih1KSlyZXR1cm4gdih7ekluZGV4OnV9KX1yZXR1cm4gY2UoYFxcYCR7dGhpcy5yZXN0fVxcYCB1bmtub3duIG9yIGludmFsaWQgdXRpbGl0eWApLG51bGx9aGFuZGxlUG9zc2libGVBcmJpdHJhcnlCcmVha3BvaW50UHJlZml4KHQpe3ZhciBuO2lmKHRbMF0hPT1cIm1cIilyZXR1cm4hMTtsZXQgcj10Lm1hdGNoKC9eKG1pbnxtYXgpLSh3fGgpLVxcWyhbXlxcXV0rKVxcXSQvKTtpZighcilyZXR1cm4hMTtpZighKCEoKG49dGhpcy5jb250ZXh0LmRldmljZSk9PT1udWxsfHxuPT09dm9pZCAwKSYmbi53aW5kb3dEaW1lbnNpb25zKSlyZXR1cm4gdGhpcy5pc051bGw9ITAsITA7bGV0IGk9dGhpcy5jb250ZXh0LmRldmljZS53aW5kb3dEaW1lbnNpb25zLFssYT1cIlwiLG89XCJcIixzPVwiXCJdPXIsdT1vPT09XCJ3XCI/aS53aWR0aDppLmhlaWdodCxsPXJlKHMsdGhpcy5jb250ZXh0KTtpZihsPT09bnVsbClyZXR1cm4gdGhpcy5pc051bGw9ITAsITA7bGV0W2YscF09bDtyZXR1cm4gcCE9PVwicHhcIiYmKHRoaXMuaXNOdWxsPSEwKSwoYT09PVwibWluXCI/dT49Zjp1PD1mKT90aGlzLmluY3JlbWVudE9yZGVyKCk6dGhpcy5pc051bGw9ITAsITB9YWR2YW5jZSh0PTEpe3RoaXMucG9zaXRpb24rPXQsdGhpcy5jaGFyPXRoaXMuc3RyaW5nW3RoaXMucG9zaXRpb25dfWdldCByZXN0KCl7cmV0dXJuIHRoaXMucGVla1NsaWNlKDAsdGhpcy5zdHJpbmcubGVuZ3RoKX1wZWVrU2xpY2UodCxuKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3NpdGlvbit0LHRoaXMucG9zaXRpb24rbil9Y29uc3VtZVBlZWtlZCh0KXtyZXR1cm4gdGhpcy5wZWVrU2xpY2UoMCx0Lmxlbmd0aCk9PT10Pyh0aGlzLmFkdmFuY2UodC5sZW5ndGgpLCEwKTohMX1wYXJzZUlzTmVnYXRpdmUoKXt0aGlzLmNoYXI9PT1cIi1cIiYmKHRoaXMuYWR2YW5jZSgpLHRoaXMuaXNOZWdhdGl2ZT0hMCx0aGlzLmNvbnRleHQuaXNOZWdhdGl2ZT0hMCl9aW5jcmVtZW50T3JkZXIoKXt2YXIgdDt0aGlzLm9yZGVyPSgodD10aGlzLm9yZGVyKSE9PW51bGwmJnQhPT12b2lkIDA/dDowKSsxfX07YygpO2Z1bmN0aW9uIHB1KGUpe2xldCB0PVtdLG49bnVsbDtyZXR1cm4gZS5mb3JFYWNoKHI9PntpZih0eXBlb2Ygcj09XCJzdHJpbmdcIil0PVsuLi50LC4uLlppKHIpXTtlbHNlIGlmKEFycmF5LmlzQXJyYXkocikpdD1bLi4udCwuLi5yLmZsYXRNYXAoWmkpXTtlbHNlIGlmKHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClmb3IobGV0W2ksYV1vZiBPYmplY3QuZW50cmllcyhyKSl0eXBlb2YgYT09XCJib29sZWFuXCI/dD1bLi4udCwuLi5hP1ppKGkpOltdXTpuP25baV09YTpuPXtbaV06YX19KSxbdC5maWx0ZXIoQm9vbGVhbikuZmlsdGVyKG4wKSxuXX1mdW5jdGlvbiBaaShlKXtyZXR1cm4gZS50cmltKCkuc3BsaXQoL1xccysvKX1mdW5jdGlvbiBuMChlLHQsbil7cmV0dXJuIG4uaW5kZXhPZihlKT09PXR9YygpO2Z1bmN0aW9uIGh1KGUpe3ZhciB0O3JldHVybih0PWU9PW51bGw/dm9pZCAwOmUucmVkdWNlKChuLHIpPT4oey4uLm4sLi4uaTAoci5oYW5kbGVyKX0pLHt9KSkhPT1udWxsJiZ0IT09dm9pZCAwP3Q6e319ZnVuY3Rpb24gaTAoZSl7bGV0IHQ9e307cmV0dXJuIGUoe2FkZFV0aWxpdGllczpuPT57dD1ufSwuLi5vMH0pLHR9ZnVuY3Rpb24gT2UoZSl7dGhyb3cgbmV3IEVycm9yKGB0YWlsd2luZGNzcyBwbHVnaW4gZnVuY3Rpb24gYXJndW1lbnQgb2JqZWN0IHByb3AgXCIke2V9XCIgbm90IGltcGxlbWVudGVkYCl9dmFyIG8wPXthZGRDb21wb25lbnRzOk9lLGFkZEJhc2U6T2UsYWRkVmFyaWFudDpPZSxlOk9lLHByZWZpeDpPZSx0aGVtZTpPZSx2YXJpYW50czpPZSxjb25maWc6T2UsY29yZVBsdWdpbnM6T2UsbWF0Y2hVdGlsaXRpZXM6T2UscG9zdGNzczpudWxsfTtmdW5jdGlvbiBndShlLHQpe2xldCBuPSgwLG11LmRlZmF1bHQpKGEwKGUpKSxyPXt9LGk9aHUobi5wbHVnaW5zKSxhPXt9LG89T2JqZWN0LmVudHJpZXMoaSkubWFwKChbZCxoXSk9PnR5cGVvZiBoPT1cInN0cmluZ1wiPyhhW2RdPWgsW2Qse2tpbmQ6XCJudWxsXCJ9XSk6W2QsdihoKV0pLmZpbHRlcigoWyxkXSk9PmQua2luZCE9PVwibnVsbFwiKTtmdW5jdGlvbiBzKCl7cmV0dXJuW3Iud2luZG93RGltZW5zaW9ucz9gdyR7ci53aW5kb3dEaW1lbnNpb25zLndpZHRofWA6ITEsci53aW5kb3dEaW1lbnNpb25zP2BoJHtyLndpbmRvd0RpbWVuc2lvbnMuaGVpZ2h0fWA6ITEsci5mb250U2NhbGU/YGZzJHtyLmZvbnRTY2FsZX1gOiExLHIuY29sb3JTY2hlbWU9PT1cImRhcmtcIj9cImRhcmtcIjohMSxyLnBpeGVsRGVuc2l0eT09PTI/XCJyZXRpbmFcIjohMV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCItLVwiKXx8XCJkZWZhdWx0XCJ9bGV0IHU9cygpLGw9e307ZnVuY3Rpb24gZigpe2xldCBkPWxbdV07aWYoZClyZXR1cm4gZDtsZXQgaD1uZXcgWHQobyk7cmV0dXJuIGxbdV09aCxofWZ1bmN0aW9uIHAoLi4uZCl7bGV0IGg9ZigpLHc9e30sYj1bXSxfPVtdLFtFLEFdPXB1KGQpLEQ9RS5qb2luKFwiIFwiKSxNPWguZ2V0U3R5bGUoRCk7aWYoTSlyZXR1cm57Li4uTSwuLi5BfHx7fX07Zm9yKGxldCBMIG9mIEUpe2xldCBGPWguZ2V0SXIoTCk7aWYoIUYmJkwgaW4gYSl7bGV0IFU9cChhW0xdKTtoLnNldElyKEwsdihVKSksdz17Li4udywuLi5VfTtjb250aW51ZX1zd2l0Y2goRj1uZXcgbHQoTCxuLGgscix0KS5wYXJzZSgpLEYua2luZCl7Y2FzZVwiY29tcGxldGVcIjp3PXsuLi53LC4uLkYuc3R5bGV9LGguc2V0SXIoTCxGKTticmVhaztjYXNlXCJkZXBlbmRlbnRcIjpiLnB1c2goRik7YnJlYWs7Y2FzZVwib3JkZXJlZFwiOl8ucHVzaChGKTticmVhaztjYXNlXCJudWxsXCI6aC5zZXRJcihMLEYpO2JyZWFrfX1pZihfLmxlbmd0aD4wKXtfLnNvcnQoKEwsRik9Pkwub3JkZXItRi5vcmRlcik7Zm9yKGxldCBMIG9mIF8pc3dpdGNoKEwuc3R5bGVJci5raW5kKXtjYXNlXCJjb21wbGV0ZVwiOnc9ey4uLncsLi4uTC5zdHlsZUlyLnN0eWxlfTticmVhaztjYXNlXCJkZXBlbmRlbnRcIjpiLnB1c2goTC5zdHlsZUlyKTticmVha319aWYoYi5sZW5ndGg+MCl7Zm9yKGxldCBMIG9mIGIpe2xldCBGPUwuY29tcGxldGUodyk7RiYmY2UoRil9cnUodyl9cmV0dXJuIEQhPT1cIlwiJiZoLnNldFN0eWxlKEQsdyksQSYmKHc9ey4uLncsLi4uQX0pLHd9ZnVuY3Rpb24gZyhkKXtsZXQgaD1wKGQuc3BsaXQoL1xccysvZykubWFwKHc9PncucmVwbGFjZSgvXihiZ3x0ZXh0fGJvcmRlciktLyxcIlwiKSkubWFwKHc9PmBiZy0ke3d9YCkuam9pbihcIiBcIikpO3JldHVybiB0eXBlb2YgaC5iYWNrZ3JvdW5kQ29sb3I9PVwic3RyaW5nXCI/aC5iYWNrZ3JvdW5kQ29sb3I6dm9pZCAwfWxldCBtPShkLC4uLmgpPT57bGV0IHc9XCJcIjtyZXR1cm4gZC5mb3JFYWNoKChiLF8pPT57dmFyIEU7dys9YisoKEU9aFtfXSkhPT1udWxsJiZFIT09dm9pZCAwP0U6XCJcIil9KSxwKHcpfTtyZXR1cm4gbS5zdHlsZT1wLG0uY29sb3I9ZyxtLnByZWZpeE1hdGNoPSguLi5kKT0+e2xldCBoPWQuc29ydCgpLmpvaW4oXCI6XCIpLHc9ZigpLGI9dy5nZXRQcmVmaXhNYXRjaChoKTtpZihiIT09dm9pZCAwKXJldHVybiBiO2xldCBBPW5ldyBsdChgJHtofTpmbGV4YCxuLHcscix0KS5wYXJzZSgpLmtpbmQhPT1cIm51bGxcIjtyZXR1cm4gdy5zZXRQcmVmaXhNYXRjaChoLEEpLEF9LG0uc2V0V2luZG93RGltZW5zaW9ucz1kPT57ci53aW5kb3dEaW1lbnNpb25zPWQsdT1zKCl9LG0uc2V0Rm9udFNjYWxlPWQ9PntyLmZvbnRTY2FsZT1kLHU9cygpfSxtLnNldFBpeGVsRGVuc2l0eT1kPT57ci5waXhlbERlbnNpdHk9ZCx1PXMoKX0sbS5zZXRDb2xvclNjaGVtZT1kPT57ci5jb2xvclNjaGVtZT1kLHU9cygpfSxtfWZ1bmN0aW9uIGEwKGUpe3JldHVybnsuLi5lLGNvbnRlbnQ6W1wiX25vX3dhcm5pbmdzX3BsZWFzZVwiXX19dmFyIHUwPXtwbHVnaW5zOlt7aGFuZGxlcjooe2FkZFV0aWxpdGllczplfSk9PntlKHtcInNoYWRvdy1zbVwiOntib3hTaGFkb3c6XCIwIDFweCAycHggMCByZ2IoMCAwIDAgLyAwLjA1KVwifSxzaGFkb3c6e2JveFNoYWRvdzpcIjAgMXB4IDNweCAwIHJnYigwIDAgMCAvIDAuMSksIDAgMXB4IDJweCAtMXB4IHJnYigwIDAgMCAvIDAuMSlcIn0sXCJzaGFkb3ctbWRcIjp7Ym94U2hhZG93OlwiMCA0cHggNnB4IC0xcHggcmdiKDAgMCAwIC8gMC4xKSwgMCAycHggNHB4IC0ycHggcmdiKDAgMCAwIC8gMC4xKVwifSxcInNoYWRvdy1sZ1wiOntib3hTaGFkb3c6XCIwIDEwcHggMTVweCAtM3B4IHJnYigwIDAgMCAvIDAuMSksIDAgNHB4IDZweCAtNHB4IHJnYigwIDAgMCAvIDAuMSlcIn0sXCJzaGFkb3cteGxcIjp7Ym94U2hhZG93OlwiMCAyMHB4IDI1cHggLTVweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDhweCAxMHB4IC02cHggcmdiKDAgMCAwIC8gMC4xKVwifSxcInNoYWRvdy0yeGxcIjp7Ym94U2hhZG93OlwiMCAyNXB4IDUwcHggLTEycHggcmdiKDAgMCAwIC8gMC4yNSlcIn0sXCJzaGFkb3ctaW5uZXJcIjp7Ym94U2hhZG93OlwiaW5zZXQgMCAycHggNHB4IDAgcmdiKDAgMCAwIC8gMC4wNSlcIn0sXCJzaGFkb3ctbm9uZVwiOntib3hTaGFkb3c6XCIwIDAgIzAwMDBcIn19KX19XX07ZnVuY3Rpb24gbDAoKXtyZXR1cm4gZ3UodTAsXCJ3ZWJcIil9dmFyIE1yO2Z1bmN0aW9uIGVvKHt3aWR0aDplLGhlaWdodDp0fSl7cmV0dXJuIE1yfHwoTXI9bDAoKSksTXIuc2V0V2luZG93RGltZW5zaW9ucyh7d2lkdGg6K2UsaGVpZ2h0Oit0fSksTXJ9dmFyIHRvPW5ldyBXZWFrTWFwO2FzeW5jIGZ1bmN0aW9uIHZ1KGUsdCl7bGV0IG49QWUoKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJTYXRvcmkgaXMgbm90IGluaXRpYWxpemVkLlwiKTtsZXQgcjt0by5oYXModC5mb250cyk/cj10by5nZXQodC5mb250cyk6dG8uc2V0KHQuZm9udHMscj1uZXcgdnQodC5mb250cykpO2xldCBpPW4uTm9kZS5jcmVhdGUoKTtpLnNldFdpZHRoKHQud2lkdGgpLGkuc2V0SGVpZ2h0KHQuaGVpZ2h0KSxpLnNldEZsZXhEaXJlY3Rpb24obi5GTEVYX0RJUkVDVElPTl9ST1cpLGkuc2V0RmxleFdyYXAobi5XUkFQX1dSQVApLGkuc2V0QWxpZ25Db250ZW50KG4uQUxJR05fQVVUTyksaS5zZXRBbGlnbkl0ZW1zKG4uQUxJR05fRkxFWF9TVEFSVCksaS5zZXRKdXN0aWZ5Q29udGVudChuLkpVU1RJRllfRkxFWF9TVEFSVCksaS5zZXRPdmVyZmxvdyhuLk9WRVJGTE9XX0hJRERFTik7bGV0IGE9ey4uLnQuZ3JhcGhlbWVJbWFnZXN9LG89Z3QoZSx7aWQ6XCJpZFwiLHBhcmVudFN0eWxlOnt9LGluaGVyaXRlZFN0eWxlOntmb250U2l6ZToxNixmb250V2VpZ2h0Olwibm9ybWFsXCIsZm9udEZhbWlseTpcInNlcmlmXCIsZm9udFN0eWxlOlwibm9ybWFsXCIsbGluZUhlaWdodDoxLjIsY29sb3I6XCJibGFja1wiLG9wYWNpdHk6MSx3aGl0ZVNwYWNlOlwibm9ybWFsXCIsX3ZpZXdwb3J0V2lkdGg6dC53aWR0aCxfdmlld3BvcnRIZWlnaHQ6dC5oZWlnaHR9LHBhcmVudDppLGZvbnQ6cixlbWJlZEZvbnQ6dC5lbWJlZEZvbnQsZGVidWc6dC5kZWJ1ZyxncmFwaGVtZUltYWdlczphLGNhbkxvYWRBZGRpdGlvbmFsQXNzZXRzOiEhdC5sb2FkQWRkaXRpb25hbEFzc2V0LGdldFR3U3R5bGVzOihsLGYpPT57bGV0IGc9ey4uLmVvKHt3aWR0aDp0LndpZHRoLGhlaWdodDp0LmhlaWdodH0pKFtsXSl9O3JldHVybiB0eXBlb2YgZy5saW5lSGVpZ2h0PT1cIm51bWJlclwiJiYoZy5saW5lSGVpZ2h0PWcubGluZUhlaWdodC8oK2cuZm9udFNpemV8fGYuZm9udFNpemV8fDE2KSksZy5zaGFkb3dDb2xvciYmZy5ib3hTaGFkb3cmJihnLmJveFNoYWRvdz1nLmJveFNoYWRvdy5yZXBsYWNlKC9yZ2JhP1xcKFteKV0rXFwpLyxnLnNoYWRvd0NvbG9yKSksZ319KSxzPShhd2FpdCBvLm5leHQoKSkudmFsdWU7aWYodC5sb2FkQWRkaXRpb25hbEFzc2V0JiZzLmxlbmd0aCl7cz1BcnJheS5mcm9tKG5ldyBTZXQoamUocy5qb2luKFwiXCIpLFwiZ3JhcGhlbWVcIikpKTtsZXQgbD17fTtzLmZvckVhY2goZz0+e2xldCBtPU1vKGcpO2xbbV09bFttXXx8W10sbT09PVwiZW1vamlcIj9sW21dLnB1c2goZyk6bFttXVswXT0obFttXVswXXx8XCJcIikrZ30pO2xldCBmPVtdLHA9e307YXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMobCkuZmxhdE1hcCgoW2csbV0pPT5tLm1hcChkPT50LmxvYWRBZGRpdGlvbmFsQXNzZXQoZyxkKS50aGVuKGg9Pnt0eXBlb2YgaD09XCJzdHJpbmdcIj9wW2RdPWg6aCYmZi5wdXNoKGgpfSkpKSksci5hZGRGb250cyhmKSxPYmplY3QuYXNzaWduKGEscCl9YXdhaXQgby5uZXh0KCksaS5jYWxjdWxhdGVMYXlvdXQodC53aWR0aCx0LmhlaWdodCxuLkRJUkVDVElPTl9MVFIpO2xldCB1PShhd2FpdCBvLm5leHQoWzAsMF0pKS52YWx1ZTtyZXR1cm4gaS5mcmVlUmVjdXJzaXZlKCkscG4oe3dpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0LGNvbnRlbnQ6dX0pfWV4cG9ydHt2dSBhcyBkZWZhdWx0LEV1IGFzIGluaXR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgud2FzbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/satori/dist/esm/index.wasm.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/yoga-wasm-web/dist/entry.js":
/*!**************************************************!*\
  !*** ./node_modules/yoga-wasm-web/dist/entry.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar L=(T,t)=>()=>(t||T((t={exports:{}}).exports,t),t.exports);var R=L((D,u)=>{var S={ALIGN_COUNT:8,ALIGN_AUTO:0,ALIGN_FLEX_START:1,ALIGN_CENTER:2,ALIGN_FLEX_END:3,ALIGN_STRETCH:4,ALIGN_BASELINE:5,ALIGN_SPACE_BETWEEN:6,ALIGN_SPACE_AROUND:7,DIMENSION_COUNT:2,DIMENSION_WIDTH:0,DIMENSION_HEIGHT:1,DIRECTION_COUNT:3,DIRECTION_INHERIT:0,DIRECTION_LTR:1,DIRECTION_RTL:2,DISPLAY_COUNT:2,DISPLAY_FLEX:0,DISPLAY_NONE:1,EDGE_COUNT:9,EDGE_LEFT:0,EDGE_TOP:1,EDGE_RIGHT:2,EDGE_BOTTOM:3,EDGE_START:4,EDGE_END:5,EDGE_HORIZONTAL:6,EDGE_VERTICAL:7,EDGE_ALL:8,EXPERIMENTAL_FEATURE_COUNT:1,EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS:0,FLEX_DIRECTION_COUNT:4,FLEX_DIRECTION_COLUMN:0,FLEX_DIRECTION_COLUMN_REVERSE:1,FLEX_DIRECTION_ROW:2,FLEX_DIRECTION_ROW_REVERSE:3,JUSTIFY_COUNT:6,JUSTIFY_FLEX_START:0,JUSTIFY_CENTER:1,JUSTIFY_FLEX_END:2,JUSTIFY_SPACE_BETWEEN:3,JUSTIFY_SPACE_AROUND:4,JUSTIFY_SPACE_EVENLY:5,LOG_LEVEL_COUNT:6,LOG_LEVEL_ERROR:0,LOG_LEVEL_WARN:1,LOG_LEVEL_INFO:2,LOG_LEVEL_DEBUG:3,LOG_LEVEL_VERBOSE:4,LOG_LEVEL_FATAL:5,MEASURE_MODE_COUNT:3,MEASURE_MODE_UNDEFINED:0,MEASURE_MODE_EXACTLY:1,MEASURE_MODE_AT_MOST:2,NODE_TYPE_COUNT:2,NODE_TYPE_DEFAULT:0,NODE_TYPE_TEXT:1,OVERFLOW_COUNT:3,OVERFLOW_VISIBLE:0,OVERFLOW_HIDDEN:1,OVERFLOW_SCROLL:2,POSITION_TYPE_COUNT:2,POSITION_TYPE_RELATIVE:0,POSITION_TYPE_ABSOLUTE:1,PRINT_OPTIONS_COUNT:3,PRINT_OPTIONS_LAYOUT:1,PRINT_OPTIONS_STYLE:2,PRINT_OPTIONS_CHILDREN:4,UNIT_COUNT:4,UNIT_UNDEFINED:0,UNIT_POINT:1,UNIT_PERCENT:2,UNIT_AUTO:3,WRAP_COUNT:3,WRAP_NO_WRAP:0,WRAP_WRAP:1,WRAP_WRAP_REVERSE:2};u.exports=S});var U=L((P,A)=>{var _=R(),a=class{left;right;top;bottom;width;height;constructor(t,N,E,e,s,o){this.left=t,this.right=N,this.top=E,this.bottom=e,this.width=s,this.height=o}fromJS(t){t(this.left,this.right,this.top,this.bottom,this.width,this.height)}toString(){return`<Layout#${this.left}:${this.right};${this.top}:${this.bottom};${this.width}:${this.height}>`}},h=class{static fromJS({width:t,height:N}){return new h(t,N)}width;height;constructor(t,N){this.width=t,this.height=N}fromJS(t){t(this.width,this.height)}toString(){return`<Size#${this.width}x${this.height}>`}},n=class{unit;value;constructor(t,N){this.unit=t,this.value=N}fromJS(t){t(this.unit,this.value)}toString(){switch(this.unit){case _.UNIT_POINT:return String(this.value);case _.UNIT_PERCENT:return`${this.value}%`;case _.UNIT_AUTO:return\"auto\";default:return`${this.value}?`}}valueOf(){return this.value}};function O(T,t,N){let E=T[t];T[t]=function(...e){return N.call(this,E,...e)}}A.exports=(T,t)=>{for(let E of[\"setPosition\",\"setMargin\",\"setFlexBasis\",\"setWidth\",\"setHeight\",\"setMinWidth\",\"setMinHeight\",\"setMaxWidth\",\"setMaxHeight\",\"setPadding\"]){let e={[_.UNIT_POINT]:t.Node.prototype[E],[_.UNIT_PERCENT]:t.Node.prototype[`${E}Percent`],[_.UNIT_AUTO]:t.Node.prototype[`${E}Auto`]};O(t.Node.prototype,E,function(s,...o){let i=o.pop(),I,r;if(i===\"auto\")I=_.UNIT_AUTO,r=void 0;else if(i instanceof n)I=i.unit,r=i.valueOf();else if(I=typeof i==\"string\"&&i.endsWith(\"%\")?_.UNIT_PERCENT:_.UNIT_POINT,r=parseFloat(i),!Number.isNaN(i)&&Number.isNaN(r))throw new Error(`Invalid value ${i} for ${E}`);if(!e[I])throw new Error(`Failed to execute \"${E}\": Unsupported unit '${i}'`);return r!==void 0?e[I].call(this,...o,r):e[I].call(this,...o)})}O(t.Config.prototype,\"free\",function(){t.Config.destroy(this)}),O(t.Node,\"create\",function(E,e){return e?t.Node.createWithConfig(e):t.Node.createDefault()}),O(t.Node.prototype,\"free\",function(){t.Node.destroy(this)}),O(t.Node.prototype,\"freeRecursive\",function(){for(let E=0,e=this.getChildCount();E<e;++E)this.getChild(0).freeRecursive();this.free()});function N(E){return t.MeasureCallback.implement({measure:E})}return O(t.Node.prototype,\"setMeasureFunc\",function(E,e){E.call(this,N(e))}),O(t.Node.prototype,\"calculateLayout\",function(E,e=NaN,s=NaN,o=_.DIRECTION_LTR){return E.call(this,e,s,o)}),{Config:t.Config,Node:t.Node,Layout:T(\"Layout\",a),Size:T(\"Size\",h),Value:T(\"Value\",n),..._}}});/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (U());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3lvZ2Etd2FzbS13ZWIvZGlzdC9lbnRyeS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMkJBQTJCLFdBQVcsd0JBQXdCLGdCQUFnQixPQUFPLDQ1Q0FBNDVDLFlBQVksRUFBRSxnQkFBZ0Isa0JBQWtCLEtBQUssTUFBTSxJQUFJLE9BQU8sTUFBTSxPQUFPLHlCQUF5Qiw2RUFBNkUsVUFBVSxvRUFBb0UsV0FBVyxpQkFBaUIsVUFBVSxHQUFHLFlBQVksRUFBRSxTQUFTLEdBQUcsYUFBYSxFQUFFLFdBQVcsR0FBRyxZQUFZLElBQUksU0FBUyxlQUFlLGlCQUFpQixFQUFFLGtCQUFrQixNQUFNLE9BQU8saUJBQWlCLDJCQUEyQixVQUFVLDBCQUEwQixXQUFXLGVBQWUsV0FBVyxHQUFHLFlBQVksSUFBSSxTQUFTLEtBQUssTUFBTSxpQkFBaUIseUJBQXlCLFVBQVUsd0JBQXdCLFdBQVcsa0JBQWtCLDRDQUE0Qyw2QkFBNkIsV0FBVyxHQUFHLDhCQUE4QixpQkFBaUIsV0FBVyxJQUFJLFVBQVUsb0JBQW9CLGtCQUFrQixXQUFXLG9CQUFvQiw0QkFBNEIsa0JBQWtCLHNKQUFzSixPQUFPLHdFQUF3RSxFQUFFLDRDQUE0QyxFQUFFLFFBQVEsc0NBQXNDLGtCQUFrQixxQ0FBcUMsOENBQThDLDZKQUE2SixHQUFHLE1BQU0sRUFBRSxHQUFHLCtDQUErQyxFQUFFLHVCQUF1QixFQUFFLElBQUksOERBQThELEVBQUUsdUNBQXVDLHVCQUF1QixrQ0FBa0MsMkRBQTJELHVDQUF1QyxxQkFBcUIsZ0RBQWdELG1DQUFtQyxJQUFJLHFDQUFxQyxZQUFZLEVBQUUsY0FBYyxvQ0FBb0MsVUFBVSxFQUFFLHlEQUF5RCxrQkFBa0IsaUZBQWlGLDBCQUEwQixHQUFHLDRGQUE0RixFQUFFLGlFQUFlLEdBQUcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveW9nYS13YXNtLXdlYi9kaXN0L2VudHJ5LmpzPzI1NzgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEw9KFQsdCk9PigpPT4odHx8VCgodD17ZXhwb3J0czp7fX0pLmV4cG9ydHMsdCksdC5leHBvcnRzKTt2YXIgUj1MKChELHUpPT57dmFyIFM9e0FMSUdOX0NPVU5UOjgsQUxJR05fQVVUTzowLEFMSUdOX0ZMRVhfU1RBUlQ6MSxBTElHTl9DRU5URVI6MixBTElHTl9GTEVYX0VORDozLEFMSUdOX1NUUkVUQ0g6NCxBTElHTl9CQVNFTElORTo1LEFMSUdOX1NQQUNFX0JFVFdFRU46NixBTElHTl9TUEFDRV9BUk9VTkQ6NyxESU1FTlNJT05fQ09VTlQ6MixESU1FTlNJT05fV0lEVEg6MCxESU1FTlNJT05fSEVJR0hUOjEsRElSRUNUSU9OX0NPVU5UOjMsRElSRUNUSU9OX0lOSEVSSVQ6MCxESVJFQ1RJT05fTFRSOjEsRElSRUNUSU9OX1JUTDoyLERJU1BMQVlfQ09VTlQ6MixESVNQTEFZX0ZMRVg6MCxESVNQTEFZX05PTkU6MSxFREdFX0NPVU5UOjksRURHRV9MRUZUOjAsRURHRV9UT1A6MSxFREdFX1JJR0hUOjIsRURHRV9CT1RUT006MyxFREdFX1NUQVJUOjQsRURHRV9FTkQ6NSxFREdFX0hPUklaT05UQUw6NixFREdFX1ZFUlRJQ0FMOjcsRURHRV9BTEw6OCxFWFBFUklNRU5UQUxfRkVBVFVSRV9DT1VOVDoxLEVYUEVSSU1FTlRBTF9GRUFUVVJFX1dFQl9GTEVYX0JBU0lTOjAsRkxFWF9ESVJFQ1RJT05fQ09VTlQ6NCxGTEVYX0RJUkVDVElPTl9DT0xVTU46MCxGTEVYX0RJUkVDVElPTl9DT0xVTU5fUkVWRVJTRToxLEZMRVhfRElSRUNUSU9OX1JPVzoyLEZMRVhfRElSRUNUSU9OX1JPV19SRVZFUlNFOjMsSlVTVElGWV9DT1VOVDo2LEpVU1RJRllfRkxFWF9TVEFSVDowLEpVU1RJRllfQ0VOVEVSOjEsSlVTVElGWV9GTEVYX0VORDoyLEpVU1RJRllfU1BBQ0VfQkVUV0VFTjozLEpVU1RJRllfU1BBQ0VfQVJPVU5EOjQsSlVTVElGWV9TUEFDRV9FVkVOTFk6NSxMT0dfTEVWRUxfQ09VTlQ6NixMT0dfTEVWRUxfRVJST1I6MCxMT0dfTEVWRUxfV0FSTjoxLExPR19MRVZFTF9JTkZPOjIsTE9HX0xFVkVMX0RFQlVHOjMsTE9HX0xFVkVMX1ZFUkJPU0U6NCxMT0dfTEVWRUxfRkFUQUw6NSxNRUFTVVJFX01PREVfQ09VTlQ6MyxNRUFTVVJFX01PREVfVU5ERUZJTkVEOjAsTUVBU1VSRV9NT0RFX0VYQUNUTFk6MSxNRUFTVVJFX01PREVfQVRfTU9TVDoyLE5PREVfVFlQRV9DT1VOVDoyLE5PREVfVFlQRV9ERUZBVUxUOjAsTk9ERV9UWVBFX1RFWFQ6MSxPVkVSRkxPV19DT1VOVDozLE9WRVJGTE9XX1ZJU0lCTEU6MCxPVkVSRkxPV19ISURERU46MSxPVkVSRkxPV19TQ1JPTEw6MixQT1NJVElPTl9UWVBFX0NPVU5UOjIsUE9TSVRJT05fVFlQRV9SRUxBVElWRTowLFBPU0lUSU9OX1RZUEVfQUJTT0xVVEU6MSxQUklOVF9PUFRJT05TX0NPVU5UOjMsUFJJTlRfT1BUSU9OU19MQVlPVVQ6MSxQUklOVF9PUFRJT05TX1NUWUxFOjIsUFJJTlRfT1BUSU9OU19DSElMRFJFTjo0LFVOSVRfQ09VTlQ6NCxVTklUX1VOREVGSU5FRDowLFVOSVRfUE9JTlQ6MSxVTklUX1BFUkNFTlQ6MixVTklUX0FVVE86MyxXUkFQX0NPVU5UOjMsV1JBUF9OT19XUkFQOjAsV1JBUF9XUkFQOjEsV1JBUF9XUkFQX1JFVkVSU0U6Mn07dS5leHBvcnRzPVN9KTt2YXIgVT1MKChQLEEpPT57dmFyIF89UigpLGE9Y2xhc3N7bGVmdDtyaWdodDt0b3A7Ym90dG9tO3dpZHRoO2hlaWdodDtjb25zdHJ1Y3Rvcih0LE4sRSxlLHMsbyl7dGhpcy5sZWZ0PXQsdGhpcy5yaWdodD1OLHRoaXMudG9wPUUsdGhpcy5ib3R0b209ZSx0aGlzLndpZHRoPXMsdGhpcy5oZWlnaHQ9b31mcm9tSlModCl7dCh0aGlzLmxlZnQsdGhpcy5yaWdodCx0aGlzLnRvcCx0aGlzLmJvdHRvbSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KX10b1N0cmluZygpe3JldHVybmA8TGF5b3V0IyR7dGhpcy5sZWZ0fToke3RoaXMucmlnaHR9OyR7dGhpcy50b3B9OiR7dGhpcy5ib3R0b219OyR7dGhpcy53aWR0aH06JHt0aGlzLmhlaWdodH0+YH19LGg9Y2xhc3N7c3RhdGljIGZyb21KUyh7d2lkdGg6dCxoZWlnaHQ6Tn0pe3JldHVybiBuZXcgaCh0LE4pfXdpZHRoO2hlaWdodDtjb25zdHJ1Y3Rvcih0LE4pe3RoaXMud2lkdGg9dCx0aGlzLmhlaWdodD1OfWZyb21KUyh0KXt0KHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpfXRvU3RyaW5nKCl7cmV0dXJuYDxTaXplIyR7dGhpcy53aWR0aH14JHt0aGlzLmhlaWdodH0+YH19LG49Y2xhc3N7dW5pdDt2YWx1ZTtjb25zdHJ1Y3Rvcih0LE4pe3RoaXMudW5pdD10LHRoaXMudmFsdWU9Tn1mcm9tSlModCl7dCh0aGlzLnVuaXQsdGhpcy52YWx1ZSl9dG9TdHJpbmcoKXtzd2l0Y2godGhpcy51bml0KXtjYXNlIF8uVU5JVF9QT0lOVDpyZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO2Nhc2UgXy5VTklUX1BFUkNFTlQ6cmV0dXJuYCR7dGhpcy52YWx1ZX0lYDtjYXNlIF8uVU5JVF9BVVRPOnJldHVyblwiYXV0b1wiO2RlZmF1bHQ6cmV0dXJuYCR7dGhpcy52YWx1ZX0/YH19dmFsdWVPZigpe3JldHVybiB0aGlzLnZhbHVlfX07ZnVuY3Rpb24gTyhULHQsTil7bGV0IEU9VFt0XTtUW3RdPWZ1bmN0aW9uKC4uLmUpe3JldHVybiBOLmNhbGwodGhpcyxFLC4uLmUpfX1BLmV4cG9ydHM9KFQsdCk9Pntmb3IobGV0IEUgb2ZbXCJzZXRQb3NpdGlvblwiLFwic2V0TWFyZ2luXCIsXCJzZXRGbGV4QmFzaXNcIixcInNldFdpZHRoXCIsXCJzZXRIZWlnaHRcIixcInNldE1pbldpZHRoXCIsXCJzZXRNaW5IZWlnaHRcIixcInNldE1heFdpZHRoXCIsXCJzZXRNYXhIZWlnaHRcIixcInNldFBhZGRpbmdcIl0pe2xldCBlPXtbXy5VTklUX1BPSU5UXTp0Lk5vZGUucHJvdG90eXBlW0VdLFtfLlVOSVRfUEVSQ0VOVF06dC5Ob2RlLnByb3RvdHlwZVtgJHtFfVBlcmNlbnRgXSxbXy5VTklUX0FVVE9dOnQuTm9kZS5wcm90b3R5cGVbYCR7RX1BdXRvYF19O08odC5Ob2RlLnByb3RvdHlwZSxFLGZ1bmN0aW9uKHMsLi4ubyl7bGV0IGk9by5wb3AoKSxJLHI7aWYoaT09PVwiYXV0b1wiKUk9Xy5VTklUX0FVVE8scj12b2lkIDA7ZWxzZSBpZihpIGluc3RhbmNlb2YgbilJPWkudW5pdCxyPWkudmFsdWVPZigpO2Vsc2UgaWYoST10eXBlb2YgaT09XCJzdHJpbmdcIiYmaS5lbmRzV2l0aChcIiVcIik/Xy5VTklUX1BFUkNFTlQ6Xy5VTklUX1BPSU5ULHI9cGFyc2VGbG9hdChpKSwhTnVtYmVyLmlzTmFOKGkpJiZOdW1iZXIuaXNOYU4ocikpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlICR7aX0gZm9yICR7RX1gKTtpZighZVtJXSl0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlIFwiJHtFfVwiOiBVbnN1cHBvcnRlZCB1bml0ICcke2l9J2ApO3JldHVybiByIT09dm9pZCAwP2VbSV0uY2FsbCh0aGlzLC4uLm8scik6ZVtJXS5jYWxsKHRoaXMsLi4ubyl9KX1PKHQuQ29uZmlnLnByb3RvdHlwZSxcImZyZWVcIixmdW5jdGlvbigpe3QuQ29uZmlnLmRlc3Ryb3kodGhpcyl9KSxPKHQuTm9kZSxcImNyZWF0ZVwiLGZ1bmN0aW9uKEUsZSl7cmV0dXJuIGU/dC5Ob2RlLmNyZWF0ZVdpdGhDb25maWcoZSk6dC5Ob2RlLmNyZWF0ZURlZmF1bHQoKX0pLE8odC5Ob2RlLnByb3RvdHlwZSxcImZyZWVcIixmdW5jdGlvbigpe3QuTm9kZS5kZXN0cm95KHRoaXMpfSksTyh0Lk5vZGUucHJvdG90eXBlLFwiZnJlZVJlY3Vyc2l2ZVwiLGZ1bmN0aW9uKCl7Zm9yKGxldCBFPTAsZT10aGlzLmdldENoaWxkQ291bnQoKTtFPGU7KytFKXRoaXMuZ2V0Q2hpbGQoMCkuZnJlZVJlY3Vyc2l2ZSgpO3RoaXMuZnJlZSgpfSk7ZnVuY3Rpb24gTihFKXtyZXR1cm4gdC5NZWFzdXJlQ2FsbGJhY2suaW1wbGVtZW50KHttZWFzdXJlOkV9KX1yZXR1cm4gTyh0Lk5vZGUucHJvdG90eXBlLFwic2V0TWVhc3VyZUZ1bmNcIixmdW5jdGlvbihFLGUpe0UuY2FsbCh0aGlzLE4oZSkpfSksTyh0Lk5vZGUucHJvdG90eXBlLFwiY2FsY3VsYXRlTGF5b3V0XCIsZnVuY3Rpb24oRSxlPU5hTixzPU5hTixvPV8uRElSRUNUSU9OX0xUUil7cmV0dXJuIEUuY2FsbCh0aGlzLGUscyxvKX0pLHtDb25maWc6dC5Db25maWcsTm9kZTp0Lk5vZGUsTGF5b3V0OlQoXCJMYXlvdXRcIixhKSxTaXplOlQoXCJTaXplXCIsaCksVmFsdWU6VChcIlZhbHVlXCIsbiksLi4uX319fSk7ZXhwb3J0IGRlZmF1bHQgVSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/yoga-wasm-web/dist/entry.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/yoga-wasm-web/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/yoga-wasm-web/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ c),\n/* harmony export */   \"initStreaming\": () => (/* binding */ l)\n/* harmony export */ });\n/* harmony import */ var _entry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entry.js */ \"(middleware)/./node_modules/yoga-wasm-web/dist/entry.js\");\n/* harmony import */ var _yoga_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./yoga.mjs */ \"(middleware)/./node_modules/yoga-wasm-web/dist/yoga.mjs\");\nfunction s(e,t){return t}async function c(e){let t=await (0,_yoga_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({instantiateWasm(r,a){return __next_webassembly_instantiate__(function() { return WebAssembly.instantiate(e,r)}).then(n=>{a(n.instance||n)}),{}},locateFile(){return\"\"}});return (0,_entry_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(s,t)}async function l(e){let t=await (0,_yoga_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({instantiateWasm(r,a){return WebAssembly.instantiateStreaming(e,r).then(n=>{a(n.instance||n)}),{}},locateFile(){return\"\"}});return (0,_entry_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(s,t)}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3lvZ2Etd2FzbS13ZWIvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9ELGdCQUFnQixTQUFTLG9CQUFvQixZQUFZLHFEQUFDLEVBQUUscUJBQXFCLE9BQU8saUZBQTRCLFlBQVUsaUJBQWlCLEtBQUssY0FBYyxVQUFVLEVBQUUsT0FBTyxxREFBQyxNQUFNLG9CQUFvQixZQUFZLHFEQUFDLEVBQUUscUJBQXFCLHNEQUFzRCxpQkFBaUIsS0FBSyxjQUFjLFVBQVUsRUFBRSxPQUFPLHFEQUFDLE1BQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy95b2dhLXdhc20td2ViL2Rpc3QvaW5kZXguanM/MDBlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaSBmcm9tXCIuL2VudHJ5LmpzXCI7aW1wb3J0IG8gZnJvbVwiLi95b2dhLm1qc1wiO2Z1bmN0aW9uIHMoZSx0KXtyZXR1cm4gdH1hc3luYyBmdW5jdGlvbiBjKGUpe2xldCB0PWF3YWl0IG8oe2luc3RhbnRpYXRlV2FzbShyLGEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlLHIpLnRoZW4obj0+e2Eobi5pbnN0YW5jZXx8bil9KSx7fX0sbG9jYXRlRmlsZSgpe3JldHVyblwiXCJ9fSk7cmV0dXJuIGkocyx0KX1hc3luYyBmdW5jdGlvbiBsKGUpe2xldCB0PWF3YWl0IG8oe2luc3RhbnRpYXRlV2FzbShyLGEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhlLHIpLnRoZW4obj0+e2Eobi5pbnN0YW5jZXx8bil9KSx7fX0sbG9jYXRlRmlsZSgpe3JldHVyblwiXCJ9fSk7cmV0dXJuIGkocyx0KX1leHBvcnR7YyBhcyBkZWZhdWx0LGwgYXMgaW5pdFN0cmVhbWluZ307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/yoga-wasm-web/dist/index.js\n");

/***/ }),

/***/ "(middleware)/./node_modules/yoga-wasm-web/dist/yoga.mjs":
/*!**************************************************!*\
  !*** ./node_modules/yoga-wasm-web/dist/yoga.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nvar yoga = (() => {\n  var _scriptDir = \"file:///D:/Programmation/JavaScript/react/svg-generator/node_modules/yoga-wasm-web/dist/yoga.mjs\";\n  \n  return (\nfunction(yoga) {\n  yoga = yoga || {};\n\n\nvar l;l||(l=typeof yoga !== 'undefined' ? yoga : {});var aa,ba;l.ready=new Promise(function(b,a){aa=b;ba=a});var da=Object.assign({},l),q=\"\";\"undefined\"!=typeof document&&document.currentScript&&(q=document.currentScript.src);_scriptDir&&(q=_scriptDir);0!==q.indexOf(\"blob:\")?q=q.substr(0,q.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):q=\"\";var ea=console.log.bind(console),v=console.warn.bind(console);Object.assign(l,da);da=null;\"object\"!=typeof WebAssembly&&w(\"no native wasm support detected\");\nvar fa,ha=!1;function ia(b,a,c,d){var e={string:function(h){var n=0;if(null!==h&&void 0!==h&&0!==h){var p=(h.length<<2)+1;n=ja(p);ka(h,n,p)}return n},array:function(h){var n=ja(h.length);x.set(h,n);return n}};b=l[\"_\"+b];var f=[],k=0;if(d)for(var g=0;g<d.length;g++){var m=e[c[g]];m?(0===k&&(k=la()),f[g]=m(d[g])):f[g]=d[g]}c=b.apply(null,f);return c=function(h){0!==k&&ma(k);return\"string\"===a?h?na(y,h):\"\":\"boolean\"===a?!!h:h}(c)}\nfunction na(b,a,c){c=a+c;for(var d=\"\";!(a>=c);){var e=b[a++];if(!e)break;if(e&128){var f=b[a++]&63;if(192==(e&224))d+=String.fromCharCode((e&31)<<6|f);else{var k=b[a++]&63;e=224==(e&240)?(e&15)<<12|f<<6|k:(e&7)<<18|f<<12|k<<6|b[a++]&63;65536>e?d+=String.fromCharCode(e):(e-=65536,d+=String.fromCharCode(55296|e>>10,56320|e&1023))}}else d+=String.fromCharCode(e)}return d}\nfunction ka(b,a,c){var d=y;if(0<c){c=a+c-1;for(var e=0;e<b.length;++e){var f=b.charCodeAt(e);if(55296<=f&&57343>=f){var k=b.charCodeAt(++e);f=65536+((f&1023)<<10)|k&1023}if(127>=f){if(a>=c)break;d[a++]=f}else{if(2047>=f){if(a+1>=c)break;d[a++]=192|f>>6}else{if(65535>=f){if(a+2>=c)break;d[a++]=224|f>>12}else{if(a+3>=c)break;d[a++]=240|f>>18;d[a++]=128|f>>12&63}d[a++]=128|f>>6&63}d[a++]=128|f&63}}d[a]=0}}\nfunction oa(b,a){for(var c=\"\",d=0;!(d>=a/2);++d){var e=A[b+2*d>>1];if(0==e)break;c+=String.fromCharCode(e)}return c}function pa(b,a,c){void 0===c&&(c=2147483647);if(2>c)return 0;c-=2;var d=a;c=c<2*b.length?c/2:b.length;for(var e=0;e<c;++e)A[a>>1]=b.charCodeAt(e),a+=2;A[a>>1]=0;return a-d}function qa(b){return 2*b.length}\nfunction ra(b,a){for(var c=0,d=\"\";!(c>=a/4);){var e=B[b+4*c>>2];if(0==e)break;++c;65536<=e?(e-=65536,d+=String.fromCharCode(55296|e>>10,56320|e&1023)):d+=String.fromCharCode(e)}return d}function sa(b,a,c){void 0===c&&(c=2147483647);if(4>c)return 0;var d=a;c=d+c-4;for(var e=0;e<b.length;++e){var f=b.charCodeAt(e);if(55296<=f&&57343>=f){var k=b.charCodeAt(++e);f=65536+((f&1023)<<10)|k&1023}B[a>>2]=f;a+=4;if(a+4>c)break}B[a>>2]=0;return a-d}\nfunction ta(b){for(var a=0,c=0;c<b.length;++c){var d=b.charCodeAt(c);55296<=d&&57343>=d&&++c;a+=4}return a}var ua,x,y,A,va,B,D,wa,xa;function ya(){var b=fa.buffer;ua=b;l.HEAP8=x=new Int8Array(b);l.HEAP16=A=new Int16Array(b);l.HEAP32=B=new Int32Array(b);l.HEAPU8=y=new Uint8Array(b);l.HEAPU16=va=new Uint16Array(b);l.HEAPU32=D=new Uint32Array(b);l.HEAPF32=wa=new Float32Array(b);l.HEAPF64=xa=new Float64Array(b)}var E,za=[],Aa=[],Ba=[],F=0,Ca=null,G=null;\nfunction w(b){b=\"Aborted(\"+b+\")\";v(b);ha=!0;b=new WebAssembly.RuntimeError(b+\". Build with -sASSERTIONS for more info.\");ba(b);throw b;}function Da(){return H.startsWith(\"data:application/octet-stream;base64,\")}var H;if(l.locateFile){if(H=\"yoga.wasm\",!Da()){var Ea=H;H=l.locateFile?l.locateFile(Ea,q):q+Ea}}else H=(\"\").toString();function Fa(){try{throw\"both async and sync fetching of the wasm failed\";}catch(b){w(b)}}\nfunction Ga(){return\"function\"==typeof fetch?fetch(H,{credentials:\"same-origin\"}).then(function(b){if(!b.ok)throw\"failed to load wasm binary file at '\"+H+\"'\";return b.arrayBuffer()}).catch(function(){return Fa()}):Promise.resolve().then(function(){return Fa()})}var I,Ha;function Ia(b){for(;0<b.length;){var a=b.shift();if(\"function\"==typeof a)a(l);else{var c=a.Qa;\"number\"==typeof c?void 0===a.ka?E.get(c)():E.get(c)(a.ka):c(void 0===a.ka?null:a.ka)}}}\nfunction Ja(b){this.U=b-24;this.ya=function(a){D[this.U+4>>2]=a};this.va=function(a){D[this.U+8>>2]=a};this.wa=function(){B[this.U>>2]=0};this.ua=function(){x[this.U+12>>0]=0};this.xa=function(){x[this.U+13>>0]=0};this.sa=function(a,c){this.ta();this.ya(a);this.va(c);this.wa();this.ua();this.xa()};this.ta=function(){D[this.U+16>>2]=0}}var Ka=0;function La(b){if(void 0===b)return\"_unknown\";b=b.replace(/[^a-zA-Z0-9_]/g,\"$\");var a=b.charCodeAt(0);return 48<=a&&57>=a?\"_\"+b:b}\nfunction Ma(b,a){b=La(b);return function(){null;return a.apply(this,arguments)}}var K=[{},{value:void 0},{value:null},{value:!0},{value:!1}],Na=[];function Oa(b){var a=Error,c=Ma(b,function(d){this.name=b;this.message=d;d=Error(d).stack;void 0!==d&&(this.stack=this.toString()+\"\\n\"+d.replace(/^Error(:[^\\n]*)?\\n/,\"\"))});c.prototype=Object.create(a.prototype);c.prototype.constructor=c;c.prototype.toString=function(){return void 0===this.message?this.name:this.name+\": \"+this.message};return c}var L=void 0;\nfunction M(b){throw new L(b);}var N=b=>{b||M(\"Cannot use deleted val. handle = \"+b);return K[b].value},Pa=b=>{switch(b){case void 0:return 1;case null:return 2;case !0:return 3;case !1:return 4;default:var a=Na.length?Na.pop():K.length;K[a]={na:1,value:b};return a}},Qa=void 0,Ra=void 0;function O(b){for(var a=\"\";y[b];)a+=Ra[y[b++]];return a}var P=[];function Sa(){for(;P.length;){var b=P.pop();b.T.fa=!1;b[\"delete\"]()}}var Ta=void 0,Q={};\nfunction Ua(b,a){for(void 0===a&&M(\"ptr should not be undefined\");b.X;)a=b.ha(a),b=b.X;return a}var R={};function Va(b){b=Wa(b);var a=O(b);S(b);return a}function Xa(b,a){var c=R[b];void 0===c&&M(a+\" has unknown type \"+Va(b));return c}function Ya(){}var Za=!1;function $a(b){--b.count.value;0===b.count.value&&(b.Z?b.aa.ba(b.Z):b.W.V.ba(b.U))}function ab(b,a,c){if(a===c)return b;if(void 0===c.X)return null;b=ab(b,a,c.X);return null===b?null:c.Ba(b)}var bb={};function cb(b,a){a=Ua(b,a);return Q[a]}\nvar db=void 0;function eb(b){throw new db(b);}function fb(b,a){a.W&&a.U||eb(\"makeClassHandle requires ptr and ptrType\");!!a.aa!==!!a.Z&&eb(\"Both smartPtrType and smartPtr must be specified\");a.count={value:1};return T(Object.create(b,{T:{value:a}}))}function T(b){if(\"undefined\"===typeof FinalizationRegistry)return T=a=>a,b;Za=new FinalizationRegistry(a=>{$a(a.T)});T=a=>{var c=a.T;c.Z&&Za.register(a,{T:c},a);return a};Ya=a=>{Za.unregister(a)};return T(b)}var gb={};\nfunction hb(b){for(;b.length;){var a=b.pop();b.pop()(a)}}function ib(b){return this.fromWireType(D[b>>2])}var U={},jb={};function V(b,a,c){function d(g){g=c(g);g.length!==b.length&&eb(\"Mismatched type converter count\");for(var m=0;m<b.length;++m)W(b[m],g[m])}b.forEach(function(g){jb[g]=a});var e=Array(a.length),f=[],k=0;a.forEach((g,m)=>{R.hasOwnProperty(g)?e[m]=R[g]:(f.push(g),U.hasOwnProperty(g)||(U[g]=[]),U[g].push(()=>{e[m]=R[g];++k;k===f.length&&d(e)}))});0===f.length&&d(e)}\nfunction kb(b){switch(b){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(\"Unknown type size: \"+b);}}\nfunction W(b,a,c={}){if(!(\"argPackAdvance\"in a))throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");var d=a.name;b||M('type \"'+d+'\" must have a positive integer typeid pointer');if(R.hasOwnProperty(b)){if(c.Ia)return;M(\"Cannot register type '\"+d+\"' twice\")}R[b]=a;delete jb[b];U.hasOwnProperty(b)&&(a=U[b],delete U[b],a.forEach(e=>e()))}function lb(b){M(b.T.W.V.name+\" instance already deleted\")}function X(){}\nfunction mb(b,a,c){if(void 0===b[a].Y){var d=b[a];b[a]=function(){b[a].Y.hasOwnProperty(arguments.length)||M(\"Function '\"+c+\"' called with an invalid number of arguments (\"+arguments.length+\") - expects one of (\"+b[a].Y+\")!\");return b[a].Y[arguments.length].apply(this,arguments)};b[a].Y=[];b[a].Y[d.ea]=d}}\nfunction nb(b,a){l.hasOwnProperty(b)?(M(\"Cannot register public name '\"+b+\"' twice\"),mb(l,b,b),l.hasOwnProperty(void 0)&&M(\"Cannot register multiple overloads of a function with the same number of arguments (undefined)!\"),l[b].Y[void 0]=a):l[b]=a}function qb(b,a,c,d,e,f,k,g){this.name=b;this.constructor=a;this.ca=c;this.ba=d;this.X=e;this.Da=f;this.ha=k;this.Ba=g;this.qa=[]}\nfunction rb(b,a,c){for(;a!==c;)a.ha||M(\"Expected null or instance of \"+c.name+\", got an instance of \"+a.name),b=a.ha(b),a=a.X;return b}function sb(b,a){if(null===a)return this.la&&M(\"null is not a valid \"+this.name),0;a.T||M('Cannot pass \"'+tb(a)+'\" as a '+this.name);a.T.U||M(\"Cannot pass deleted object as a pointer of type \"+this.name);return rb(a.T.U,a.T.W.V,this.V)}\nfunction ub(b,a){if(null===a){this.la&&M(\"null is not a valid \"+this.name);if(this.ja){var c=this.ma();null!==b&&b.push(this.ba,c);return c}return 0}a.T||M('Cannot pass \"'+tb(a)+'\" as a '+this.name);a.T.U||M(\"Cannot pass deleted object as a pointer of type \"+this.name);!this.ia&&a.T.W.ia&&M(\"Cannot convert argument of type \"+(a.T.aa?a.T.aa.name:a.T.W.name)+\" to parameter type \"+this.name);c=rb(a.T.U,a.T.W.V,this.V);if(this.ja)switch(void 0===a.T.Z&&M(\"Passing raw pointer to smart pointer is illegal\"),\nthis.Pa){case 0:a.T.aa===this?c=a.T.Z:M(\"Cannot convert argument of type \"+(a.T.aa?a.T.aa.name:a.T.W.name)+\" to parameter type \"+this.name);break;case 1:c=a.T.Z;break;case 2:if(a.T.aa===this)c=a.T.Z;else{var d=a.clone();c=this.La(c,Pa(function(){d[\"delete\"]()}));null!==b&&b.push(this.ba,c)}break;default:M(\"Unsupporting sharing policy\")}return c}\nfunction vb(b,a){if(null===a)return this.la&&M(\"null is not a valid \"+this.name),0;a.T||M('Cannot pass \"'+tb(a)+'\" as a '+this.name);a.T.U||M(\"Cannot pass deleted object as a pointer of type \"+this.name);a.T.W.ia&&M(\"Cannot convert argument of type \"+a.T.W.name+\" to parameter type \"+this.name);return rb(a.T.U,a.T.W.V,this.V)}\nfunction Y(b,a,c,d){this.name=b;this.V=a;this.la=c;this.ia=d;this.ja=!1;this.ba=this.La=this.ma=this.ra=this.Pa=this.Ka=void 0;void 0!==a.X?this.toWireType=ub:(this.toWireType=d?sb:vb,this.$=null)}function wb(b,a){l.hasOwnProperty(b)||eb(\"Replacing nonexistant public symbol\");l[b]=a;l[b].ea=void 0}\nfunction xb(b,a){var c=[];return function(){c.length=0;Object.assign(c,arguments);if(b.includes(\"j\")){var d=l[\"dynCall_\"+b];d=c&&c.length?d.apply(null,[a].concat(c)):d.call(null,a)}else d=E.get(a).apply(null,c);return d}}function Z(b,a){b=O(b);var c=b.includes(\"j\")?xb(b,a):E.get(a);\"function\"!=typeof c&&M(\"unknown function pointer with signature \"+b+\": \"+a);return c}var yb=void 0;\nfunction zb(b,a){function c(f){e[f]||R[f]||(jb[f]?jb[f].forEach(c):(d.push(f),e[f]=!0))}var d=[],e={};a.forEach(c);throw new yb(b+\": \"+d.map(Va).join([\", \"]));}\nfunction Ab(b,a,c,d,e){var f=a.length;2>f&&M(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");var k=null!==a[1]&&null!==c,g=!1;for(c=1;c<a.length;++c)if(null!==a[c]&&void 0===a[c].$){g=!0;break}var m=\"void\"!==a[0].name,h=f-2,n=Array(h),p=[],r=[];return function(){arguments.length!==h&&M(\"function \"+b+\" called with \"+arguments.length+\" arguments, expected \"+h+\" args!\");r.length=0;p.length=k?2:1;p[0]=e;if(k){var u=a[1].toWireType(r,this);p[1]=u}for(var t=0;t<h;++t)n[t]=\na[t+2].toWireType(r,arguments[t]),p.push(n[t]);t=d.apply(null,p);if(g)hb(r);else for(var z=k?1:2;z<a.length;z++){var C=1===z?u:n[z-2];null!==a[z].$&&a[z].$(C)}u=m?a[0].fromWireType(t):void 0;return u}}function Bb(b,a){for(var c=[],d=0;d<b;d++)c.push(B[(a>>2)+d]);return c}function Cb(b){4<b&&0===--K[b].na&&(K[b]=void 0,Na.push(b))}\nfunction Db(b,a,c){switch(a){case 0:return function(d){return this.fromWireType((c?x:y)[d])};case 1:return function(d){return this.fromWireType((c?A:va)[d>>1])};case 2:return function(d){return this.fromWireType((c?B:D)[d>>2])};default:throw new TypeError(\"Unknown integer type: \"+b);}}function tb(b){if(null===b)return\"null\";var a=typeof b;return\"object\"===a||\"array\"===a||\"function\"===a?b.toString():\"\"+b}\nfunction Eb(b,a){switch(a){case 2:return function(c){return this.fromWireType(wa[c>>2])};case 3:return function(c){return this.fromWireType(xa[c>>3])};default:throw new TypeError(\"Unknown float type: \"+b);}}\nfunction Fb(b,a,c){switch(a){case 0:return c?function(d){return x[d]}:function(d){return y[d]};case 1:return c?function(d){return A[d>>1]}:function(d){return va[d>>1]};case 2:return c?function(d){return B[d>>2]}:function(d){return D[d>>2]};default:throw new TypeError(\"Unknown integer type: \"+b);}}var Gb={};function Hb(b){var a=Gb[b];return void 0===a?O(b):a}var Ib=[];function Jb(b){var a=Ib.length;Ib.push(b);return a}\nfunction Kb(b,a){for(var c=Array(b),d=0;d<b;++d)c[d]=Xa(D[a+4*d>>2],\"parameter \"+d);return c}var Lb=[],Mb=[null,[],[]];L=l.BindingError=Oa(\"BindingError\");l.count_emval_handles=function(){for(var b=0,a=5;a<K.length;++a)void 0!==K[a]&&++b;return b};l.get_first_emval=function(){for(var b=5;b<K.length;++b)if(void 0!==K[b])return K[b];return null};Qa=l.PureVirtualError=Oa(\"PureVirtualError\");for(var Nb=Array(256),Ob=0;256>Ob;++Ob)Nb[Ob]=String.fromCharCode(Ob);Ra=Nb;l.getInheritedInstanceCount=function(){return Object.keys(Q).length};\nl.getLiveInheritedInstances=function(){var b=[],a;for(a in Q)Q.hasOwnProperty(a)&&b.push(Q[a]);return b};l.flushPendingDeletes=Sa;l.setDelayFunction=function(b){Ta=b;P.length&&Ta&&Ta(Sa)};db=l.InternalError=Oa(\"InternalError\");X.prototype.isAliasOf=function(b){if(!(this instanceof X&&b instanceof X))return!1;var a=this.T.W.V,c=this.T.U,d=b.T.W.V;for(b=b.T.U;a.X;)c=a.ha(c),a=a.X;for(;d.X;)b=d.ha(b),d=d.X;return a===d&&c===b};\nX.prototype.clone=function(){this.T.U||lb(this);if(this.T.ga)return this.T.count.value+=1,this;var b=T,a=Object,c=a.create,d=Object.getPrototypeOf(this),e=this.T;b=b(c.call(a,d,{T:{value:{count:e.count,fa:e.fa,ga:e.ga,U:e.U,W:e.W,Z:e.Z,aa:e.aa}}}));b.T.count.value+=1;b.T.fa=!1;return b};X.prototype[\"delete\"]=function(){this.T.U||lb(this);this.T.fa&&!this.T.ga&&M(\"Object already scheduled for deletion\");Ya(this);$a(this.T);this.T.ga||(this.T.Z=void 0,this.T.U=void 0)};X.prototype.isDeleted=function(){return!this.T.U};\nX.prototype.deleteLater=function(){this.T.U||lb(this);this.T.fa&&!this.T.ga&&M(\"Object already scheduled for deletion\");P.push(this);1===P.length&&Ta&&Ta(Sa);this.T.fa=!0;return this};Y.prototype.Ea=function(b){this.ra&&(b=this.ra(b));return b};Y.prototype.oa=function(b){this.ba&&this.ba(b)};Y.prototype.argPackAdvance=8;Y.prototype.readValueFromPointer=ib;Y.prototype.deleteObject=function(b){if(null!==b)b[\"delete\"]()};\nY.prototype.fromWireType=function(b){function a(){return this.ja?fb(this.V.ca,{W:this.Ka,U:c,aa:this,Z:b}):fb(this.V.ca,{W:this,U:b})}var c=this.Ea(b);if(!c)return this.oa(b),null;var d=cb(this.V,c);if(void 0!==d){if(0===d.T.count.value)return d.T.U=c,d.T.Z=b,d.clone();d=d.clone();this.oa(b);return d}d=this.V.Da(c);d=bb[d];if(!d)return a.call(this);d=this.ia?d.za:d.pointerType;var e=ab(c,this.V,d.V);return null===e?a.call(this):this.ja?fb(d.V.ca,{W:d,U:e,aa:this,Z:b}):fb(d.V.ca,{W:d,U:e})};\nyb=l.UnboundTypeError=Oa(\"UnboundTypeError\");\nvar Qb={l:function(b){return Pb(b+24)+24},k:function(b,a,c){(new Ja(b)).sa(a,c);Ka++;throw b;},r:function(b,a,c){b=O(b);a=Xa(a,\"wrapper\");c=N(c);var d=[].slice,e=a.V,f=e.ca,k=e.X.ca,g=e.X.constructor;b=Ma(b,function(){e.X.qa.forEach(function(h){if(this[h]===k[h])throw new Qa(\"Pure virtual function \"+h+\" must be implemented in JavaScript\");}.bind(this));Object.defineProperty(this,\"__parent\",{value:f});this.__construct.apply(this,d.call(arguments))});f.__construct=function(){this===f&&M(\"Pass correct 'this' to __construct\");\nvar h=g.implement.apply(void 0,[this].concat(d.call(arguments)));Ya(h);var n=h.T;h.notifyOnDestruction();n.ga=!0;Object.defineProperties(this,{T:{value:n}});T(this);h=n.U;h=Ua(e,h);Q.hasOwnProperty(h)?M(\"Tried to register registered instance: \"+h):Q[h]=this};f.__destruct=function(){this===f&&M(\"Pass correct 'this' to __destruct\");Ya(this);var h=this.T.U;h=Ua(e,h);Q.hasOwnProperty(h)?delete Q[h]:M(\"Tried to unregister unregistered instance: \"+h)};b.prototype=Object.create(f);for(var m in c)b.prototype[m]=\nc[m];return Pa(b)},j:function(b){var a=gb[b];delete gb[b];var c=a.ma,d=a.ba,e=a.pa,f=e.map(k=>k.Ha).concat(e.map(k=>k.Na));V([b],f,k=>{var g={};e.forEach((m,h)=>{var n=k[h],p=m.Fa,r=m.Ga,u=k[h+e.length],t=m.Ma,z=m.Oa;g[m.Ca]={read:C=>n.fromWireType(p(r,C)),write:(C,ca)=>{var J=[];t(z,C,u.toWireType(J,ca));hb(J)}}});return[{name:a.name,fromWireType:function(m){var h={},n;for(n in g)h[n]=g[n].read(m);d(m);return h},toWireType:function(m,h){for(var n in g)if(!(n in h))throw new TypeError('Missing field:  \"'+\nn+'\"');var p=c();for(n in g)g[n].write(p,h[n]);null!==m&&m.push(d,p);return p},argPackAdvance:8,readValueFromPointer:ib,$:d}]})},u:function(){},B:function(b,a,c,d,e){var f=kb(c);a=O(a);W(b,{name:a,fromWireType:function(k){return!!k},toWireType:function(k,g){return g?d:e},argPackAdvance:8,readValueFromPointer:function(k){if(1===c)var g=x;else if(2===c)g=A;else if(4===c)g=B;else throw new TypeError(\"Unknown boolean type size: \"+a);return this.fromWireType(g[k>>f])},$:null})},e:function(b,a,c,d,e,f,\nk,g,m,h,n,p,r){n=O(n);f=Z(e,f);g&&(g=Z(k,g));h&&(h=Z(m,h));r=Z(p,r);var u=La(n);nb(u,function(){zb(\"Cannot construct \"+n+\" due to unbound types\",[d])});V([b,a,c],d?[d]:[],function(t){t=t[0];if(d){var z=t.V;var C=z.ca}else C=X.prototype;t=Ma(u,function(){if(Object.getPrototypeOf(this)!==ca)throw new L(\"Use 'new' to construct \"+n);if(void 0===J.da)throw new L(n+\" has no accessible constructor\");var ob=J.da[arguments.length];if(void 0===ob)throw new L(\"Tried to invoke ctor of \"+n+\" with invalid number of parameters (\"+\narguments.length+\") - expected (\"+Object.keys(J.da).toString()+\") parameters instead!\");return ob.apply(this,arguments)});var ca=Object.create(C,{constructor:{value:t}});t.prototype=ca;var J=new qb(n,t,ca,r,z,f,g,h);z=new Y(n,J,!0,!1);C=new Y(n+\"*\",J,!1,!1);var pb=new Y(n+\" const*\",J,!1,!0);bb[b]={pointerType:C,za:pb};wb(u,t);return[z,C,pb]})},d:function(b,a,c,d,e,f,k){var g=Bb(c,d);a=O(a);f=Z(e,f);V([],[b],function(m){function h(){zb(\"Cannot call \"+n+\" due to unbound types\",g)}m=m[0];var n=m.name+\n\".\"+a;a.startsWith(\"@@\")&&(a=Symbol[a.substring(2)]);var p=m.V.constructor;void 0===p[a]?(h.ea=c-1,p[a]=h):(mb(p,a,n),p[a].Y[c-1]=h);V([],g,function(r){r=Ab(n,[r[0],null].concat(r.slice(1)),null,f,k);void 0===p[a].Y?(r.ea=c-1,p[a]=r):p[a].Y[c-1]=r;return[]});return[]})},m:function(b,a,c,d,e,f){0<a||w();var k=Bb(a,c);e=Z(d,e);V([],[b],function(g){g=g[0];var m=\"constructor \"+g.name;void 0===g.V.da&&(g.V.da=[]);if(void 0!==g.V.da[a-1])throw new L(\"Cannot register multiple constructors with identical number of parameters (\"+\n(a-1)+\") for class '\"+g.name+\"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");g.V.da[a-1]=()=>{zb(\"Cannot construct \"+g.name+\" due to unbound types\",k)};V([],k,function(h){h.splice(1,0,null);g.V.da[a-1]=Ab(m,h,null,e,f);return[]});return[]})},a:function(b,a,c,d,e,f,k,g){var m=Bb(c,d);a=O(a);f=Z(e,f);V([],[b],function(h){function n(){zb(\"Cannot call \"+p+\" due to unbound types\",m)}h=h[0];var p=h.name+\".\"+a;a.startsWith(\"@@\")&&(a=Symbol[a.substring(2)]);\ng&&h.V.qa.push(a);var r=h.V.ca,u=r[a];void 0===u||void 0===u.Y&&u.className!==h.name&&u.ea===c-2?(n.ea=c-2,n.className=h.name,r[a]=n):(mb(r,a,p),r[a].Y[c-2]=n);V([],m,function(t){t=Ab(p,t,h,f,k);void 0===r[a].Y?(t.ea=c-2,r[a]=t):r[a].Y[c-2]=t;return[]});return[]})},A:function(b,a){a=O(a);W(b,{name:a,fromWireType:function(c){var d=N(c);Cb(c);return d},toWireType:function(c,d){return Pa(d)},argPackAdvance:8,readValueFromPointer:ib,$:null})},o:function(b,a,c,d){function e(){}c=kb(c);a=O(a);e.values=\n{};W(b,{name:a,constructor:e,fromWireType:function(f){return this.constructor.values[f]},toWireType:function(f,k){return k.value},argPackAdvance:8,readValueFromPointer:Db(a,c,d),$:null});nb(a,e)},n:function(b,a,c){var d=Xa(b,\"enum\");a=O(a);b=d.constructor;d=Object.create(d.constructor.prototype,{value:{value:c},constructor:{value:Ma(d.name+\"_\"+a,function(){})}});b.values[c]=d;b[a]=d},p:function(b,a,c){c=kb(c);a=O(a);W(b,{name:a,fromWireType:function(d){return d},toWireType:function(d,e){return e},\nargPackAdvance:8,readValueFromPointer:Eb(a,c),$:null})},c:function(b,a,c,d,e){a=O(a);-1===e&&(e=4294967295);e=kb(c);var f=g=>g;if(0===d){var k=32-8*c;f=g=>g<<k>>>k}c=a.includes(\"unsigned\")?function(g,m){return m>>>0}:function(g,m){return m};W(b,{name:a,fromWireType:f,toWireType:c,argPackAdvance:8,readValueFromPointer:Fb(a,e,0!==d),$:null})},b:function(b,a,c){function d(f){f>>=2;var k=D;return new e(ua,k[f+1],k[f])}var e=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,\nFloat64Array][a];c=O(c);W(b,{name:c,fromWireType:d,argPackAdvance:8,readValueFromPointer:d},{Ia:!0})},q:function(b,a){a=O(a);var c=\"std::string\"===a;W(b,{name:a,fromWireType:function(d){var e=D[d>>2];if(c)for(var f=d+4,k=0;k<=e;++k){var g=d+4+k;if(k==e||0==y[g]){f=f?na(y,f,g-f):\"\";if(void 0===m)var m=f;else m+=String.fromCharCode(0),m+=f;f=g+1}}else{m=Array(e);for(k=0;k<e;++k)m[k]=String.fromCharCode(y[d+4+k]);m=m.join(\"\")}S(d);return m},toWireType:function(d,e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));\nvar f=\"string\"==typeof e;f||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Int8Array||M(\"Cannot pass non-string to std::string\");var k=(c&&f?()=>{for(var h=0,n=0;n<e.length;++n){var p=e.charCodeAt(n);55296<=p&&57343>=p&&(p=65536+((p&1023)<<10)|e.charCodeAt(++n)&1023);127>=p?++h:h=2047>=p?h+2:65535>=p?h+3:h+4}return h}:()=>e.length)(),g=Pb(4+k+1);D[g>>2]=k;if(c&&f)ka(e,g+4,k+1);else if(f)for(f=0;f<k;++f){var m=e.charCodeAt(f);255<m&&(S(g),M(\"String has UTF-16 code units that do not fit in 8 bits\"));\ny[g+4+f]=m}else for(f=0;f<k;++f)y[g+4+f]=e[f];null!==d&&d.push(S,g);return g},argPackAdvance:8,readValueFromPointer:ib,$:function(d){S(d)}})},i:function(b,a,c){c=O(c);if(2===a){var d=oa;var e=pa;var f=qa;var k=()=>va;var g=1}else 4===a&&(d=ra,e=sa,f=ta,k=()=>D,g=2);W(b,{name:c,fromWireType:function(m){for(var h=D[m>>2],n=k(),p,r=m+4,u=0;u<=h;++u){var t=m+4+u*a;if(u==h||0==n[t>>g])r=d(r,t-r),void 0===p?p=r:(p+=String.fromCharCode(0),p+=r),r=t+a}S(m);return p},toWireType:function(m,h){\"string\"!=typeof h&&\nM(\"Cannot pass non-string to C++ string type \"+c);var n=f(h),p=Pb(4+n+a);D[p>>2]=n>>g;e(h,p+4,n+a);null!==m&&m.push(S,p);return p},argPackAdvance:8,readValueFromPointer:ib,$:function(m){S(m)}})},h:function(b,a,c,d,e,f){gb[b]={name:O(a),ma:Z(c,d),ba:Z(e,f),pa:[]}},g:function(b,a,c,d,e,f,k,g,m,h){gb[b].pa.push({Ca:O(a),Ha:c,Fa:Z(d,e),Ga:f,Na:k,Ma:Z(g,m),Oa:h})},C:function(b,a){a=O(a);W(b,{Ja:!0,name:a,argPackAdvance:0,fromWireType:function(){},toWireType:function(){}})},F:function(b,a,c,d,e){b=Ib[b];\na=N(a);c=Hb(c);var f=[];B[d>>2]=Pa(f);return b(a,c,f,e)},H:function(b,a,c,d){b=Ib[b];a=N(a);c=Hb(c);b(a,c,null,d)},G:Cb,s:function(b,a){var c=Kb(b,a),d=c[0];a=d.name+\"_$\"+c.slice(1).map(function(k){return k.name}).join(\"_\")+\"$\";var e=Lb[a];if(void 0!==e)return e;var f=Array(b-1);e=Jb((k,g,m,h)=>{for(var n=0,p=0;p<b-1;++p)f[p]=c[p+1].readValueFromPointer(h+n),n+=c[p+1].argPackAdvance;k=k[g].apply(k,f);for(p=0;p<b-1;++p)c[p+1].Aa&&c[p+1].Aa(f[p]);if(!d.Ja)return d.toWireType(m,k)});return Lb[a]=e},\nD:function(b){4<b&&(K[b].na+=1)},E:function(b){var a=N(b);hb(a);Cb(b)},f:function(){w(\"\")},x:function(b,a,c){y.copyWithin(b,a,a+c)},w:function(b){var a=y.length;b>>>=0;if(2147483648<b)return!1;for(var c=1;4>=c;c*=2){var d=a*(1+.2/c);d=Math.min(d,b+100663296);var e=Math;d=Math.max(b,d);e=e.min.call(e,2147483648,d+(65536-d%65536)%65536);a:{try{fa.grow(e-ua.byteLength+65535>>>16);ya();var f=1;break a}catch(k){}f=void 0}if(f)return!0}return!1},z:function(){return 52},t:function(){return 70},y:function(b,\na,c,d){for(var e=0,f=0;f<c;f++){var k=D[a>>2],g=D[a+4>>2];a+=8;for(var m=0;m<g;m++){var h=y[k+m],n=Mb[b];0===h||10===h?((1===b?ea:v)(na(n,0)),n.length=0):n.push(h)}e+=g}D[d>>2]=e;return 0},v:function(){}};\n(function(){function b(e){l.asm=e.exports;fa=l.asm.I;ya();E=l.asm.O;Aa.unshift(l.asm.J);F--;0==F&&(null!==Ca&&(clearInterval(Ca),Ca=null),G&&(e=G,G=null,e()))}function a(e){b(e.instance)}function c(e){return Ga().then(function(f){return __next_webassembly_instantiate__(function() { return WebAssembly.instantiate(f,d)})}).then(function(f){return f}).then(e,function(f){v(\"failed to asynchronously prepare wasm: \"+f);w(f)})}var d={a:Qb};F++;if(l.instantiateWasm)try{return l.instantiateWasm(d,b)}catch(e){return v(\"Module.instantiateWasm callback failed with error: \"+\ne),!1}(function(){return\"function\"!=typeof WebAssembly.instantiateStreaming||Da()||\"function\"!=typeof fetch?c(a):fetch(H,{credentials:\"same-origin\"}).then(function(e){return WebAssembly.instantiateStreaming(e,d).then(a,function(f){v(\"wasm streaming compile failed: \"+f);v(\"falling back to ArrayBuffer instantiation\");return c(a)})})})().catch(ba);return{}})();l.___wasm_call_ctors=function(){return(l.___wasm_call_ctors=l.asm.J).apply(null,arguments)};\nvar Pb=l._malloc=function(){return(Pb=l._malloc=l.asm.K).apply(null,arguments)},S=l._free=function(){return(S=l._free=l.asm.L).apply(null,arguments)},Wa=l.___getTypeName=function(){return(Wa=l.___getTypeName=l.asm.M).apply(null,arguments)};l.___embind_register_native_and_builtin_types=function(){return(l.___embind_register_native_and_builtin_types=l.asm.N).apply(null,arguments)};\nvar la=l.stackSave=function(){return(la=l.stackSave=l.asm.P).apply(null,arguments)},ma,ja=l.stackAlloc=function(){return(ja=l.stackAlloc=l.asm.Q).apply(null,arguments)};l.___cxa_is_pointer_type=function(){return(l.___cxa_is_pointer_type=l.asm.R).apply(null,arguments)};l.dynCall_jiji=function(){return(l.dynCall_jiji=l.asm.S).apply(null,arguments)};l.cwrap=function(b,a,c,d){c=c||[];var e=c.every(function(f){return\"number\"===f});return\"string\"!==a&&e&&!d?l[\"_\"+b]:function(){return ia(b,a,c,arguments)}};\nl.setValue=function(b,a,c=\"i8\"){c.endsWith(\"*\")&&(c=\"i32\");switch(c){case \"i1\":x[b>>0]=a;break;case \"i8\":x[b>>0]=a;break;case \"i16\":A[b>>1]=a;break;case \"i32\":B[b>>2]=a;break;case \"i64\":Ha=[a>>>0,(I=a,1<=+Math.abs(I)?0<I?(Math.min(+Math.floor(I/4294967296),4294967295)|0)>>>0:~~+Math.ceil((I-+(~~I>>>0))/4294967296)>>>0:0)];B[b>>2]=Ha[0];B[b+4>>2]=Ha[1];break;case \"float\":wa[b>>2]=a;break;case \"double\":xa[b>>3]=a;break;default:w(\"invalid type for setValue: \"+c)}};var Rb;\nG=function Sb(){Rb||Tb();Rb||(G=Sb)};function Tb(){0<F||(Ia(za),0<F||Rb||(Rb=!0,l.calledRun=!0,ha||(Ia(Aa),aa(l),Ia(Ba))))}l.run=Tb;Tb();\n\n\n  return yoga.ready\n}\n);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (yoga);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3lvZ2Etd2FzbS13ZWIvZGlzdC95b2dhLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUNBO0FBQ0EsbUJBQW1CLGtHQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxNQUFNLDZDQUE2QyxFQUFFLFVBQVUsa0NBQWtDLEtBQUssS0FBSyxFQUFFLHVCQUF1QixTQUFTLHFGQUFxRiwyQkFBMkIsb0ZBQW9GLDhEQUE4RCxvQkFBb0IsUUFBUTtBQUMzYSxhQUFhLHFCQUFxQixPQUFPLG1CQUFtQixRQUFRLGdDQUFnQyxzQkFBc0IsUUFBUSxVQUFVLFNBQVMsbUJBQW1CLG1CQUFtQixXQUFXLFdBQVcsV0FBVyxhQUFhLGlCQUFpQixXQUFXLEtBQUssY0FBYywyQ0FBMkMsa0JBQWtCLHFCQUFxQixhQUFhLG9EQUFvRDtBQUMzYSxtQkFBbUIsTUFBTSxhQUFhLFFBQVEsRUFBRSxhQUFhLFlBQVksVUFBVSxnQkFBZ0Isb0RBQW9ELEtBQUssZ0JBQWdCLGdFQUFnRSwrRkFBK0YsK0JBQStCO0FBQzFXLG1CQUFtQixRQUFRLFFBQVEsUUFBUSxZQUFZLFdBQVcsS0FBSyxzQkFBc0IsdUJBQXVCLHdCQUF3Qiw4QkFBOEIsV0FBVyxjQUFjLFNBQVMsS0FBSyxZQUFZLGdCQUFnQixnQkFBZ0IsS0FBSyxhQUFhLGdCQUFnQixpQkFBaUIsS0FBSyxnQkFBZ0IsaUJBQWlCLG9CQUFvQixtQkFBbUIsaUJBQWlCO0FBQzlZLGlCQUFpQixpQkFBaUIsVUFBVSxLQUFLLGtCQUFrQixjQUFjLDBCQUEwQixTQUFTLG1CQUFtQiwyQkFBMkIsZ0JBQWdCLEtBQUssUUFBUSw0QkFBNEIsWUFBWSxJQUFJLGlDQUFpQyxVQUFVLFdBQVcsZUFBZTtBQUNoVCxpQkFBaUIsaUJBQWlCLFVBQVUsRUFBRSxrQkFBa0IsY0FBYyxJQUFJLCtGQUErRixTQUFTLG1CQUFtQiwyQkFBMkIsZ0JBQWdCLFFBQVEsUUFBUSxZQUFZLFdBQVcsS0FBSyxzQkFB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QixFQUFFLDhDQUE4QztBQUM1ZCxnQ0FBZ0MsMkJBQTJCLFVBQVUsb0JBQW9CLE1BQU0sb0JBQW9CLE1BQU0scUJBQXFCLE1BQU0scUJBQXFCLE1BQU0scUpBQXFKLGNBQWMsZ0JBQWdCLE1BQU0sd0JBQXdCLE1BQU0seUJBQXlCLE1BQU0sNkNBQTZDO0FBQ2xkLGdCQUFnQixTQUFTLFlBQVksY0FBYyx3RUFBd0UsU0FBUzs7O0FBR3BJO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpRUFBZSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy95b2dhLXdhc20td2ViL2Rpc3QveW9nYS5tanM/NDI2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciB5b2dhID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHREaXIgPSBpbXBvcnQubWV0YS51cmw7XG4gIFxuICByZXR1cm4gKFxuZnVuY3Rpb24oeW9nYSkge1xuICB5b2dhID0geW9nYSB8fCB7fTtcblxuXG52YXIgbDtsfHwobD10eXBlb2YgeW9nYSAhPT0gJ3VuZGVmaW5lZCcgPyB5b2dhIDoge30pO3ZhciBhYSxiYTtsLnJlYWR5PW5ldyBQcm9taXNlKGZ1bmN0aW9uKGIsYSl7YWE9YjtiYT1hfSk7dmFyIGRhPU9iamVjdC5hc3NpZ24oe30sbCkscT1cIlwiO1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKHE9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpO19zY3JpcHREaXImJihxPV9zY3JpcHREaXIpOzAhPT1xLmluZGV4T2YoXCJibG9iOlwiKT9xPXEuc3Vic3RyKDAscS5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpxPVwiXCI7dmFyIGVhPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksdj1jb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKGwsZGEpO2RhPW51bGw7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZ3KFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTtcbnZhciBmYSxoYT0hMTtmdW5jdGlvbiBpYShiLGEsYyxkKXt2YXIgZT17c3RyaW5nOmZ1bmN0aW9uKGgpe3ZhciBuPTA7aWYobnVsbCE9PWgmJnZvaWQgMCE9PWgmJjAhPT1oKXt2YXIgcD0oaC5sZW5ndGg8PDIpKzE7bj1qYShwKTtrYShoLG4scCl9cmV0dXJuIG59LGFycmF5OmZ1bmN0aW9uKGgpe3ZhciBuPWphKGgubGVuZ3RoKTt4LnNldChoLG4pO3JldHVybiBufX07Yj1sW1wiX1wiK2JdO3ZhciBmPVtdLGs9MDtpZihkKWZvcih2YXIgZz0wO2c8ZC5sZW5ndGg7ZysrKXt2YXIgbT1lW2NbZ11dO20/KDA9PT1rJiYoaz1sYSgpKSxmW2ddPW0oZFtnXSkpOmZbZ109ZFtnXX1jPWIuYXBwbHkobnVsbCxmKTtyZXR1cm4gYz1mdW5jdGlvbihoKXswIT09ayYmbWEoayk7cmV0dXJuXCJzdHJpbmdcIj09PWE/aD9uYSh5LGgpOlwiXCI6XCJib29sZWFuXCI9PT1hPyEhaDpofShjKX1cbmZ1bmN0aW9uIG5hKGIsYSxjKXtjPWErYztmb3IodmFyIGQ9XCJcIjshKGE+PWMpOyl7dmFyIGU9YlthKytdO2lmKCFlKWJyZWFrO2lmKGUmMTI4KXt2YXIgZj1iW2ErK10mNjM7aWYoMTkyPT0oZSYyMjQpKWQrPVN0cmluZy5mcm9tQ2hhckNvZGUoKGUmMzEpPDw2fGYpO2Vsc2V7dmFyIGs9YlthKytdJjYzO2U9MjI0PT0oZSYyNDApPyhlJjE1KTw8MTJ8Zjw8NnxrOihlJjcpPDwxOHxmPDwxMnxrPDw2fGJbYSsrXSY2Mzs2NTUzNj5lP2QrPVN0cmluZy5mcm9tQ2hhckNvZGUoZSk6KGUtPTY1NTM2LGQrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8ZT4+MTAsNTYzMjB8ZSYxMDIzKSl9fWVsc2UgZCs9U3RyaW5nLmZyb21DaGFyQ29kZShlKX1yZXR1cm4gZH1cbmZ1bmN0aW9uIGthKGIsYSxjKXt2YXIgZD15O2lmKDA8Yyl7Yz1hK2MtMTtmb3IodmFyIGU9MDtlPGIubGVuZ3RoOysrZSl7dmFyIGY9Yi5jaGFyQ29kZUF0KGUpO2lmKDU1Mjk2PD1mJiY1NzM0Mz49Zil7dmFyIGs9Yi5jaGFyQ29kZUF0KCsrZSk7Zj02NTUzNisoKGYmMTAyMyk8PDEwKXxrJjEwMjN9aWYoMTI3Pj1mKXtpZihhPj1jKWJyZWFrO2RbYSsrXT1mfWVsc2V7aWYoMjA0Nz49Zil7aWYoYSsxPj1jKWJyZWFrO2RbYSsrXT0xOTJ8Zj4+Nn1lbHNle2lmKDY1NTM1Pj1mKXtpZihhKzI+PWMpYnJlYWs7ZFthKytdPTIyNHxmPj4xMn1lbHNle2lmKGErMz49YylicmVhaztkW2ErK109MjQwfGY+PjE4O2RbYSsrXT0xMjh8Zj4+MTImNjN9ZFthKytdPTEyOHxmPj42JjYzfWRbYSsrXT0xMjh8ZiY2M319ZFthXT0wfX1cbmZ1bmN0aW9uIG9hKGIsYSl7Zm9yKHZhciBjPVwiXCIsZD0wOyEoZD49YS8yKTsrK2Qpe3ZhciBlPUFbYisyKmQ+PjFdO2lmKDA9PWUpYnJlYWs7Yys9U3RyaW5nLmZyb21DaGFyQ29kZShlKX1yZXR1cm4gY31mdW5jdGlvbiBwYShiLGEsYyl7dm9pZCAwPT09YyYmKGM9MjE0NzQ4MzY0Nyk7aWYoMj5jKXJldHVybiAwO2MtPTI7dmFyIGQ9YTtjPWM8MipiLmxlbmd0aD9jLzI6Yi5sZW5ndGg7Zm9yKHZhciBlPTA7ZTxjOysrZSlBW2E+PjFdPWIuY2hhckNvZGVBdChlKSxhKz0yO0FbYT4+MV09MDtyZXR1cm4gYS1kfWZ1bmN0aW9uIHFhKGIpe3JldHVybiAyKmIubGVuZ3RofVxuZnVuY3Rpb24gcmEoYixhKXtmb3IodmFyIGM9MCxkPVwiXCI7IShjPj1hLzQpOyl7dmFyIGU9QltiKzQqYz4+Ml07aWYoMD09ZSlicmVhazsrK2M7NjU1MzY8PWU/KGUtPTY1NTM2LGQrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8ZT4+MTAsNTYzMjB8ZSYxMDIzKSk6ZCs9U3RyaW5nLmZyb21DaGFyQ29kZShlKX1yZXR1cm4gZH1mdW5jdGlvbiBzYShiLGEsYyl7dm9pZCAwPT09YyYmKGM9MjE0NzQ4MzY0Nyk7aWYoND5jKXJldHVybiAwO3ZhciBkPWE7Yz1kK2MtNDtmb3IodmFyIGU9MDtlPGIubGVuZ3RoOysrZSl7dmFyIGY9Yi5jaGFyQ29kZUF0KGUpO2lmKDU1Mjk2PD1mJiY1NzM0Mz49Zil7dmFyIGs9Yi5jaGFyQ29kZUF0KCsrZSk7Zj02NTUzNisoKGYmMTAyMyk8PDEwKXxrJjEwMjN9QlthPj4yXT1mO2ErPTQ7aWYoYSs0PmMpYnJlYWt9QlthPj4yXT0wO3JldHVybiBhLWR9XG5mdW5jdGlvbiB0YShiKXtmb3IodmFyIGE9MCxjPTA7YzxiLmxlbmd0aDsrK2Mpe3ZhciBkPWIuY2hhckNvZGVBdChjKTs1NTI5Njw9ZCYmNTczNDM+PWQmJisrYzthKz00fXJldHVybiBhfXZhciB1YSx4LHksQSx2YSxCLEQsd2EseGE7ZnVuY3Rpb24geWEoKXt2YXIgYj1mYS5idWZmZXI7dWE9YjtsLkhFQVA4PXg9bmV3IEludDhBcnJheShiKTtsLkhFQVAxNj1BPW5ldyBJbnQxNkFycmF5KGIpO2wuSEVBUDMyPUI9bmV3IEludDMyQXJyYXkoYik7bC5IRUFQVTg9eT1uZXcgVWludDhBcnJheShiKTtsLkhFQVBVMTY9dmE9bmV3IFVpbnQxNkFycmF5KGIpO2wuSEVBUFUzMj1EPW5ldyBVaW50MzJBcnJheShiKTtsLkhFQVBGMzI9d2E9bmV3IEZsb2F0MzJBcnJheShiKTtsLkhFQVBGNjQ9eGE9bmV3IEZsb2F0NjRBcnJheShiKX12YXIgRSx6YT1bXSxBYT1bXSxCYT1bXSxGPTAsQ2E9bnVsbCxHPW51bGw7XG5mdW5jdGlvbiB3KGIpe2I9XCJBYm9ydGVkKFwiK2IrXCIpXCI7dihiKTtoYT0hMDtiPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoYitcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIik7YmEoYik7dGhyb3cgYjt9ZnVuY3Rpb24gRGEoKXtyZXR1cm4gSC5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX12YXIgSDtpZihsLmxvY2F0ZUZpbGUpe2lmKEg9XCJ5b2dhLndhc21cIiwhRGEoKSl7dmFyIEVhPUg7SD1sLmxvY2F0ZUZpbGU/bC5sb2NhdGVGaWxlKEVhLHEpOnErRWF9fWVsc2UgSD0oXCJcIikudG9TdHJpbmcoKTtmdW5jdGlvbiBGYSgpe3RyeXt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjt9Y2F0Y2goYil7dyhiKX19XG5mdW5jdGlvbiBHYSgpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoP2ZldGNoKEgse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZnVuY3Rpb24oYil7aWYoIWIub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK0grXCInXCI7cmV0dXJuIGIuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuIEZhKCl9KTpQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEZhKCl9KX12YXIgSSxIYTtmdW5jdGlvbiBJYShiKXtmb3IoOzA8Yi5sZW5ndGg7KXt2YXIgYT1iLnNoaWZ0KCk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgYSlhKGwpO2Vsc2V7dmFyIGM9YS5RYTtcIm51bWJlclwiPT10eXBlb2YgYz92b2lkIDA9PT1hLmthP0UuZ2V0KGMpKCk6RS5nZXQoYykoYS5rYSk6Yyh2b2lkIDA9PT1hLmthP251bGw6YS5rYSl9fX1cbmZ1bmN0aW9uIEphKGIpe3RoaXMuVT1iLTI0O3RoaXMueWE9ZnVuY3Rpb24oYSl7RFt0aGlzLlUrND4+Ml09YX07dGhpcy52YT1mdW5jdGlvbihhKXtEW3RoaXMuVSs4Pj4yXT1hfTt0aGlzLndhPWZ1bmN0aW9uKCl7Qlt0aGlzLlU+PjJdPTB9O3RoaXMudWE9ZnVuY3Rpb24oKXt4W3RoaXMuVSsxMj4+MF09MH07dGhpcy54YT1mdW5jdGlvbigpe3hbdGhpcy5VKzEzPj4wXT0wfTt0aGlzLnNhPWZ1bmN0aW9uKGEsYyl7dGhpcy50YSgpO3RoaXMueWEoYSk7dGhpcy52YShjKTt0aGlzLndhKCk7dGhpcy51YSgpO3RoaXMueGEoKX07dGhpcy50YT1mdW5jdGlvbigpe0RbdGhpcy5VKzE2Pj4yXT0wfX12YXIgS2E9MDtmdW5jdGlvbiBMYShiKXtpZih2b2lkIDA9PT1iKXJldHVyblwiX3Vua25vd25cIjtiPWIucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLFwiJFwiKTt2YXIgYT1iLmNoYXJDb2RlQXQoMCk7cmV0dXJuIDQ4PD1hJiY1Nz49YT9cIl9cIitiOmJ9XG5mdW5jdGlvbiBNYShiLGEpe2I9TGEoYik7cmV0dXJuIGZ1bmN0aW9uKCl7bnVsbDtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBLPVt7fSx7dmFsdWU6dm9pZCAwfSx7dmFsdWU6bnVsbH0se3ZhbHVlOiEwfSx7dmFsdWU6ITF9XSxOYT1bXTtmdW5jdGlvbiBPYShiKXt2YXIgYT1FcnJvcixjPU1hKGIsZnVuY3Rpb24oZCl7dGhpcy5uYW1lPWI7dGhpcy5tZXNzYWdlPWQ7ZD1FcnJvcihkKS5zdGFjazt2b2lkIDAhPT1kJiYodGhpcy5zdGFjaz10aGlzLnRvU3RyaW5nKCkrXCJcXG5cIitkLnJlcGxhY2UoL15FcnJvcig6W15cXG5dKik/XFxuLyxcIlwiKSl9KTtjLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGEucHJvdG90eXBlKTtjLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1jO2MucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMubWVzc2FnZT90aGlzLm5hbWU6dGhpcy5uYW1lK1wiOiBcIit0aGlzLm1lc3NhZ2V9O3JldHVybiBjfXZhciBMPXZvaWQgMDtcbmZ1bmN0aW9uIE0oYil7dGhyb3cgbmV3IEwoYik7fXZhciBOPWI9PntifHxNKFwiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gXCIrYik7cmV0dXJuIEtbYl0udmFsdWV9LFBhPWI9Pntzd2l0Y2goYil7Y2FzZSB2b2lkIDA6cmV0dXJuIDE7Y2FzZSBudWxsOnJldHVybiAyO2Nhc2UgITA6cmV0dXJuIDM7Y2FzZSAhMTpyZXR1cm4gNDtkZWZhdWx0OnZhciBhPU5hLmxlbmd0aD9OYS5wb3AoKTpLLmxlbmd0aDtLW2FdPXtuYToxLHZhbHVlOmJ9O3JldHVybiBhfX0sUWE9dm9pZCAwLFJhPXZvaWQgMDtmdW5jdGlvbiBPKGIpe2Zvcih2YXIgYT1cIlwiO3lbYl07KWErPVJhW3lbYisrXV07cmV0dXJuIGF9dmFyIFA9W107ZnVuY3Rpb24gU2EoKXtmb3IoO1AubGVuZ3RoOyl7dmFyIGI9UC5wb3AoKTtiLlQuZmE9ITE7YltcImRlbGV0ZVwiXSgpfX12YXIgVGE9dm9pZCAwLFE9e307XG5mdW5jdGlvbiBVYShiLGEpe2Zvcih2b2lkIDA9PT1hJiZNKFwicHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkXCIpO2IuWDspYT1iLmhhKGEpLGI9Yi5YO3JldHVybiBhfXZhciBSPXt9O2Z1bmN0aW9uIFZhKGIpe2I9V2EoYik7dmFyIGE9TyhiKTtTKGIpO3JldHVybiBhfWZ1bmN0aW9uIFhhKGIsYSl7dmFyIGM9UltiXTt2b2lkIDA9PT1jJiZNKGErXCIgaGFzIHVua25vd24gdHlwZSBcIitWYShiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gWWEoKXt9dmFyIFphPSExO2Z1bmN0aW9uICRhKGIpey0tYi5jb3VudC52YWx1ZTswPT09Yi5jb3VudC52YWx1ZSYmKGIuWj9iLmFhLmJhKGIuWik6Yi5XLlYuYmEoYi5VKSl9ZnVuY3Rpb24gYWIoYixhLGMpe2lmKGE9PT1jKXJldHVybiBiO2lmKHZvaWQgMD09PWMuWClyZXR1cm4gbnVsbDtiPWFiKGIsYSxjLlgpO3JldHVybiBudWxsPT09Yj9udWxsOmMuQmEoYil9dmFyIGJiPXt9O2Z1bmN0aW9uIGNiKGIsYSl7YT1VYShiLGEpO3JldHVybiBRW2FdfVxudmFyIGRiPXZvaWQgMDtmdW5jdGlvbiBlYihiKXt0aHJvdyBuZXcgZGIoYik7fWZ1bmN0aW9uIGZiKGIsYSl7YS5XJiZhLlV8fGViKFwibWFrZUNsYXNzSGFuZGxlIHJlcXVpcmVzIHB0ciBhbmQgcHRyVHlwZVwiKTshIWEuYWEhPT0hIWEuWiYmZWIoXCJCb3RoIHNtYXJ0UHRyVHlwZSBhbmQgc21hcnRQdHIgbXVzdCBiZSBzcGVjaWZpZWRcIik7YS5jb3VudD17dmFsdWU6MX07cmV0dXJuIFQoT2JqZWN0LmNyZWF0ZShiLHtUOnt2YWx1ZTphfX0pKX1mdW5jdGlvbiBUKGIpe2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkpcmV0dXJuIFQ9YT0+YSxiO1phPW5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShhPT57JGEoYS5UKX0pO1Q9YT0+e3ZhciBjPWEuVDtjLlomJlphLnJlZ2lzdGVyKGEse1Q6Y30sYSk7cmV0dXJuIGF9O1lhPWE9PntaYS51bnJlZ2lzdGVyKGEpfTtyZXR1cm4gVChiKX12YXIgZ2I9e307XG5mdW5jdGlvbiBoYihiKXtmb3IoO2IubGVuZ3RoOyl7dmFyIGE9Yi5wb3AoKTtiLnBvcCgpKGEpfX1mdW5jdGlvbiBpYihiKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoRFtiPj4yXSl9dmFyIFU9e30samI9e307ZnVuY3Rpb24gVihiLGEsYyl7ZnVuY3Rpb24gZChnKXtnPWMoZyk7Zy5sZW5ndGghPT1iLmxlbmd0aCYmZWIoXCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50XCIpO2Zvcih2YXIgbT0wO208Yi5sZW5ndGg7KyttKVcoYlttXSxnW21dKX1iLmZvckVhY2goZnVuY3Rpb24oZyl7amJbZ109YX0pO3ZhciBlPUFycmF5KGEubGVuZ3RoKSxmPVtdLGs9MDthLmZvckVhY2goKGcsbSk9PntSLmhhc093blByb3BlcnR5KGcpP2VbbV09UltnXTooZi5wdXNoKGcpLFUuaGFzT3duUHJvcGVydHkoZyl8fChVW2ddPVtdKSxVW2ddLnB1c2goKCk9PntlW21dPVJbZ107KytrO2s9PT1mLmxlbmd0aCYmZChlKX0pKX0pOzA9PT1mLmxlbmd0aCYmZChlKX1cbmZ1bmN0aW9uIGtiKGIpe3N3aXRjaChiKXtjYXNlIDE6cmV0dXJuIDA7Y2FzZSAyOnJldHVybiAxO2Nhc2UgNDpyZXR1cm4gMjtjYXNlIDg6cmV0dXJuIDM7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biB0eXBlIHNpemU6IFwiK2IpO319XG5mdW5jdGlvbiBXKGIsYSxjPXt9KXtpZighKFwiYXJnUGFja0FkdmFuY2VcImluIGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlXCIpO3ZhciBkPWEubmFtZTtifHxNKCd0eXBlIFwiJytkKydcIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyJyk7aWYoUi5oYXNPd25Qcm9wZXJ0eShiKSl7aWYoYy5JYSlyZXR1cm47TShcIkNhbm5vdCByZWdpc3RlciB0eXBlICdcIitkK1wiJyB0d2ljZVwiKX1SW2JdPWE7ZGVsZXRlIGpiW2JdO1UuaGFzT3duUHJvcGVydHkoYikmJihhPVVbYl0sZGVsZXRlIFVbYl0sYS5mb3JFYWNoKGU9PmUoKSkpfWZ1bmN0aW9uIGxiKGIpe00oYi5ULlcuVi5uYW1lK1wiIGluc3RhbmNlIGFscmVhZHkgZGVsZXRlZFwiKX1mdW5jdGlvbiBYKCl7fVxuZnVuY3Rpb24gbWIoYixhLGMpe2lmKHZvaWQgMD09PWJbYV0uWSl7dmFyIGQ9YlthXTtiW2FdPWZ1bmN0aW9uKCl7YlthXS5ZLmhhc093blByb3BlcnR5KGFyZ3VtZW50cy5sZW5ndGgpfHxNKFwiRnVuY3Rpb24gJ1wiK2MrXCInIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyAoXCIrYXJndW1lbnRzLmxlbmd0aCtcIikgLSBleHBlY3RzIG9uZSBvZiAoXCIrYlthXS5ZK1wiKSFcIik7cmV0dXJuIGJbYV0uWVthcmd1bWVudHMubGVuZ3RoXS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2JbYV0uWT1bXTtiW2FdLllbZC5lYV09ZH19XG5mdW5jdGlvbiBuYihiLGEpe2wuaGFzT3duUHJvcGVydHkoYik/KE0oXCJDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJ1wiK2IrXCInIHR3aWNlXCIpLG1iKGwsYixiKSxsLmhhc093blByb3BlcnR5KHZvaWQgMCkmJk0oXCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgb3ZlcmxvYWRzIG9mIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzICh1bmRlZmluZWQpIVwiKSxsW2JdLllbdm9pZCAwXT1hKTpsW2JdPWF9ZnVuY3Rpb24gcWIoYixhLGMsZCxlLGYsayxnKXt0aGlzLm5hbWU9Yjt0aGlzLmNvbnN0cnVjdG9yPWE7dGhpcy5jYT1jO3RoaXMuYmE9ZDt0aGlzLlg9ZTt0aGlzLkRhPWY7dGhpcy5oYT1rO3RoaXMuQmE9Zzt0aGlzLnFhPVtdfVxuZnVuY3Rpb24gcmIoYixhLGMpe2Zvcig7YSE9PWM7KWEuaGF8fE0oXCJFeHBlY3RlZCBudWxsIG9yIGluc3RhbmNlIG9mIFwiK2MubmFtZStcIiwgZ290IGFuIGluc3RhbmNlIG9mIFwiK2EubmFtZSksYj1hLmhhKGIpLGE9YS5YO3JldHVybiBifWZ1bmN0aW9uIHNiKGIsYSl7aWYobnVsbD09PWEpcmV0dXJuIHRoaXMubGEmJk0oXCJudWxsIGlzIG5vdCBhIHZhbGlkIFwiK3RoaXMubmFtZSksMDthLlR8fE0oJ0Nhbm5vdCBwYXNzIFwiJyt0YihhKSsnXCIgYXMgYSAnK3RoaXMubmFtZSk7YS5ULlV8fE0oXCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSBcIit0aGlzLm5hbWUpO3JldHVybiByYihhLlQuVSxhLlQuVy5WLHRoaXMuVil9XG5mdW5jdGlvbiB1YihiLGEpe2lmKG51bGw9PT1hKXt0aGlzLmxhJiZNKFwibnVsbCBpcyBub3QgYSB2YWxpZCBcIit0aGlzLm5hbWUpO2lmKHRoaXMuamEpe3ZhciBjPXRoaXMubWEoKTtudWxsIT09YiYmYi5wdXNoKHRoaXMuYmEsYyk7cmV0dXJuIGN9cmV0dXJuIDB9YS5UfHxNKCdDYW5ub3QgcGFzcyBcIicrdGIoYSkrJ1wiIGFzIGEgJyt0aGlzLm5hbWUpO2EuVC5VfHxNKFwiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgXCIrdGhpcy5uYW1lKTshdGhpcy5pYSYmYS5ULlcuaWEmJk0oXCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlIFwiKyhhLlQuYWE/YS5ULmFhLm5hbWU6YS5ULlcubmFtZSkrXCIgdG8gcGFyYW1ldGVyIHR5cGUgXCIrdGhpcy5uYW1lKTtjPXJiKGEuVC5VLGEuVC5XLlYsdGhpcy5WKTtpZih0aGlzLmphKXN3aXRjaCh2b2lkIDA9PT1hLlQuWiYmTShcIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsXCIpLFxudGhpcy5QYSl7Y2FzZSAwOmEuVC5hYT09PXRoaXM/Yz1hLlQuWjpNKFwiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSBcIisoYS5ULmFhP2EuVC5hYS5uYW1lOmEuVC5XLm5hbWUpK1wiIHRvIHBhcmFtZXRlciB0eXBlIFwiK3RoaXMubmFtZSk7YnJlYWs7Y2FzZSAxOmM9YS5ULlo7YnJlYWs7Y2FzZSAyOmlmKGEuVC5hYT09PXRoaXMpYz1hLlQuWjtlbHNle3ZhciBkPWEuY2xvbmUoKTtjPXRoaXMuTGEoYyxQYShmdW5jdGlvbigpe2RbXCJkZWxldGVcIl0oKX0pKTtudWxsIT09YiYmYi5wdXNoKHRoaXMuYmEsYyl9YnJlYWs7ZGVmYXVsdDpNKFwiVW5zdXBwb3J0aW5nIHNoYXJpbmcgcG9saWN5XCIpfXJldHVybiBjfVxuZnVuY3Rpb24gdmIoYixhKXtpZihudWxsPT09YSlyZXR1cm4gdGhpcy5sYSYmTShcIm51bGwgaXMgbm90IGEgdmFsaWQgXCIrdGhpcy5uYW1lKSwwO2EuVHx8TSgnQ2Fubm90IHBhc3MgXCInK3RiKGEpKydcIiBhcyBhICcrdGhpcy5uYW1lKTthLlQuVXx8TShcIkNhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlIFwiK3RoaXMubmFtZSk7YS5ULlcuaWEmJk0oXCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlIFwiK2EuVC5XLm5hbWUrXCIgdG8gcGFyYW1ldGVyIHR5cGUgXCIrdGhpcy5uYW1lKTtyZXR1cm4gcmIoYS5ULlUsYS5ULlcuVix0aGlzLlYpfVxuZnVuY3Rpb24gWShiLGEsYyxkKXt0aGlzLm5hbWU9Yjt0aGlzLlY9YTt0aGlzLmxhPWM7dGhpcy5pYT1kO3RoaXMuamE9ITE7dGhpcy5iYT10aGlzLkxhPXRoaXMubWE9dGhpcy5yYT10aGlzLlBhPXRoaXMuS2E9dm9pZCAwO3ZvaWQgMCE9PWEuWD90aGlzLnRvV2lyZVR5cGU9dWI6KHRoaXMudG9XaXJlVHlwZT1kP3NiOnZiLHRoaXMuJD1udWxsKX1mdW5jdGlvbiB3YihiLGEpe2wuaGFzT3duUHJvcGVydHkoYil8fGViKFwiUmVwbGFjaW5nIG5vbmV4aXN0YW50IHB1YmxpYyBzeW1ib2xcIik7bFtiXT1hO2xbYl0uZWE9dm9pZCAwfVxuZnVuY3Rpb24geGIoYixhKXt2YXIgYz1bXTtyZXR1cm4gZnVuY3Rpb24oKXtjLmxlbmd0aD0wO09iamVjdC5hc3NpZ24oYyxhcmd1bWVudHMpO2lmKGIuaW5jbHVkZXMoXCJqXCIpKXt2YXIgZD1sW1wiZHluQ2FsbF9cIitiXTtkPWMmJmMubGVuZ3RoP2QuYXBwbHkobnVsbCxbYV0uY29uY2F0KGMpKTpkLmNhbGwobnVsbCxhKX1lbHNlIGQ9RS5nZXQoYSkuYXBwbHkobnVsbCxjKTtyZXR1cm4gZH19ZnVuY3Rpb24gWihiLGEpe2I9TyhiKTt2YXIgYz1iLmluY2x1ZGVzKFwialwiKT94YihiLGEpOkUuZ2V0KGEpO1wiZnVuY3Rpb25cIiE9dHlwZW9mIGMmJk0oXCJ1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgXCIrYitcIjogXCIrYSk7cmV0dXJuIGN9dmFyIHliPXZvaWQgMDtcbmZ1bmN0aW9uIHpiKGIsYSl7ZnVuY3Rpb24gYyhmKXtlW2ZdfHxSW2ZdfHwoamJbZl0/amJbZl0uZm9yRWFjaChjKTooZC5wdXNoKGYpLGVbZl09ITApKX12YXIgZD1bXSxlPXt9O2EuZm9yRWFjaChjKTt0aHJvdyBuZXcgeWIoYitcIjogXCIrZC5tYXAoVmEpLmpvaW4oW1wiLCBcIl0pKTt9XG5mdW5jdGlvbiBBYihiLGEsYyxkLGUpe3ZhciBmPWEubGVuZ3RoOzI+ZiYmTShcImFyZ1R5cGVzIGFycmF5IHNpemUgbWlzbWF0Y2ghIE11c3QgYXQgbGVhc3QgZ2V0IHJldHVybiB2YWx1ZSBhbmQgJ3RoaXMnIHR5cGVzIVwiKTt2YXIgaz1udWxsIT09YVsxXSYmbnVsbCE9PWMsZz0hMTtmb3IoYz0xO2M8YS5sZW5ndGg7KytjKWlmKG51bGwhPT1hW2NdJiZ2b2lkIDA9PT1hW2NdLiQpe2c9ITA7YnJlYWt9dmFyIG09XCJ2b2lkXCIhPT1hWzBdLm5hbWUsaD1mLTIsbj1BcnJheShoKSxwPVtdLHI9W107cmV0dXJuIGZ1bmN0aW9uKCl7YXJndW1lbnRzLmxlbmd0aCE9PWgmJk0oXCJmdW5jdGlvbiBcIitiK1wiIGNhbGxlZCB3aXRoIFwiK2FyZ3VtZW50cy5sZW5ndGgrXCIgYXJndW1lbnRzLCBleHBlY3RlZCBcIitoK1wiIGFyZ3MhXCIpO3IubGVuZ3RoPTA7cC5sZW5ndGg9az8yOjE7cFswXT1lO2lmKGspe3ZhciB1PWFbMV0udG9XaXJlVHlwZShyLHRoaXMpO3BbMV09dX1mb3IodmFyIHQ9MDt0PGg7Kyt0KW5bdF09XG5hW3QrMl0udG9XaXJlVHlwZShyLGFyZ3VtZW50c1t0XSkscC5wdXNoKG5bdF0pO3Q9ZC5hcHBseShudWxsLHApO2lmKGcpaGIocik7ZWxzZSBmb3IodmFyIHo9az8xOjI7ejxhLmxlbmd0aDt6Kyspe3ZhciBDPTE9PT16P3U6blt6LTJdO251bGwhPT1hW3pdLiQmJmFbel0uJChDKX11PW0/YVswXS5mcm9tV2lyZVR5cGUodCk6dm9pZCAwO3JldHVybiB1fX1mdW5jdGlvbiBCYihiLGEpe2Zvcih2YXIgYz1bXSxkPTA7ZDxiO2QrKyljLnB1c2goQlsoYT4+MikrZF0pO3JldHVybiBjfWZ1bmN0aW9uIENiKGIpezQ8YiYmMD09PS0tS1tiXS5uYSYmKEtbYl09dm9pZCAwLE5hLnB1c2goYikpfVxuZnVuY3Rpb24gRGIoYixhLGMpe3N3aXRjaChhKXtjYXNlIDA6cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZSgoYz94OnkpW2RdKX07Y2FzZSAxOnJldHVybiBmdW5jdGlvbihkKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoKGM/QTp2YSlbZD4+MV0pfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZSgoYz9COkQpW2Q+PjJdKX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBpbnRlZ2VyIHR5cGU6IFwiK2IpO319ZnVuY3Rpb24gdGIoYil7aWYobnVsbD09PWIpcmV0dXJuXCJudWxsXCI7dmFyIGE9dHlwZW9mIGI7cmV0dXJuXCJvYmplY3RcIj09PWF8fFwiYXJyYXlcIj09PWF8fFwiZnVuY3Rpb25cIj09PWE/Yi50b1N0cmluZygpOlwiXCIrYn1cbmZ1bmN0aW9uIEViKGIsYSl7c3dpdGNoKGEpe2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHdhW2M+PjJdKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoeGFbYz4+M10pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGZsb2F0IHR5cGU6IFwiK2IpO319XG5mdW5jdGlvbiBGYihiLGEsYyl7c3dpdGNoKGEpe2Nhc2UgMDpyZXR1cm4gYz9mdW5jdGlvbihkKXtyZXR1cm4geFtkXX06ZnVuY3Rpb24oZCl7cmV0dXJuIHlbZF19O2Nhc2UgMTpyZXR1cm4gYz9mdW5jdGlvbihkKXtyZXR1cm4gQVtkPj4xXX06ZnVuY3Rpb24oZCl7cmV0dXJuIHZhW2Q+PjFdfTtjYXNlIDI6cmV0dXJuIGM/ZnVuY3Rpb24oZCl7cmV0dXJuIEJbZD4+Ml19OmZ1bmN0aW9uKGQpe3JldHVybiBEW2Q+PjJdfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGludGVnZXIgdHlwZTogXCIrYik7fX12YXIgR2I9e307ZnVuY3Rpb24gSGIoYil7dmFyIGE9R2JbYl07cmV0dXJuIHZvaWQgMD09PWE/TyhiKTphfXZhciBJYj1bXTtmdW5jdGlvbiBKYihiKXt2YXIgYT1JYi5sZW5ndGg7SWIucHVzaChiKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIEtiKGIsYSl7Zm9yKHZhciBjPUFycmF5KGIpLGQ9MDtkPGI7KytkKWNbZF09WGEoRFthKzQqZD4+Ml0sXCJwYXJhbWV0ZXIgXCIrZCk7cmV0dXJuIGN9dmFyIExiPVtdLE1iPVtudWxsLFtdLFtdXTtMPWwuQmluZGluZ0Vycm9yPU9hKFwiQmluZGluZ0Vycm9yXCIpO2wuY291bnRfZW12YWxfaGFuZGxlcz1mdW5jdGlvbigpe2Zvcih2YXIgYj0wLGE9NTthPEsubGVuZ3RoOysrYSl2b2lkIDAhPT1LW2FdJiYrK2I7cmV0dXJuIGJ9O2wuZ2V0X2ZpcnN0X2VtdmFsPWZ1bmN0aW9uKCl7Zm9yKHZhciBiPTU7YjxLLmxlbmd0aDsrK2IpaWYodm9pZCAwIT09S1tiXSlyZXR1cm4gS1tiXTtyZXR1cm4gbnVsbH07UWE9bC5QdXJlVmlydHVhbEVycm9yPU9hKFwiUHVyZVZpcnR1YWxFcnJvclwiKTtmb3IodmFyIE5iPUFycmF5KDI1NiksT2I9MDsyNTY+T2I7KytPYilOYltPYl09U3RyaW5nLmZyb21DaGFyQ29kZShPYik7UmE9TmI7bC5nZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKFEpLmxlbmd0aH07XG5sLmdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXM9ZnVuY3Rpb24oKXt2YXIgYj1bXSxhO2ZvcihhIGluIFEpUS5oYXNPd25Qcm9wZXJ0eShhKSYmYi5wdXNoKFFbYV0pO3JldHVybiBifTtsLmZsdXNoUGVuZGluZ0RlbGV0ZXM9U2E7bC5zZXREZWxheUZ1bmN0aW9uPWZ1bmN0aW9uKGIpe1RhPWI7UC5sZW5ndGgmJlRhJiZUYShTYSl9O2RiPWwuSW50ZXJuYWxFcnJvcj1PYShcIkludGVybmFsRXJyb3JcIik7WC5wcm90b3R5cGUuaXNBbGlhc09mPWZ1bmN0aW9uKGIpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFgmJmIgaW5zdGFuY2VvZiBYKSlyZXR1cm4hMTt2YXIgYT10aGlzLlQuVy5WLGM9dGhpcy5ULlUsZD1iLlQuVy5WO2ZvcihiPWIuVC5VO2EuWDspYz1hLmhhKGMpLGE9YS5YO2Zvcig7ZC5YOyliPWQuaGEoYiksZD1kLlg7cmV0dXJuIGE9PT1kJiZjPT09Yn07XG5YLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3RoaXMuVC5VfHxsYih0aGlzKTtpZih0aGlzLlQuZ2EpcmV0dXJuIHRoaXMuVC5jb3VudC52YWx1ZSs9MSx0aGlzO3ZhciBiPVQsYT1PYmplY3QsYz1hLmNyZWF0ZSxkPU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSxlPXRoaXMuVDtiPWIoYy5jYWxsKGEsZCx7VDp7dmFsdWU6e2NvdW50OmUuY291bnQsZmE6ZS5mYSxnYTplLmdhLFU6ZS5VLFc6ZS5XLFo6ZS5aLGFhOmUuYWF9fX0pKTtiLlQuY291bnQudmFsdWUrPTE7Yi5ULmZhPSExO3JldHVybiBifTtYLnByb3RvdHlwZVtcImRlbGV0ZVwiXT1mdW5jdGlvbigpe3RoaXMuVC5VfHxsYih0aGlzKTt0aGlzLlQuZmEmJiF0aGlzLlQuZ2EmJk0oXCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uXCIpO1lhKHRoaXMpOyRhKHRoaXMuVCk7dGhpcy5ULmdhfHwodGhpcy5ULlo9dm9pZCAwLHRoaXMuVC5VPXZvaWQgMCl9O1gucHJvdG90eXBlLmlzRGVsZXRlZD1mdW5jdGlvbigpe3JldHVybiF0aGlzLlQuVX07XG5YLnByb3RvdHlwZS5kZWxldGVMYXRlcj1mdW5jdGlvbigpe3RoaXMuVC5VfHxsYih0aGlzKTt0aGlzLlQuZmEmJiF0aGlzLlQuZ2EmJk0oXCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uXCIpO1AucHVzaCh0aGlzKTsxPT09UC5sZW5ndGgmJlRhJiZUYShTYSk7dGhpcy5ULmZhPSEwO3JldHVybiB0aGlzfTtZLnByb3RvdHlwZS5FYT1mdW5jdGlvbihiKXt0aGlzLnJhJiYoYj10aGlzLnJhKGIpKTtyZXR1cm4gYn07WS5wcm90b3R5cGUub2E9ZnVuY3Rpb24oYil7dGhpcy5iYSYmdGhpcy5iYShiKX07WS5wcm90b3R5cGUuYXJnUGFja0FkdmFuY2U9ODtZLnByb3RvdHlwZS5yZWFkVmFsdWVGcm9tUG9pbnRlcj1pYjtZLnByb3RvdHlwZS5kZWxldGVPYmplY3Q9ZnVuY3Rpb24oYil7aWYobnVsbCE9PWIpYltcImRlbGV0ZVwiXSgpfTtcblkucHJvdG90eXBlLmZyb21XaXJlVHlwZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBhKCl7cmV0dXJuIHRoaXMuamE/ZmIodGhpcy5WLmNhLHtXOnRoaXMuS2EsVTpjLGFhOnRoaXMsWjpifSk6ZmIodGhpcy5WLmNhLHtXOnRoaXMsVTpifSl9dmFyIGM9dGhpcy5FYShiKTtpZighYylyZXR1cm4gdGhpcy5vYShiKSxudWxsO3ZhciBkPWNiKHRoaXMuVixjKTtpZih2b2lkIDAhPT1kKXtpZigwPT09ZC5ULmNvdW50LnZhbHVlKXJldHVybiBkLlQuVT1jLGQuVC5aPWIsZC5jbG9uZSgpO2Q9ZC5jbG9uZSgpO3RoaXMub2EoYik7cmV0dXJuIGR9ZD10aGlzLlYuRGEoYyk7ZD1iYltkXTtpZighZClyZXR1cm4gYS5jYWxsKHRoaXMpO2Q9dGhpcy5pYT9kLnphOmQucG9pbnRlclR5cGU7dmFyIGU9YWIoYyx0aGlzLlYsZC5WKTtyZXR1cm4gbnVsbD09PWU/YS5jYWxsKHRoaXMpOnRoaXMuamE/ZmIoZC5WLmNhLHtXOmQsVTplLGFhOnRoaXMsWjpifSk6ZmIoZC5WLmNhLHtXOmQsVTplfSl9O1xueWI9bC5VbmJvdW5kVHlwZUVycm9yPU9hKFwiVW5ib3VuZFR5cGVFcnJvclwiKTtcbnZhciBRYj17bDpmdW5jdGlvbihiKXtyZXR1cm4gUGIoYisyNCkrMjR9LGs6ZnVuY3Rpb24oYixhLGMpeyhuZXcgSmEoYikpLnNhKGEsYyk7S2ErKzt0aHJvdyBiO30scjpmdW5jdGlvbihiLGEsYyl7Yj1PKGIpO2E9WGEoYSxcIndyYXBwZXJcIik7Yz1OKGMpO3ZhciBkPVtdLnNsaWNlLGU9YS5WLGY9ZS5jYSxrPWUuWC5jYSxnPWUuWC5jb25zdHJ1Y3RvcjtiPU1hKGIsZnVuY3Rpb24oKXtlLlgucWEuZm9yRWFjaChmdW5jdGlvbihoKXtpZih0aGlzW2hdPT09a1toXSl0aHJvdyBuZXcgUWEoXCJQdXJlIHZpcnR1YWwgZnVuY3Rpb24gXCIraCtcIiBtdXN0IGJlIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHRcIik7fS5iaW5kKHRoaXMpKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcIl9fcGFyZW50XCIse3ZhbHVlOmZ9KTt0aGlzLl9fY29uc3RydWN0LmFwcGx5KHRoaXMsZC5jYWxsKGFyZ3VtZW50cykpfSk7Zi5fX2NvbnN0cnVjdD1mdW5jdGlvbigpe3RoaXM9PT1mJiZNKFwiUGFzcyBjb3JyZWN0ICd0aGlzJyB0byBfX2NvbnN0cnVjdFwiKTtcbnZhciBoPWcuaW1wbGVtZW50LmFwcGx5KHZvaWQgMCxbdGhpc10uY29uY2F0KGQuY2FsbChhcmd1bWVudHMpKSk7WWEoaCk7dmFyIG49aC5UO2gubm90aWZ5T25EZXN0cnVjdGlvbigpO24uZ2E9ITA7T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyx7VDp7dmFsdWU6bn19KTtUKHRoaXMpO2g9bi5VO2g9VWEoZSxoKTtRLmhhc093blByb3BlcnR5KGgpP00oXCJUcmllZCB0byByZWdpc3RlciByZWdpc3RlcmVkIGluc3RhbmNlOiBcIitoKTpRW2hdPXRoaXN9O2YuX19kZXN0cnVjdD1mdW5jdGlvbigpe3RoaXM9PT1mJiZNKFwiUGFzcyBjb3JyZWN0ICd0aGlzJyB0byBfX2Rlc3RydWN0XCIpO1lhKHRoaXMpO3ZhciBoPXRoaXMuVC5VO2g9VWEoZSxoKTtRLmhhc093blByb3BlcnR5KGgpP2RlbGV0ZSBRW2hdOk0oXCJUcmllZCB0byB1bnJlZ2lzdGVyIHVucmVnaXN0ZXJlZCBpbnN0YW5jZTogXCIraCl9O2IucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZik7Zm9yKHZhciBtIGluIGMpYi5wcm90b3R5cGVbbV09XG5jW21dO3JldHVybiBQYShiKX0sajpmdW5jdGlvbihiKXt2YXIgYT1nYltiXTtkZWxldGUgZ2JbYl07dmFyIGM9YS5tYSxkPWEuYmEsZT1hLnBhLGY9ZS5tYXAoaz0+ay5IYSkuY29uY2F0KGUubWFwKGs9PmsuTmEpKTtWKFtiXSxmLGs9Pnt2YXIgZz17fTtlLmZvckVhY2goKG0saCk9Pnt2YXIgbj1rW2hdLHA9bS5GYSxyPW0uR2EsdT1rW2grZS5sZW5ndGhdLHQ9bS5NYSx6PW0uT2E7Z1ttLkNhXT17cmVhZDpDPT5uLmZyb21XaXJlVHlwZShwKHIsQykpLHdyaXRlOihDLGNhKT0+e3ZhciBKPVtdO3QoeixDLHUudG9XaXJlVHlwZShKLGNhKSk7aGIoSil9fX0pO3JldHVyblt7bmFtZTphLm5hbWUsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKG0pe3ZhciBoPXt9LG47Zm9yKG4gaW4gZyloW25dPWdbbl0ucmVhZChtKTtkKG0pO3JldHVybiBofSx0b1dpcmVUeXBlOmZ1bmN0aW9uKG0saCl7Zm9yKHZhciBuIGluIGcpaWYoIShuIGluIGgpKXRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgZmllbGQ6ICBcIicrXG5uKydcIicpO3ZhciBwPWMoKTtmb3IobiBpbiBnKWdbbl0ud3JpdGUocCxoW25dKTtudWxsIT09bSYmbS5wdXNoKGQscCk7cmV0dXJuIHB9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6aWIsJDpkfV19KX0sdTpmdW5jdGlvbigpe30sQjpmdW5jdGlvbihiLGEsYyxkLGUpe3ZhciBmPWtiKGMpO2E9TyhhKTtXKGIse25hbWU6YSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oayl7cmV0dXJuISFrfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGssZyl7cmV0dXJuIGc/ZDplfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZ1bmN0aW9uKGspe2lmKDE9PT1jKXZhciBnPXg7ZWxzZSBpZigyPT09YylnPUE7ZWxzZSBpZig0PT09YylnPUI7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBib29sZWFuIHR5cGUgc2l6ZTogXCIrYSk7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKGdbaz4+Zl0pfSwkOm51bGx9KX0sZTpmdW5jdGlvbihiLGEsYyxkLGUsZixcbmssZyxtLGgsbixwLHIpe249TyhuKTtmPVooZSxmKTtnJiYoZz1aKGssZykpO2gmJihoPVoobSxoKSk7cj1aKHAscik7dmFyIHU9TGEobik7bmIodSxmdW5jdGlvbigpe3piKFwiQ2Fubm90IGNvbnN0cnVjdCBcIituK1wiIGR1ZSB0byB1bmJvdW5kIHR5cGVzXCIsW2RdKX0pO1YoW2IsYSxjXSxkP1tkXTpbXSxmdW5jdGlvbih0KXt0PXRbMF07aWYoZCl7dmFyIHo9dC5WO3ZhciBDPXouY2F9ZWxzZSBDPVgucHJvdG90eXBlO3Q9TWEodSxmdW5jdGlvbigpe2lmKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSE9PWNhKXRocm93IG5ldyBMKFwiVXNlICduZXcnIHRvIGNvbnN0cnVjdCBcIituKTtpZih2b2lkIDA9PT1KLmRhKXRocm93IG5ldyBMKG4rXCIgaGFzIG5vIGFjY2Vzc2libGUgY29uc3RydWN0b3JcIik7dmFyIG9iPUouZGFbYXJndW1lbnRzLmxlbmd0aF07aWYodm9pZCAwPT09b2IpdGhyb3cgbmV3IEwoXCJUcmllZCB0byBpbnZva2UgY3RvciBvZiBcIituK1wiIHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoXCIrXG5hcmd1bWVudHMubGVuZ3RoK1wiKSAtIGV4cGVjdGVkIChcIitPYmplY3Qua2V5cyhKLmRhKS50b1N0cmluZygpK1wiKSBwYXJhbWV0ZXJzIGluc3RlYWQhXCIpO3JldHVybiBvYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTt2YXIgY2E9T2JqZWN0LmNyZWF0ZShDLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dH19KTt0LnByb3RvdHlwZT1jYTt2YXIgSj1uZXcgcWIobix0LGNhLHIseixmLGcsaCk7ej1uZXcgWShuLEosITAsITEpO0M9bmV3IFkobitcIipcIixKLCExLCExKTt2YXIgcGI9bmV3IFkobitcIiBjb25zdCpcIixKLCExLCEwKTtiYltiXT17cG9pbnRlclR5cGU6Qyx6YTpwYn07d2IodSx0KTtyZXR1cm5beixDLHBiXX0pfSxkOmZ1bmN0aW9uKGIsYSxjLGQsZSxmLGspe3ZhciBnPUJiKGMsZCk7YT1PKGEpO2Y9WihlLGYpO1YoW10sW2JdLGZ1bmN0aW9uKG0pe2Z1bmN0aW9uIGgoKXt6YihcIkNhbm5vdCBjYWxsIFwiK24rXCIgZHVlIHRvIHVuYm91bmQgdHlwZXNcIixnKX1tPW1bMF07dmFyIG49bS5uYW1lK1xuXCIuXCIrYTthLnN0YXJ0c1dpdGgoXCJAQFwiKSYmKGE9U3ltYm9sW2Euc3Vic3RyaW5nKDIpXSk7dmFyIHA9bS5WLmNvbnN0cnVjdG9yO3ZvaWQgMD09PXBbYV0/KGguZWE9Yy0xLHBbYV09aCk6KG1iKHAsYSxuKSxwW2FdLllbYy0xXT1oKTtWKFtdLGcsZnVuY3Rpb24ocil7cj1BYihuLFtyWzBdLG51bGxdLmNvbmNhdChyLnNsaWNlKDEpKSxudWxsLGYsayk7dm9pZCAwPT09cFthXS5ZPyhyLmVhPWMtMSxwW2FdPXIpOnBbYV0uWVtjLTFdPXI7cmV0dXJuW119KTtyZXR1cm5bXX0pfSxtOmZ1bmN0aW9uKGIsYSxjLGQsZSxmKXswPGF8fHcoKTt2YXIgaz1CYihhLGMpO2U9WihkLGUpO1YoW10sW2JdLGZ1bmN0aW9uKGcpe2c9Z1swXTt2YXIgbT1cImNvbnN0cnVjdG9yIFwiK2cubmFtZTt2b2lkIDA9PT1nLlYuZGEmJihnLlYuZGE9W10pO2lmKHZvaWQgMCE9PWcuVi5kYVthLTFdKXRocm93IG5ldyBMKFwiQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIGNvbnN0cnVjdG9ycyB3aXRoIGlkZW50aWNhbCBudW1iZXIgb2YgcGFyYW1ldGVycyAoXCIrXG4oYS0xKStcIikgZm9yIGNsYXNzICdcIitnLm5hbWUrXCInISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyFcIik7Zy5WLmRhW2EtMV09KCk9Pnt6YihcIkNhbm5vdCBjb25zdHJ1Y3QgXCIrZy5uYW1lK1wiIGR1ZSB0byB1bmJvdW5kIHR5cGVzXCIsayl9O1YoW10sayxmdW5jdGlvbihoKXtoLnNwbGljZSgxLDAsbnVsbCk7Zy5WLmRhW2EtMV09QWIobSxoLG51bGwsZSxmKTtyZXR1cm5bXX0pO3JldHVybltdfSl9LGE6ZnVuY3Rpb24oYixhLGMsZCxlLGYsayxnKXt2YXIgbT1CYihjLGQpO2E9TyhhKTtmPVooZSxmKTtWKFtdLFtiXSxmdW5jdGlvbihoKXtmdW5jdGlvbiBuKCl7emIoXCJDYW5ub3QgY2FsbCBcIitwK1wiIGR1ZSB0byB1bmJvdW5kIHR5cGVzXCIsbSl9aD1oWzBdO3ZhciBwPWgubmFtZStcIi5cIithO2Euc3RhcnRzV2l0aChcIkBAXCIpJiYoYT1TeW1ib2xbYS5zdWJzdHJpbmcoMildKTtcbmcmJmguVi5xYS5wdXNoKGEpO3ZhciByPWguVi5jYSx1PXJbYV07dm9pZCAwPT09dXx8dm9pZCAwPT09dS5ZJiZ1LmNsYXNzTmFtZSE9PWgubmFtZSYmdS5lYT09PWMtMj8obi5lYT1jLTIsbi5jbGFzc05hbWU9aC5uYW1lLHJbYV09bik6KG1iKHIsYSxwKSxyW2FdLllbYy0yXT1uKTtWKFtdLG0sZnVuY3Rpb24odCl7dD1BYihwLHQsaCxmLGspO3ZvaWQgMD09PXJbYV0uWT8odC5lYT1jLTIsclthXT10KTpyW2FdLllbYy0yXT10O3JldHVybltdfSk7cmV0dXJuW119KX0sQTpmdW5jdGlvbihiLGEpe2E9TyhhKTtXKGIse25hbWU6YSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oYyl7dmFyIGQ9TihjKTtDYihjKTtyZXR1cm4gZH0sdG9XaXJlVHlwZTpmdW5jdGlvbihjLGQpe3JldHVybiBQYShkKX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjppYiwkOm51bGx9KX0sbzpmdW5jdGlvbihiLGEsYyxkKXtmdW5jdGlvbiBlKCl7fWM9a2IoYyk7YT1PKGEpO2UudmFsdWVzPVxue307VyhiLHtuYW1lOmEsY29uc3RydWN0b3I6ZSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oZil7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudmFsdWVzW2ZdfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGYsayl7cmV0dXJuIGsudmFsdWV9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6RGIoYSxjLGQpLCQ6bnVsbH0pO25iKGEsZSl9LG46ZnVuY3Rpb24oYixhLGMpe3ZhciBkPVhhKGIsXCJlbnVtXCIpO2E9TyhhKTtiPWQuY29uc3RydWN0b3I7ZD1PYmplY3QuY3JlYXRlKGQuY29uc3RydWN0b3IucHJvdG90eXBlLHt2YWx1ZTp7dmFsdWU6Y30sY29uc3RydWN0b3I6e3ZhbHVlOk1hKGQubmFtZStcIl9cIithLGZ1bmN0aW9uKCl7fSl9fSk7Yi52YWx1ZXNbY109ZDtiW2FdPWR9LHA6ZnVuY3Rpb24oYixhLGMpe2M9a2IoYyk7YT1PKGEpO1coYix7bmFtZTphLGZyb21XaXJlVHlwZTpmdW5jdGlvbihkKXtyZXR1cm4gZH0sdG9XaXJlVHlwZTpmdW5jdGlvbihkLGUpe3JldHVybiBlfSxcbmFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6RWIoYSxjKSwkOm51bGx9KX0sYzpmdW5jdGlvbihiLGEsYyxkLGUpe2E9TyhhKTstMT09PWUmJihlPTQyOTQ5NjcyOTUpO2U9a2IoYyk7dmFyIGY9Zz0+ZztpZigwPT09ZCl7dmFyIGs9MzItOCpjO2Y9Zz0+Zzw8az4+Pmt9Yz1hLmluY2x1ZGVzKFwidW5zaWduZWRcIik/ZnVuY3Rpb24oZyxtKXtyZXR1cm4gbT4+PjB9OmZ1bmN0aW9uKGcsbSl7cmV0dXJuIG19O1coYix7bmFtZTphLGZyb21XaXJlVHlwZTpmLHRvV2lyZVR5cGU6YyxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOkZiKGEsZSwwIT09ZCksJDpudWxsfSl9LGI6ZnVuY3Rpb24oYixhLGMpe2Z1bmN0aW9uIGQoZil7Zj4+PTI7dmFyIGs9RDtyZXR1cm4gbmV3IGUodWEsa1tmKzFdLGtbZl0pfXZhciBlPVtJbnQ4QXJyYXksVWludDhBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LFxuRmxvYXQ2NEFycmF5XVthXTtjPU8oYyk7VyhiLHtuYW1lOmMsZnJvbVdpcmVUeXBlOmQsYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpkfSx7SWE6ITB9KX0scTpmdW5jdGlvbihiLGEpe2E9TyhhKTt2YXIgYz1cInN0ZDo6c3RyaW5nXCI9PT1hO1coYix7bmFtZTphLGZyb21XaXJlVHlwZTpmdW5jdGlvbihkKXt2YXIgZT1EW2Q+PjJdO2lmKGMpZm9yKHZhciBmPWQrNCxrPTA7azw9ZTsrK2spe3ZhciBnPWQrNCtrO2lmKGs9PWV8fDA9PXlbZ10pe2Y9Zj9uYSh5LGYsZy1mKTpcIlwiO2lmKHZvaWQgMD09PW0pdmFyIG09ZjtlbHNlIG0rPVN0cmluZy5mcm9tQ2hhckNvZGUoMCksbSs9ZjtmPWcrMX19ZWxzZXttPUFycmF5KGUpO2ZvcihrPTA7azxlOysrayltW2tdPVN0cmluZy5mcm9tQ2hhckNvZGUoeVtkKzQra10pO209bS5qb2luKFwiXCIpfVMoZCk7cmV0dXJuIG19LHRvV2lyZVR5cGU6ZnVuY3Rpb24oZCxlKXtlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJihlPW5ldyBVaW50OEFycmF5KGUpKTtcbnZhciBmPVwic3RyaW5nXCI9PXR5cGVvZiBlO2Z8fGUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fGUgaW5zdGFuY2VvZiBJbnQ4QXJyYXl8fE0oXCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nXCIpO3ZhciBrPShjJiZmPygpPT57Zm9yKHZhciBoPTAsbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgcD1lLmNoYXJDb2RlQXQobik7NTUyOTY8PXAmJjU3MzQzPj1wJiYocD02NTUzNisoKHAmMTAyMyk8PDEwKXxlLmNoYXJDb2RlQXQoKytuKSYxMDIzKTsxMjc+PXA/KytoOmg9MjA0Nz49cD9oKzI6NjU1MzU+PXA/aCszOmgrNH1yZXR1cm4gaH06KCk9PmUubGVuZ3RoKSgpLGc9UGIoNCtrKzEpO0RbZz4+Ml09aztpZihjJiZmKWthKGUsZys0LGsrMSk7ZWxzZSBpZihmKWZvcihmPTA7ZjxrOysrZil7dmFyIG09ZS5jaGFyQ29kZUF0KGYpOzI1NTxtJiYoUyhnKSxNKFwiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzXCIpKTtcbnlbZys0K2ZdPW19ZWxzZSBmb3IoZj0wO2Y8azsrK2YpeVtnKzQrZl09ZVtmXTtudWxsIT09ZCYmZC5wdXNoKFMsZyk7cmV0dXJuIGd9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6aWIsJDpmdW5jdGlvbihkKXtTKGQpfX0pfSxpOmZ1bmN0aW9uKGIsYSxjKXtjPU8oYyk7aWYoMj09PWEpe3ZhciBkPW9hO3ZhciBlPXBhO3ZhciBmPXFhO3ZhciBrPSgpPT52YTt2YXIgZz0xfWVsc2UgND09PWEmJihkPXJhLGU9c2EsZj10YSxrPSgpPT5ELGc9Mik7VyhiLHtuYW1lOmMsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKG0pe2Zvcih2YXIgaD1EW20+PjJdLG49aygpLHAscj1tKzQsdT0wO3U8PWg7Kyt1KXt2YXIgdD1tKzQrdSphO2lmKHU9PWh8fDA9PW5bdD4+Z10pcj1kKHIsdC1yKSx2b2lkIDA9PT1wP3A9cjoocCs9U3RyaW5nLmZyb21DaGFyQ29kZSgwKSxwKz1yKSxyPXQrYX1TKG0pO3JldHVybiBwfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKG0saCl7XCJzdHJpbmdcIiE9dHlwZW9mIGgmJlxuTShcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlIFwiK2MpO3ZhciBuPWYoaCkscD1QYig0K24rYSk7RFtwPj4yXT1uPj5nO2UoaCxwKzQsbithKTtudWxsIT09bSYmbS5wdXNoKFMscCk7cmV0dXJuIHB9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6aWIsJDpmdW5jdGlvbihtKXtTKG0pfX0pfSxoOmZ1bmN0aW9uKGIsYSxjLGQsZSxmKXtnYltiXT17bmFtZTpPKGEpLG1hOlooYyxkKSxiYTpaKGUsZikscGE6W119fSxnOmZ1bmN0aW9uKGIsYSxjLGQsZSxmLGssZyxtLGgpe2diW2JdLnBhLnB1c2goe0NhOk8oYSksSGE6YyxGYTpaKGQsZSksR2E6ZixOYTprLE1hOlooZyxtKSxPYTpofSl9LEM6ZnVuY3Rpb24oYixhKXthPU8oYSk7VyhiLHtKYTohMCxuYW1lOmEsYXJnUGFja0FkdmFuY2U6MCxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oKXt9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oKXt9fSl9LEY6ZnVuY3Rpb24oYixhLGMsZCxlKXtiPUliW2JdO1xuYT1OKGEpO2M9SGIoYyk7dmFyIGY9W107QltkPj4yXT1QYShmKTtyZXR1cm4gYihhLGMsZixlKX0sSDpmdW5jdGlvbihiLGEsYyxkKXtiPUliW2JdO2E9TihhKTtjPUhiKGMpO2IoYSxjLG51bGwsZCl9LEc6Q2IsczpmdW5jdGlvbihiLGEpe3ZhciBjPUtiKGIsYSksZD1jWzBdO2E9ZC5uYW1lK1wiXyRcIitjLnNsaWNlKDEpLm1hcChmdW5jdGlvbihrKXtyZXR1cm4gay5uYW1lfSkuam9pbihcIl9cIikrXCIkXCI7dmFyIGU9TGJbYV07aWYodm9pZCAwIT09ZSlyZXR1cm4gZTt2YXIgZj1BcnJheShiLTEpO2U9SmIoKGssZyxtLGgpPT57Zm9yKHZhciBuPTAscD0wO3A8Yi0xOysrcClmW3BdPWNbcCsxXS5yZWFkVmFsdWVGcm9tUG9pbnRlcihoK24pLG4rPWNbcCsxXS5hcmdQYWNrQWR2YW5jZTtrPWtbZ10uYXBwbHkoayxmKTtmb3IocD0wO3A8Yi0xOysrcCljW3ArMV0uQWEmJmNbcCsxXS5BYShmW3BdKTtpZighZC5KYSlyZXR1cm4gZC50b1dpcmVUeXBlKG0sayl9KTtyZXR1cm4gTGJbYV09ZX0sXG5EOmZ1bmN0aW9uKGIpezQ8YiYmKEtbYl0ubmErPTEpfSxFOmZ1bmN0aW9uKGIpe3ZhciBhPU4oYik7aGIoYSk7Q2IoYil9LGY6ZnVuY3Rpb24oKXt3KFwiXCIpfSx4OmZ1bmN0aW9uKGIsYSxjKXt5LmNvcHlXaXRoaW4oYixhLGErYyl9LHc6ZnVuY3Rpb24oYil7dmFyIGE9eS5sZW5ndGg7Yj4+Pj0wO2lmKDIxNDc0ODM2NDg8YilyZXR1cm4hMTtmb3IodmFyIGM9MTs0Pj1jO2MqPTIpe3ZhciBkPWEqKDErLjIvYyk7ZD1NYXRoLm1pbihkLGIrMTAwNjYzMjk2KTt2YXIgZT1NYXRoO2Q9TWF0aC5tYXgoYixkKTtlPWUubWluLmNhbGwoZSwyMTQ3NDgzNjQ4LGQrKDY1NTM2LWQlNjU1MzYpJTY1NTM2KTthOnt0cnl7ZmEuZ3JvdyhlLXVhLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNik7eWEoKTt2YXIgZj0xO2JyZWFrIGF9Y2F0Y2goayl7fWY9dm9pZCAwfWlmKGYpcmV0dXJuITB9cmV0dXJuITF9LHo6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LHQ6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LHk6ZnVuY3Rpb24oYixcbmEsYyxkKXtmb3IodmFyIGU9MCxmPTA7ZjxjO2YrKyl7dmFyIGs9RFthPj4yXSxnPURbYSs0Pj4yXTthKz04O2Zvcih2YXIgbT0wO208ZzttKyspe3ZhciBoPXlbayttXSxuPU1iW2JdOzA9PT1ofHwxMD09PWg/KCgxPT09Yj9lYTp2KShuYShuLDApKSxuLmxlbmd0aD0wKTpuLnB1c2goaCl9ZSs9Z31EW2Q+PjJdPWU7cmV0dXJuIDB9LHY6ZnVuY3Rpb24oKXt9fTtcbihmdW5jdGlvbigpe2Z1bmN0aW9uIGIoZSl7bC5hc209ZS5leHBvcnRzO2ZhPWwuYXNtLkk7eWEoKTtFPWwuYXNtLk87QWEudW5zaGlmdChsLmFzbS5KKTtGLS07MD09RiYmKG51bGwhPT1DYSYmKGNsZWFySW50ZXJ2YWwoQ2EpLENhPW51bGwpLEcmJihlPUcsRz1udWxsLGUoKSkpfWZ1bmN0aW9uIGEoZSl7YihlLmluc3RhbmNlKX1mdW5jdGlvbiBjKGUpe3JldHVybiBHYSgpLnRoZW4oZnVuY3Rpb24oZil7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGYsZCl9KS50aGVuKGZ1bmN0aW9uKGYpe3JldHVybiBmfSkudGhlbihlLGZ1bmN0aW9uKGYpe3YoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitmKTt3KGYpfSl9dmFyIGQ9e2E6UWJ9O0YrKztpZihsLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGwuaW5zdGFudGlhdGVXYXNtKGQsYil9Y2F0Y2goZSl7cmV0dXJuIHYoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitcbmUpLCExfShmdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxEYSgpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9jKGEpOmZldGNoKEgse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGUsZCkudGhlbihhLGZ1bmN0aW9uKGYpe3YoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrZik7dihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpO3JldHVybiBjKGEpfSl9KX0pKCkuY2F0Y2goYmEpO3JldHVybnt9fSkoKTtsLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihsLl9fX3dhc21fY2FsbF9jdG9ycz1sLmFzbS5KKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O1xudmFyIFBiPWwuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihQYj1sLl9tYWxsb2M9bC5hc20uSykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxTPWwuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oUz1sLl9mcmVlPWwuYXNtLkwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sV2E9bC5fX19nZXRUeXBlTmFtZT1mdW5jdGlvbigpe3JldHVybihXYT1sLl9fX2dldFR5cGVOYW1lPWwuYXNtLk0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07bC5fX19lbWJpbmRfcmVnaXN0ZXJfbmF0aXZlX2FuZF9idWlsdGluX3R5cGVzPWZ1bmN0aW9uKCl7cmV0dXJuKGwuX19fZW1iaW5kX3JlZ2lzdGVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlcz1sLmFzbS5OKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O1xudmFyIGxhPWwuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKGxhPWwuc3RhY2tTYXZlPWwuYXNtLlApLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbWEsamE9bC5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGphPWwuc3RhY2tBbGxvYz1sLmFzbS5RKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2wuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihsLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9bC5hc20uUikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtsLmR5bkNhbGxfamlqaT1mdW5jdGlvbigpe3JldHVybihsLmR5bkNhbGxfamlqaT1sLmFzbS5TKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2wuY3dyYXA9ZnVuY3Rpb24oYixhLGMsZCl7Yz1jfHxbXTt2YXIgZT1jLmV2ZXJ5KGZ1bmN0aW9uKGYpe3JldHVyblwibnVtYmVyXCI9PT1mfSk7cmV0dXJuXCJzdHJpbmdcIiE9PWEmJmUmJiFkP2xbXCJfXCIrYl06ZnVuY3Rpb24oKXtyZXR1cm4gaWEoYixhLGMsYXJndW1lbnRzKX19O1xubC5zZXRWYWx1ZT1mdW5jdGlvbihiLGEsYz1cImk4XCIpe2MuZW5kc1dpdGgoXCIqXCIpJiYoYz1cImkzMlwiKTtzd2l0Y2goYyl7Y2FzZSBcImkxXCI6eFtiPj4wXT1hO2JyZWFrO2Nhc2UgXCJpOFwiOnhbYj4+MF09YTticmVhaztjYXNlIFwiaTE2XCI6QVtiPj4xXT1hO2JyZWFrO2Nhc2UgXCJpMzJcIjpCW2I+PjJdPWE7YnJlYWs7Y2FzZSBcImk2NFwiOkhhPVthPj4+MCwoST1hLDE8PStNYXRoLmFicyhJKT8wPEk/KE1hdGgubWluKCtNYXRoLmZsb29yKEkvNDI5NDk2NzI5NiksNDI5NDk2NzI5NSl8MCk+Pj4wOn5+K01hdGguY2VpbCgoSS0rKH5+ST4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldO0JbYj4+Ml09SGFbMF07QltiKzQ+PjJdPUhhWzFdO2JyZWFrO2Nhc2UgXCJmbG9hdFwiOndhW2I+PjJdPWE7YnJlYWs7Y2FzZSBcImRvdWJsZVwiOnhhW2I+PjNdPWE7YnJlYWs7ZGVmYXVsdDp3KFwiaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogXCIrYyl9fTt2YXIgUmI7XG5HPWZ1bmN0aW9uIFNiKCl7UmJ8fFRiKCk7UmJ8fChHPVNiKX07ZnVuY3Rpb24gVGIoKXswPEZ8fChJYSh6YSksMDxGfHxSYnx8KFJiPSEwLGwuY2FsbGVkUnVuPSEwLGhhfHwoSWEoQWEpLGFhKGwpLElhKEJhKSkpKX1sLnJ1bj1UYjtUYigpO1xuXG5cbiAgcmV0dXJuIHlvZ2EucmVhZHlcbn1cbik7XG59KSgpO1xuZXhwb3J0IGRlZmF1bHQgeW9nYTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/yoga-wasm-web/dist/yoga.mjs\n");

/***/ }),

/***/ "(middleware)/./node_modules/css-color-keywords/colors.json":
/*!*****************************************************!*\
  !*** ./node_modules/css-color-keywords/colors.json ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"black":"#000000","silver":"#c0c0c0","gray":"#808080","white":"#ffffff","maroon":"#800000","red":"#ff0000","purple":"#800080","fuchsia":"#ff00ff","green":"#008000","lime":"#00ff00","olive":"#808000","yellow":"#ffff00","navy":"#000080","blue":"#0000ff","teal":"#008080","aqua":"#00ffff","orange":"#ffa500","aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aquamarine":"#7fffd4","azure":"#f0ffff","beige":"#f5f5dc","bisque":"#ffe4c4","blanchedalmond":"#ffebcd","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887","cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkgrey":"#a9a9a9","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f","darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkslategrey":"#2f4f4f","darkturquoise":"#00ced1","darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dimgrey":"#696969","dodgerblue":"#1e90ff","firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","greenyellow":"#adff2f","grey":"#808080","honeydew":"#f0fff0","hotpink":"#ff69b4","indianred":"#cd5c5c","indigo":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c","lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2","lightgray":"#d3d3d3","lightgreen":"#90ee90","lightgrey":"#d3d3d3","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightslategrey":"#778899","lightsteelblue":"#b0c4de","lightyellow":"#ffffe0","limegreen":"#32cd32","linen":"#faf0e6","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370db","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee","mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5","navajowhite":"#ffdead","oldlace":"#fdf5e6","olivedrab":"#6b8e23","orangered":"#ff4500","orchid":"#da70d6","palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#db7093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","rosybrown":"#bc8f8f","royalblue":"#4169e1","saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","slategrey":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4","tan":"#d2b48c","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0","violet":"#ee82ee","wheat":"#f5deb3","whitesmoke":"#f5f5f5","yellowgreen":"#9acd32","rebeccapurple":"#663399"}');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("(middleware)/./node_modules/next/dist/build/webpack/loaders/next-edge-function-loader.js?absolutePagePath=D%3A%5CProgrammation%5CJavaScript%5Creact%5Csvg-generator%5Cpages%5Capi%5CcreateImage.js&page=%2Fapi%2FcreateImage&rootDir=D%3A%5CProgrammation%5CJavaScript%5Creact%5Csvg-generator!"));
/******/ (_ENTRIES = typeof _ENTRIES === "undefined" ? {} : _ENTRIES)["middleware_pages/api/createImage"] = __webpack_exports__;
/******/ }
]);